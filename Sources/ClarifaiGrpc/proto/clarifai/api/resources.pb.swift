// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: proto/clarifai/api/resources.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

public enum Clarifai_Api_WorkflowModelUseCase: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case notSet // = 0

  /// Classifier models without a detector parent (recursive check) in a workflow
  /// are used for classification.
  case classification // = 1

  /// Detector models in a workflow are used for detection.
  /// Classifier models that run after a detector model are also used for detection.
  case detection // = 2
  case UNRECOGNIZED(Int)

  public init() {
    self = .notSet
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .notSet
    case 1: self = .classification
    case 2: self = .detection
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .notSet: return 0
    case .classification: return 1
    case .detection: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Clarifai_Api_WorkflowModelUseCase: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Clarifai_Api_WorkflowModelUseCase] = [
    .notSet,
    .classification,
    .detection,
  ]
}

#endif  // swift(>=4.2)

public enum Clarifai_Api_DatasetVersionRequestOrigin: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case notSet // = 0
  case manual // = 1
  case training // = 2
  case evalGroundTruth // = 3
  case evalPredictions // = 4
  case UNRECOGNIZED(Int)

  public init() {
    self = .notSet
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .notSet
    case 1: self = .manual
    case 2: self = .training
    case 3: self = .evalGroundTruth
    case 4: self = .evalPredictions
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .notSet: return 0
    case .manual: return 1
    case .training: return 2
    case .evalGroundTruth: return 3
    case .evalPredictions: return 4
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Clarifai_Api_DatasetVersionRequestOrigin: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Clarifai_Api_DatasetVersionRequestOrigin] = [
    .notSet,
    .manual,
    .training,
    .evalGroundTruth,
    .evalPredictions,
  ]
}

#endif  // swift(>=4.2)

public enum Clarifai_Api_DatasetVersionMetricsGroupType: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case notSet // = 0

  /// Group data examples by input type.
  /// Examples: images, videos, text, audio.
  case inputType // = 2

  /// Group data examples by concept ID.
  /// Examples: inputs with cat concept, inputs with dog concept.
  case conceptID // = 10

  /// Group data examples by concepts count.
  /// Examples: inputs with 20 concepts, inputs with 21 concepts.
  case conceptsCount // = 11

  /// Group data examples by bounding boxes count.
  /// Examples: inputs with 20 bounding boxes, inputs with 21 bounding boxes.
  case boundingBoxesCount // = 20

  /// Group data examples by polygons count.
  /// Examples: inputs with 20 polygons, inputs with 21 polygons.
  case polygonsCount // = 21

  /// Group data examples by points count.
  /// Examples: inputs with 20 points, inputs with 21 points.
  case pointsCount // = 22

  /// Group data examples by masks count.
  /// Examples: inputs with 20 masks, inputs with 21 masks.
  case masksCount // = 23

  /// Group data examples by pixels count.
  /// In order to reduce the number of groups, we use bins.
  /// Examples for bin size = 400: inputs with [200000, 200400) pixels, inputs with [200400, 200800) pixels.
  case pixelsCount // = 30

  /// Group data examples by aspect ratio.
  /// In order to reduce the number of groups, we use bins.
  /// Examples for bin size = 0.1: inputs with [0.5, 0.6) aspect ratio, inputs with [0.6, 0.7) aspect ratio.
  case aspectRatio // = 31
  case UNRECOGNIZED(Int)

  public init() {
    self = .notSet
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .notSet
    case 2: self = .inputType
    case 10: self = .conceptID
    case 11: self = .conceptsCount
    case 20: self = .boundingBoxesCount
    case 21: self = .polygonsCount
    case 22: self = .pointsCount
    case 23: self = .masksCount
    case 30: self = .pixelsCount
    case 31: self = .aspectRatio
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .notSet: return 0
    case .inputType: return 2
    case .conceptID: return 10
    case .conceptsCount: return 11
    case .boundingBoxesCount: return 20
    case .polygonsCount: return 21
    case .pointsCount: return 22
    case .masksCount: return 23
    case .pixelsCount: return 30
    case .aspectRatio: return 31
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Clarifai_Api_DatasetVersionMetricsGroupType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Clarifai_Api_DatasetVersionMetricsGroupType] = [
    .notSet,
    .inputType,
    .conceptID,
    .conceptsCount,
    .boundingBoxesCount,
    .polygonsCount,
    .pointsCount,
    .masksCount,
    .pixelsCount,
    .aspectRatio,
  ]
}

#endif  // swift(>=4.2)

public enum Clarifai_Api_DatasetVersionExportFormat: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case notSet // = 0

  /// CLARIFAI_DATA_PROTOBUF is the proprietary Clarifai API Data format. It
  /// is a ZIP-archive containing batches of serialized InputBatch protobuf messages.
  ///
  /// Note that only the "id" and "data" fields of exported inputs are set.
  case clarifaiDataProtobuf // = 1

  /// CLARIFAI_DATA_JSON is the proprietary Clarifai API Data format in JSON. It
  /// is a ZIP-archive containing batches of serialized InputBatch JSON messages.
  ///
  /// Note that only the "id" and "data" fields of exported inputs are set.
  case clarifaiDataJson // = 3

  /// COCO is the data format used by Common Objects in Context. It is a
  /// ZIP-archive containing JSON files with the dataset version annotations.
  /// See https://cocodataset.org/#format-data.
  case coco // = 2
  case UNRECOGNIZED(Int)

  public init() {
    self = .notSet
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .notSet
    case 1: self = .clarifaiDataProtobuf
    case 2: self = .coco
    case 3: self = .clarifaiDataJson
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .notSet: return 0
    case .clarifaiDataProtobuf: return 1
    case .coco: return 2
    case .clarifaiDataJson: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Clarifai_Api_DatasetVersionExportFormat: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Clarifai_Api_DatasetVersionExportFormat] = [
    .notSet,
    .clarifaiDataProtobuf,
    .clarifaiDataJson,
    .coco,
  ]
}

#endif  // swift(>=4.2)

public enum Clarifai_Api_ExpirationAction: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case notSet // = 0

  /// Progressively delay the execution of operations
  case delay // = 1

  /// Cease functioning
  case expiry // = 2
  case UNRECOGNIZED(Int)

  public init() {
    self = .notSet
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .notSet
    case 1: self = .delay
    case 2: self = .expiry
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .notSet: return 0
    case .delay: return 1
    case .expiry: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Clarifai_Api_ExpirationAction: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Clarifai_Api_ExpirationAction] = [
    .notSet,
    .delay,
    .expiry,
  ]
}

#endif  // swift(>=4.2)

public enum Clarifai_Api_LicenseScope: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case notSet // = 0
  case predict // = 1
  case train // = 2
  case search // = 3
  case UNRECOGNIZED(Int)

  public init() {
    self = .notSet
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .notSet
    case 1: self = .predict
    case 2: self = .train
    case 3: self = .search
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .notSet: return 0
    case .predict: return 1
    case .train: return 2
    case .search: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Clarifai_Api_LicenseScope: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Clarifai_Api_LicenseScope] = [
    .notSet,
    .predict,
    .train,
    .search,
  ]
}

#endif  // swift(>=4.2)

public enum Clarifai_Api_LicenseType: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case unknownLicenseType // = 0
  case firstParty // = 1
  case openSource // = 2
  case closedSource // = 3
  case UNRECOGNIZED(Int)

  public init() {
    self = .unknownLicenseType
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unknownLicenseType
    case 1: self = .firstParty
    case 2: self = .openSource
    case 3: self = .closedSource
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unknownLicenseType: return 0
    case .firstParty: return 1
    case .openSource: return 2
    case .closedSource: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Clarifai_Api_LicenseType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Clarifai_Api_LicenseType] = [
    .unknownLicenseType,
    .firstParty,
    .openSource,
    .closedSource,
  ]
}

#endif  // swift(>=4.2)

public enum Clarifai_Api_DataType: SwiftProtobuf.Enum {
  public typealias RawValue = Int

  /// Default value, should not be used
  case undefined // = 0
  case string // = 1
  case uint8 // = 2
  case int32 // = 3
  case int64 // = 4
  case fp32 // = 5
  case UNRECOGNIZED(Int)

  public init() {
    self = .undefined
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .undefined
    case 1: self = .string
    case 2: self = .uint8
    case 3: self = .int32
    case 4: self = .int64
    case 5: self = .fp32
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .undefined: return 0
    case .string: return 1
    case .uint8: return 2
    case .int32: return 3
    case .int64: return 4
    case .fp32: return 5
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Clarifai_Api_DataType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Clarifai_Api_DataType] = [
    .undefined,
    .string,
    .uint8,
    .int32,
    .int64,
    .fp32,
  ]
}

#endif  // swift(>=4.2)

public enum Clarifai_Api_ValueComparator: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case conceptThresholdNotSet // = 0

  /// input > value
  case greaterThan // = 1

  /// input >= value
  case greaterThanOrEqual // = 2

  /// input < value
  case lessThan // = 3

  /// input <= value
  case lessThanOrEqual // = 4

  /// input == value
  case equal // = 5
  case UNRECOGNIZED(Int)

  public init() {
    self = .conceptThresholdNotSet
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .conceptThresholdNotSet
    case 1: self = .greaterThan
    case 2: self = .greaterThanOrEqual
    case 3: self = .lessThan
    case 4: self = .lessThanOrEqual
    case 5: self = .equal
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .conceptThresholdNotSet: return 0
    case .greaterThan: return 1
    case .greaterThanOrEqual: return 2
    case .lessThan: return 3
    case .lessThanOrEqual: return 4
    case .equal: return 5
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Clarifai_Api_ValueComparator: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Clarifai_Api_ValueComparator] = [
    .conceptThresholdNotSet,
    .greaterThan,
    .greaterThanOrEqual,
    .lessThan,
    .lessThanOrEqual,
    .equal,
  ]
}

#endif  // swift(>=4.2)

public enum Clarifai_Api_EvaluationType: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case undefined // = 0

  /// default
  case classification // = 1
  case detection // = 2
  case segmentation // = 3
  case clustering // = 4
  case tracker // = 5
  case generation // = 6
  case UNRECOGNIZED(Int)

  public init() {
    self = .undefined
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .undefined
    case 1: self = .classification
    case 2: self = .detection
    case 3: self = .segmentation
    case 4: self = .clustering
    case 5: self = .tracker
    case 6: self = .generation
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .undefined: return 0
    case .classification: return 1
    case .detection: return 2
    case .segmentation: return 3
    case .clustering: return 4
    case .tracker: return 5
    case .generation: return 6
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Clarifai_Api_EvaluationType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Clarifai_Api_EvaluationType] = [
    .undefined,
    .classification,
    .detection,
    .segmentation,
    .clustering,
    .tracker,
    .generation,
  ]
}

#endif  // swift(>=4.2)

public enum Clarifai_Api_APIEventType: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case notSet // = 0

  /// On Prem event types
  case onPremPredict // = 1
  case onPremTrain // = 2
  case onPremSearch // = 3
  case UNRECOGNIZED(Int)

  public init() {
    self = .notSet
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .notSet
    case 1: self = .onPremPredict
    case 2: self = .onPremTrain
    case 3: self = .onPremSearch
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .notSet: return 0
    case .onPremPredict: return 1
    case .onPremTrain: return 2
    case .onPremSearch: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Clarifai_Api_APIEventType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Clarifai_Api_APIEventType] = [
    .notSet,
    .onPremPredict,
    .onPremTrain,
    .onPremSearch,
  ]
}

#endif  // swift(>=4.2)

public enum Clarifai_Api_UsageIntervalType: SwiftProtobuf.Enum {
  public typealias RawValue = Int

  /// undef UsageIntervalType is so that the interval field can be forced to be included
  case undef // = 0
  case day // = 1
  case month // = 2
  case year // = 3
  case UNRECOGNIZED(Int)

  public init() {
    self = .undef
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .undef
    case 1: self = .day
    case 2: self = .month
    case 3: self = .year
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .undef: return 0
    case .day: return 1
    case .month: return 2
    case .year: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Clarifai_Api_UsageIntervalType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Clarifai_Api_UsageIntervalType] = [
    .undef,
    .day,
    .month,
    .year,
  ]
}

#endif  // swift(>=4.2)

public enum Clarifai_Api_AnnotationDataType: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case notSet // = 0
  case tag // = 1
  case boundingBox // = 2
  case polygon // = 4
  case point // = 8
  case span // = 16
  case mask // = 32
  case UNRECOGNIZED(Int)

  public init() {
    self = .notSet
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .notSet
    case 1: self = .tag
    case 2: self = .boundingBox
    case 4: self = .polygon
    case 8: self = .point
    case 16: self = .span
    case 32: self = .mask
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .notSet: return 0
    case .tag: return 1
    case .boundingBox: return 2
    case .polygon: return 4
    case .point: return 8
    case .span: return 16
    case .mask: return 32
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Clarifai_Api_AnnotationDataType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Clarifai_Api_AnnotationDataType] = [
    .notSet,
    .tag,
    .boundingBox,
    .polygon,
    .point,
    .span,
    .mask,
  ]
}

#endif  // swift(>=4.2)

public enum Clarifai_Api_RoleType: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case team // = 0
  case org // = 1
  case UNRECOGNIZED(Int)

  public init() {
    self = .team
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .team
    case 1: self = .org
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .team: return 0
    case .org: return 1
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Clarifai_Api_RoleType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Clarifai_Api_RoleType] = [
    .team,
    .org,
  ]
}

#endif  // swift(>=4.2)

public enum Clarifai_Api_StatValueAggType: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case sum // = 0
  case avg // = 1
  case UNRECOGNIZED(Int)

  public init() {
    self = .sum
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .sum
    case 1: self = .avg
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .sum: return 0
    case .avg: return 1
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Clarifai_Api_StatValueAggType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Clarifai_Api_StatValueAggType] = [
    .sum,
    .avg,
  ]
}

#endif  // swift(>=4.2)

public enum Clarifai_Api_StatTimeAggType: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case noTimeAgg // = 0
  case year // = 1
  case month // = 2
  case week // = 3
  case day // = 4
  case hour // = 5
  case minute // = 6
  case UNRECOGNIZED(Int)

  public init() {
    self = .noTimeAgg
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .noTimeAgg
    case 1: self = .year
    case 2: self = .month
    case 3: self = .week
    case 4: self = .day
    case 5: self = .hour
    case 6: self = .minute
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .noTimeAgg: return 0
    case .year: return 1
    case .month: return 2
    case .week: return 3
    case .day: return 4
    case .hour: return 5
    case .minute: return 6
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Clarifai_Api_StatTimeAggType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Clarifai_Api_StatTimeAggType] = [
    .noTimeAgg,
    .year,
    .month,
    .week,
    .day,
    .hour,
    .minute,
  ]
}

#endif  // swift(>=4.2)

public enum Clarifai_Api_ValidationErrorType: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case notSet // = 0
  case restricted // = 1
  case database // = 2
  case format // = 3
  case UNRECOGNIZED(Int)

  public init() {
    self = .notSet
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .notSet
    case 1: self = .restricted
    case 2: self = .database
    case 3: self = .format
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .notSet: return 0
    case .restricted: return 1
    case .database: return 2
    case .format: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Clarifai_Api_ValidationErrorType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Clarifai_Api_ValidationErrorType] = [
    .notSet,
    .restricted,
    .database,
    .format,
  ]
}

#endif  // swift(>=4.2)

public enum Clarifai_Api_InputIDConflictResolution: SwiftProtobuf.Enum {
  public typealias RawValue = Int

  /// Defaults to SKIP
  case notSet // = 0

  /// Mark duplicate inputs as error and skip processing them.
  case skip // = 1

  /// Add a suffix to inputs with conflicting IDs. Attempts numeric suffixes "-1" to "-9" and then a randomized suffix. Identical ID's in the same request are still treated as errors.
  case suffix // = 2
  case UNRECOGNIZED(Int)

  public init() {
    self = .notSet
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .notSet
    case 1: self = .skip
    case 2: self = .suffix
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .notSet: return 0
    case .skip: return 1
    case .suffix: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Clarifai_Api_InputIDConflictResolution: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Clarifai_Api_InputIDConflictResolution] = [
    .notSet,
    .skip,
    .suffix,
  ]
}

#endif  // swift(>=4.2)

public enum Clarifai_Api_RunnerMethodType: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case unknown // = 0

  /// single request, single response. predict() in code
  case unaryUnary // = 1

  /// single request, streamed response. generate() in code
  case unaryStreaming // = 2

  /// stream of requests, single response.
  case streamingUnary // = 3

  /// stream of requests, stream of responses. stream() in code
  case streamingStreaming // = 4
  case UNRECOGNIZED(Int)

  public init() {
    self = .unknown
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unknown
    case 1: self = .unaryUnary
    case 2: self = .unaryStreaming
    case 3: self = .streamingUnary
    case 4: self = .streamingStreaming
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unknown: return 0
    case .unaryUnary: return 1
    case .unaryStreaming: return 2
    case .streamingUnary: return 3
    case .streamingStreaming: return 4
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Clarifai_Api_RunnerMethodType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Clarifai_Api_RunnerMethodType] = [
    .unknown,
    .unaryUnary,
    .unaryStreaming,
    .streamingUnary,
    .streamingStreaming,
  ]
}

#endif  // swift(>=4.2)

public enum Clarifai_Api_EventType: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case notSet // = 0

  /// Event types related to organization memberships and teams: 100 - 199
  case organizationMemberAdd // = 100
  case organizationMemberChange // = 101
  case organizationMemberRemove // = 102
  case organizationMemberInvitationCreate // = 103
  case organizationMemberInvitationCancel // = 104
  case organizationMemberInvitationAccept // = 105
  case organizationMemberInvitationDecline // = 106
  case organizationTeamCreate // = 107
  case organizationTeamUpdate // = 108
  case organizationTeamDelete // = 109
  case organizationTeamMemberAdd // = 110
  case organizationTeamMemberRemove // = 111
  case organizationTeamAppAdd // = 112
  case organizationTeamAppRemove // = 113

  /// Event types related to modules: 200 - 299
  case moduleCreate // = 200
  case moduleUpdate // = 201
  case moduleDelete // = 202
  case moduleVersionCreate // = 203
  case moduleVersionUpdate // = 204
  case moduleVersionDelete // = 205

  /// Event types related to models: 300 - 399
  case modelCreate // = 300
  case modelUpdate // = 301
  case modelDelete // = 302
  case modelVersionCreate // = 303
  case modelVersionUpdate // = 304
  case modelVersionDelete // = 305

  /// Event types related to workflows: 400 - 499
  case workflowCreate // = 400
  case workflowUpdate // = 401
  case workflowDelete // = 402
  case workflowVersionCreate // = 403
  case workflowVersionUpdate // = 404
  case workflowVersionDelete // = 405

  /// Event types related to applications: 600 - 699
  case applicationCreate // = 600
  case applicationUpdate // = 601
  case applicationDelete // = 602

  /// Event types related to collaborators: 700 - 799
  case collaboratorAdd // = 700
  case collaboratorUpdate // = 701
  case collaboratorRemove // = 702

  /// Event types related to users: 800 - 899
  case userUpdate // = 800
  case UNRECOGNIZED(Int)

  public init() {
    self = .notSet
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .notSet
    case 100: self = .organizationMemberAdd
    case 101: self = .organizationMemberChange
    case 102: self = .organizationMemberRemove
    case 103: self = .organizationMemberInvitationCreate
    case 104: self = .organizationMemberInvitationCancel
    case 105: self = .organizationMemberInvitationAccept
    case 106: self = .organizationMemberInvitationDecline
    case 107: self = .organizationTeamCreate
    case 108: self = .organizationTeamUpdate
    case 109: self = .organizationTeamDelete
    case 110: self = .organizationTeamMemberAdd
    case 111: self = .organizationTeamMemberRemove
    case 112: self = .organizationTeamAppAdd
    case 113: self = .organizationTeamAppRemove
    case 200: self = .moduleCreate
    case 201: self = .moduleUpdate
    case 202: self = .moduleDelete
    case 203: self = .moduleVersionCreate
    case 204: self = .moduleVersionUpdate
    case 205: self = .moduleVersionDelete
    case 300: self = .modelCreate
    case 301: self = .modelUpdate
    case 302: self = .modelDelete
    case 303: self = .modelVersionCreate
    case 304: self = .modelVersionUpdate
    case 305: self = .modelVersionDelete
    case 400: self = .workflowCreate
    case 401: self = .workflowUpdate
    case 402: self = .workflowDelete
    case 403: self = .workflowVersionCreate
    case 404: self = .workflowVersionUpdate
    case 405: self = .workflowVersionDelete
    case 600: self = .applicationCreate
    case 601: self = .applicationUpdate
    case 602: self = .applicationDelete
    case 700: self = .collaboratorAdd
    case 701: self = .collaboratorUpdate
    case 702: self = .collaboratorRemove
    case 800: self = .userUpdate
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .notSet: return 0
    case .organizationMemberAdd: return 100
    case .organizationMemberChange: return 101
    case .organizationMemberRemove: return 102
    case .organizationMemberInvitationCreate: return 103
    case .organizationMemberInvitationCancel: return 104
    case .organizationMemberInvitationAccept: return 105
    case .organizationMemberInvitationDecline: return 106
    case .organizationTeamCreate: return 107
    case .organizationTeamUpdate: return 108
    case .organizationTeamDelete: return 109
    case .organizationTeamMemberAdd: return 110
    case .organizationTeamMemberRemove: return 111
    case .organizationTeamAppAdd: return 112
    case .organizationTeamAppRemove: return 113
    case .moduleCreate: return 200
    case .moduleUpdate: return 201
    case .moduleDelete: return 202
    case .moduleVersionCreate: return 203
    case .moduleVersionUpdate: return 204
    case .moduleVersionDelete: return 205
    case .modelCreate: return 300
    case .modelUpdate: return 301
    case .modelDelete: return 302
    case .modelVersionCreate: return 303
    case .modelVersionUpdate: return 304
    case .modelVersionDelete: return 305
    case .workflowCreate: return 400
    case .workflowUpdate: return 401
    case .workflowDelete: return 402
    case .workflowVersionCreate: return 403
    case .workflowVersionUpdate: return 404
    case .workflowVersionDelete: return 405
    case .applicationCreate: return 600
    case .applicationUpdate: return 601
    case .applicationDelete: return 602
    case .collaboratorAdd: return 700
    case .collaboratorUpdate: return 701
    case .collaboratorRemove: return 702
    case .userUpdate: return 800
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Clarifai_Api_EventType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Clarifai_Api_EventType] = [
    .notSet,
    .organizationMemberAdd,
    .organizationMemberChange,
    .organizationMemberRemove,
    .organizationMemberInvitationCreate,
    .organizationMemberInvitationCancel,
    .organizationMemberInvitationAccept,
    .organizationMemberInvitationDecline,
    .organizationTeamCreate,
    .organizationTeamUpdate,
    .organizationTeamDelete,
    .organizationTeamMemberAdd,
    .organizationTeamMemberRemove,
    .organizationTeamAppAdd,
    .organizationTeamAppRemove,
    .moduleCreate,
    .moduleUpdate,
    .moduleDelete,
    .moduleVersionCreate,
    .moduleVersionUpdate,
    .moduleVersionDelete,
    .modelCreate,
    .modelUpdate,
    .modelDelete,
    .modelVersionCreate,
    .modelVersionUpdate,
    .modelVersionDelete,
    .workflowCreate,
    .workflowUpdate,
    .workflowDelete,
    .workflowVersionCreate,
    .workflowVersionUpdate,
    .workflowVersionDelete,
    .applicationCreate,
    .applicationUpdate,
    .applicationDelete,
    .collaboratorAdd,
    .collaboratorUpdate,
    .collaboratorRemove,
    .userUpdate,
  ]
}

#endif  // swift(>=4.2)

/// Annotation of an asset with metadata
public struct Clarifai_Api_Annotation {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The ID for the annotation
  public var id: String {
    get {return _storage._id}
    set {_uniqueStorage()._id = newValue}
  }

  /// ID of the input this annotation is tied to
  public var inputID: String {
    get {return _storage._inputID}
    set {_uniqueStorage()._inputID = newValue}
  }

  /// The data passed along in this annotation.
  public var data: Clarifai_Api_Data {
    get {return _storage._data ?? Clarifai_Api_Data()}
    set {_uniqueStorage()._data = newValue}
  }
  /// Returns true if `data` has been explicitly set.
  public var hasData: Bool {return _storage._data != nil}
  /// Clears the value of `data`. Subsequent reads from it will return its default value.
  public mutating func clearData() {_uniqueStorage()._data = nil}

  /// task_id is deprecated in annotation_info. Use task_id
  public var annotationInfo: SwiftProtobuf.Google_Protobuf_Struct {
    get {return _storage._annotationInfo ?? SwiftProtobuf.Google_Protobuf_Struct()}
    set {_uniqueStorage()._annotationInfo = newValue}
  }
  /// Returns true if `annotationInfo` has been explicitly set.
  public var hasAnnotationInfo: Bool {return _storage._annotationInfo != nil}
  /// Clears the value of `annotationInfo`. Subsequent reads from it will return its default value.
  public mutating func clearAnnotationInfo() {_uniqueStorage()._annotationInfo = nil}

  /// DEPRECATED: Use worker.user.id instead.
  public var userID: String {
    get {return _storage._userID}
    set {_uniqueStorage()._userID = newValue}
  }

  /// DEPRECATED: Use worker.model.model_version.id instead
  public var modelVersionID: String {
    get {return _storage._modelVersionID}
    set {_uniqueStorage()._modelVersionID = newValue}
  }

  /// DEPRECATED.
  public var embedModelVersionID: String {
    get {return _storage._embedModelVersionID}
    set {_uniqueStorage()._embedModelVersionID = newValue}
  }

  /// Annotation Status
  public var status: Clarifai_Api_Status_Status {
    get {return _storage._status ?? Clarifai_Api_Status_Status()}
    set {_uniqueStorage()._status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  public var hasStatus: Bool {return _storage._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  public mutating func clearStatus() {_uniqueStorage()._status = nil}

  /// When the annotation was created. We follow the XXXX timestamp
  /// format. We use https://www.ietf.org/rfc/rfc3339.txt format:
  /// "2006-01-02T15:04:05.999999Z" so you can expect results like
  /// the following from the API:
  /// "2017-04-11T21:50:50.223962Z"
  public var createdAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._createdAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._createdAt = newValue}
  }
  /// Returns true if `createdAt` has been explicitly set.
  public var hasCreatedAt: Bool {return _storage._createdAt != nil}
  /// Clears the value of `createdAt`. Subsequent reads from it will return its default value.
  public mutating func clearCreatedAt() {_uniqueStorage()._createdAt = nil}

  /// When the annotation was modified.
  public var modifiedAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._modifiedAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._modifiedAt = newValue}
  }
  /// Returns true if `modifiedAt` has been explicitly set.
  public var hasModifiedAt: Bool {return _storage._modifiedAt != nil}
  /// Clears the value of `modifiedAt`. Subsequent reads from it will return its default value.
  public mutating func clearModifiedAt() {_uniqueStorage()._modifiedAt = nil}

  /// Whether or not this annotation is trusted
  /// Will be deprecated
  public var trusted: Bool {
    get {return _storage._trusted}
    set {_uniqueStorage()._trusted = newValue}
  }

  /// Is this the input level annotation.
  public var inputLevel: Bool {
    get {return _storage._inputLevel}
    set {_uniqueStorage()._inputLevel = newValue}
  }

  /// Consensus review related information, e.g.
  /// * annotation group
  /// * id of annotation parent, in case the annotation was split from another annotation
  public var consensusInfo: SwiftProtobuf.Google_Protobuf_Struct {
    get {return _storage._consensusInfo ?? SwiftProtobuf.Google_Protobuf_Struct()}
    set {_uniqueStorage()._consensusInfo = newValue}
  }
  /// Returns true if `consensusInfo` has been explicitly set.
  public var hasConsensusInfo: Bool {return _storage._consensusInfo != nil}
  /// Clears the value of `consensusInfo`. Subsequent reads from it will return its default value.
  public mutating func clearConsensusInfo() {_uniqueStorage()._consensusInfo = nil}

  /// The id of the task annotation belongs to
  public var taskID: String {
    get {return _storage._taskID}
    set {_uniqueStorage()._taskID = newValue}
  }

  /// Worker is the worker that created the annotation.
  public var worker: Clarifai_Api_Worker {
    get {return _storage._worker ?? Clarifai_Api_Worker()}
    set {_uniqueStorage()._worker = newValue}
  }
  /// Returns true if `worker` has been explicitly set.
  public var hasWorker: Bool {return _storage._worker != nil}
  /// Clears the value of `worker`. Subsequent reads from it will return its default value.
  public mutating func clearWorker() {_uniqueStorage()._worker = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Worker is the author of an annotation.
public struct Clarifai_Api_Worker {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var worker: Clarifai_Api_Worker.OneOf_Worker? = nil

  /// User is the human that created the annotation.
  ///
  /// By default no real names of users are returned in responses. These can
  /// be requested with the 'names' additional field.
  public var user: Clarifai_Api_User {
    get {
      if case .user(let v)? = worker {return v}
      return Clarifai_Api_User()
    }
    set {worker = .user(newValue)}
  }

  /// Model is the model that created the annotation.
  public var model: Clarifai_Api_Model {
    get {
      if case .model(let v)? = worker {return v}
      return Clarifai_Api_Model()
    }
    set {worker = .model(newValue)}
  }

  /// Workflow is the workflow that created the annotation.
  public var workflow: Clarifai_Api_Workflow {
    get {
      if case .workflow(let v)? = worker {return v}
      return Clarifai_Api_Workflow()
    }
    set {worker = .workflow(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Worker: Equatable {
    /// User is the human that created the annotation.
    ///
    /// By default no real names of users are returned in responses. These can
    /// be requested with the 'names' additional field.
    case user(Clarifai_Api_User)
    /// Model is the model that created the annotation.
    case model(Clarifai_Api_Model)
    /// Workflow is the workflow that created the annotation.
    case workflow(Clarifai_Api_Workflow)

  #if !swift(>=4.1)
    public static func ==(lhs: Clarifai_Api_Worker.OneOf_Worker, rhs: Clarifai_Api_Worker.OneOf_Worker) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.user, .user): return {
        guard case .user(let l) = lhs, case .user(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.model, .model): return {
        guard case .model(let l) = lhs, case .model(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.workflow, .workflow): return {
        guard case .workflow(let l) = lhs, case .workflow(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

/// Application with tasks and datasets
public struct Clarifai_Api_App {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: String {
    get {return _storage._id}
    set {_uniqueStorage()._id = newValue}
  }

  public var name: String {
    get {return _storage._name}
    set {_uniqueStorage()._name = newValue}
  }

  public var defaultLanguage: String {
    get {return _storage._defaultLanguage}
    set {_uniqueStorage()._defaultLanguage = newValue}
  }

  /// Default workflow id deprecated in favor of default_workflow
  public var defaultWorkflowID: String {
    get {return _storage._defaultWorkflowID}
    set {_uniqueStorage()._defaultWorkflowID = newValue}
  }

  public var defaultWorkflow: Clarifai_Api_Workflow {
    get {return _storage._defaultWorkflow ?? Clarifai_Api_Workflow()}
    set {_uniqueStorage()._defaultWorkflow = newValue}
  }
  /// Returns true if `defaultWorkflow` has been explicitly set.
  public var hasDefaultWorkflow: Bool {return _storage._defaultWorkflow != nil}
  /// Clears the value of `defaultWorkflow`. Subsequent reads from it will return its default value.
  public mutating func clearDefaultWorkflow() {_uniqueStorage()._defaultWorkflow = nil}

  /// why is user_id present here when this message type is used in PostApps but completely ignored there? PostApp already
  /// specifies the userid in path but doesn't even actually use neither of userids, it instead used the id from auth context.
  /// This creates a lot of ambiguity, should always have different message types for Post/Get endpoints so that the minimum interface for each op can be described
  public var userID: String {
    get {return _storage._userID}
    set {_uniqueStorage()._userID = newValue}
  }

  /// When the app was created. We follow the XXXX timestamp
  /// format. We use https://www.ietf.org/rfc/rfc3339.txt format:
  /// "2006-01-02T15:04:05.999999Z" so you can expect results like
  /// the following from the API:
  /// "2017-04-11T21:50:50.223962Z"
  public var createdAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._createdAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._createdAt = newValue}
  }
  /// Returns true if `createdAt` has been explicitly set.
  public var hasCreatedAt: Bool {return _storage._createdAt != nil}
  /// Clears the value of `createdAt`. Subsequent reads from it will return its default value.
  public mutating func clearCreatedAt() {_uniqueStorage()._createdAt = nil}

  /// When the app was last modified
  public var modifiedAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._modifiedAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._modifiedAt = newValue}
  }
  /// Returns true if `modifiedAt` has been explicitly set.
  public var hasModifiedAt: Bool {return _storage._modifiedAt != nil}
  /// Clears the value of `modifiedAt`. Subsequent reads from it will return its default value.
  public mutating func clearModifiedAt() {_uniqueStorage()._modifiedAt = nil}

  /// if user accept legal consent for face recognition
  public var legalConsentStatus: UInt32 {
    get {return _storage._legalConsentStatus}
    set {_uniqueStorage()._legalConsentStatus = newValue}
  }

  /// To handle arbitrary json metadata you can use a struct field:
  /// https://github.com/google/protobuf/blob/master/src/google/protobuf/struct.proto
  public var metadata: SwiftProtobuf.Google_Protobuf_Struct {
    get {return _storage._metadata ?? SwiftProtobuf.Google_Protobuf_Struct()}
    set {_uniqueStorage()._metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  public var hasMetadata: Bool {return _storage._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  public mutating func clearMetadata() {_uniqueStorage()._metadata = nil}

  /// short description about the app.
  public var description_p: String {
    get {return _storage._description_p}
    set {_uniqueStorage()._description_p = newValue}
  }

  /// Default value for model predictions on video: Sample delay for video predicting (1 frame per N milliseconds)
  public var sampleMs: UInt32 {
    get {return _storage._sampleMs}
    set {_uniqueStorage()._sampleMs = newValue}
  }

  /// The visibility field represents whether this message is privately/publicly visible.
  /// To be visible to the public the App that contains it AND the User that contains the App must
  /// also be publicly visible.
  public var visibility: Clarifai_Api_Visibility {
    get {return _storage._visibility ?? Clarifai_Api_Visibility()}
    set {_uniqueStorage()._visibility = newValue}
  }
  /// Returns true if `visibility` has been explicitly set.
  public var hasVisibility: Bool {return _storage._visibility != nil}
  /// Clears the value of `visibility`. Subsequent reads from it will return its default value.
  public mutating func clearVisibility() {_uniqueStorage()._visibility = nil}

  /// data tier id this app is using.
  public var dataTierID: String {
    get {return _storage._dataTierID}
    set {_uniqueStorage()._dataTierID = newValue}
  }

  /// Is starred by the requesting user (only showed on get/list requests)
  /// Please use PostAppStars/DeleteAppStars endpoints to star/unstar an app
  public var isStarred: Bool {
    get {return _storage._isStarred}
    set {_uniqueStorage()._isStarred = newValue}
  }

  /// How many users have starred the app (only showed on get/list requests)
  /// Computed value, not editable
  public var starCount: Int32 {
    get {return _storage._starCount}
    set {_uniqueStorage()._starCount = newValue}
  }

  /// Notes for the application
  /// This field should be used for in-depth notes and supports up to 64Kbs.
  public var notes: String {
    get {return _storage._notes}
    set {_uniqueStorage()._notes = newValue}
  }

  /// Representative image for this app
  public var image: Clarifai_Api_Image {
    get {return _storage._image ?? Clarifai_Api_Image()}
    set {_uniqueStorage()._image = newValue}
  }
  /// Returns true if `image` has been explicitly set.
  public var hasImage: Bool {return _storage._image != nil}
  /// Clears the value of `image`. Subsequent reads from it will return its default value.
  public mutating func clearImage() {_uniqueStorage()._image = nil}

  /// An app marked as a template can be duplicated by any user that can see it,
  /// including all visible resources within it.
  public var isTemplate: SwiftProtobuf.Google_Protobuf_BoolValue {
    get {return _storage._isTemplate ?? SwiftProtobuf.Google_Protobuf_BoolValue()}
    set {_uniqueStorage()._isTemplate = newValue}
  }
  /// Returns true if `isTemplate` has been explicitly set.
  public var hasIsTemplate: Bool {return _storage._isTemplate != nil}
  /// Clears the value of `isTemplate`. Subsequent reads from it will return its default value.
  public mutating func clearIsTemplate() {_uniqueStorage()._isTemplate = nil}

  public var extraInfo: Clarifai_Api_AppExtraInfo {
    get {return _storage._extraInfo ?? Clarifai_Api_AppExtraInfo()}
    set {_uniqueStorage()._extraInfo = newValue}
  }
  /// Returns true if `extraInfo` has been explicitly set.
  public var hasExtraInfo: Bool {return _storage._extraInfo != nil}
  /// Clears the value of `extraInfo`. Subsequent reads from it will return its default value.
  public mutating func clearExtraInfo() {_uniqueStorage()._extraInfo = nil}

  /// Where app embeddings are stored
  /// postgres (default), qdrant
  public var embeddingsStorage: Clarifai_Api_App.EmbeddingsStorage {
    get {return _storage._embeddingsStorage}
    set {_uniqueStorage()._embeddingsStorage = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum EmbeddingsStorage: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case embeddingStorageNotSet // = 0
    case postgres // = 1
    case qdrant // = 2
    case UNRECOGNIZED(Int)

    public init() {
      self = .embeddingStorageNotSet
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .embeddingStorageNotSet
      case 1: self = .postgres
      case 2: self = .qdrant
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .embeddingStorageNotSet: return 0
      case .postgres: return 1
      case .qdrant: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

#if swift(>=4.2)

extension Clarifai_Api_App.EmbeddingsStorage: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Clarifai_Api_App.EmbeddingsStorage] = [
    .embeddingStorageNotSet,
    .postgres,
    .qdrant,
  ]
}

#endif  // swift(>=4.2)

public struct Clarifai_Api_AppExtraInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Revision marker for this application.
  /// The value of the revision changes when
  /// * inputs are added, updated or deleted
  /// * annotations are added, updated or deleted
  /// * inputs are added to or removed from datasets
  /// For example, this value can be used to detect if client side caches related to searching should be invalidated.
  /// Field not filled in for list endpoints, use GetApp
  public var searchRevisionMarker: String = String()

  public var counts: Clarifai_Api_AppResourceCounts {
    get {return _counts ?? Clarifai_Api_AppResourceCounts()}
    set {_counts = newValue}
  }
  /// Returns true if `counts` has been explicitly set.
  public var hasCounts: Bool {return self._counts != nil}
  /// Clears the value of `counts`. Subsequent reads from it will return its default value.
  public mutating func clearCounts() {self._counts = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _counts: Clarifai_Api_AppResourceCounts? = nil
}

/// App query
public struct Clarifai_Api_AppQuery {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Query by application name. This supports wildcard queries like "gen*" to match "general" as an example.
  public var name: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Clarifai_Api_AppResourceCounts {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var datasets: Int64 = 0

  public var models: Int64 = 0

  public var workflows: Int64 = 0

  public var modules: Int64 = 0

  public var inputs: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Collaborator - invited user, who shares an access to an application
public struct Clarifai_Api_Collaborator {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// id of this collaborator
  public var id: String = String()

  /// the app this collaborator has access to
  /// FIXME(zeiler): this should be in the user_app_id.app_id already from the endpoint.
  public var app: Clarifai_Api_App {
    get {return _app ?? Clarifai_Api_App()}
    set {_app = newValue}
  }
  /// Returns true if `app` has been explicitly set.
  public var hasApp: Bool {return self._app != nil}
  /// Clears the value of `app`. Subsequent reads from it will return its default value.
  public mutating func clearApp() {self._app = nil}

  /// who is this collaborator
  public var user: Clarifai_Api_User {
    get {return _user ?? Clarifai_Api_User()}
    set {_user = newValue}
  }
  /// Returns true if `user` has been explicitly set.
  public var hasUser: Bool {return self._user != nil}
  /// Clears the value of `user`. Subsequent reads from it will return its default value.
  public mutating func clearUser() {self._user = nil}

  /// the permission this collaborator
  public var scopes: [String] = []

  public var endpoints: [String] = []

  /// When the app was shared with. We follow the XXXX timestamp
  /// format. We use https://www.ietf.org/rfc/rfc3339.txt format:
  /// "2006-01-02T15:04:05.999999Z" so you can expect results like
  /// the following from the API:
  /// "2017-04-11T21:50:50.223962Z"
  public var createdAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _createdAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_createdAt = newValue}
  }
  /// Returns true if `createdAt` has been explicitly set.
  public var hasCreatedAt: Bool {return self._createdAt != nil}
  /// Clears the value of `createdAt`. Subsequent reads from it will return its default value.
  public mutating func clearCreatedAt() {self._createdAt = nil}

  /// When the collaborator was updated.
  public var modifiedAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _modifiedAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_modifiedAt = newValue}
  }
  /// Returns true if `modifiedAt` has been explicitly set.
  public var hasModifiedAt: Bool {return self._modifiedAt != nil}
  /// Clears the value of `modifiedAt`. Subsequent reads from it will return its default value.
  public mutating func clearModifiedAt() {self._modifiedAt = nil}

  /// When the collaborator was removed from app.
  public var deletedAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _deletedAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_deletedAt = newValue}
  }
  /// Returns true if `deletedAt` has been explicitly set.
  public var hasDeletedAt: Bool {return self._deletedAt != nil}
  /// Clears the value of `deletedAt`. Subsequent reads from it will return its default value.
  public mutating func clearDeletedAt() {self._deletedAt = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _app: Clarifai_Api_App? = nil
  fileprivate var _user: Clarifai_Api_User? = nil
  fileprivate var _createdAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _modifiedAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _deletedAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

/// collaboration includes an app you're invited to work on.
public struct Clarifai_Api_Collaboration {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// the application
  public var app: Clarifai_Api_App {
    get {return _app ?? Clarifai_Api_App()}
    set {_app = newValue}
  }
  /// Returns true if `app` has been explicitly set.
  public var hasApp: Bool {return self._app != nil}
  /// Clears the value of `app`. Subsequent reads from it will return its default value.
  public mutating func clearApp() {self._app = nil}

  /// the app owner's info(including user_unique_id, first_name, last_name, primary_email)
  public var appOwner: Clarifai_Api_User {
    get {return _appOwner ?? Clarifai_Api_User()}
    set {_appOwner = newValue}
  }
  /// Returns true if `appOwner` has been explicitly set.
  public var hasAppOwner: Bool {return self._appOwner != nil}
  /// Clears the value of `appOwner`. Subsequent reads from it will return its default value.
  public mutating func clearAppOwner() {self._appOwner = nil}

  /// the low-level scope users are shared with for this collaboration
  public var scopes: [String] = []

  /// the endpoint-level scopes users are shared with for this collaboration
  public var endpoints: [String] = []

  /// when is the collaboration created
  public var createdAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _createdAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_createdAt = newValue}
  }
  /// Returns true if `createdAt` has been explicitly set.
  public var hasCreatedAt: Bool {return self._createdAt != nil}
  /// Clears the value of `createdAt`. Subsequent reads from it will return its default value.
  public mutating func clearCreatedAt() {self._createdAt = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _app: Clarifai_Api_App? = nil
  fileprivate var _appOwner: Clarifai_Api_User? = nil
  fileprivate var _createdAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

/// Audio asset struct
public struct Clarifai_Api_Audio {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// This is a URL to a publicly accessible image file. The platform will download this file server
  /// side and then process.
  public var url: String = String()

  /// The base64 field is using image file bytes directly in the request.
  /// NOTE: if you're sending a json request, then this MUST be base64 encoded before sending (hence
  /// the name here).
  /// When using our grpc clients, you DO NOT need to base64 encode
  /// it yourself since the clients know how to do this for you automatically and will avoid the
  /// base64 encoding if they send a binary request.
  public var base64: Data = Data()

  /// If True then you will be allowed to have multiple urls.
  public var allowDuplicateURL: Bool = false

  /// The hosted field lists original audio hosted in Clarifai storage. This field is currently used
  /// only in response.
  public var hosted: Clarifai_Api_HostedURL {
    get {return _hosted ?? Clarifai_Api_HostedURL()}
    set {_hosted = newValue}
  }
  /// Returns true if `hosted` has been explicitly set.
  public var hasHosted: Bool {return self._hosted != nil}
  /// Clears the value of `hosted`. Subsequent reads from it will return its default value.
  public mutating func clearHosted() {self._hosted = nil}

  /// audio info
  public var audioInfo: Clarifai_Api_AudioInfo {
    get {return _audioInfo ?? Clarifai_Api_AudioInfo()}
    set {_audioInfo = newValue}
  }
  /// Returns true if `audioInfo` has been explicitly set.
  public var hasAudioInfo: Bool {return self._audioInfo != nil}
  /// Clears the value of `audioInfo`. Subsequent reads from it will return its default value.
  public mutating func clearAudioInfo() {self._audioInfo = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _hosted: Clarifai_Api_HostedURL? = nil
  fileprivate var _audioInfo: Clarifai_Api_AudioInfo? = nil
}

public struct Clarifai_Api_AudioInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// audio format
  public var audioFormat: String = String()

  /// sample rate
  public var sampleRate: Int32 = 0

  /// audio track duration in seconds
  public var durationSeconds: Float = 0

  /// audio track bit rate
  public var bitRate: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Track proto encodes information of a track over a number of frames
public struct Clarifai_Api_Track {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// track id
  public var id: String = String()

  /// This is a recursive definition which can contain all the concepts,
  /// embeddings, etc. that are computed within this track.
  public var data: Clarifai_Api_Data {
    get {return _data ?? Clarifai_Api_Data()}
    set {_data = newValue}
  }
  /// Returns true if `data` has been explicitly set.
  public var hasData: Bool {return self._data != nil}
  /// Clears the value of `data`. Subsequent reads from it will return its default value.
  public mutating func clearData() {self._data = nil}

  public var timeInfo: Clarifai_Api_TimeInfo {
    get {return _timeInfo ?? Clarifai_Api_TimeInfo()}
    set {_timeInfo = newValue}
  }
  /// Returns true if `timeInfo` has been explicitly set.
  public var hasTimeInfo: Bool {return self._timeInfo != nil}
  /// Clears the value of `timeInfo`. Subsequent reads from it will return its default value.
  public mutating func clearTimeInfo() {self._timeInfo = nil}

  public var quality: Float = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _data: Clarifai_Api_Data? = nil
  fileprivate var _timeInfo: Clarifai_Api_TimeInfo? = nil
}

/// Cluster data
public struct Clarifai_Api_Cluster {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: String = String()

  /// Number of annotations tied to the cluster in the app
  public var count: UInt32 = 0

  /// The score assigned to this cluster.
  /// For List Clusters endpoint, this represents percentage of inputs in the app assigned to this cluster.
  public var score: Float = 0

  /// Representative hits for cluster (for now we only return 1)
  public var hits: [Clarifai_Api_Hit] = []

  public var projection: [Float] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Color data
public struct Clarifai_Api_Color {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var rawHex: String = String()

  public var w3C: Clarifai_Api_W3C {
    get {return _w3C ?? Clarifai_Api_W3C()}
    set {_w3C = newValue}
  }
  /// Returns true if `w3C` has been explicitly set.
  public var hasW3C: Bool {return self._w3C != nil}
  /// Clears the value of `w3C`. Subsequent reads from it will return its default value.
  public mutating func clearW3C() {self._w3C = nil}

  public var value: Float = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _w3C: Clarifai_Api_W3C? = nil
}

public struct Clarifai_Api_W3C {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var hex: String = String()

  public var name: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Common message to identify the app in a url endpoint.
public struct Clarifai_Api_UserAppIDSet {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Note user_id 'me' is reserved - it is the alias for the id of authorized user
  public var userID: String = String()

  public var appID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// PatchAction
public struct Clarifai_Api_PatchAction {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The operation to perform on the patched metadata given a path
  /// For now only operations 'overwrite', 'delete, and 'merge' is supported
  public var op: String = String()

  /// If the action is 'merge' and there is a conflict, how to resolve it.
  /// The options are
  /// 'overwrite_by_id', 'remove_by_id', 'merge_by_id','overwrite', 'append' and 'do_nothing'
  /// Note that for conflict resolutions '*_by_id' to work on a list, the list should contain
  /// objects with an 'id' field which will be used to uniquely identify each field. For example
  /// Patching existing json
  /// {
  ///   "tag": [
  ///     {
  ///       "id": "1",
  ///       "data": 1
  ///     },
  ///     {
  ///       "id": "2",
  ///       "data": 2
  ///     }
  ///   ]
  /// }
  /// with op 'merge' and merge_conflict_resolution 'overwrite_by_id'
  /// {
  ///   "tag": [
  ///     {
  ///       "id": "2",
  ///       "data": 3
  ///     }
  ///   ]
  /// }
  /// would produce
  /// {
  ///   "tag": [
  ///     {
  ///       "id": "1",
  ///       "data": 1
  ///     },
  ///     {
  ///       "id": "2",
  ///       "data": 3
  ///     }
  ///   ]
  /// }
  /// while with merge_conflict_resolution 'remove_by_id' it would produce
  /// {
  ///   "tag": [
  ///     {
  ///       "id": "1",
  ///       "data": 1
  ///     }
  ///   ]
  /// }
  ///
  /// Option 'append' will simply create a list on conflicts. For example in above example
  /// the final result would be
  /// {
  ///   "tag": [
  ///     {
  ///       "id": "1",
  ///       "data": 1
  ///     },
  ///     {
  ///       "id": "2",
  ///       "data": [2, 3]
  ///     }
  ///   ]
  /// }
  public var mergeConflictResolution: String = String()

  /// Path for the change. For example 'tag[1].data' is a valid path in above example.
  /// Default path is root level i.e. ''.
  public var path: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Concept or tag
public struct Clarifai_Api_Concept {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The concept's unique id.
  public var id: String {
    get {return _storage._id}
    set {_uniqueStorage()._id = newValue}
  }

  /// The name of the concept in the given language.
  public var name: String {
    get {return _storage._name}
    set {_uniqueStorage()._name = newValue}
  }

  /// Used to indicate presence (1.0) or not (0.0) of this concept when making a request.
  /// This is also the prediction probability when returning predictions from our API.
  /// For convenience we use the default of 1.0 when making requests so the concept you provide is
  /// is treated as a positive (1.0) and not a negative (which would be value == 0.0).
  public var value: Float {
    get {return _storage._value}
    set {_uniqueStorage()._value = newValue}
  }

  /// When the concept was created. The format is https://www.ietf.org/rfc/rfc3339.txt .
  /// Example: "2006-01-02T15:04:05.999999Z". This field is used only in a response.
  public var createdAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._createdAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._createdAt = newValue}
  }
  /// Returns true if `createdAt` has been explicitly set.
  public var hasCreatedAt: Bool {return _storage._createdAt != nil}
  /// Clears the value of `createdAt`. Subsequent reads from it will return its default value.
  public mutating func clearCreatedAt() {_uniqueStorage()._createdAt = nil}

  /// The language in which the concept name is in. This is *ONLY* used in the response and setting
  /// it in a request is ignored since the default language of your app is used when creating
  /// or patching a Concept. To set other languages for your concept use the ConceptLanguage object
  /// and its corresponding endpoints.
  public var language: String {
    get {return _storage._language}
    set {_uniqueStorage()._language = newValue}
  }

  /// The application id that this concept is within. This can be ignored by most users.
  public var appID: String {
    get {return _storage._appID}
    set {_uniqueStorage()._appID = newValue}
  }

  /// The definition for the concept. Similar to name. This can be ignored by most users.
  public var definition: String {
    get {return _storage._definition}
    set {_uniqueStorage()._definition = newValue}
  }

  /// The vocabulary that this concept belongs to. This is useful if you have different unique sets
  /// of concepts that you can separate out based on this field. For example "age_appearance" vs
  /// "gender_appearance" in a list of concept returned from the demographics model.
  public var vocabID: String {
    get {return _storage._vocabID}
    set {_uniqueStorage()._vocabID = newValue}
  }

  /// The visibility field represents whether this message is privately/publicly visible.
  /// To be visible to the public the App that contains it AND the User that contains the App must
  /// also be publicly visible.
  public var visibility: Clarifai_Api_Visibility {
    get {return _storage._visibility ?? Clarifai_Api_Visibility()}
    set {_uniqueStorage()._visibility = newValue}
  }
  /// Returns true if `visibility` has been explicitly set.
  public var hasVisibility: Bool {return _storage._visibility != nil}
  /// Clears the value of `visibility`. Subsequent reads from it will return its default value.
  public mutating func clearVisibility() {_uniqueStorage()._visibility = nil}

  /// The user the concept belongs to.
  public var userID: String {
    get {return _storage._userID}
    set {_uniqueStorage()._userID = newValue}
  }

  /// Information about keypoints for this concept
  public var keypointInfo: Clarifai_Api_KeypointInfo {
    get {return _storage._keypointInfo ?? Clarifai_Api_KeypointInfo()}
    set {_uniqueStorage()._keypointInfo = newValue}
  }
  /// Returns true if `keypointInfo` has been explicitly set.
  public var hasKeypointInfo: Bool {return _storage._keypointInfo != nil}
  /// Clears the value of `keypointInfo`. Subsequent reads from it will return its default value.
  public mutating func clearKeypointInfo() {_uniqueStorage()._keypointInfo = nil}

  /// Optional extra info.
  public var extraInfo: Clarifai_Api_ConceptExtraInfo {
    get {return _storage._extraInfo ?? Clarifai_Api_ConceptExtraInfo()}
    set {_uniqueStorage()._extraInfo = newValue}
  }
  /// Returns true if `extraInfo` has been explicitly set.
  public var hasExtraInfo: Bool {return _storage._extraInfo != nil}
  /// Clears the value of `extraInfo`. Subsequent reads from it will return its default value.
  public mutating func clearExtraInfo() {_uniqueStorage()._extraInfo = nil}

  /// To handle arbitrary json metadata:
  /// https://github.com/google/protobuf/blob/master/src/google/protobuf/struct.proto
  public var metadata: SwiftProtobuf.Google_Protobuf_Struct {
    get {return _storage._metadata ?? SwiftProtobuf.Google_Protobuf_Struct()}
    set {_uniqueStorage()._metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  public var hasMetadata: Bool {return _storage._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  public mutating func clearMetadata() {_uniqueStorage()._metadata = nil}

  /// Representative image for the concept
  public var image: Clarifai_Api_Image {
    get {return _storage._image ?? Clarifai_Api_Image()}
    set {_uniqueStorage()._image = newValue}
  }
  /// Returns true if `image` has been explicitly set.
  public var hasImage: Bool {return _storage._image != nil}
  /// Clears the value of `image`. Subsequent reads from it will return its default value.
  public mutating func clearImage() {_uniqueStorage()._image = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Clarifai_Api_KeypointInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Names of the keypoints
  public var keypointNames: [String] = []

  /// Defines the connections between keypoint_names. Each value represents the index in keypoint_names.
  public var skeleton: [Clarifai_Api_KeypointEdge] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Clarifai_Api_KeypointEdge {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var k1: UInt32 = 0

  public var k2: UInt32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// ConceptExtraInfo represents extra information related to a concept that is context-dependent.
/// It is only set when requested in ConceptExtraInfoRequest.
public struct Clarifai_Api_ConceptExtraInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Whether this concept is rankable based on ConceptExtraInfoRequest configuration.
  public var isRankable: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// ConceptCount
public struct Clarifai_Api_ConceptCount {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The concept's unique id.
  public var id: String = String()

  /// The name of the concept.
  public var name: String = String()

  /// The total count for concepts labeled for all asset statues (processing, to_process, processed, error)
  public var conceptTypeCount: Clarifai_Api_ConceptTypeCount {
    get {return _conceptTypeCount ?? Clarifai_Api_ConceptTypeCount()}
    set {_conceptTypeCount = newValue}
  }
  /// Returns true if `conceptTypeCount` has been explicitly set.
  public var hasConceptTypeCount: Bool {return self._conceptTypeCount != nil}
  /// Clears the value of `conceptTypeCount`. Subsequent reads from it will return its default value.
  public mutating func clearConceptTypeCount() {self._conceptTypeCount = nil}

  /// The detail count for different assets status
  public var detailConceptCount: Clarifai_Api_DetailConceptCount {
    get {return _detailConceptCount ?? Clarifai_Api_DetailConceptCount()}
    set {_detailConceptCount = newValue}
  }
  /// Returns true if `detailConceptCount` has been explicitly set.
  public var hasDetailConceptCount: Bool {return self._detailConceptCount != nil}
  /// Clears the value of `detailConceptCount`. Subsequent reads from it will return its default value.
  public mutating func clearDetailConceptCount() {self._detailConceptCount = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _conceptTypeCount: Clarifai_Api_ConceptTypeCount? = nil
  fileprivate var _detailConceptCount: Clarifai_Api_DetailConceptCount? = nil
}

/// ConceptTypeCount
public struct Clarifai_Api_ConceptTypeCount {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The number of inputs that have a concept with a value of 1.0 (indicating presence of the
  /// concept in an input).
  public var positive: UInt32 = 0

  /// The number of inputs that have a concept with a value of 0.0 (indicating absence of the
  /// concept in an input).
  public var negative: UInt32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// DetailConceptCount
public struct Clarifai_Api_DetailConceptCount {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The concept count for processed assets
  public var processed: Clarifai_Api_ConceptTypeCount {
    get {return _processed ?? Clarifai_Api_ConceptTypeCount()}
    set {_processed = newValue}
  }
  /// Returns true if `processed` has been explicitly set.
  public var hasProcessed: Bool {return self._processed != nil}
  /// Clears the value of `processed`. Subsequent reads from it will return its default value.
  public mutating func clearProcessed() {self._processed = nil}

  /// The concept count for to process assets
  public var toProcess: Clarifai_Api_ConceptTypeCount {
    get {return _toProcess ?? Clarifai_Api_ConceptTypeCount()}
    set {_toProcess = newValue}
  }
  /// Returns true if `toProcess` has been explicitly set.
  public var hasToProcess: Bool {return self._toProcess != nil}
  /// Clears the value of `toProcess`. Subsequent reads from it will return its default value.
  public mutating func clearToProcess() {self._toProcess = nil}

  /// The concept count for assets with status error
  public var errors: Clarifai_Api_ConceptTypeCount {
    get {return _errors ?? Clarifai_Api_ConceptTypeCount()}
    set {_errors = newValue}
  }
  /// Returns true if `errors` has been explicitly set.
  public var hasErrors: Bool {return self._errors != nil}
  /// Clears the value of `errors`. Subsequent reads from it will return its default value.
  public mutating func clearErrors() {self._errors = nil}

  /// The concept count for processing assets
  public var processing: Clarifai_Api_ConceptTypeCount {
    get {return _processing ?? Clarifai_Api_ConceptTypeCount()}
    set {_processing = newValue}
  }
  /// Returns true if `processing` has been explicitly set.
  public var hasProcessing: Bool {return self._processing != nil}
  /// Clears the value of `processing`. Subsequent reads from it will return its default value.
  public mutating func clearProcessing() {self._processing = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _processed: Clarifai_Api_ConceptTypeCount? = nil
  fileprivate var _toProcess: Clarifai_Api_ConceptTypeCount? = nil
  fileprivate var _errors: Clarifai_Api_ConceptTypeCount? = nil
  fileprivate var _processing: Clarifai_Api_ConceptTypeCount? = nil
}

/// ConceptQuery
public struct Clarifai_Api_ConceptQuery {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The name of the concept to search.
  public var name: String = String()

  /// The language of the concept name in a search. Defaults to English.
  public var language: String = String()

  /// Deprecated: Use workflow.id instead.
  public var workflowID: String = String()

  /// The concepts must belong to models with specified use cases.
  /// Multiple values are joined using an OR condition.
  public var useCases: [Clarifai_Api_WorkflowModelUseCase] = []

  /// Search for concepts in a specific model or workflow.
  /// ########## Supported fields ##########
  ///  - model.id                - fetch concepts from this model
  ///  - model.model_version.id  - if set, then use the specified model version. if not set, use latest model version
  ///
  ///  - workflow.id             - fetch concepts from this workflow
  ///  - workflow.version.id     - if set, then use the specified workflow version. if not set, use latest workflow version
  /// ######################################
  public var source: Clarifai_Api_ConceptQuery.OneOf_Source? = nil

  public var model: Clarifai_Api_Model {
    get {
      if case .model(let v)? = source {return v}
      return Clarifai_Api_Model()
    }
    set {source = .model(newValue)}
  }

  public var workflow: Clarifai_Api_Workflow {
    get {
      if case .workflow(let v)? = source {return v}
      return Clarifai_Api_Workflow()
    }
    set {source = .workflow(newValue)}
  }

  /// By default, we return app concepts combined with source (model or workflow) concepts.
  /// If source is not set, then we only return app concepts.
  /// If ignore_app_concepts is true, then we only return source concepts.
  /// When use_cases are set, then ignore_app_concepts is always true, because
  /// concept use cases can only be determined in relation to a model or a workflow.
  public var ignoreAppConcepts: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Search for concepts in a specific model or workflow.
  /// ########## Supported fields ##########
  ///  - model.id                - fetch concepts from this model
  ///  - model.model_version.id  - if set, then use the specified model version. if not set, use latest model version
  ///
  ///  - workflow.id             - fetch concepts from this workflow
  ///  - workflow.version.id     - if set, then use the specified workflow version. if not set, use latest workflow version
  /// ######################################
  public enum OneOf_Source: Equatable {
    case model(Clarifai_Api_Model)
    case workflow(Clarifai_Api_Workflow)

  #if !swift(>=4.1)
    public static func ==(lhs: Clarifai_Api_ConceptQuery.OneOf_Source, rhs: Clarifai_Api_ConceptQuery.OneOf_Source) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.model, .model): return {
        guard case .model(let l) = lhs, case .model(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.workflow, .workflow): return {
        guard case .workflow(let l) = lhs, case .workflow(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

/// This represents a relation (i.e. edge) between the subject concept and the object concept
public struct Clarifai_Api_ConceptRelation {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// ID of the concept relation
  public var id: String = String()

  /// The subject concept (i.e. source) of the concept relation
  public var subjectConcept: Clarifai_Api_Concept {
    get {return _subjectConcept ?? Clarifai_Api_Concept()}
    set {_subjectConcept = newValue}
  }
  /// Returns true if `subjectConcept` has been explicitly set.
  public var hasSubjectConcept: Bool {return self._subjectConcept != nil}
  /// Clears the value of `subjectConcept`. Subsequent reads from it will return its default value.
  public mutating func clearSubjectConcept() {self._subjectConcept = nil}

  /// The subject concept (i.e. destination) of the concept relation
  public var objectConcept: Clarifai_Api_Concept {
    get {return _objectConcept ?? Clarifai_Api_Concept()}
    set {_objectConcept = newValue}
  }
  /// Returns true if `objectConcept` has been explicitly set.
  public var hasObjectConcept: Bool {return self._objectConcept != nil}
  /// Clears the value of `objectConcept`. Subsequent reads from it will return its default value.
  public mutating func clearObjectConcept() {self._objectConcept = nil}

  /// The predicate (i.e. edge) linking the subject and the object
  /// Both subject_concept and object_concept are concepts.
  /// The predicate is the type of relationship.
  /// That predicate acts on the subject.
  ///
  /// There are three current types of predicates:
  /// 1) "hyponym"
  /// 2) "hypernym"
  /// 3) "synonym"
  ///
  /// 1) For example, 'hyponym' is a type of predicate which represents 'is_a_kind_of' relation so
  /// the following relationship:
  /// 'honey' (subject), 'hyponym' (predicate), 'food' (object)
  /// Can more easily be read as:
  /// 'honey' 'is a kind of' 'food'
  ///
  ///
  /// 2) The 'hypernym' relation is the opposite of 'hyponym' and when you add one of the
  /// relationships the opposite will automatically appear for you in queries.
  ///
  /// The 'hypernym' can be read as 'is a parent of' so:
  /// 'food' (subject), 'hypernym' (predicate), 'honey' (object)
  /// Can more easily be read as:
  /// 'food' is a parent of 'honey'
  ///
  /// 3) The 'synonym' relation defines two concepts that essential mean the same thing. This
  /// is more like a "is" relationship. So for example a 'synonym' relationship could be:
  /// "puppy" is "pup"
  /// The reverse is also true once the former is added so:
  /// "pup" is "puppy"
  /// will appear in queries as well.
  public var predicate: String = String()

  /// The knowledge graph id that this edge belongs to. If using the app's global knowledge graph
  /// and not a specific one then this should be the empty string "".
  public var knowledgeGraphID: String = String()

  /// The visibility field represents whether this message is privately/publicly visible.
  /// To be visible to the public the App that contains it AND the User that contains the App must
  /// also be publicly visible.
  public var visibility: Clarifai_Api_Visibility {
    get {return _visibility ?? Clarifai_Api_Visibility()}
    set {_visibility = newValue}
  }
  /// Returns true if `visibility` has been explicitly set.
  public var hasVisibility: Bool {return self._visibility != nil}
  /// Clears the value of `visibility`. Subsequent reads from it will return its default value.
  public mutating func clearVisibility() {self._visibility = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _subjectConcept: Clarifai_Api_Concept? = nil
  fileprivate var _objectConcept: Clarifai_Api_Concept? = nil
  fileprivate var _visibility: Clarifai_Api_Visibility? = nil
}

/// A Knowledge Graph is a logical subsets of edges in the overall Concept Graph
public struct Clarifai_Api_KnowledgeGraph {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// ID of the knowledge graph
  public var id: String = String()

  /// Name of the knowledge graph
  public var name: String = String()

  /// Human readable description of the knowledge graph
  public var description_p: String = String()

  /// The app that contains the images that correspond to the concepts in the knowledge graph
  public var examplesAppID: String = String()

  /// The app that contains the sample images that we want to show the customer for the concepts in the knowledge graph
  public var sampledExamplesAppID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// This represents a link to an outside source for the given concept.
/// The values from here are sticked into Concept message into the name and definition fields when
/// returning from the API in your default language. The "id" field here becomes the "language"
/// field of the Concept message which is a little weird.
public struct Clarifai_Api_ConceptLanguage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// This is the language code for the language such as "en".
  public var id: String = String()

  /// The type of the outside source.
  public var name: String = String()

  /// The ID that is referenced in the source.
  public var definition: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Data
public struct Clarifai_Api_Data {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Input and output images.
  public var image: Clarifai_Api_Image {
    get {return _storage._image ?? Clarifai_Api_Image()}
    set {_uniqueStorage()._image = newValue}
  }
  /// Returns true if `image` has been explicitly set.
  public var hasImage: Bool {return _storage._image != nil}
  /// Clears the value of `image`. Subsequent reads from it will return its default value.
  public mutating func clearImage() {_uniqueStorage()._image = nil}

  /// Input and output videos.
  public var video: Clarifai_Api_Video {
    get {return _storage._video ?? Clarifai_Api_Video()}
    set {_uniqueStorage()._video = newValue}
  }
  /// Returns true if `video` has been explicitly set.
  public var hasVideo: Bool {return _storage._video != nil}
  /// Clears the value of `video`. Subsequent reads from it will return its default value.
  public mutating func clearVideo() {_uniqueStorage()._video = nil}

  /// A list of concepts.
  public var concepts: [Clarifai_Api_Concept] {
    get {return _storage._concepts}
    set {_uniqueStorage()._concepts = newValue}
  }

  /// To handle arbitrary json metadata you can use a struct field:
  /// https://github.com/google/protobuf/blob/master/src/google/protobuf/struct.proto
  public var metadata: SwiftProtobuf.Google_Protobuf_Struct {
    get {return _storage._metadata ?? SwiftProtobuf.Google_Protobuf_Struct()}
    set {_uniqueStorage()._metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  public var hasMetadata: Bool {return _storage._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  public mutating func clearMetadata() {_uniqueStorage()._metadata = nil}

  /// Geography information.
  public var geo: Clarifai_Api_Geo {
    get {return _storage._geo ?? Clarifai_Api_Geo()}
    set {_uniqueStorage()._geo = newValue}
  }
  /// Returns true if `geo` has been explicitly set.
  public var hasGeo: Bool {return _storage._geo != nil}
  /// Clears the value of `geo`. Subsequent reads from it will return its default value.
  public mutating func clearGeo() {_uniqueStorage()._geo = nil}

  /// The dominant colors within an image.
  public var colors: [Clarifai_Api_Color] {
    get {return _storage._colors}
    set {_uniqueStorage()._colors = newValue}
  }

  /// Clustering centroids for inputs.
  public var clusters: [Clarifai_Api_Cluster] {
    get {return _storage._clusters}
    set {_uniqueStorage()._clusters = newValue}
  }

  /// Embedding vectors representing each input.
  public var embeddings: [Clarifai_Api_Embedding] {
    get {return _storage._embeddings}
    set {_uniqueStorage()._embeddings = newValue}
  }

  /// For recursing into localized regions of an input.
  public var regions: [Clarifai_Api_Region] {
    get {return _storage._regions}
    set {_uniqueStorage()._regions = newValue}
  }

  /// For temporal content like video.
  public var frames: [Clarifai_Api_Frame] {
    get {return _storage._frames}
    set {_uniqueStorage()._frames = newValue}
  }

  /// Input, output or annotation text.
  public var text: Clarifai_Api_Text {
    get {return _storage._text ?? Clarifai_Api_Text()}
    set {_uniqueStorage()._text = newValue}
  }
  /// Returns true if `text` has been explicitly set.
  public var hasText: Bool {return _storage._text != nil}
  /// Clears the value of `text`. Subsequent reads from it will return its default value.
  public mutating func clearText() {_uniqueStorage()._text = nil}

  /// Input and output audio.
  public var audio: Clarifai_Api_Audio {
    get {return _storage._audio ?? Clarifai_Api_Audio()}
    set {_uniqueStorage()._audio = newValue}
  }
  /// Returns true if `audio` has been explicitly set.
  public var hasAudio: Bool {return _storage._audio != nil}
  /// Clears the value of `audio`. Subsequent reads from it will return its default value.
  public mutating func clearAudio() {_uniqueStorage()._audio = nil}

  /// Track information.
  public var tracks: [Clarifai_Api_Track] {
    get {return _storage._tracks}
    set {_uniqueStorage()._tracks = newValue}
  }

  /// Time segments information.
  public var timeSegments: [Clarifai_Api_TimeSegment] {
    get {return _storage._timeSegments}
    set {_uniqueStorage()._timeSegments = newValue}
  }

  /// Holds score, rank, and user, app, input IDs and search hit data
  public var hits: [Clarifai_Api_Hit] {
    get {return _storage._hits}
    set {_uniqueStorage()._hits = newValue}
  }

  /// Heatmap as 2d image
  public var heatmaps: [Clarifai_Api_Image] {
    get {return _storage._heatmaps}
    set {_uniqueStorage()._heatmaps = newValue}
  }

  /// For data messages that have multiple parts such as multi-modal
  /// requests, we allow you to specify those as a list of Data objects.
  public var parts: [Clarifai_Api_Part] {
    get {return _storage._parts}
    set {_uniqueStorage()._parts = newValue}
  }

  /// A proto representation for numpy arrays, useful to pass information from python SDK to a
  /// python based model implementation.
  public var ndarray: Clarifai_Api_NDArray {
    get {return _storage._ndarray ?? Clarifai_Api_NDArray()}
    set {_uniqueStorage()._ndarray = newValue}
  }
  /// Returns true if `ndarray` has been explicitly set.
  public var hasNdarray: Bool {return _storage._ndarray != nil}
  /// Clears the value of `ndarray`. Subsequent reads from it will return its default value.
  public mutating func clearNdarray() {_uniqueStorage()._ndarray = nil}

  /// Input and output integer number
  public var intValue: Int64 {
    get {return _storage._intValue}
    set {_uniqueStorage()._intValue = newValue}
  }

  /// Input and output floating number
  public var floatValue: Double {
    get {return _storage._floatValue}
    set {_uniqueStorage()._floatValue = newValue}
  }

  /// Input and output bytes data
  public var bytesValue: Data {
    get {return _storage._bytesValue}
    set {_uniqueStorage()._bytesValue = newValue}
  }

  /// Input and output bool data
  public var boolValue: Bool {
    get {return _storage._boolValue}
    set {_uniqueStorage()._boolValue = newValue}
  }

  /// Input and output string data
  public var stringValue: String {
    get {return _storage._stringValue}
    set {_uniqueStorage()._stringValue = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// A part of data used for multi-modal processing.
public struct Clarifai_Api_Part {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The data for this part.
  public var data: Clarifai_Api_Data {
    get {return _data ?? Clarifai_Api_Data()}
    set {_data = newValue}
  }
  /// Returns true if `data` has been explicitly set.
  public var hasData: Bool {return self._data != nil}
  /// Clears the value of `data`. Subsequent reads from it will return its default value.
  public mutating func clearData() {self._data = nil}

  /// A unique id for the part.
  public var id: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _data: Clarifai_Api_Data? = nil
}

/// A region within the data.
public struct Clarifai_Api_Region {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// A unique id for the region.
  public var id: String = String()

  /// The details about the location of the region.
  public var regionInfo: Clarifai_Api_RegionInfo {
    get {return _regionInfo ?? Clarifai_Api_RegionInfo()}
    set {_regionInfo = newValue}
  }
  /// Returns true if `regionInfo` has been explicitly set.
  public var hasRegionInfo: Bool {return self._regionInfo != nil}
  /// Clears the value of `regionInfo`. Subsequent reads from it will return its default value.
  public mutating func clearRegionInfo() {self._regionInfo = nil}

  /// A recursive definition of the data within the Region. For example, this will contain
  /// data.concepts if the region also has annotations or predictions of concepts within it.
  public var data: Clarifai_Api_Data {
    get {return _data ?? Clarifai_Api_Data()}
    set {_data = newValue}
  }
  /// Returns true if `data` has been explicitly set.
  public var hasData: Bool {return self._data != nil}
  /// Clears the value of `data`. Subsequent reads from it will return its default value.
  public mutating func clearData() {self._data = nil}

  /// This is the confidence score of the overall Region.
  public var value: Float = 0

  /// For tracking algorithsm and annotations we tie regions together with this track id.
  public var trackID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _regionInfo: Clarifai_Api_RegionInfo? = nil
  fileprivate var _data: Clarifai_Api_Data? = nil
}

/// The information of the location of the Region.
public struct Clarifai_Api_RegionInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Details of the region's rectangular bounding box.
  public var boundingBox: Clarifai_Api_BoundingBox {
    get {return _storage._boundingBox ?? Clarifai_Api_BoundingBox()}
    set {_uniqueStorage()._boundingBox = newValue}
  }
  /// Returns true if `boundingBox` has been explicitly set.
  public var hasBoundingBox: Bool {return _storage._boundingBox != nil}
  /// Clears the value of `boundingBox`. Subsequent reads from it will return its default value.
  public mutating func clearBoundingBox() {_uniqueStorage()._boundingBox = nil}

  /// Details of the region's segmentation mask.
  public var mask: Clarifai_Api_Mask {
    get {return _storage._mask ?? Clarifai_Api_Mask()}
    set {_uniqueStorage()._mask = newValue}
  }
  /// Returns true if `mask` has been explicitly set.
  public var hasMask: Bool {return _storage._mask != nil}
  /// Clears the value of `mask`. Subsequent reads from it will return its default value.
  public mutating func clearMask() {_uniqueStorage()._mask = nil}

  /// A polygon of points.
  public var polygon: Clarifai_Api_Polygon {
    get {return _storage._polygon ?? Clarifai_Api_Polygon()}
    set {_uniqueStorage()._polygon = newValue}
  }
  /// Returns true if `polygon` has been explicitly set.
  public var hasPolygon: Bool {return _storage._polygon != nil}
  /// Clears the value of `polygon`. Subsequent reads from it will return its default value.
  public mutating func clearPolygon() {_uniqueStorage()._polygon = nil}

  /// A landmark point location.
  public var point: Clarifai_Api_Point {
    get {return _storage._point ?? Clarifai_Api_Point()}
    set {_uniqueStorage()._point = newValue}
  }
  /// Returns true if `point` has been explicitly set.
  public var hasPoint: Bool {return _storage._point != nil}
  /// Clears the value of `point`. Subsequent reads from it will return its default value.
  public mutating func clearPoint() {_uniqueStorage()._point = nil}

  /// Span char sequence for NLP.
  public var span: Clarifai_Api_Span {
    get {return _storage._span ?? Clarifai_Api_Span()}
    set {_uniqueStorage()._span = newValue}
  }
  /// Returns true if `span` has been explicitly set.
  public var hasSpan: Bool {return _storage._span != nil}
  /// Clears the value of `span`. Subsequent reads from it will return its default value.
  public mutating func clearSpan() {_uniqueStorage()._span = nil}

  /// Token char sequence for NLP.
  public var token: Clarifai_Api_Token {
    get {return _storage._token ?? Clarifai_Api_Token()}
    set {_uniqueStorage()._token = newValue}
  }
  /// Returns true if `token` has been explicitly set.
  public var hasToken: Bool {return _storage._token != nil}
  /// Clears the value of `token`. Subsequent reads from it will return its default value.
  public mutating func clearToken() {_uniqueStorage()._token = nil}

  /// The locations of detected keypoints, which are to be used in conjunction with the detected concept's skeleton to connect the keypoint locations.
  /// These will be in the same order as the respective keypoint_names inside the concept.
  public var keypointLocations: [Clarifai_Api_Point] {
    get {return _storage._keypointLocations}
    set {_uniqueStorage()._keypointLocations = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Rectangular bounding box for a region.
public struct Clarifai_Api_BoundingBox {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The top left of the bounding box normalized to the data dimension to be within [0-1.0]
  public var topRow: Float = 0

  /// The left column of the bounding box normalized to the data dimension to be within [0-1.0]
  public var leftCol: Float = 0

  /// The bottom row of the bounding box normalized to the data dimension to be within [0-1.0]
  public var bottomRow: Float = 0

  /// The right col of the bounding box normalized to the data dimension to be within [0-1.0]
  public var rightCol: Float = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// The information of the location of the Frame.
public struct Clarifai_Api_FrameInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Deprecated. Use Time instead.
  /// The index of the frame, informational and optional.
  /// Depends on the sampling rate used during processing
  /// May be 0 for interpolated frames that are generated for brief time (training) or if new frame is manually added
  public var index: UInt32 = 0

  /// time in the video in milliseconds. This is independent of the sampling rates used during
  /// processing.
  public var time: UInt32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// A Frame of time-series Data such as a Video.
public struct Clarifai_Api_Frame {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Information aboue frame such as number and time.
  public var frameInfo: Clarifai_Api_FrameInfo {
    get {return _frameInfo ?? Clarifai_Api_FrameInfo()}
    set {_frameInfo = newValue}
  }
  /// Returns true if `frameInfo` has been explicitly set.
  public var hasFrameInfo: Bool {return self._frameInfo != nil}
  /// Clears the value of `frameInfo`. Subsequent reads from it will return its default value.
  public mutating func clearFrameInfo() {self._frameInfo = nil}

  /// A recursive definition of the data within the Frame. For example, this will contain
  /// data.concepts if the Frame also has annotations or predictions of concepts within it.
  /// This can also have data.regions for annotation or predictions of detection regions, which can
  /// then recursively have their data field filled in as well.
  public var data: Clarifai_Api_Data {
    get {return _data ?? Clarifai_Api_Data()}
    set {_data = newValue}
  }
  /// Returns true if `data` has been explicitly set.
  public var hasData: Bool {return self._data != nil}
  /// Clears the value of `data`. Subsequent reads from it will return its default value.
  public mutating func clearData() {self._data = nil}

  /// An ID for the frame.
  public var id: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _frameInfo: Clarifai_Api_FrameInfo? = nil
  fileprivate var _data: Clarifai_Api_Data? = nil
}

/// A representation of a numpy array as a proto.
/// To convert a numpy array 'ndarray' to this proto do:
/// NDArray(buffer=ndarray.tobytes(), shape=ndarray.shape, dtype=str(ndarray.dtype))
///
/// To convert this proto 'ndarray_proto' to a numpy array:
/// array = np.frombuffer(ndarray_proto.buffer, dtype=ndarray_proto.dtype)
/// array = array.reshape(tuple(ndarray_proto.shape))
public struct Clarifai_Api_NDArray {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The bytes of data from the array from array.tobytes()
  public var buffer: Data = Data()

  /// Simply the shape of the numpy array. array.shape.
  public var shape: [UInt32] = []

  /// Dtype for numpy. You can get it back from this string format using:
  /// np.dtype('float32') for example.
  public var dtype: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Segmentation mask.
public struct Clarifai_Api_Mask {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The image of the mask in a non-raster format.
  public var image: Clarifai_Api_Image {
    get {return _image ?? Clarifai_Api_Image()}
    set {_image = newValue}
  }
  /// Returns true if `image` has been explicitly set.
  public var hasImage: Bool {return self._image != nil}
  /// Clears the value of `image`. Subsequent reads from it will return its default value.
  public mutating func clearImage() {self._image = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _image: Clarifai_Api_Image? = nil
}

/// Polygon
public struct Clarifai_Api_Polygon {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// A list of points connected together to form the polygon.
  public var points: [Clarifai_Api_Point] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Point
public struct Clarifai_Api_Point {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The row location of the point. This has a [0.0-1.0] range with 0.0 being top row and 1.0
  /// being the bottom row.
  public var row: Float = 0

  /// The column location of the point. This has a [0.0-1.0] range with 0.0 being left col and 1.0
  /// being the right col.
  public var col: Float = 0

  /// Depth if applicable for the point.
  public var z: Float = 0

  public var visibility: Clarifai_Api_Point.Visibility = .notSet

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Whether this point is visible or occluded
  public enum Visibility: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// Visibility of the point is not set
    case notSet // = 0

    /// Point is visible
    case visible // = 1

    /// Point is occluded
    case notVisible // = 2

    /// Point is not in the image
    case notPresent // = 3
    case UNRECOGNIZED(Int)

    public init() {
      self = .notSet
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .notSet
      case 1: self = .visible
      case 2: self = .notVisible
      case 3: self = .notPresent
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .notSet: return 0
      case .visible: return 1
      case .notVisible: return 2
      case .notPresent: return 3
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Clarifai_Api_Point.Visibility: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Clarifai_Api_Point.Visibility] = [
    .notSet,
    .visible,
    .notVisible,
    .notPresent,
  ]
}

#endif  // swift(>=4.2)

public struct Clarifai_Api_Span {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var charStart: UInt32 = 0

  public var charEnd: UInt32 = 0

  public var rawText: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Clarifai_Api_Token {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var charStart: UInt32 = 0

  public var charEnd: UInt32 = 0

  public var rawText: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Embedding
public struct Clarifai_Api_Embedding {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var vector: [Float] = []

  public var numDimensions: UInt32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// GeoPoint
public struct Clarifai_Api_GeoPoint {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var longitude: Float = 0

  public var latitude: Float = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// GeoLimit
public struct Clarifai_Api_GeoLimit {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var type: String = String()

  public var value: Float = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// GeoBoxedPoint
public struct Clarifai_Api_GeoBoxedPoint {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var geoPoint: Clarifai_Api_GeoPoint {
    get {return _geoPoint ?? Clarifai_Api_GeoPoint()}
    set {_geoPoint = newValue}
  }
  /// Returns true if `geoPoint` has been explicitly set.
  public var hasGeoPoint: Bool {return self._geoPoint != nil}
  /// Clears the value of `geoPoint`. Subsequent reads from it will return its default value.
  public mutating func clearGeoPoint() {self._geoPoint = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _geoPoint: Clarifai_Api_GeoPoint? = nil
}

/// Geo
public struct Clarifai_Api_Geo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var geoPoint: Clarifai_Api_GeoPoint {
    get {return _geoPoint ?? Clarifai_Api_GeoPoint()}
    set {_geoPoint = newValue}
  }
  /// Returns true if `geoPoint` has been explicitly set.
  public var hasGeoPoint: Bool {return self._geoPoint != nil}
  /// Clears the value of `geoPoint`. Subsequent reads from it will return its default value.
  public mutating func clearGeoPoint() {self._geoPoint = nil}

  public var geoLimit: Clarifai_Api_GeoLimit {
    get {return _geoLimit ?? Clarifai_Api_GeoLimit()}
    set {_geoLimit = newValue}
  }
  /// Returns true if `geoLimit` has been explicitly set.
  public var hasGeoLimit: Bool {return self._geoLimit != nil}
  /// Clears the value of `geoLimit`. Subsequent reads from it will return its default value.
  public mutating func clearGeoLimit() {self._geoLimit = nil}

  /// NOTE: inconsistency: should have been geo_boxed_points
  public var geoBox: [Clarifai_Api_GeoBoxedPoint] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _geoPoint: Clarifai_Api_GeoPoint? = nil
  fileprivate var _geoLimit: Clarifai_Api_GeoLimit? = nil
}

/// Image
public struct Clarifai_Api_Image {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// This is a URL to a publicly accessible image file. The platform will download this file server
  /// side and then process.
  public var url: String = String()

  /// The base64 field is using image file bytes directly in the request.
  /// NOTE: if you're sending a json request, then this MUST be base64 encoded before sending (hence
  /// the name here).
  /// When using our grpc clients, you DO NOT need to base64 encode
  /// it yourself since the clients know how to do this for you automatically and will avoid the
  /// base64 encoding if they send a binary request.
  public var base64: Data = Data()

  public var allowDuplicateURL: Bool = false

  /// The hosted field lists images in different sizes hosted in Clarifai storage.
  public var hosted: Clarifai_Api_HostedURL {
    get {return _hosted ?? Clarifai_Api_HostedURL()}
    set {_hosted = newValue}
  }
  /// Returns true if `hosted` has been explicitly set.
  public var hasHosted: Bool {return self._hosted != nil}
  /// Clears the value of `hosted`. Subsequent reads from it will return its default value.
  public mutating func clearHosted() {self._hosted = nil}

  /// image info for original size. for image info for other sizes, use hosted_image_info
  public var imageInfo: Clarifai_Api_ImageInfo {
    get {return _imageInfo ?? Clarifai_Api_ImageInfo()}
    set {_imageInfo = newValue}
  }
  /// Returns true if `imageInfo` has been explicitly set.
  public var hasImageInfo: Bool {return self._imageInfo != nil}
  /// Clears the value of `imageInfo`. Subsequent reads from it will return its default value.
  public mutating func clearImageInfo() {self._imageInfo = nil}

  /// The map of hosted image info of different sizes (see hosted.sizes), excluding the original image.
  /// Note: keys(hosted_image_info) = hosted.sizes - "orig"
  public var hostedImageInfo: Dictionary<String,Clarifai_Api_ImageInfo> = [:]

  /// For internal processing of already decoded bytes.
  public var decodedBytes: Data = Data()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _hosted: Clarifai_Api_HostedURL? = nil
  fileprivate var _imageInfo: Clarifai_Api_ImageInfo? = nil
}

public struct Clarifai_Api_ImageInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// width
  public var width: Int32 = 0

  /// height
  public var height: Int32 = 0

  /// image format
  public var format: String = String()

  /// image color mode
  public var colorMode: String = String()

  /// mode (when used for decoded_bytes) (RGB, RGBA, P, L, etc.)
  public var mode: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// HostedURL
public struct Clarifai_Api_HostedURL {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Prefix of the URL of every hosted image.
  public var prefix: String = String()

  /// Suffix of an image stored in different sizes.
  public var suffix: String = String()

  /// The sizes field lists which images of the different sizes are hosted in our storage. The URL
  /// of each hosted image can be obtained by joining the prefix, one of the sizes and suffix.
  public var sizes: [String] = []

  /// The crossorigin property of html media tag
  /// For Secure Data Hosting this needs to be set to 'use-credentials'
  public var crossorigin: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Input
public struct Clarifai_Api_Input {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The ID for the input
  public var id: String {
    get {return _storage._id}
    set {_uniqueStorage()._id = newValue}
  }

  /// The data passed along in this input.
  public var data: Clarifai_Api_Data {
    get {return _storage._data ?? Clarifai_Api_Data()}
    set {_uniqueStorage()._data = newValue}
  }
  /// Returns true if `data` has been explicitly set.
  public var hasData: Bool {return _storage._data != nil}
  /// Clears the value of `data`. Subsequent reads from it will return its default value.
  public mutating func clearData() {_uniqueStorage()._data = nil}

  /// When the input was created. We follow the XXXX timestamp
  /// format. We use https://www.ietf.org/rfc/rfc3339.txt format:
  /// "2006-01-02T15:04:05.999999Z" so you can expect results like
  /// the following from the API:
  /// "2017-04-11T21:50:50.223962Z"
  public var createdAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._createdAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._createdAt = newValue}
  }
  /// Returns true if `createdAt` has been explicitly set.
  public var hasCreatedAt: Bool {return _storage._createdAt != nil}
  /// Clears the value of `createdAt`. Subsequent reads from it will return its default value.
  public mutating func clearCreatedAt() {_uniqueStorage()._createdAt = nil}

  /// When the input was modified.
  public var modifiedAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._modifiedAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._modifiedAt = newValue}
  }
  /// Returns true if `modifiedAt` has been explicitly set.
  public var hasModifiedAt: Bool {return _storage._modifiedAt != nil}
  /// Clears the value of `modifiedAt`. Subsequent reads from it will return its default value.
  public mutating func clearModifiedAt() {_uniqueStorage()._modifiedAt = nil}

  /// This is the status at a per Input level which allows for
  /// partial failures.
  public var status: Clarifai_Api_Status_Status {
    get {return _storage._status ?? Clarifai_Api_Status_Status()}
    set {_uniqueStorage()._status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  public var hasStatus: Bool {return _storage._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  public mutating func clearStatus() {_uniqueStorage()._status = nil}

  /// List of dataset IDs that this input is part of
  /// Currently, this field is ONLY used to
  /// * search inputs part of dataset(s), e.g. in `PostSearches`, `PostInputsSearches` and `PostAnnotationsSearches` endpoints, and
  /// * to add inputs to dataset(s) in `PostInputs` endpoint.
  /// Note that this field is ignored for other endpoints, e.g. `GetInput`, `ListInputs` and `PatchInputs`.
  public var datasetIds: [String] {
    get {return _storage._datasetIds}
    set {_uniqueStorage()._datasetIds = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// InputBatch is a batch of Input resources. Large amounts of inputs are usually
/// divided into multiple InputBatches.
public struct Clarifai_Api_InputBatch {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var inputs: [Clarifai_Api_Input] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// NOTE: inconsistency: this is weird mix of plural and singular words.
public struct Clarifai_Api_InputCount {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var processed: UInt32 = 0

  public var toProcess: UInt32 = 0

  public var errors: UInt32 = 0

  public var processing: UInt32 = 0

  public var reindexed: UInt32 = 0

  public var toReindex: UInt32 = 0

  public var reindexErrors: UInt32 = 0

  public var reindexing: UInt32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Dataset
public struct Clarifai_Api_Dataset {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The ID for the dataset
  public var id: String {
    get {return _storage._id}
    set {_uniqueStorage()._id = newValue}
  }

  /// When the dataset was created.
  /// The format is https://www.ietf.org/rfc/rfc3339.txt.
  /// Example: "2006-01-02T15:04:05.999999Z".
  public var createdAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._createdAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._createdAt = newValue}
  }
  /// Returns true if `createdAt` has been explicitly set.
  public var hasCreatedAt: Bool {return _storage._createdAt != nil}
  /// Clears the value of `createdAt`. Subsequent reads from it will return its default value.
  public mutating func clearCreatedAt() {_uniqueStorage()._createdAt = nil}

  /// When the dataset was modified.
  /// The format is https://www.ietf.org/rfc/rfc3339.txt.
  /// Example: "2006-01-02T15:04:05.999999Z".
  public var modifiedAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._modifiedAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._modifiedAt = newValue}
  }
  /// Returns true if `modifiedAt` has been explicitly set.
  public var hasModifiedAt: Bool {return _storage._modifiedAt != nil}
  /// Clears the value of `modifiedAt`. Subsequent reads from it will return its default value.
  public mutating func clearModifiedAt() {_uniqueStorage()._modifiedAt = nil}

  /// The app the dataset belongs to.
  public var appID: String {
    get {return _storage._appID}
    set {_uniqueStorage()._appID = newValue}
  }

  /// The user the dataset belongs to.
  public var userID: String {
    get {return _storage._userID}
    set {_uniqueStorage()._userID = newValue}
  }

  /// Description of the dataset
  public var description_p: String {
    get {return _storage._description_p}
    set {_uniqueStorage()._description_p = newValue}
  }

  /// To handle arbitrary json metadata you can use a struct field:
  /// https://github.com/google/protobuf/blob/master/src/google/protobuf/struct.proto
  public var metadata: SwiftProtobuf.Google_Protobuf_Struct {
    get {return _storage._metadata ?? SwiftProtobuf.Google_Protobuf_Struct()}
    set {_uniqueStorage()._metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  public var hasMetadata: Bool {return _storage._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  public mutating func clearMetadata() {_uniqueStorage()._metadata = nil}

  /// The visibility field represents whether this message is privately/publicly visible.
  /// To be visible to the public the App that contains it AND the User that contains the App must
  /// also be publicly visible.
  public var visibility: Clarifai_Api_Visibility {
    get {return _storage._visibility ?? Clarifai_Api_Visibility()}
    set {_uniqueStorage()._visibility = newValue}
  }
  /// Returns true if `visibility` has been explicitly set.
  public var hasVisibility: Bool {return _storage._visibility != nil}
  /// Clears the value of `visibility`. Subsequent reads from it will return its default value.
  public mutating func clearVisibility() {_uniqueStorage()._visibility = nil}

  /// Default annotation filter used for this dataset.
  public var defaultAnnotationFilter: Clarifai_Api_AnnotationFilter {
    get {return _storage._defaultAnnotationFilter ?? Clarifai_Api_AnnotationFilter()}
    set {_uniqueStorage()._defaultAnnotationFilter = newValue}
  }
  /// Returns true if `defaultAnnotationFilter` has been explicitly set.
  public var hasDefaultAnnotationFilter: Bool {return _storage._defaultAnnotationFilter != nil}
  /// Clears the value of `defaultAnnotationFilter`. Subsequent reads from it will return its default value.
  public mutating func clearDefaultAnnotationFilter() {_uniqueStorage()._defaultAnnotationFilter = nil}

  /// Default processing info used for this dataset.
  public var defaultProcessingInfo: Clarifai_Api_DatasetVersionProcessingInfo {
    get {return _storage._defaultProcessingInfo ?? Clarifai_Api_DatasetVersionProcessingInfo()}
    set {_uniqueStorage()._defaultProcessingInfo = newValue}
  }
  /// Returns true if `defaultProcessingInfo` has been explicitly set.
  public var hasDefaultProcessingInfo: Bool {return _storage._defaultProcessingInfo != nil}
  /// Clears the value of `defaultProcessingInfo`. Subsequent reads from it will return its default value.
  public mutating func clearDefaultProcessingInfo() {_uniqueStorage()._defaultProcessingInfo = nil}

  /// Notes for the dataset
  /// This field should be used for in-depth notes and supports up to 64Kbs.
  public var notes: String {
    get {return _storage._notes}
    set {_uniqueStorage()._notes = newValue}
  }

  /// Dataset version associated with this dataset. This is used in listing Datasets
  /// and including the latest version.
  public var version: Clarifai_Api_DatasetVersion {
    get {return _storage._version ?? Clarifai_Api_DatasetVersion()}
    set {_uniqueStorage()._version = newValue}
  }
  /// Returns true if `version` has been explicitly set.
  public var hasVersion: Bool {return _storage._version != nil}
  /// Clears the value of `version`. Subsequent reads from it will return its default value.
  public mutating func clearVersion() {_uniqueStorage()._version = nil}

  /// Whether the dataset is starred by the requesting user.
  public var isStarred: Bool {
    get {return _storage._isStarred}
    set {_uniqueStorage()._isStarred = newValue}
  }

  /// Number of users that starred this dataset.
  public var starCount: Int32 {
    get {return _storage._starCount}
    set {_uniqueStorage()._starCount = newValue}
  }

  /// bookmark info. When set, this dataset is a bookmarked dataset of this app.
  /// Info in this field will allow you to find/access original dataset.
  public var bookmarkOrigin: Clarifai_Api_BookmarkOrigin {
    get {return _storage._bookmarkOrigin ?? Clarifai_Api_BookmarkOrigin()}
    set {_uniqueStorage()._bookmarkOrigin = newValue}
  }
  /// Returns true if `bookmarkOrigin` has been explicitly set.
  public var hasBookmarkOrigin: Bool {return _storage._bookmarkOrigin != nil}
  /// Clears the value of `bookmarkOrigin`. Subsequent reads from it will return its default value.
  public mutating func clearBookmarkOrigin() {_uniqueStorage()._bookmarkOrigin = nil}

  /// Representative image for this dataset
  public var image: Clarifai_Api_Image {
    get {return _storage._image ?? Clarifai_Api_Image()}
    set {_uniqueStorage()._image = newValue}
  }
  /// Returns true if `image` has been explicitly set.
  public var hasImage: Bool {return _storage._image != nil}
  /// Clears the value of `image`. Subsequent reads from it will return its default value.
  public mutating func clearImage() {_uniqueStorage()._image = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// AnnotationFilter is used to create a new dataset version.
/// For now, the filter is simply a wrapper over a Search.
/// In the future, we may add extra fields to customize the filtering.
public struct Clarifai_Api_AnnotationFilter {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The ID for the annotation filter
  public var id: String = String()

  /// When the annotation filter was created.
  /// The format is https://www.ietf.org/rfc/rfc3339.txt.
  /// Example: "2006-01-02T15:04:05.999999Z".
  public var createdAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _createdAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_createdAt = newValue}
  }
  /// Returns true if `createdAt` has been explicitly set.
  public var hasCreatedAt: Bool {return self._createdAt != nil}
  /// Clears the value of `createdAt`. Subsequent reads from it will return its default value.
  public mutating func clearCreatedAt() {self._createdAt = nil}

  /// When the annotation filter was modified.
  /// The format is https://www.ietf.org/rfc/rfc3339.txt.
  /// Example: "2006-01-02T15:04:05.999999Z".
  public var modifiedAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _modifiedAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_modifiedAt = newValue}
  }
  /// Returns true if `modifiedAt` has been explicitly set.
  public var hasModifiedAt: Bool {return self._modifiedAt != nil}
  /// Clears the value of `modifiedAt`. Subsequent reads from it will return its default value.
  public mutating func clearModifiedAt() {self._modifiedAt = nil}

  /// The user the annotation filter belongs to.
  public var userID: String = String()

  /// The app the annotation filter belongs to.
  public var appID: String = String()

  /// The search that this filter uses.
  public var search: Clarifai_Api_Search {
    get {return _search ?? Clarifai_Api_Search()}
    set {_search = newValue}
  }
  /// Returns true if `search` has been explicitly set.
  public var hasSearch: Bool {return self._search != nil}
  /// Clears the value of `search`. Subsequent reads from it will return its default value.
  public mutating func clearSearch() {self._search = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _createdAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _modifiedAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _search: Clarifai_Api_Search? = nil
}

/// DatasetInput
public struct Clarifai_Api_DatasetInput {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// When the input was added to the dataset.
  /// The format is https://www.ietf.org/rfc/rfc3339.txt.
  /// Example: "2006-01-02T15:04:05.999999Z".
  public var createdAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _createdAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_createdAt = newValue}
  }
  /// Returns true if `createdAt` has been explicitly set.
  public var hasCreatedAt: Bool {return self._createdAt != nil}
  /// Clears the value of `createdAt`. Subsequent reads from it will return its default value.
  public mutating func clearCreatedAt() {self._createdAt = nil}

  /// The input data.
  public var input: Clarifai_Api_Input {
    get {return _input ?? Clarifai_Api_Input()}
    set {_input = newValue}
  }
  /// Returns true if `input` has been explicitly set.
  public var hasInput: Bool {return self._input != nil}
  /// Clears the value of `input`. Subsequent reads from it will return its default value.
  public mutating func clearInput() {self._input = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _createdAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _input: Clarifai_Api_Input? = nil
}

/// DatasetVersion
public struct Clarifai_Api_DatasetVersion {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The ID for the dataset version
  public var id: String {
    get {return _storage._id}
    set {_uniqueStorage()._id = newValue}
  }

  /// When the dataset version was created.
  /// The format is https://www.ietf.org/rfc/rfc3339.txt.
  /// Example: "2006-01-02T15:04:05.999999Z".
  public var createdAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._createdAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._createdAt = newValue}
  }
  /// Returns true if `createdAt` has been explicitly set.
  public var hasCreatedAt: Bool {return _storage._createdAt != nil}
  /// Clears the value of `createdAt`. Subsequent reads from it will return its default value.
  public mutating func clearCreatedAt() {_uniqueStorage()._createdAt = nil}

  /// When the dataset version was modified.
  /// The format is https://www.ietf.org/rfc/rfc3339.txt.
  /// Example: "2006-01-02T15:04:05.999999Z".
  public var modifiedAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._modifiedAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._modifiedAt = newValue}
  }
  /// Returns true if `modifiedAt` has been explicitly set.
  public var hasModifiedAt: Bool {return _storage._modifiedAt != nil}
  /// Clears the value of `modifiedAt`. Subsequent reads from it will return its default value.
  public mutating func clearModifiedAt() {_uniqueStorage()._modifiedAt = nil}

  /// The app the dataset version belongs to.
  public var appID: String {
    get {return _storage._appID}
    set {_uniqueStorage()._appID = newValue}
  }

  /// The user the dataset version belongs to.
  public var userID: String {
    get {return _storage._userID}
    set {_uniqueStorage()._userID = newValue}
  }

  /// The dataset the dataset version belongs to.
  public var datasetID: String {
    get {return _storage._datasetID}
    set {_uniqueStorage()._datasetID = newValue}
  }

  /// Data config reveals how the dataset version is generated.
  public var dataConfig: OneOf_DataConfig? {
    get {return _storage._dataConfig}
    set {_uniqueStorage()._dataConfig = newValue}
  }

  /// The dataset version will be generated based on a single annotation filter.
  public var annotationFilterConfig: Clarifai_Api_AnnotationFilterConfig {
    get {
      if case .annotationFilterConfig(let v)? = _storage._dataConfig {return v}
      return Clarifai_Api_AnnotationFilterConfig()
    }
    set {_uniqueStorage()._dataConfig = .annotationFilterConfig(newValue)}
  }

  /// The dataset version will be generated based on model version inferences.
  public var modelPredictConfig: Clarifai_Api_ModelPredictConfig {
    get {
      if case .modelPredictConfig(let v)? = _storage._dataConfig {return v}
      return Clarifai_Api_ModelPredictConfig()
    }
    set {_uniqueStorage()._dataConfig = .modelPredictConfig(newValue)}
  }

  /// Status for this dataset version.
  public var status: Clarifai_Api_Status_Status {
    get {return _storage._status ?? Clarifai_Api_Status_Status()}
    set {_uniqueStorage()._status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  public var hasStatus: Bool {return _storage._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  public mutating func clearStatus() {_uniqueStorage()._status = nil}

  /// Description of the dataset version
  public var description_p: String {
    get {return _storage._description_p}
    set {_uniqueStorage()._description_p = newValue}
  }

  /// Dataset version processing. If this is not set when the dataset version is
  /// created, then the dataset default_processing_info is copied instead. Later
  /// updates to default_processing_info will not apply to existing versions.
  public var processingInfo: Clarifai_Api_DatasetVersionProcessingInfo {
    get {return _storage._processingInfo ?? Clarifai_Api_DatasetVersionProcessingInfo()}
    set {_uniqueStorage()._processingInfo = newValue}
  }
  /// Returns true if `processingInfo` has been explicitly set.
  public var hasProcessingInfo: Bool {return _storage._processingInfo != nil}
  /// Clears the value of `processingInfo`. Subsequent reads from it will return its default value.
  public mutating func clearProcessingInfo() {_uniqueStorage()._processingInfo = nil}

  /// Dataset version metrics
  public var metrics: Dictionary<String,Clarifai_Api_DatasetVersionMetrics> {
    get {return _storage._metrics}
    set {_uniqueStorage()._metrics = newValue}
  }

  /// Dataset version exports
  public var exportInfo: Clarifai_Api_DatasetVersionExportInfo {
    get {return _storage._exportInfo ?? Clarifai_Api_DatasetVersionExportInfo()}
    set {_uniqueStorage()._exportInfo = newValue}
  }
  /// Returns true if `exportInfo` has been explicitly set.
  public var hasExportInfo: Bool {return _storage._exportInfo != nil}
  /// Clears the value of `exportInfo`. Subsequent reads from it will return its default value.
  public mutating func clearExportInfo() {_uniqueStorage()._exportInfo = nil}

  /// To handle arbitrary json metadata you can use a struct field:
  /// https://github.com/google/protobuf/blob/master/src/google/protobuf/struct.proto
  public var metadata: SwiftProtobuf.Google_Protobuf_Struct {
    get {return _storage._metadata ?? SwiftProtobuf.Google_Protobuf_Struct()}
    set {_uniqueStorage()._metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  public var hasMetadata: Bool {return _storage._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  public mutating func clearMetadata() {_uniqueStorage()._metadata = nil}

  /// The visibility field represents whether this message is privately/publicly visible.
  /// To be visible to the public the App that contains it AND the User that contains the App must
  /// also be publicly visible.
  public var visibility: Clarifai_Api_Visibility {
    get {return _storage._visibility ?? Clarifai_Api_Visibility()}
    set {_uniqueStorage()._visibility = newValue}
  }
  /// Returns true if `visibility` has been explicitly set.
  public var hasVisibility: Bool {return _storage._visibility != nil}
  /// Clears the value of `visibility`. Subsequent reads from it will return its default value.
  public mutating func clearVisibility() {_uniqueStorage()._visibility = nil}

  /// The embedding models to return embeddings for. If empty, no embeddings are returned.
  public var embedModelVersionIds: [String] {
    get {return _storage._embedModelVersionIds}
    set {_uniqueStorage()._embedModelVersionIds = newValue}
  }

  /// Read Only. Cannot be Set
  /// Origin of request for new dataset version
  public var requestOrigin: Clarifai_Api_DatasetVersionRequestOrigin {
    get {return _storage._requestOrigin}
    set {_uniqueStorage()._requestOrigin = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Data config reveals how the dataset version is generated.
  public enum OneOf_DataConfig: Equatable {
    /// The dataset version will be generated based on a single annotation filter.
    case annotationFilterConfig(Clarifai_Api_AnnotationFilterConfig)
    /// The dataset version will be generated based on model version inferences.
    case modelPredictConfig(Clarifai_Api_ModelPredictConfig)

  #if !swift(>=4.1)
    public static func ==(lhs: Clarifai_Api_DatasetVersion.OneOf_DataConfig, rhs: Clarifai_Api_DatasetVersion.OneOf_DataConfig) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.annotationFilterConfig, .annotationFilterConfig): return {
        guard case .annotationFilterConfig(let l) = lhs, case .annotationFilterConfig(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.modelPredictConfig, .modelPredictConfig): return {
        guard case .modelPredictConfig(let l) = lhs, case .modelPredictConfig(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Clarifai_Api_AnnotationFilterConfig {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The annotation filter that is used.
  public var annotationFilter: Clarifai_Api_AnnotationFilter {
    get {return _annotationFilter ?? Clarifai_Api_AnnotationFilter()}
    set {_annotationFilter = newValue}
  }
  /// Returns true if `annotationFilter` has been explicitly set.
  public var hasAnnotationFilter: Bool {return self._annotationFilter != nil}
  /// Clears the value of `annotationFilter`. Subsequent reads from it will return its default value.
  public mutating func clearAnnotationFilter() {self._annotationFilter = nil}

  /// If true, empty inputs are not included in the dataset version.
  /// If false, empty inputs are included in the dataset version.
  /// We define an empty input as an input without any annotations after annotation filter is applied.
  public var ignoreEmptyInputs: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _annotationFilter: Clarifai_Api_AnnotationFilter? = nil
}

public struct Clarifai_Api_ModelPredictConfig {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Assumed to be owned by the calling users app unless user_id and app_id are filled out.
  public var model: Clarifai_Api_Model {
    get {return _storage._model ?? Clarifai_Api_Model()}
    set {_uniqueStorage()._model = newValue}
  }
  /// Returns true if `model` has been explicitly set.
  public var hasModel: Bool {return _storage._model != nil}
  /// Clears the value of `model`. Subsequent reads from it will return its default value.
  public mutating func clearModel() {_uniqueStorage()._model = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Clarifai_Api_DatasetVersionMetrics {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Number of inputs
  public var inputsCount: SwiftProtobuf.Google_Protobuf_UInt64Value {
    get {return _storage._inputsCount ?? SwiftProtobuf.Google_Protobuf_UInt64Value()}
    set {_uniqueStorage()._inputsCount = newValue}
  }
  /// Returns true if `inputsCount` has been explicitly set.
  public var hasInputsCount: Bool {return _storage._inputsCount != nil}
  /// Clears the value of `inputsCount`. Subsequent reads from it will return its default value.
  public mutating func clearInputsCount() {_uniqueStorage()._inputsCount = nil}

  /// Number of unlabeled inputs
  /// An input is considered unlabeled if it there are no annotations with positive labels for that input.
  public var unlabeledInputsCount: SwiftProtobuf.Google_Protobuf_UInt64Value {
    get {return _storage._unlabeledInputsCount ?? SwiftProtobuf.Google_Protobuf_UInt64Value()}
    set {_uniqueStorage()._unlabeledInputsCount = newValue}
  }
  /// Returns true if `unlabeledInputsCount` has been explicitly set.
  public var hasUnlabeledInputsCount: Bool {return _storage._unlabeledInputsCount != nil}
  /// Clears the value of `unlabeledInputsCount`. Subsequent reads from it will return its default value.
  public mutating func clearUnlabeledInputsCount() {_uniqueStorage()._unlabeledInputsCount = nil}

  /// Number of inputs that have metadata
  public var inputsWithMetadataCount: SwiftProtobuf.Google_Protobuf_UInt64Value {
    get {return _storage._inputsWithMetadataCount ?? SwiftProtobuf.Google_Protobuf_UInt64Value()}
    set {_uniqueStorage()._inputsWithMetadataCount = newValue}
  }
  /// Returns true if `inputsWithMetadataCount` has been explicitly set.
  public var hasInputsWithMetadataCount: Bool {return _storage._inputsWithMetadataCount != nil}
  /// Clears the value of `inputsWithMetadataCount`. Subsequent reads from it will return its default value.
  public mutating func clearInputsWithMetadataCount() {_uniqueStorage()._inputsWithMetadataCount = nil}

  /// Number of inputs that have geo information
  public var inputsWithGeoCount: SwiftProtobuf.Google_Protobuf_UInt64Value {
    get {return _storage._inputsWithGeoCount ?? SwiftProtobuf.Google_Protobuf_UInt64Value()}
    set {_uniqueStorage()._inputsWithGeoCount = newValue}
  }
  /// Returns true if `inputsWithGeoCount` has been explicitly set.
  public var hasInputsWithGeoCount: Bool {return _storage._inputsWithGeoCount != nil}
  /// Clears the value of `inputsWithGeoCount`. Subsequent reads from it will return its default value.
  public mutating func clearInputsWithGeoCount() {_uniqueStorage()._inputsWithGeoCount = nil}

  /// Number of regions
  public var regionsCount: SwiftProtobuf.Google_Protobuf_UInt64Value {
    get {return _storage._regionsCount ?? SwiftProtobuf.Google_Protobuf_UInt64Value()}
    set {_uniqueStorage()._regionsCount = newValue}
  }
  /// Returns true if `regionsCount` has been explicitly set.
  public var hasRegionsCount: Bool {return _storage._regionsCount != nil}
  /// Clears the value of `regionsCount`. Subsequent reads from it will return its default value.
  public mutating func clearRegionsCount() {_uniqueStorage()._regionsCount = nil}

  /// The matrix shows where the regions are located.
  /// Example: If the matrix has 2x2 dimensions, then
  /// * region_location_matrix[0][0] = the number of regions that appear in the top left corner, i.e. [0,0]..(0.5,0.5)
  /// * region_location_matrix[0][1] = the number of regions that appear in the top right corner, i.e. [0,0.5]..[0.5,1]
  /// * region_location_matrix[1][0] = the number of regions that appear in the bottom left corner, i.e. [0.5,0]..[1,0.5)
  /// * region_location_matrix[1][1] = the number of regions that appear in the bottom right corner, i.e. [0.5,0.5]..[1,1]
  public var regionLocationMatrix: MatrixUint64 {
    get {return _storage._regionLocationMatrix ?? MatrixUint64()}
    set {_uniqueStorage()._regionLocationMatrix = newValue}
  }
  /// Returns true if `regionLocationMatrix` has been explicitly set.
  public var hasRegionLocationMatrix: Bool {return _storage._regionLocationMatrix != nil}
  /// Clears the value of `regionLocationMatrix`. Subsequent reads from it will return its default value.
  public mutating func clearRegionLocationMatrix() {_uniqueStorage()._regionLocationMatrix = nil}

  /// Number of bounding boxes
  public var boundingBoxesCount: SwiftProtobuf.Google_Protobuf_UInt64Value {
    get {return _storage._boundingBoxesCount ?? SwiftProtobuf.Google_Protobuf_UInt64Value()}
    set {_uniqueStorage()._boundingBoxesCount = newValue}
  }
  /// Returns true if `boundingBoxesCount` has been explicitly set.
  public var hasBoundingBoxesCount: Bool {return _storage._boundingBoxesCount != nil}
  /// Clears the value of `boundingBoxesCount`. Subsequent reads from it will return its default value.
  public mutating func clearBoundingBoxesCount() {_uniqueStorage()._boundingBoxesCount = nil}

  /// Number of polygons
  public var polygonsCount: SwiftProtobuf.Google_Protobuf_UInt64Value {
    get {return _storage._polygonsCount ?? SwiftProtobuf.Google_Protobuf_UInt64Value()}
    set {_uniqueStorage()._polygonsCount = newValue}
  }
  /// Returns true if `polygonsCount` has been explicitly set.
  public var hasPolygonsCount: Bool {return _storage._polygonsCount != nil}
  /// Clears the value of `polygonsCount`. Subsequent reads from it will return its default value.
  public mutating func clearPolygonsCount() {_uniqueStorage()._polygonsCount = nil}

  /// Number of points
  public var pointsCount: SwiftProtobuf.Google_Protobuf_UInt64Value {
    get {return _storage._pointsCount ?? SwiftProtobuf.Google_Protobuf_UInt64Value()}
    set {_uniqueStorage()._pointsCount = newValue}
  }
  /// Returns true if `pointsCount` has been explicitly set.
  public var hasPointsCount: Bool {return _storage._pointsCount != nil}
  /// Clears the value of `pointsCount`. Subsequent reads from it will return its default value.
  public mutating func clearPointsCount() {_uniqueStorage()._pointsCount = nil}

  /// Number of masks
  public var masksCount: SwiftProtobuf.Google_Protobuf_UInt64Value {
    get {return _storage._masksCount ?? SwiftProtobuf.Google_Protobuf_UInt64Value()}
    set {_uniqueStorage()._masksCount = newValue}
  }
  /// Returns true if `masksCount` has been explicitly set.
  public var hasMasksCount: Bool {return _storage._masksCount != nil}
  /// Clears the value of `masksCount`. Subsequent reads from it will return its default value.
  public mutating func clearMasksCount() {_uniqueStorage()._masksCount = nil}

  /// Number of inputs that have regions attached
  /// Note that this is not a recursive count: if an input contains frames that contains regions, then the region_frames_count is increased, but region_inputs_count is not increased.
  public var regionInputsCount: SwiftProtobuf.Google_Protobuf_UInt64Value {
    get {return _storage._regionInputsCount ?? SwiftProtobuf.Google_Protobuf_UInt64Value()}
    set {_uniqueStorage()._regionInputsCount = newValue}
  }
  /// Returns true if `regionInputsCount` has been explicitly set.
  public var hasRegionInputsCount: Bool {return _storage._regionInputsCount != nil}
  /// Clears the value of `regionInputsCount`. Subsequent reads from it will return its default value.
  public mutating func clearRegionInputsCount() {_uniqueStorage()._regionInputsCount = nil}

  /// Number of frames that have regions attached
  public var regionFramesCount: SwiftProtobuf.Google_Protobuf_UInt64Value {
    get {return _storage._regionFramesCount ?? SwiftProtobuf.Google_Protobuf_UInt64Value()}
    set {_uniqueStorage()._regionFramesCount = newValue}
  }
  /// Returns true if `regionFramesCount` has been explicitly set.
  public var hasRegionFramesCount: Bool {return _storage._regionFramesCount != nil}
  /// Clears the value of `regionFramesCount`. Subsequent reads from it will return its default value.
  public mutating func clearRegionFramesCount() {_uniqueStorage()._regionFramesCount = nil}

  /// Number of frames
  public var framesCount: SwiftProtobuf.Google_Protobuf_UInt64Value {
    get {return _storage._framesCount ?? SwiftProtobuf.Google_Protobuf_UInt64Value()}
    set {_uniqueStorage()._framesCount = newValue}
  }
  /// Returns true if `framesCount` has been explicitly set.
  public var hasFramesCount: Bool {return _storage._framesCount != nil}
  /// Clears the value of `framesCount`. Subsequent reads from it will return its default value.
  public mutating func clearFramesCount() {_uniqueStorage()._framesCount = nil}

  /// Number of inputs that have frames attached
  public var frameInputsCount: SwiftProtobuf.Google_Protobuf_UInt64Value {
    get {return _storage._frameInputsCount ?? SwiftProtobuf.Google_Protobuf_UInt64Value()}
    set {_uniqueStorage()._frameInputsCount = newValue}
  }
  /// Returns true if `frameInputsCount` has been explicitly set.
  public var hasFrameInputsCount: Bool {return _storage._frameInputsCount != nil}
  /// Clears the value of `frameInputsCount`. Subsequent reads from it will return its default value.
  public mutating func clearFrameInputsCount() {_uniqueStorage()._frameInputsCount = nil}

  /// Number of embeddings
  public var embeddingsCount: SwiftProtobuf.Google_Protobuf_UInt64Value {
    get {return _storage._embeddingsCount ?? SwiftProtobuf.Google_Protobuf_UInt64Value()}
    set {_uniqueStorage()._embeddingsCount = newValue}
  }
  /// Returns true if `embeddingsCount` has been explicitly set.
  public var hasEmbeddingsCount: Bool {return _storage._embeddingsCount != nil}
  /// Clears the value of `embeddingsCount`. Subsequent reads from it will return its default value.
  public mutating func clearEmbeddingsCount() {_uniqueStorage()._embeddingsCount = nil}

  /// Number of positive tags added at input-level
  public var positiveInputTagsCount: SwiftProtobuf.Google_Protobuf_UInt64Value {
    get {return _storage._positiveInputTagsCount ?? SwiftProtobuf.Google_Protobuf_UInt64Value()}
    set {_uniqueStorage()._positiveInputTagsCount = newValue}
  }
  /// Returns true if `positiveInputTagsCount` has been explicitly set.
  public var hasPositiveInputTagsCount: Bool {return _storage._positiveInputTagsCount != nil}
  /// Clears the value of `positiveInputTagsCount`. Subsequent reads from it will return its default value.
  public mutating func clearPositiveInputTagsCount() {_uniqueStorage()._positiveInputTagsCount = nil}

  /// Number of positive tags added at region-level
  public var positiveRegionTagsCount: SwiftProtobuf.Google_Protobuf_UInt64Value {
    get {return _storage._positiveRegionTagsCount ?? SwiftProtobuf.Google_Protobuf_UInt64Value()}
    set {_uniqueStorage()._positiveRegionTagsCount = newValue}
  }
  /// Returns true if `positiveRegionTagsCount` has been explicitly set.
  public var hasPositiveRegionTagsCount: Bool {return _storage._positiveRegionTagsCount != nil}
  /// Clears the value of `positiveRegionTagsCount`. Subsequent reads from it will return its default value.
  public mutating func clearPositiveRegionTagsCount() {_uniqueStorage()._positiveRegionTagsCount = nil}

  /// Number of positive tags added at frame-level
  public var positiveFrameTagsCount: SwiftProtobuf.Google_Protobuf_UInt64Value {
    get {return _storage._positiveFrameTagsCount ?? SwiftProtobuf.Google_Protobuf_UInt64Value()}
    set {_uniqueStorage()._positiveFrameTagsCount = newValue}
  }
  /// Returns true if `positiveFrameTagsCount` has been explicitly set.
  public var hasPositiveFrameTagsCount: Bool {return _storage._positiveFrameTagsCount != nil}
  /// Clears the value of `positiveFrameTagsCount`. Subsequent reads from it will return its default value.
  public mutating func clearPositiveFrameTagsCount() {_uniqueStorage()._positiveFrameTagsCount = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Clarifai_Api_DatasetVersionMetricsGroup {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var parentPath: String = String()

  public var type: Clarifai_Api_DatasetVersionMetricsGroupType = .notSet

  public var value: SwiftProtobuf.Google_Protobuf_Value {
    get {return _value ?? SwiftProtobuf.Google_Protobuf_Value()}
    set {_value = newValue}
  }
  /// Returns true if `value` has been explicitly set.
  public var hasValue: Bool {return self._value != nil}
  /// Clears the value of `value`. Subsequent reads from it will return its default value.
  public mutating func clearValue() {self._value = nil}

  public var metrics: Clarifai_Api_DatasetVersionMetrics {
    get {return _metrics ?? Clarifai_Api_DatasetVersionMetrics()}
    set {_metrics = newValue}
  }
  /// Returns true if `metrics` has been explicitly set.
  public var hasMetrics: Bool {return self._metrics != nil}
  /// Clears the value of `metrics`. Subsequent reads from it will return its default value.
  public mutating func clearMetrics() {self._metrics = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _value: SwiftProtobuf.Google_Protobuf_Value? = nil
  fileprivate var _metrics: Clarifai_Api_DatasetVersionMetrics? = nil
}

/// DatasetVersionExportInfo contains information about all exports of a dataset version.
///
/// If the dataset version has not been exported in a format, then the DatasetVersionExport
/// field for that format is empty instead of having a "not exported" status.
public struct Clarifai_Api_DatasetVersionExportInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// clarifai_data_protobuf is a CLARIFAI_DATA_PROTOBUF export of the dataset version.
  public var clarifaiDataProtobuf: Clarifai_Api_DatasetVersionExport {
    get {return _clarifaiDataProtobuf ?? Clarifai_Api_DatasetVersionExport()}
    set {_clarifaiDataProtobuf = newValue}
  }
  /// Returns true if `clarifaiDataProtobuf` has been explicitly set.
  public var hasClarifaiDataProtobuf: Bool {return self._clarifaiDataProtobuf != nil}
  /// Clears the value of `clarifaiDataProtobuf`. Subsequent reads from it will return its default value.
  public mutating func clearClarifaiDataProtobuf() {self._clarifaiDataProtobuf = nil}

  /// clarifai_data_json is a CLARIFAI_DATA_JSON export of the dataset version.
  public var clarifaiDataJson: Clarifai_Api_DatasetVersionExport {
    get {return _clarifaiDataJson ?? Clarifai_Api_DatasetVersionExport()}
    set {_clarifaiDataJson = newValue}
  }
  /// Returns true if `clarifaiDataJson` has been explicitly set.
  public var hasClarifaiDataJson: Bool {return self._clarifaiDataJson != nil}
  /// Clears the value of `clarifaiDataJson`. Subsequent reads from it will return its default value.
  public mutating func clearClarifaiDataJson() {self._clarifaiDataJson = nil}

  /// coco is a COCO export of the dataset version.
  public var coco: Clarifai_Api_DatasetVersionExport {
    get {return _coco ?? Clarifai_Api_DatasetVersionExport()}
    set {_coco = newValue}
  }
  /// Returns true if `coco` has been explicitly set.
  public var hasCoco: Bool {return self._coco != nil}
  /// Clears the value of `coco`. Subsequent reads from it will return its default value.
  public mutating func clearCoco() {self._coco = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _clarifaiDataProtobuf: Clarifai_Api_DatasetVersionExport? = nil
  fileprivate var _clarifaiDataJson: Clarifai_Api_DatasetVersionExport? = nil
  fileprivate var _coco: Clarifai_Api_DatasetVersionExport? = nil
}

/// DatasetVersionExport contains metadata for a single dataset version export.
public struct Clarifai_Api_DatasetVersionExport {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// format is the format of the dataset version export.
  public var format: Clarifai_Api_DatasetVersionExportFormat {
    get {return _storage._format}
    set {_uniqueStorage()._format = newValue}
  }

  /// status is the current status of the dataset version export.
  public var status: Clarifai_Api_Status_Status {
    get {return _storage._status ?? Clarifai_Api_Status_Status()}
    set {_uniqueStorage()._status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  public var hasStatus: Bool {return _storage._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  public mutating func clearStatus() {_uniqueStorage()._status = nil}

  /// url is the URL from where the dataset version export can be downloaded.
  public var url: String {
    get {return _storage._url}
    set {_uniqueStorage()._url = newValue}
  }

  /// size is the size of the dataset version export in number of bytes.
  public var size: UInt64 {
    get {return _storage._size}
    set {_uniqueStorage()._size = newValue}
  }

  /// whether to include embeddings in the export or not.
  public var includeEmbeddings: Bool {
    get {return _storage._includeEmbeddings}
    set {_uniqueStorage()._includeEmbeddings = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// DatasetVersionProcessingInfo contains information about processing applied
/// to a dataset version.
public struct Clarifai_Api_DatasetVersionProcessingInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// If frame_interpolation_info is set, then these settings are used to
  /// interpolate new frame annotation from other video annotations.
  ///
  /// If frame_interpolation_info is set in the dataset default_processing_info,
  /// then it can be disabled for a single dataset version by setting
  /// processing_info but not setting processing_info.frame_interpolation_info.
  public var frameInterpolationInfo: Clarifai_Api_FrameInterpolationInfo {
    get {return _frameInterpolationInfo ?? Clarifai_Api_FrameInterpolationInfo()}
    set {_frameInterpolationInfo = newValue}
  }
  /// Returns true if `frameInterpolationInfo` has been explicitly set.
  public var hasFrameInterpolationInfo: Bool {return self._frameInterpolationInfo != nil}
  /// Clears the value of `frameInterpolationInfo`. Subsequent reads from it will return its default value.
  public mutating func clearFrameInterpolationInfo() {self._frameInterpolationInfo = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _frameInterpolationInfo: Clarifai_Api_FrameInterpolationInfo? = nil
}

/// FrameInterpolationInfo contains information about frame annotations
/// interpolated from other video annotations, such as image object-detection
/// regions generated from video object-tracking regions.
public struct Clarifai_Api_FrameInterpolationInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// sample_ms is the sampling rate at which frame annotations are interpolated.
  /// If sample_ms is zero, then the dataset default_processing_info value is used.
  /// If the dataset default is zero or not set, then the input frame prediction
  /// sampling rate is used.
  public var sampleMs: UInt32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Key
public struct Clarifai_Api_Key {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The id of this key, it is used for authorization.
  public var id: String = String()

  /// The type of key, it can be api_key or personal_access_token, the default value is api_key
  public var type: String = String()

  /// The description
  public var description_p: String = String()

  /// The low-level scopes this key has
  public var scopes: [String] = []

  /// The endpoint-level scopes this key has
  public var endpoints: [String] = []

  /// The apps that this key give you access to, it is empty if this key is personal_access_token
  /// API key can only give you access to a single app.
  public var apps: [Clarifai_Api_App] = []

  /// When the key was created. We follow the XXXX timestamp
  /// format. We use https://www.ietf.org/rfc/rfc3339.txt format:
  /// "2006-01-02T15:04:05.999999Z" so you can expect results like
  /// the following from the API:
  /// "2017-04-11T21:50:50.223962Z"
  public var createdAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _createdAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_createdAt = newValue}
  }
  /// Returns true if `createdAt` has been explicitly set.
  public var hasCreatedAt: Bool {return self._createdAt != nil}
  /// Clears the value of `createdAt`. Subsequent reads from it will return its default value.
  public mutating func clearCreatedAt() {self._createdAt = nil}

  /// When does the key expires, the key won't expire if this is empty
  public var expiresAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _expiresAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_expiresAt = newValue}
  }
  /// Returns true if `expiresAt` has been explicitly set.
  public var hasExpiresAt: Bool {return self._expiresAt != nil}
  /// Clears the value of `expiresAt`. Subsequent reads from it will return its default value.
  public mutating func clearExpiresAt() {self._expiresAt = nil}

  /// list of idp ids at which key is currently authorized
  public var authorizedIdpIds: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _createdAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _expiresAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

/// This is the Model object which represents a created model in the platform.
/// Each model has a particular type denoted by the model_type_id.
/// When creating a Model with PostModels the following happens:
///  - if the ModelType is trainable, then a new ModelVersion is created that is
///    - UNTRAINED status by default
///    - TRAINED status if a ModelVersion was included with PretrainedModelConfig in PostModels
///  - if the ModelType is not trainable, then a new ModelVersion is created with TRAINED status.
/// To modify config settings like OutputInfo for the Model you an use PatchModels. This will
/// also create a new ModelVersion, potentially UNTRAINED following the same rules as above.
/// The fields that are patchable include Model.name, Model.display_name and Model.output_info
/// (except the Model.output_info.type and Model.output_info.type_ext).
public struct Clarifai_Api_Model {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The model's ID. Must be unique within a particular app and URL-friendly.
  public var id: String {
    get {return _storage._id}
    set {_uniqueStorage()._id = newValue}
  }

  /// DEPRECATED: Please use the model id to name the model.
  public var name: String {
    get {return _storage._name}
    set {_uniqueStorage()._name = newValue}
  }

  /// When the model was created. We follow the XXXX timestamp
  /// format. We use https://www.ietf.org/rfc/rfc3339.txt format:
  /// "2006-01-02T15:04:05.999999Z" so you can expect results like
  ///  the following from the API:
  ///  "2017-04-11T21:50:50.223962Z"
  public var createdAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._createdAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._createdAt = newValue}
  }
  /// Returns true if `createdAt` has been explicitly set.
  public var hasCreatedAt: Bool {return _storage._createdAt != nil}
  /// Clears the value of `createdAt`. Subsequent reads from it will return its default value.
  public mutating func clearCreatedAt() {_uniqueStorage()._createdAt = nil}

  /// When was the most recent model version created at
  public var modifiedAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._modifiedAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._modifiedAt = newValue}
  }
  /// Returns true if `modifiedAt` has been explicitly set.
  public var hasModifiedAt: Bool {return _storage._modifiedAt != nil}
  /// Clears the value of `modifiedAt`. Subsequent reads from it will return its default value.
  public mutating func clearModifiedAt() {_uniqueStorage()._modifiedAt = nil}

  /// The app the model belongs to.
  public var appID: String {
    get {return _storage._appID}
    set {_uniqueStorage()._appID = newValue}
  }

  /// Info about the model's output and configuration.
  /// DEPRECATED: Will be moved to model version
  public var outputInfo: Clarifai_Api_OutputInfo {
    get {return _storage._outputInfo ?? Clarifai_Api_OutputInfo()}
    set {_uniqueStorage()._outputInfo = newValue}
  }
  /// Returns true if `outputInfo` has been explicitly set.
  public var hasOutputInfo: Bool {return _storage._outputInfo != nil}
  /// Clears the value of `outputInfo`. Subsequent reads from it will return its default value.
  public mutating func clearOutputInfo() {_uniqueStorage()._outputInfo = nil}

  /// A particular version of the model, e.g., to specify the version when creating a workflow or
  /// when listing Models to include the latest ModelVersion of the model in the response.
  public var modelVersion: Clarifai_Api_ModelVersion {
    get {return _storage._modelVersion ?? Clarifai_Api_ModelVersion()}
    set {_uniqueStorage()._modelVersion = newValue}
  }
  /// Returns true if `modelVersion` has been explicitly set.
  public var hasModelVersion: Bool {return _storage._modelVersion != nil}
  /// Clears the value of `modelVersion`. Subsequent reads from it will return its default value.
  public mutating func clearModelVersion() {_uniqueStorage()._modelVersion = nil}

  /// DEPRECATED: Please use the model id to name the model.
  public var displayName: String {
    get {return _storage._displayName}
    set {_uniqueStorage()._displayName = newValue}
  }

  /// The user id that the model belongs to.
  public var userID: String {
    get {return _storage._userID}
    set {_uniqueStorage()._userID = newValue}
  }

  /// The default evaluation info. Can be overwritten by eval request.
  public var defaultEvalInfo: Clarifai_Api_EvalInfo {
    get {return _storage._defaultEvalInfo ?? Clarifai_Api_EvalInfo()}
    set {_uniqueStorage()._defaultEvalInfo = newValue}
  }
  /// Returns true if `defaultEvalInfo` has been explicitly set.
  public var hasDefaultEvalInfo: Bool {return _storage._defaultEvalInfo != nil}
  /// Clears the value of `defaultEvalInfo`. Subsequent reads from it will return its default value.
  public mutating func clearDefaultEvalInfo() {_uniqueStorage()._defaultEvalInfo = nil}

  /// The ModelType.Id that is used for this model. This is used for all versions and you cannot
  /// change model_type_id between versions of the same model.
  public var modelTypeID: String {
    get {return _storage._modelTypeID}
    set {_uniqueStorage()._modelTypeID = newValue}
  }

  /// The task the model was trained to do
  public var task: String {
    get {return _storage._task}
    set {_uniqueStorage()._task = newValue}
  }

  /// The visibility field represents whether this message is privately/publicly visible.
  /// To be visible to the public the App that contains it AND the User that contains the App must
  /// also be publicly visible.
  public var visibility: Clarifai_Api_Visibility {
    get {return _storage._visibility ?? Clarifai_Api_Visibility()}
    set {_uniqueStorage()._visibility = newValue}
  }
  /// Returns true if `visibility` has been explicitly set.
  public var hasVisibility: Bool {return _storage._visibility != nil}
  /// Clears the value of `visibility`. Subsequent reads from it will return its default value.
  public mutating func clearVisibility() {_uniqueStorage()._visibility = nil}

  /// Short description about this model
  public var description_p: String {
    get {return _storage._description_p}
    set {_uniqueStorage()._description_p = newValue}
  }

  /// To handle arbitrary json metadata you can use a struct field:
  /// https://github.com/google/protobuf/blob/master/src/google/protobuf/struct.proto
  public var metadata: SwiftProtobuf.Google_Protobuf_Struct {
    get {return _storage._metadata ?? SwiftProtobuf.Google_Protobuf_Struct()}
    set {_uniqueStorage()._metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  public var hasMetadata: Bool {return _storage._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  public mutating func clearMetadata() {_uniqueStorage()._metadata = nil}

  public var presets: SwiftProtobuf.Google_Protobuf_Struct {
    get {return _storage._presets ?? SwiftProtobuf.Google_Protobuf_Struct()}
    set {_uniqueStorage()._presets = newValue}
  }
  /// Returns true if `presets` has been explicitly set.
  public var hasPresets: Bool {return _storage._presets != nil}
  /// Clears the value of `presets`. Subsequent reads from it will return its default value.
  public mutating func clearPresets() {_uniqueStorage()._presets = nil}

  /// Notes for the model
  /// This field should be used for in-depth notes and supports up to 64Kbs.
  public var notes: String {
    get {return _storage._notes}
    set {_uniqueStorage()._notes = newValue}
  }

  /// Tags from toolkits category
  public var toolkits: [String] {
    get {return _storage._toolkits}
    set {_uniqueStorage()._toolkits = newValue}
  }

  /// Tags from use_cases category
  public var useCases: [String] {
    get {return _storage._useCases}
    set {_uniqueStorage()._useCases = newValue}
  }

  /// Tags from languages category.
  public var languages: [String] {
    get {return _storage._languages}
    set {_uniqueStorage()._languages = newValue}
  }

  /// Tags from languages category with names, only used in responses.
  public var languagesFull: [Clarifai_Api_FullTag] {
    get {return _storage._languagesFull}
    set {_uniqueStorage()._languagesFull = newValue}
  }

  public var checkConsents: [String] {
    get {return _storage._checkConsents}
    set {_uniqueStorage()._checkConsents = newValue}
  }

  /// Is starred by the requesting user (only showed on get/list requests)
  /// Please use PostModelStars/DeleteModelStars endpoints to star/unstar a model
  public var isStarred: Bool {
    get {return _storage._isStarred}
    set {_uniqueStorage()._isStarred = newValue}
  }

  /// How many users have starred the model (only showed on get/list requests)
  /// Computed value, not editable
  public var starCount: Int32 {
    get {return _storage._starCount}
    set {_uniqueStorage()._starCount = newValue}
  }

  /// Whether it's recommended that this model is used within a workflow
  public var workflowRecommended: SwiftProtobuf.Google_Protobuf_BoolValue {
    get {return _storage._workflowRecommended ?? SwiftProtobuf.Google_Protobuf_BoolValue()}
    set {_uniqueStorage()._workflowRecommended = newValue}
  }
  /// Returns true if `workflowRecommended` has been explicitly set.
  public var hasWorkflowRecommended: Bool {return _storage._workflowRecommended != nil}
  /// Clears the value of `workflowRecommended`. Subsequent reads from it will return its default value.
  public mutating func clearWorkflowRecommended() {_uniqueStorage()._workflowRecommended = nil}

  /// bookmark info. When set, this model is a bookmarked model of this app.
  /// Info in this field will allow you to find/access original model.
  public var bookmarkOrigin: Clarifai_Api_BookmarkOrigin {
    get {return _storage._bookmarkOrigin ?? Clarifai_Api_BookmarkOrigin()}
    set {_uniqueStorage()._bookmarkOrigin = newValue}
  }
  /// Returns true if `bookmarkOrigin` has been explicitly set.
  public var hasBookmarkOrigin: Bool {return _storage._bookmarkOrigin != nil}
  /// Clears the value of `bookmarkOrigin`. Subsequent reads from it will return its default value.
  public mutating func clearBookmarkOrigin() {_uniqueStorage()._bookmarkOrigin = nil}

  /// Representative image for this model
  public var image: Clarifai_Api_Image {
    get {return _storage._image ?? Clarifai_Api_Image()}
    set {_uniqueStorage()._image = newValue}
  }
  /// Returns true if `image` has been explicitly set.
  public var hasImage: Bool {return _storage._image != nil}
  /// Clears the value of `image`. Subsequent reads from it will return its default value.
  public mutating func clearImage() {_uniqueStorage()._image = nil}

  /// License Type
  public var licenseType: Clarifai_Api_LicenseType {
    get {return _storage._licenseType}
    set {_uniqueStorage()._licenseType = newValue}
  }

  public var source: Clarifai_Api_Model.Source {
    get {return _storage._source}
    set {_uniqueStorage()._source = newValue}
  }

  /// Creator of Model
  public var creator: String {
    get {return _storage._creator}
    set {_uniqueStorage()._creator = newValue}
  }

  public var versionCount: Int32 {
    get {return _storage._versionCount}
    set {_uniqueStorage()._versionCount = newValue}
  }

  public var billingType: Clarifai_Api_Model.BillingType {
    get {return _storage._billingType}
    set {_uniqueStorage()._billingType = newValue}
  }

  /// Whether the model should be featured, and if so, the order in which it should be featured.
  /// The order is relative to other models that are also featured.
  /// Models with a higher order will be featured first.
  public var featuredOrder: SwiftProtobuf.Google_Protobuf_Int32Value {
    get {return _storage._featuredOrder ?? SwiftProtobuf.Google_Protobuf_Int32Value()}
    set {_uniqueStorage()._featuredOrder = newValue}
  }
  /// Returns true if `featuredOrder` has been explicitly set.
  public var hasFeaturedOrder: Bool {return _storage._featuredOrder != nil}
  /// Clears the value of `featuredOrder`. Subsequent reads from it will return its default value.
  public mutating func clearFeaturedOrder() {_uniqueStorage()._featuredOrder = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Source of Model
  public enum Source: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case unknownSource // = 0
    case hosted // = 1
    case wrapped // = 2
    case UNRECOGNIZED(Int)

    public init() {
      self = .unknownSource
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknownSource
      case 1: self = .hosted
      case 2: self = .wrapped
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unknownSource: return 0
      case .hosted: return 1
      case .wrapped: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public enum BillingType: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case unknown // = 0
    case tokens // = 1
    case ops // = 2
    case UNRECOGNIZED(Int)

    public init() {
      self = .unknown
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknown
      case 1: self = .tokens
      case 2: self = .ops
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unknown: return 0
      case .tokens: return 1
      case .ops: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

#if swift(>=4.2)

extension Clarifai_Api_Model.Source: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Clarifai_Api_Model.Source] = [
    .unknownSource,
    .hosted,
    .wrapped,
  ]
}

extension Clarifai_Api_Model.BillingType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Clarifai_Api_Model.BillingType] = [
    .unknown,
    .tokens,
    .ops,
  ]
}

#endif  // swift(>=4.2)

/// A link to a html/markdown/text file that stores reference material tied to a model.
public struct Clarifai_Api_ModelReference {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Id of the reference
  public var id: String = String()

  /// The id of the model this Model reference is tied to.
  public var modelID: String = String()

  /// address of resource
  public var url: String = String()

  /// name of link
  public var name: String = String()

  /// To handle arbitrary json metadata:
  /// https://github.com/google/protobuf/blob/master/src/google/protobuf/struct.proto
  public var metadata: SwiftProtobuf.Google_Protobuf_Struct {
    get {return _metadata ?? SwiftProtobuf.Google_Protobuf_Struct()}
    set {_metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  public var hasMetadata: Bool {return self._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  public mutating func clearMetadata() {self._metadata = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _metadata: SwiftProtobuf.Google_Protobuf_Struct? = nil
}

/// ModelVersionInputExample
public struct Clarifai_Api_ModelVersionInputExample {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// user unique id
  public var id: String = String()

  /// external id of model
  public var modelID: String = String()

  /// external id of model version
  public var modelVersionID: String = String()

  /// data to store as example input for model
  public var data: Clarifai_Api_Data {
    get {return _data ?? Clarifai_Api_Data()}
    set {_data = newValue}
  }
  /// Returns true if `data` has been explicitly set.
  public var hasData: Bool {return self._data != nil}
  /// Clears the value of `data`. Subsequent reads from it will return its default value.
  public mutating func clearData() {self._data = nil}

  /// name of link for display
  public var name: String = String()

  /// description of link contents
  public var description_p: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _data: Clarifai_Api_Data? = nil
}

/// OutputInfo defines some of the settings for each model version that PatchModels can effect. These
/// parameters control some of the training or inference operations that this model can do.
/// As the number of parameters continued to grow when we launched more ModelTypes we decided to move
/// to using the OutputInfo.params field which is a Struct (or JSON object if you're using
/// our JSON REST APIs). This allows each ModelType to define the set of fields, their default values
/// and description of each field so that we can display those in Portal and make the creation of
/// Model's very extensible. The OutputConfig object will eventually go away in favor of
/// output_info.params struct.
public struct Clarifai_Api_OutputInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// List of concepts or other output related data for the model.
  public var data: Clarifai_Api_Data {
    get {return _storage._data ?? Clarifai_Api_Data()}
    set {_uniqueStorage()._data = newValue}
  }
  /// Returns true if `data` has been explicitly set.
  public var hasData: Bool {return _storage._data != nil}
  /// Clears the value of `data`. Subsequent reads from it will return its default value.
  public mutating func clearData() {_uniqueStorage()._data = nil}

  /// Model configuration...going away in favor of output_info.params and train_params over time.
  /// TO BE DEPRECATED
  public var outputConfig: Clarifai_Api_OutputConfig {
    get {return _storage._outputConfig ?? Clarifai_Api_OutputConfig()}
    set {_uniqueStorage()._outputConfig = newValue}
  }
  /// Returns true if `outputConfig` has been explicitly set.
  public var hasOutputConfig: Bool {return _storage._outputConfig != nil}
  /// Clears the value of `outputConfig`. Subsequent reads from it will return its default value.
  public mutating func clearOutputConfig() {_uniqueStorage()._outputConfig = nil}

  /// For returning where to look for the Output info if not returning it.
  public var message: String {
    get {return _storage._message}
    set {_uniqueStorage()._message = newValue}
  }

  /// Map from the api.Data field names to the underlying model graph's outputs. When using a
  /// PretrainedModelConfig the values in this map need to match the Triton config.pbtxt output names.
  public var fieldsMap: SwiftProtobuf.Google_Protobuf_Struct {
    get {return _storage._fieldsMap ?? SwiftProtobuf.Google_Protobuf_Struct()}
    set {_uniqueStorage()._fieldsMap = newValue}
  }
  /// Returns true if `fieldsMap` has been explicitly set.
  public var hasFieldsMap: Bool {return _storage._fieldsMap != nil}
  /// Clears the value of `fieldsMap`. Subsequent reads from it will return its default value.
  public mutating func clearFieldsMap() {_uniqueStorage()._fieldsMap = nil}

  /// For predicting with the various ModelType's we accept a Struct (JSON object) worth of args
  /// that the ModelTypeField defines. During inference, the settings contained within are sent
  /// to the model predictor to alter predictions from this Model.
  public var params: SwiftProtobuf.Google_Protobuf_Struct {
    get {return _storage._params ?? SwiftProtobuf.Google_Protobuf_Struct()}
    set {_uniqueStorage()._params = newValue}
  }
  /// Returns true if `params` has been explicitly set.
  public var hasParams: Bool {return _storage._params != nil}
  /// Clears the value of `params`. Subsequent reads from it will return its default value.
  public mutating func clearParams() {_uniqueStorage()._params = nil}

  /// These allow you to specifcy addition fields that a specific model supports beyond those defined
  /// in it's ModelType. This field is to be deprecated and will be replaced by MethodSignature
  /// proto.
  public var paramsSpecs: [Clarifai_Api_ModelTypeField] {
    get {return _storage._paramsSpecs}
    set {_uniqueStorage()._paramsSpecs = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// InputInfo
public struct Clarifai_Api_InputInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Map from the api.Data field names to the underlying model graph's inputs. When using a
  /// PretrainedModelConfig the values in this map need to match the Triton config.pbtxt input names.
  public var fieldsMap: SwiftProtobuf.Google_Protobuf_Struct {
    get {return _storage._fieldsMap ?? SwiftProtobuf.Google_Protobuf_Struct()}
    set {_uniqueStorage()._fieldsMap = newValue}
  }
  /// Returns true if `fieldsMap` has been explicitly set.
  public var hasFieldsMap: Bool {return _storage._fieldsMap != nil}
  /// Clears the value of `fieldsMap`. Subsequent reads from it will return its default value.
  public mutating func clearFieldsMap() {_uniqueStorage()._fieldsMap = nil}

  /// To control the inputs to the given model we allow a list of parameters
  /// defined for each ModelType as a Struct (JSON object) here. During training or inference, the
  /// settings contained within are sent to the training processor to alter the training process.
  public var params: SwiftProtobuf.Google_Protobuf_Struct {
    get {return _storage._params ?? SwiftProtobuf.Google_Protobuf_Struct()}
    set {_uniqueStorage()._params = newValue}
  }
  /// Returns true if `params` has been explicitly set.
  public var hasParams: Bool {return _storage._params != nil}
  /// Clears the value of `params`. Subsequent reads from it will return its default value.
  public mutating func clearParams() {_uniqueStorage()._params = nil}

  /// For base model to get embeddings from for transfer learned models.
  public var baseEmbedModel: Clarifai_Api_Model {
    get {return _storage._baseEmbedModel ?? Clarifai_Api_Model()}
    set {_uniqueStorage()._baseEmbedModel = newValue}
  }
  /// Returns true if `baseEmbedModel` has been explicitly set.
  public var hasBaseEmbedModel: Bool {return _storage._baseEmbedModel != nil}
  /// Clears the value of `baseEmbedModel`. Subsequent reads from it will return its default value.
  public mutating func clearBaseEmbedModel() {_uniqueStorage()._baseEmbedModel = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Clarifai_Api_TrainInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// To control the training process when PostModelVersions is used we allow a list of parameters
  /// defined for each ModelType as a Struct (JSON object) here. During training, the settings
  /// contained within are sent to the training processor to alter the training process.
  public var params: SwiftProtobuf.Google_Protobuf_Struct {
    get {return _storage._params ?? SwiftProtobuf.Google_Protobuf_Struct()}
    set {_uniqueStorage()._params = newValue}
  }
  /// Returns true if `params` has been explicitly set.
  public var hasParams: Bool {return _storage._params != nil}
  /// Clears the value of `params`. Subsequent reads from it will return its default value.
  public mutating func clearParams() {_uniqueStorage()._params = nil}

  /// The dataset and dataset version this model version was or will be trained on
  public var dataset: Clarifai_Api_Dataset {
    get {return _storage._dataset ?? Clarifai_Api_Dataset()}
    set {_uniqueStorage()._dataset = newValue}
  }
  /// Returns true if `dataset` has been explicitly set.
  public var hasDataset: Bool {return _storage._dataset != nil}
  /// Clears the value of `dataset`. Subsequent reads from it will return its default value.
  public mutating func clearDataset() {_uniqueStorage()._dataset = nil}

  /// The model to resume training from.
  public var resumeFromModel: Clarifai_Api_Model {
    get {return _storage._resumeFromModel ?? Clarifai_Api_Model()}
    set {_uniqueStorage()._resumeFromModel = newValue}
  }
  /// Returns true if `resumeFromModel` has been explicitly set.
  public var hasResumeFromModel: Bool {return _storage._resumeFromModel != nil}
  /// Clears the value of `resumeFromModel`. Subsequent reads from it will return its default value.
  public mutating func clearResumeFromModel() {_uniqueStorage()._resumeFromModel = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Clarifai_Api_EvalInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// To control the evaluation process.
  /// Allow a list of parameters.
  public var params: SwiftProtobuf.Google_Protobuf_Struct {
    get {return _params ?? SwiftProtobuf.Google_Protobuf_Struct()}
    set {_params = newValue}
  }
  /// Returns true if `params` has been explicitly set.
  public var hasParams: Bool {return self._params != nil}
  /// Clears the value of `params`. Subsequent reads from it will return its default value.
  public mutating func clearParams() {self._params = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _params: SwiftProtobuf.Google_Protobuf_Struct? = nil
}

public struct Clarifai_Api_ImportInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Used to configure model imports from third-party toolkits.
  public var params: SwiftProtobuf.Google_Protobuf_Struct {
    get {return _params ?? SwiftProtobuf.Google_Protobuf_Struct()}
    set {_params = newValue}
  }
  /// Returns true if `params` has been explicitly set.
  public var hasParams: Bool {return self._params != nil}
  /// Clears the value of `params`. Subsequent reads from it will return its default value.
  public mutating func clearParams() {self._params = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _params: SwiftProtobuf.Google_Protobuf_Struct? = nil
}

/// OutputConfig is a collection of parameters controlling either inference or training settings for
/// the given Model. This message will be deprecated over time in favor or output_info.params and
/// train_params in OutputInfo which are cleaner and more extensible for many ModelTypes.
public struct Clarifai_Api_OutputConfig {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// For custom concept model training: whether the concept predictions must sum to 1.
  public var conceptsMutuallyExclusive: Bool = false

  /// DEPRECATED: For custom models, this is the base model to use for image embeddings.
  /// Default is general model.
  public var existingModelID: String = String()

  /// For concept model predictions: Overrides the default_language for the app in a predict call.
  public var language: String = String()

  /// DEPRECATED: Hyper-parameters for custom training.
  /// Use new hyper_params field instead.
  public var hyperParameters: String = String()

  /// For concept model predictions:  Maximum number of concepts in result. Defaults to 0 which under
  /// the hood will return default of 20. We do a server side default in order to control this
  /// feature in the future.
  public var maxConcepts: UInt32 = 0

  /// For concept model predictions: Minimum value of concept's probability score in result.
  /// Defaults to 0.0 which means we won't do any thresholding as all probabilities will
  /// likely be > 0.0.
  public var minValue: Float = 0

  /// For concept model predictions: Select concepts in result by name or by id
  public var selectConcepts: [Clarifai_Api_Concept] = []

  /// For custom concept model training: Training timeout of the model (in seconds)
  public var trainingTimeout: UInt32 = 0

  /// For model predictions on video: Sample delay for video predicting (1 frame per N milliseconds)
  public var sampleMs: UInt32 = 0

  /// For custom model training: Hyperparameters for custom training
  public var hyperParams: SwiftProtobuf.Google_Protobuf_Struct {
    get {return _hyperParams ?? SwiftProtobuf.Google_Protobuf_Struct()}
    set {_hyperParams = newValue}
  }
  /// Returns true if `hyperParams` has been explicitly set.
  public var hasHyperParams: Bool {return self._hyperParams != nil}
  /// Clears the value of `hyperParams`. Subsequent reads from it will return its default value.
  public mutating func clearHyperParams() {self._hyperParams = nil}

  /// For custom model training: this is the base model version to use for image embeddings.
  /// This has to be one of the embed models in the app workflow.
  public var embedModelVersionID: String = String()

  /// For custom model training: Use this flag to fail on missing positive examples
  /// By default we fill in the missing with random examples
  public var failOnMissingPositiveExamples: Bool = false

  /// For custom model training: This is any additional metadata as a JSON object that we want
  /// want to persist in the model's output config. This is a useful quick way to set fields for
  /// introducing fields for new model types so we don't have to add a new proto field and DB field
  /// each time. Please refer to the documentation or model implementation internally for more
  /// details on what fields are supported for which models.
  /// TODO(zeiler): remove this field after Portal is updated.
  public var modelMetadata: SwiftProtobuf.Google_Protobuf_Struct {
    get {return _modelMetadata ?? SwiftProtobuf.Google_Protobuf_Struct()}
    set {_modelMetadata = newValue}
  }
  /// Returns true if `modelMetadata` has been explicitly set.
  public var hasModelMetadata: Bool {return self._modelMetadata != nil}
  /// Clears the value of `modelMetadata`. Subsequent reads from it will return its default value.
  public mutating func clearModelMetadata() {self._modelMetadata = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _hyperParams: SwiftProtobuf.Google_Protobuf_Struct? = nil
  fileprivate var _modelMetadata: SwiftProtobuf.Google_Protobuf_Struct? = nil
}

/// ModelType is a definition of a set of models that generally have the same input and output fields.
/// This is used to understand more about the possible models in our platform.
public struct Clarifai_Api_ModelType {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// A unique identifier for this model type.
  public var id: String = String()

  /// A display title for this model.
  public var title: String = String()

  /// Description of this model type.
  public var description_p: String = String()

  /// The list of input fields that this model expects as inputs.
  /// Used to validate that request input data has the expected fields.
  public var inputFields: [String] = []

  /// The list of output fields that this model accepts.
  public var outputFields: [String] = []

  /// Is this model trainable in our platform.
  public var trainable: Bool = false

  /// Is this model creatable. We have some pre-trained model types that users cannot create yet in
  /// model mode.
  public var creatable: Bool = false

  /// Is this model type only for internal users at this time.
  public var internalOnly: Bool = false

  /// The remaining fields are definitions of the configurable fields that exist.
  public var modelTypeFields: [Clarifai_Api_ModelTypeField] = []

  /// For sequence models we need to know when processing that they require temporal time frames
  /// in sequential order. This will be true for model types like trackers as an example.
  public var requiresSequentialFrames: Bool = false

  /// Expected input layers of an uploaded model.
  public var expectedInputLayers: [Clarifai_Api_ModelLayerInfo] = []

  /// Expected output layers of an uploaded model
  public var expectedOutputLayers: [Clarifai_Api_ModelLayerInfo] = []

  /// What type of evaluation is supported for this model type.
  public var evaluationType: Clarifai_Api_EvaluationType = .undefined

  /// method signature for this model type
  /// This will be used in the future to replace input_fields, output_fields, and model_type_fields
  /// as it can define any python function call.
  public var methodSignatures: [Clarifai_Api_MethodSignature] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Clarifai_Api_ModelLayerInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The api.Data field this layer will be parsed into
  public var dataFieldName: String = String()

  /// Description of the expected shape. Can support multiple support layer shapes.
  public var shapes: [Clarifai_Api_LayerShape] = []

  /// Brief description about the layer if needed
  public var description_p: String = String()

  /// Whether this layer should have a label_filename specified and provided
  public var requiresLabelFilename: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Clarifai_Api_TritonCondaEnvInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var condaPackURL: String = String()

  public var condaYamlURL: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Clarifai_Api_LayerShape {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Supported dimensions
  /// Example: [-1,4] is a 2-dimensional array with the first dimension of variablesize, but second dimension with a static size: [[1,2,3,4],[4,5,6,7],...]
  public var dims: [Int32] = []

  /// Max dimension size, applicable to layers that can have flexible sizes.
  public var maxDims: [Int32] = []

  /// The triton data type
  public var dataType: Clarifai_Api_DataType = .undefined

  /// Description about the dimensions
  public var description_p: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// ModelTypeField stores a field value of a configurable type.
public struct Clarifai_Api_ModelTypeField {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The path where the value of the field will be stored in the model version object.
  /// Example:
  /// "output_info.data" would be the Data message in the OutputInfo message.
  /// "output_info.output_config.language" is in the OutputConfig message within OutputInfo
  /// "input_info.params" is in the params struct within InputInfo.
  /// "output_info.params" is in the params struct within OutputInfo.
  /// "train_info.params" is in the params struct within TrainInfo.
  /// and so on.
  public var path: String = String()

  /// The field for this field. This is often used for displaying the field in the UI whereas
  /// the DataType enum below defines the specific type of datain the Python function.
  public var fieldType: Clarifai_Api_ModelTypeField.ModelTypeFieldType = .invalidModelTypeFieldType

  /// A default value. We use the Value field because we want to have structured data (just like
  /// google.protobuf.Struct but this is just a single value).
  public var defaultValue: SwiftProtobuf.Google_Protobuf_Value {
    get {return _defaultValue ?? SwiftProtobuf.Google_Protobuf_Value()}
    set {_defaultValue = newValue}
  }
  /// Returns true if `defaultValue` has been explicitly set.
  public var hasDefaultValue: Bool {return self._defaultValue != nil}
  /// Clears the value of `defaultValue`. Subsequent reads from it will return its default value.
  public mutating func clearDefaultValue() {self._defaultValue = nil}

  /// Description for this field.
  public var description_p: String = String()

  /// Placeholder text for the UI element.
  public var placeholder: String = String()

  /// List of options of the ENUM type and potentially additional fields they bring with them.
  public var modelTypeEnumOptions: [Clarifai_Api_ModelTypeEnumOption] = []

  /// If this field should appear for internal users only.
  public var internalOnly: Bool = false

  /// If this field is a required field. If True then during validation you won't be able to create
  /// a model of this type with providing a value for this field. When False, the ModelType's
  /// default_value will be used for this field.
  public var required: Bool = false

  /// If the field_type is RANGE, this must be filled in.
  public var modelTypeRangeInfo: Clarifai_Api_ModelTypeRangeInfo {
    get {return _modelTypeRangeInfo ?? Clarifai_Api_ModelTypeRangeInfo()}
    set {_modelTypeRangeInfo = newValue}
  }
  /// Returns true if `modelTypeRangeInfo` has been explicitly set.
  public var hasModelTypeRangeInfo: Bool {return self._modelTypeRangeInfo != nil}
  /// Clears the value of `modelTypeRangeInfo`. Subsequent reads from it will return its default value.
  public mutating func clearModelTypeRangeInfo() {self._modelTypeRangeInfo = nil}

  /// name of method signature argument
  public var name: String = String()

  /// The type of the argument.
  public var type: Clarifai_Api_ModelTypeField.DataType = .notSet

  /// type enum, and recursively set type_args with
  /// the inner type argumets in complex objects (e.g. List[Tuple[int, str]])
  public var typeArgs: [Clarifai_Api_ModelTypeField] = []

  /// this will be use to define whether the method argument supports streaming as an iterator.
  public var iterator: Bool = false

  /// This specify the default value of the method argument. We define this as a string
  /// because the default value can be a string, int, float, bool, or a complex object like a JSON
  /// The default_value field above should not also be used.
  public var `default`: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// These are various types of fields that we have UIs for.
  public enum ModelTypeFieldType: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case invalidModelTypeFieldType // = 0
    case boolean // = 1
    case string // = 2
    case number // = 3

    /// For auto-completing to concepts in the app. This goes into an data.concepts field.
    case arrayOfConcepts // = 4

    /// For auto-completing to concepts in the app. This goes into an data.concepts field.
    case arrayOfConceptsWithThreshold // = 5

    /// A range for a float value.
    case range // = 7

    /// If ENUM is used then the "enum_options" field should also be filled in with the respective ID and description
    /// for the different ENUM options.
    case `enum` // = 8

    /// For listing collaborators of the app. The field is a string of the collaborator's user_id.
    case collaborators // = 9

    /// For arbitrary json object: "{...}"
    case json // = 10

    /// Such as [1.0, 2.0, 3.5]
    case arrayOfNumbers // = 11

    /// For selecting the embed_model_version_id for context based models.
    case workflowEmbedModels // = 12

    /// Such as ['a', 'b', 'cantaloupe']
    case arrayOfStrings // = 13

    /// If RECURSIVE_ENUM is used then the "enum_options" field should also be filled in with the respective ID and
    /// description for the different RECURSIVE_ENUM options, as well as model_type_fields for each enum choice.
    case recursiveEnum // = 14

    /// For blocks of code that need to be specified by the user for setup or execution during workflow runs.
    case pythonCode // = 15

    /// For selecting a dataset id in model parameters. String in API request.
    case datasetID // = 16

    /// For selecting a dataset version id. String.
    case datasetVersionID // = 17

    /// For auto-completing to concepts in the model.
    case arrayOfModelConcepts // = 18

    /// For selecting a dataset
    case dataset // = 19

    /// For selecting a dataset version
    case datasetVersion // = 20

    /// To pass a string downstream, that is encrypted in the DB and API.
    case encryptedString // = 21

    /// For selecting a model version of the same model type to resume training from.
    case checkpointModel // = 22
    case UNRECOGNIZED(Int)

    public init() {
      self = .invalidModelTypeFieldType
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .invalidModelTypeFieldType
      case 1: self = .boolean
      case 2: self = .string
      case 3: self = .number
      case 4: self = .arrayOfConcepts
      case 5: self = .arrayOfConceptsWithThreshold
      case 7: self = .range
      case 8: self = .enum
      case 9: self = .collaborators
      case 10: self = .json
      case 11: self = .arrayOfNumbers
      case 12: self = .workflowEmbedModels
      case 13: self = .arrayOfStrings
      case 14: self = .recursiveEnum
      case 15: self = .pythonCode
      case 16: self = .datasetID
      case 17: self = .datasetVersionID
      case 18: self = .arrayOfModelConcepts
      case 19: self = .dataset
      case 20: self = .datasetVersion
      case 21: self = .encryptedString
      case 22: self = .checkpointModel
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .invalidModelTypeFieldType: return 0
      case .boolean: return 1
      case .string: return 2
      case .number: return 3
      case .arrayOfConcepts: return 4
      case .arrayOfConceptsWithThreshold: return 5
      case .range: return 7
      case .enum: return 8
      case .collaborators: return 9
      case .json: return 10
      case .arrayOfNumbers: return 11
      case .workflowEmbedModels: return 12
      case .arrayOfStrings: return 13
      case .recursiveEnum: return 14
      case .pythonCode: return 15
      case .datasetID: return 16
      case .datasetVersionID: return 17
      case .arrayOfModelConcepts: return 18
      case .dataset: return 19
      case .datasetVersion: return 20
      case .encryptedString: return 21
      case .checkpointModel: return 22
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  /// DataType is used in MethodSignature to define all the possible types that a python function
  /// may have that we want to support. These include built-ins like int, float, str, bool, and
  /// more complex types like JSON, numpy arrays, List, Tuple, Dict (as Named Fields), as well as Clarifai provided
  /// unstructured types like Image, Video, Text, etc.
  public enum DataType: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case notSet // = 0

    /// A string value.
    case str // = 1

    /// A byte string. This is used for binary data.
    case bytes // = 2

    /// An integer value.
    case int // = 3

    /// A float value.
    case float // = 4

    /// A boolean value.
    case bool // = 5

    /// A proto representation for numpy arrays.
    case ndarray // = 6

    /// For arbitrary json object: "{...}"
    case jsonData // = 7

    /// For text data
    case text // = 8

    /// A image is a image proto for url or bytes.
    case image // = 9

    /// A concept is a concept proto that represents a concept in the app.
    case concept // = 10

    /// A region is a bounding box in an image or video frame.
    case region // = 11

    /// A frame is a single image in a video stream
    case frame // = 12

    /// A audio is a audio proto for url or bytes.
    case audio // = 13

    /// A video is a video proto for url or bytes.
    case video // = 14

    /// this can be used to store named fields with values similar to Dict
    case namedFields // = 20

    /// An arg that is a tuple.
    case tuple // = 21

    /// An arg that is a list.
    case list // = 22
    case UNRECOGNIZED(Int)

    public init() {
      self = .notSet
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .notSet
      case 1: self = .str
      case 2: self = .bytes
      case 3: self = .int
      case 4: self = .float
      case 5: self = .bool
      case 6: self = .ndarray
      case 7: self = .jsonData
      case 8: self = .text
      case 9: self = .image
      case 10: self = .concept
      case 11: self = .region
      case 12: self = .frame
      case 13: self = .audio
      case 14: self = .video
      case 20: self = .namedFields
      case 21: self = .tuple
      case 22: self = .list
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .notSet: return 0
      case .str: return 1
      case .bytes: return 2
      case .int: return 3
      case .float: return 4
      case .bool: return 5
      case .ndarray: return 6
      case .jsonData: return 7
      case .text: return 8
      case .image: return 9
      case .concept: return 10
      case .region: return 11
      case .frame: return 12
      case .audio: return 13
      case .video: return 14
      case .namedFields: return 20
      case .tuple: return 21
      case .list: return 22
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}

  fileprivate var _defaultValue: SwiftProtobuf.Google_Protobuf_Value? = nil
  fileprivate var _modelTypeRangeInfo: Clarifai_Api_ModelTypeRangeInfo? = nil
}

#if swift(>=4.2)

extension Clarifai_Api_ModelTypeField.ModelTypeFieldType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Clarifai_Api_ModelTypeField.ModelTypeFieldType] = [
    .invalidModelTypeFieldType,
    .boolean,
    .string,
    .number,
    .arrayOfConcepts,
    .arrayOfConceptsWithThreshold,
    .range,
    .enum,
    .collaborators,
    .json,
    .arrayOfNumbers,
    .workflowEmbedModels,
    .arrayOfStrings,
    .recursiveEnum,
    .pythonCode,
    .datasetID,
    .datasetVersionID,
    .arrayOfModelConcepts,
    .dataset,
    .datasetVersion,
    .encryptedString,
    .checkpointModel,
  ]
}

extension Clarifai_Api_ModelTypeField.DataType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Clarifai_Api_ModelTypeField.DataType] = [
    .notSet,
    .str,
    .bytes,
    .int,
    .float,
    .bool,
    .ndarray,
    .jsonData,
    .text,
    .image,
    .concept,
    .region,
    .frame,
    .audio,
    .video,
    .namedFields,
    .tuple,
    .list,
  ]
}

#endif  // swift(>=4.2)

/// ModelTypeRangeInfo
public struct Clarifai_Api_ModelTypeRangeInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The start of the range as a float.
  public var min: Float = 0

  /// The end of the range as a float.
  public var max: Float = 0

  /// An optional step size for the range. If provided then only values at that step size will be
  /// rounded to. For example if step is 0.02 then 0.0245 will round to 0.02.
  public var step: Float = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// ModelTypeEnumOption
public struct Clarifai_Api_ModelTypeEnumOption {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The unique value of the enum option.
  public var id: String = String()

  /// List of other ID values that are equivalent with this ID.
  /// This allows the user to choose this option by multiple IDs.
  /// Example: if enum is "Phone Number Prefix", you could add an option that is selectable by two values:
  /// 1. ID: "Estonia"
  /// 2. Alias: 37
  public var aliases: [Clarifai_Api_ModelTypeEnumOptionAlias] = []

  /// Optional description for this enum option.
  public var description_p: String = String()

  /// These are additional fields that are specific to this enum choice. This allows
  /// us to use enums to control configuration settings as well.
  public var modelTypeFields: [Clarifai_Api_ModelTypeField] = []

  /// If this enum option should be internal only.
  public var internalOnly: Bool = false

  /// Whether this is the recommended enum option. Set to `true` when there
  /// are multiple options, and one is shown to be better than the others.
  public var recommended: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Clarifai_Api_ModelTypeEnumOptionAlias {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Integer alias for id.
  public var idInt: Int64 = 0

  /// String that can contain wild cards and the regex needs to match.
  public var wildcardString: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// ModelQuery
public struct Clarifai_Api_ModelQuery {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The name ofthe field. This supports wilcard queries like "gen*" to match "general" as an example.
  public var name: String = String()

  /// Filter models by the specific model_type_id. See ListModelTypes for the list of ModelType.Id's
  /// supported.
  public var modelTypeID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// ModelVersion
public struct Clarifai_Api_ModelVersion {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: String {
    get {return _storage._id}
    set {_uniqueStorage()._id = newValue}
  }

  /// When the version was created.
  public var createdAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._createdAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._createdAt = newValue}
  }
  /// Returns true if `createdAt` has been explicitly set.
  public var hasCreatedAt: Bool {return _storage._createdAt != nil}
  /// Clears the value of `createdAt`. Subsequent reads from it will return its default value.
  public mutating func clearCreatedAt() {_uniqueStorage()._createdAt = nil}

  /// The status of the version (whether it's untrained, training, trained, etc.).
  public var status: Clarifai_Api_Status_Status {
    get {return _storage._status ?? Clarifai_Api_Status_Status()}
    set {_uniqueStorage()._status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  public var hasStatus: Bool {return _storage._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  public mutating func clearStatus() {_uniqueStorage()._status = nil}

  public var activeConceptCount: UInt32 {
    get {return _storage._activeConceptCount}
    set {_uniqueStorage()._activeConceptCount = newValue}
  }

  public var metrics: Clarifai_Api_EvalMetrics {
    get {return _storage._metrics ?? Clarifai_Api_EvalMetrics()}
    set {_uniqueStorage()._metrics = newValue}
  }
  /// Returns true if `metrics` has been explicitly set.
  public var hasMetrics: Bool {return _storage._metrics != nil}
  /// Clears the value of `metrics`. Subsequent reads from it will return its default value.
  public mutating func clearMetrics() {_uniqueStorage()._metrics = nil}

  /// number of inputs in the model version
  public var totalInputCount: UInt32 {
    get {return _storage._totalInputCount}
    set {_uniqueStorage()._totalInputCount = newValue}
  }

  /// When a model has already been trained externally, you can upload
  /// it directly to the platform as a model version directly by
  /// setting the PretrainedModelConfig
  public var pretrainedModelConfig: Clarifai_Api_PretrainedModelConfig {
    get {return _storage._pretrainedModelConfig ?? Clarifai_Api_PretrainedModelConfig()}
    set {_uniqueStorage()._pretrainedModelConfig = newValue}
  }
  /// Returns true if `pretrainedModelConfig` has been explicitly set.
  public var hasPretrainedModelConfig: Bool {return _storage._pretrainedModelConfig != nil}
  /// Clears the value of `pretrainedModelConfig`. Subsequent reads from it will return its default value.
  public mutating func clearPretrainedModelConfig() {_uniqueStorage()._pretrainedModelConfig = nil}

  /// When training of this version was completed.
  public var completedAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._completedAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._completedAt = newValue}
  }
  /// Returns true if `completedAt` has been explicitly set.
  public var hasCompletedAt: Bool {return _storage._completedAt != nil}
  /// Clears the value of `completedAt`. Subsequent reads from it will return its default value.
  public mutating func clearCompletedAt() {_uniqueStorage()._completedAt = nil}

  /// Description about this version
  public var description_p: String {
    get {return _storage._description_p}
    set {_uniqueStorage()._description_p = newValue}
  }

  /// The visibility field represents whether this message is privately/publicly visible.
  /// To be visible to the public the App that contains it AND the User that contains the App must
  /// also be publicly visible.
  public var visibility: Clarifai_Api_Visibility {
    get {return _storage._visibility ?? Clarifai_Api_Visibility()}
    set {_uniqueStorage()._visibility = newValue}
  }
  /// Returns true if `visibility` has been explicitly set.
  public var hasVisibility: Bool {return _storage._visibility != nil}
  /// Clears the value of `visibility`. Subsequent reads from it will return its default value.
  public mutating func clearVisibility() {_uniqueStorage()._visibility = nil}

  /// The app the model version belongs to.
  public var appID: String {
    get {return _storage._appID}
    set {_uniqueStorage()._appID = newValue}
  }

  /// The user the model version belongs to.
  public var userID: String {
    get {return _storage._userID}
    set {_uniqueStorage()._userID = newValue}
  }

  /// When this model version was last modified
  public var modifiedAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._modifiedAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._modifiedAt = newValue}
  }
  /// Returns true if `modifiedAt` has been explicitly set.
  public var hasModifiedAt: Bool {return _storage._modifiedAt != nil}
  /// Clears the value of `modifiedAt`. Subsequent reads from it will return its default value.
  public mutating func clearModifiedAt() {_uniqueStorage()._modifiedAt = nil}

  /// To handle arbitrary json metadata you can use a struct field:
  /// https://github.com/google/protobuf/blob/master/src/google/protobuf/struct.proto
  public var metadata: SwiftProtobuf.Google_Protobuf_Struct {
    get {return _storage._metadata ?? SwiftProtobuf.Google_Protobuf_Struct()}
    set {_uniqueStorage()._metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  public var hasMetadata: Bool {return _storage._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  public mutating func clearMetadata() {_uniqueStorage()._metadata = nil}

  public var license: String {
    get {return _storage._license}
    set {_uniqueStorage()._license = newValue}
  }

  /// Info about the model's output. Besides `output_info.data`, these fields should
  /// be reserved for parameters that affect the models outputs when inferencing.
  /// `output_info.data` is used to specify the training concepts for this model version.
  public var outputInfo: Clarifai_Api_OutputInfo {
    get {return _storage._outputInfo ?? Clarifai_Api_OutputInfo()}
    set {_uniqueStorage()._outputInfo = newValue}
  }
  /// Returns true if `outputInfo` has been explicitly set.
  public var hasOutputInfo: Bool {return _storage._outputInfo != nil}
  /// Clears the value of `outputInfo`. Subsequent reads from it will return its default value.
  public mutating func clearOutputInfo() {_uniqueStorage()._outputInfo = nil}

  /// Info about preprocessing the models inputs, before they are sent to this model for training or inferencing.
  /// E.g.: `input_info.base_embed_model` lets us know inputs should be ran through a base model before being sent to an embedding-classifier.
  public var inputInfo: Clarifai_Api_InputInfo {
    get {return _storage._inputInfo ?? Clarifai_Api_InputInfo()}
    set {_uniqueStorage()._inputInfo = newValue}
  }
  /// Returns true if `inputInfo` has been explicitly set.
  public var hasInputInfo: Bool {return _storage._inputInfo != nil}
  /// Clears the value of `inputInfo`. Subsequent reads from it will return its default value.
  public mutating func clearInputInfo() {_uniqueStorage()._inputInfo = nil}

  /// Configuration for the training process of this model version.
  public var trainInfo: Clarifai_Api_TrainInfo {
    get {return _storage._trainInfo ?? Clarifai_Api_TrainInfo()}
    set {_uniqueStorage()._trainInfo = newValue}
  }
  /// Returns true if `trainInfo` has been explicitly set.
  public var hasTrainInfo: Bool {return _storage._trainInfo != nil}
  /// Clears the value of `trainInfo`. Subsequent reads from it will return its default value.
  public mutating func clearTrainInfo() {_uniqueStorage()._trainInfo = nil}

  /// Configuration used to import model from third-party toolkits
  public var importInfo: Clarifai_Api_ImportInfo {
    get {return _storage._importInfo ?? Clarifai_Api_ImportInfo()}
    set {_uniqueStorage()._importInfo = newValue}
  }
  /// Returns true if `importInfo` has been explicitly set.
  public var hasImportInfo: Bool {return _storage._importInfo != nil}
  /// Clears the value of `importInfo`. Subsequent reads from it will return its default value.
  public mutating func clearImportInfo() {_uniqueStorage()._importInfo = nil}

  /// Contains the training logs if available
  public var trainLog: String {
    get {return _storage._trainLog}
    set {_uniqueStorage()._trainLog = newValue}
  }

  /// The minimum required compute resource for this model for inference.
  public var inferenceComputeInfo: Clarifai_Api_ComputeInfo {
    get {return _storage._inferenceComputeInfo ?? Clarifai_Api_ComputeInfo()}
    set {_uniqueStorage()._inferenceComputeInfo = newValue}
  }
  /// Returns true if `inferenceComputeInfo` has been explicitly set.
  public var hasInferenceComputeInfo: Bool {return _storage._inferenceComputeInfo != nil}
  /// Clears the value of `inferenceComputeInfo`. Subsequent reads from it will return its default value.
  public mutating func clearInferenceComputeInfo() {_uniqueStorage()._inferenceComputeInfo = nil}

  /// Build information for the model version
  public var buildInfo: Clarifai_Api_BuildInfo {
    get {return _storage._buildInfo ?? Clarifai_Api_BuildInfo()}
    set {_uniqueStorage()._buildInfo = newValue}
  }
  /// Returns true if `buildInfo` has been explicitly set.
  public var hasBuildInfo: Bool {return _storage._buildInfo != nil}
  /// Clears the value of `buildInfo`. Subsequent reads from it will return its default value.
  public mutating func clearBuildInfo() {_uniqueStorage()._buildInfo = nil}

  /// Model signature information for the model version
  public var methodSignatures: [Clarifai_Api_MethodSignature] {
    get {return _storage._methodSignatures}
    set {_uniqueStorage()._methodSignatures = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// MethodSignature is a definition of a method that a model can have.
/// This is used to communicate between a python method definition of any arbitrary function
/// to the client or UI on how to call that function from the client side.
public struct Clarifai_Api_MethodSignature {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The name of the method on the server.
  public var name: String = String()

  /// whether the method is for predict(unary-unary), generate(unary-stream), stream(stream-stream)
  public var methodType: Clarifai_Api_RunnerMethodType = .unknown

  /// description from the docstring of the method on the server.
  public var description_p: String = String()

  /// input fields and signature of every method arguments
  public var inputFields: [Clarifai_Api_ModelTypeField] = []

  /// output signature of method
  public var outputFields: [Clarifai_Api_ModelTypeField] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Clarifai_Api_BuildInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Docker image name
  public var dockerImageName: String = String()

  /// Docker image tag
  public var dockerImageTag: String = String()

  /// Docker image digest
  public var dockerImageDigest: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// ModelVersionExport contains metadata for a single Model version export.
public struct Clarifai_Api_ModelVersionExport {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// status is the current status of the dataset version export.
  public var status: Clarifai_Api_Status_Status {
    get {return _status ?? Clarifai_Api_Status_Status()}
    set {_status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  public var hasStatus: Bool {return self._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  public mutating func clearStatus() {self._status = nil}

  /// url is the URL from where the model version export can be downloaded.
  public var url: String = String()

  /// size of model file
  public var size: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _status: Clarifai_Api_Status_Status? = nil
}

/// PretrainedModelConfig
public struct Clarifai_Api_PretrainedModelConfig {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// This is the internal id of the pretrained model.
  /// Map from the api.Data field names to the Triton config.pbtxt input.
  public var inputFieldsMap: SwiftProtobuf.Google_Protobuf_Struct {
    get {return _inputFieldsMap ?? SwiftProtobuf.Google_Protobuf_Struct()}
    set {_inputFieldsMap = newValue}
  }
  /// Returns true if `inputFieldsMap` has been explicitly set.
  public var hasInputFieldsMap: Bool {return self._inputFieldsMap != nil}
  /// Clears the value of `inputFieldsMap`. Subsequent reads from it will return its default value.
  public mutating func clearInputFieldsMap() {self._inputFieldsMap = nil}

  /// Map from the api.Data field names to the Triton config.pbtxt output.
  public var outputFieldsMap: SwiftProtobuf.Google_Protobuf_Struct {
    get {return _outputFieldsMap ?? SwiftProtobuf.Google_Protobuf_Struct()}
    set {_outputFieldsMap = newValue}
  }
  /// Returns true if `outputFieldsMap` has been explicitly set.
  public var hasOutputFieldsMap: Bool {return self._outputFieldsMap != nil}
  /// Clears the value of `outputFieldsMap`. Subsequent reads from it will return its default value.
  public mutating func clearOutputFieldsMap() {self._outputFieldsMap = nil}

  /// Url to a zipped up model in triton format with the following files and folders at the root:
  ///  config.pbtxt
  ///  version 1 folder that contains model files (onnx graph, torch script, python BE model, and etc.)
  public var modelZipURL: String = String()

  /// Whether to overwrite the model for the existing internal id
  /// If this is a local dev model that runs external to the platform, set this to true.
  /// This helps during development of models before uploading them to the platform.
  /// These models MUST run in an associated compute cluster with cluster_type = "local-dev"
  public var localDev: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _inputFieldsMap: SwiftProtobuf.Google_Protobuf_Struct? = nil
  fileprivate var _outputFieldsMap: SwiftProtobuf.Google_Protobuf_Struct? = nil
}

/// TrainStats
public struct Clarifai_Api_TrainStats {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var lossCurve: [Clarifai_Api_LossCurveEntry] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// LossCurveEntry
public struct Clarifai_Api_LossCurveEntry {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// current epoch
  public var epoch: UInt32 = 0

  /// current global step
  public var globalStep: UInt32 = 0

  /// current cost
  /// FIXME(rigel): this should be loss instead of cost.
  public var cost: Float = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// LabelCount
public struct Clarifai_Api_LabelCount {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var conceptName: String = String()

  public var count: UInt32 = 0

  public var concept: Clarifai_Api_Concept {
    get {return _concept ?? Clarifai_Api_Concept()}
    set {_concept = newValue}
  }
  /// Returns true if `concept` has been explicitly set.
  public var hasConcept: Bool {return self._concept != nil}
  /// Clears the value of `concept`. Subsequent reads from it will return its default value.
  public mutating func clearConcept() {self._concept = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _concept: Clarifai_Api_Concept? = nil
}

/// LabelDistribution
public struct Clarifai_Api_LabelDistribution {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var positiveLabelCounts: [Clarifai_Api_LabelCount] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// NOTE: this is inefficient, should just have the order of the rows/cols
public struct Clarifai_Api_CooccurrenceMatrixEntry {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// concept_id for the row
  public var row: String = String()

  /// concept_id for the col
  public var col: String = String()

  public var count: UInt32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// CooccurrenceMatrix
public struct Clarifai_Api_CooccurrenceMatrix {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var matrix: [Clarifai_Api_CooccurrenceMatrixEntry] = []

  /// These concept_ids are ordered by the strength of the diagonal in the ConfusionMatrix.
  public var conceptIds: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// ConfusionMatrixEntry
public struct Clarifai_Api_ConfusionMatrixEntry {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var predicted: String = String()

  public var actual: String = String()

  public var value: Float = 0

  public var predictedConcept: Clarifai_Api_Concept {
    get {return _predictedConcept ?? Clarifai_Api_Concept()}
    set {_predictedConcept = newValue}
  }
  /// Returns true if `predictedConcept` has been explicitly set.
  public var hasPredictedConcept: Bool {return self._predictedConcept != nil}
  /// Clears the value of `predictedConcept`. Subsequent reads from it will return its default value.
  public mutating func clearPredictedConcept() {self._predictedConcept = nil}

  public var actualConcept: Clarifai_Api_Concept {
    get {return _actualConcept ?? Clarifai_Api_Concept()}
    set {_actualConcept = newValue}
  }
  /// Returns true if `actualConcept` has been explicitly set.
  public var hasActualConcept: Bool {return self._actualConcept != nil}
  /// Clears the value of `actualConcept`. Subsequent reads from it will return its default value.
  public mutating func clearActualConcept() {self._actualConcept = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _predictedConcept: Clarifai_Api_Concept? = nil
  fileprivate var _actualConcept: Clarifai_Api_Concept? = nil
}

/// ConfusionMatrix
public struct Clarifai_Api_ConfusionMatrix {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var matrix: [Clarifai_Api_ConfusionMatrixEntry] = []

  /// These concept_ids are ordered by the strength of the diagonal in the ConfusionMatrix.
  public var conceptIds: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// ROC
public struct Clarifai_Api_ROC {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var fpr: [Float] = []

  public var tpr: [Float] = []

  public var thresholds: [Float] = []

  public var fprPerImage: [Float] = []

  public var fprPerObject: [Float] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// PrecisionRecallCurve
public struct Clarifai_Api_PrecisionRecallCurve {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var recall: [Float] = []

  public var precision: [Float] = []

  public var thresholds: [Float] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// BinaryMetrics
public struct Clarifai_Api_BinaryMetrics {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var numPos: UInt32 {
    get {return _storage._numPos}
    set {_uniqueStorage()._numPos = newValue}
  }

  public var numNeg: UInt32 {
    get {return _storage._numNeg}
    set {_uniqueStorage()._numNeg = newValue}
  }

  public var numTot: UInt32 {
    get {return _storage._numTot}
    set {_uniqueStorage()._numTot = newValue}
  }

  public var rocAuc: Float {
    get {return _storage._rocAuc}
    set {_uniqueStorage()._rocAuc = newValue}
  }

  public var f1: Float {
    get {return _storage._f1}
    set {_uniqueStorage()._f1 = newValue}
  }

  public var concept: Clarifai_Api_Concept {
    get {return _storage._concept ?? Clarifai_Api_Concept()}
    set {_uniqueStorage()._concept = newValue}
  }
  /// Returns true if `concept` has been explicitly set.
  public var hasConcept: Bool {return _storage._concept != nil}
  /// Clears the value of `concept`. Subsequent reads from it will return its default value.
  public mutating func clearConcept() {_uniqueStorage()._concept = nil}

  public var rocCurve: Clarifai_Api_ROC {
    get {return _storage._rocCurve ?? Clarifai_Api_ROC()}
    set {_uniqueStorage()._rocCurve = newValue}
  }
  /// Returns true if `rocCurve` has been explicitly set.
  public var hasRocCurve: Bool {return _storage._rocCurve != nil}
  /// Clears the value of `rocCurve`. Subsequent reads from it will return its default value.
  public mutating func clearRocCurve() {_uniqueStorage()._rocCurve = nil}

  public var precisionRecallCurve: Clarifai_Api_PrecisionRecallCurve {
    get {return _storage._precisionRecallCurve ?? Clarifai_Api_PrecisionRecallCurve()}
    set {_uniqueStorage()._precisionRecallCurve = newValue}
  }
  /// Returns true if `precisionRecallCurve` has been explicitly set.
  public var hasPrecisionRecallCurve: Bool {return _storage._precisionRecallCurve != nil}
  /// Clears the value of `precisionRecallCurve`. Subsequent reads from it will return its default value.
  public mutating func clearPrecisionRecallCurve() {_uniqueStorage()._precisionRecallCurve = nil}

  public var avgPrecision: Float {
    get {return _storage._avgPrecision}
    set {_uniqueStorage()._avgPrecision = newValue}
  }

  public var areaName: String {
    get {return _storage._areaName}
    set {_uniqueStorage()._areaName = newValue}
  }

  public var areaMin: Double {
    get {return _storage._areaMin}
    set {_uniqueStorage()._areaMin = newValue}
  }

  public var areaMax: Double {
    get {return _storage._areaMax}
    set {_uniqueStorage()._areaMax = newValue}
  }

  public var iou: Float {
    get {return _storage._iou}
    set {_uniqueStorage()._iou = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// TrackerMetrics
public struct Clarifai_Api_TrackerMetrics {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Multiple object tracking accuracy
  public var motMota: Float = 0

  /// Number of switches between tracks
  public var motNumSwitches: Int32 = 0

  /// MORSE fragmentation rate (a.k.a unique switch rate, only calculated in public sector)
  public var morseFrag: Float = 0

  /// Average precision calculated from all processed frames
  public var avgPrecision: Float = 0

  /// The concept that we are evaluating the tracker
  public var aiid: String = String()

  /// Same as morse_frag but calculated using MOT mapping/metrics
  public var uniqueSwitchRate: Float = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// EvalTestSetEntry
public struct Clarifai_Api_EvalTestSetEntry {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// the input information
  public var input: Clarifai_Api_Input {
    get {return _input ?? Clarifai_Api_Input()}
    set {_input = newValue}
  }
  /// Returns true if `input` has been explicitly set.
  public var hasInput: Bool {return self._input != nil}
  /// Clears the value of `input`. Subsequent reads from it will return its default value.
  public mutating func clearInput() {self._input = nil}

  public var predictedConcepts: [Clarifai_Api_Concept] = []

  /// All the ground truth concepts will be show on the top level
  public var groundTruthConcepts: [Clarifai_Api_Concept] = []

  /// Only region-based/frame-based app contains this annotation
  /// Each annotation only contains one region
  /// And the concepts is in ground_truth_concepts instead of this annotation
  public var annotation: Clarifai_Api_Annotation {
    get {return _annotation ?? Clarifai_Api_Annotation()}
    set {_annotation = newValue}
  }
  /// Returns true if `annotation` has been explicitly set.
  public var hasAnnotation: Bool {return self._annotation != nil}
  /// Clears the value of `annotation`. Subsequent reads from it will return its default value.
  public mutating func clearAnnotation() {self._annotation = nil}

  /// For region based models, region and associated concepts are stored together.
  public var predictedAnnotation: Clarifai_Api_Annotation {
    get {return _predictedAnnotation ?? Clarifai_Api_Annotation()}
    set {_predictedAnnotation = newValue}
  }
  /// Returns true if `predictedAnnotation` has been explicitly set.
  public var hasPredictedAnnotation: Bool {return self._predictedAnnotation != nil}
  /// Clears the value of `predictedAnnotation`. Subsequent reads from it will return its default value.
  public mutating func clearPredictedAnnotation() {self._predictedAnnotation = nil}

  public var groundTruthAnnotation: Clarifai_Api_Annotation {
    get {return _groundTruthAnnotation ?? Clarifai_Api_Annotation()}
    set {_groundTruthAnnotation = newValue}
  }
  /// Returns true if `groundTruthAnnotation` has been explicitly set.
  public var hasGroundTruthAnnotation: Bool {return self._groundTruthAnnotation != nil}
  /// Clears the value of `groundTruthAnnotation`. Subsequent reads from it will return its default value.
  public mutating func clearGroundTruthAnnotation() {self._groundTruthAnnotation = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _input: Clarifai_Api_Input? = nil
  fileprivate var _annotation: Clarifai_Api_Annotation? = nil
  fileprivate var _predictedAnnotation: Clarifai_Api_Annotation? = nil
  fileprivate var _groundTruthAnnotation: Clarifai_Api_Annotation? = nil
}

/// LOPQEvalResult
public struct Clarifai_Api_LOPQEvalResult {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Rank k for which all metrics are reported.
  public var k: Int32 = 0

  /// Recall @ k assuming the brute force search is the ground truth.
  public var recallVsBruteForce: Float = 0

  /// Kendall's tau correlation @ k assuming the brute force search is the ground truth.
  public var kendallTauVsBruteForce: Float = 0

  /// The percentage of the most frequent code in the indexed part of evaluation data.
  public var mostFrequentCodePercent: Float = 0

  /// Normalized Discounted Cumulative Gain (NDCG) @ k with a ground truth inferred from annotations
  /// and/or prediction for this evaluation LOPQ model.
  /// NDCG uses individual relevance scores of each returned image to evaluate the usefulness, or
  /// gain, of a document based on its position in the result list. The premise of DCG is that
  /// highly relevant documents appearing lower in a search result list should be penalized as the
  /// graded relevance value is reduced logarithmically proportional to the position of the result.
  /// See: https://en.wikipedia.org/wiki/Information_retrieval#Discounted_cumulative_gain
  ///
  /// To compute the relevance score between two images we consider two cases:
  /// 1) Only one label for each image
  /// An image is relevant to an image query iff they are labeled the same (score 1), and
  /// not relevant otherwise (score 0)
  /// 2) Multiple labels for each image
  /// Here an image relevancy with respect to a single image query is measured by f-beta score
  /// assuming the query image list of labels as ground truth and comparing them with that of
  /// the search result. These labels can come from image annotations or if substitute_annotation_misses
  /// is set, predictions of base classifier where any prediction with prob < prob_threshold are
  /// discarded. To quantify the relevancy score of a single search result we opt to compute precision
  /// and recall @ k for simplicity, and combine them with f-beta score to obtain a single number.
  public var lopqNdcg: Float = 0

  /// Brute force NDCG which gives a baseline to compare to and is a measure of how good
  /// the embeddings are.
  public var bruteForceNdcg: Float = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// MetricsSummary
public struct Clarifai_Api_MetricsSummary {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var top1Accuracy: Float = 0

  public var top5Accuracy: Float = 0

  public var macroAvgRocAuc: Float = 0

  public var macroStdRocAuc: Float = 0

  public var macroAvgF1Score: Float = 0

  public var macroStdF1Score: Float = 0

  public var macroAvgPrecision: Float = 0

  public var macroAvgRecall: Float = 0

  public var meanAvgPrecisionIou50: Float = 0

  public var meanAvgPrecisionIouRange: Float = 0

  public var lopqMetrics: [Clarifai_Api_LOPQEvalResult] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// EvalMetrics
public struct Clarifai_Api_EvalMetrics {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var status: Clarifai_Api_Status_Status {
    get {return _storage._status ?? Clarifai_Api_Status_Status()}
    set {_uniqueStorage()._status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  public var hasStatus: Bool {return _storage._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  public mutating func clearStatus() {_uniqueStorage()._status = nil}

  /// user id that owns this evaluation
  public var userID: String {
    get {return _storage._userID}
    set {_uniqueStorage()._userID = newValue}
  }

  /// app id that owns this evaluation
  public var appID: String {
    get {return _storage._appID}
    set {_uniqueStorage()._appID = newValue}
  }

  /// Id of this evaluation
  public var id: String {
    get {return _storage._id}
    set {_uniqueStorage()._id = newValue}
  }

  /// Model to evaluate
  public var model: Clarifai_Api_Model {
    get {return _storage._model ?? Clarifai_Api_Model()}
    set {_uniqueStorage()._model = newValue}
  }
  /// Returns true if `model` has been explicitly set.
  public var hasModel: Bool {return _storage._model != nil}
  /// Clears the value of `model`. Subsequent reads from it will return its default value.
  public mutating func clearModel() {_uniqueStorage()._model = nil}

  /// The ground truth dataset
  public var groundTruthDataset: Clarifai_Api_Dataset {
    get {return _storage._groundTruthDataset ?? Clarifai_Api_Dataset()}
    set {_uniqueStorage()._groundTruthDataset = newValue}
  }
  /// Returns true if `groundTruthDataset` has been explicitly set.
  public var hasGroundTruthDataset: Bool {return _storage._groundTruthDataset != nil}
  /// Clears the value of `groundTruthDataset`. Subsequent reads from it will return its default value.
  public mutating func clearGroundTruthDataset() {_uniqueStorage()._groundTruthDataset = nil}

  /// The dataset with predictions
  public var predictionsDataset: Clarifai_Api_Dataset {
    get {return _storage._predictionsDataset ?? Clarifai_Api_Dataset()}
    set {_uniqueStorage()._predictionsDataset = newValue}
  }
  /// Returns true if `predictionsDataset` has been explicitly set.
  public var hasPredictionsDataset: Bool {return _storage._predictionsDataset != nil}
  /// Clears the value of `predictionsDataset`. Subsequent reads from it will return its default value.
  public mutating func clearPredictionsDataset() {_uniqueStorage()._predictionsDataset = nil}

  public var summary: Clarifai_Api_MetricsSummary {
    get {return _storage._summary ?? Clarifai_Api_MetricsSummary()}
    set {_uniqueStorage()._summary = newValue}
  }
  /// Returns true if `summary` has been explicitly set.
  public var hasSummary: Bool {return _storage._summary != nil}
  /// Clears the value of `summary`. Subsequent reads from it will return its default value.
  public mutating func clearSummary() {_uniqueStorage()._summary = nil}

  public var confusionMatrix: Clarifai_Api_ConfusionMatrix {
    get {return _storage._confusionMatrix ?? Clarifai_Api_ConfusionMatrix()}
    set {_uniqueStorage()._confusionMatrix = newValue}
  }
  /// Returns true if `confusionMatrix` has been explicitly set.
  public var hasConfusionMatrix: Bool {return _storage._confusionMatrix != nil}
  /// Clears the value of `confusionMatrix`. Subsequent reads from it will return its default value.
  public mutating func clearConfusionMatrix() {_uniqueStorage()._confusionMatrix = nil}

  public var cooccurrenceMatrix: Clarifai_Api_CooccurrenceMatrix {
    get {return _storage._cooccurrenceMatrix ?? Clarifai_Api_CooccurrenceMatrix()}
    set {_uniqueStorage()._cooccurrenceMatrix = newValue}
  }
  /// Returns true if `cooccurrenceMatrix` has been explicitly set.
  public var hasCooccurrenceMatrix: Bool {return _storage._cooccurrenceMatrix != nil}
  /// Clears the value of `cooccurrenceMatrix`. Subsequent reads from it will return its default value.
  public mutating func clearCooccurrenceMatrix() {_uniqueStorage()._cooccurrenceMatrix = nil}

  public var labelCounts: Clarifai_Api_LabelDistribution {
    get {return _storage._labelCounts ?? Clarifai_Api_LabelDistribution()}
    set {_uniqueStorage()._labelCounts = newValue}
  }
  /// Returns true if `labelCounts` has been explicitly set.
  public var hasLabelCounts: Bool {return _storage._labelCounts != nil}
  /// Clears the value of `labelCounts`. Subsequent reads from it will return its default value.
  public mutating func clearLabelCounts() {_uniqueStorage()._labelCounts = nil}

  public var binaryMetrics: [Clarifai_Api_BinaryMetrics] {
    get {return _storage._binaryMetrics}
    set {_uniqueStorage()._binaryMetrics = newValue}
  }

  public var testSet: [Clarifai_Api_EvalTestSetEntry] {
    get {return _storage._testSet}
    set {_uniqueStorage()._testSet = newValue}
  }

  public var metricsByArea: [Clarifai_Api_BinaryMetrics] {
    get {return _storage._metricsByArea}
    set {_uniqueStorage()._metricsByArea = newValue}
  }

  public var metricsByClass: [Clarifai_Api_BinaryMetrics] {
    get {return _storage._metricsByClass}
    set {_uniqueStorage()._metricsByClass = newValue}
  }

  public var trackerMetrics: [Clarifai_Api_TrackerMetrics] {
    get {return _storage._trackerMetrics}
    set {_uniqueStorage()._trackerMetrics = newValue}
  }

  /// Evaluation parameters to pass. Expected to match what
  /// is defined in the model type for the respective model.
  public var evalInfo: Clarifai_Api_EvalInfo {
    get {return _storage._evalInfo ?? Clarifai_Api_EvalInfo()}
    set {_uniqueStorage()._evalInfo = newValue}
  }
  /// Returns true if `evalInfo` has been explicitly set.
  public var hasEvalInfo: Bool {return _storage._evalInfo != nil}
  /// Clears the value of `evalInfo`. Subsequent reads from it will return its default value.
  public mutating func clearEvalInfo() {_uniqueStorage()._evalInfo = nil}

  public var extendedMetrics: Clarifai_Api_ExtendedMetrics {
    get {return _storage._extendedMetrics ?? Clarifai_Api_ExtendedMetrics()}
    set {_uniqueStorage()._extendedMetrics = newValue}
  }
  /// Returns true if `extendedMetrics` has been explicitly set.
  public var hasExtendedMetrics: Bool {return _storage._extendedMetrics != nil}
  /// Clears the value of `extendedMetrics`. Subsequent reads from it will return its default value.
  public mutating func clearExtendedMetrics() {_uniqueStorage()._extendedMetrics = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Clarifai_Api_ExtendedMetrics {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var userMetrics: SwiftProtobuf.Google_Protobuf_Struct {
    get {return _userMetrics ?? SwiftProtobuf.Google_Protobuf_Struct()}
    set {_userMetrics = newValue}
  }
  /// Returns true if `userMetrics` has been explicitly set.
  public var hasUserMetrics: Bool {return self._userMetrics != nil}
  /// Clears the value of `userMetrics`. Subsequent reads from it will return its default value.
  public mutating func clearUserMetrics() {self._userMetrics = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _userMetrics: SwiftProtobuf.Google_Protobuf_Struct? = nil
}

/// FieldsValue
public struct Clarifai_Api_FieldsValue {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var confusionMatrix: Bool = false

  public var cooccurrenceMatrix: Bool = false

  public var labelCounts: Bool = false

  public var binaryMetrics: Bool = false

  public var testSet: Bool = false

  public var metricsByArea: Bool = false

  public var metricsByClass: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Output
public struct Clarifai_Api_Output {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// One of these outputs per Input
  public var id: String {
    get {return _storage._id}
    set {_uniqueStorage()._id = newValue}
  }

  public var status: Clarifai_Api_Status_Status {
    get {return _storage._status ?? Clarifai_Api_Status_Status()}
    set {_uniqueStorage()._status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  public var hasStatus: Bool {return _storage._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  public mutating func clearStatus() {_uniqueStorage()._status = nil}

  /// When the object was created. We follow the XXXX timestamp
  /// format. We use https://www.ietf.org/rfc/rfc3339.txt format:
  /// "2006-01-02T15:04:05.999999Z" so you can expect results like
  /// the following from the API:
  /// "2017-04-11T21:50:50.223962Z"
  public var createdAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._createdAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._createdAt = newValue}
  }
  /// Returns true if `createdAt` has been explicitly set.
  public var hasCreatedAt: Bool {return _storage._createdAt != nil}
  /// Clears the value of `createdAt`. Subsequent reads from it will return its default value.
  public mutating func clearCreatedAt() {_uniqueStorage()._createdAt = nil}

  /// The model that created this Output.
  public var model: Clarifai_Api_Model {
    get {return _storage._model ?? Clarifai_Api_Model()}
    set {_uniqueStorage()._model = newValue}
  }
  /// Returns true if `model` has been explicitly set.
  public var hasModel: Bool {return _storage._model != nil}
  /// Clears the value of `model`. Subsequent reads from it will return its default value.
  public mutating func clearModel() {_uniqueStorage()._model = nil}

  /// The input that was passed to the model to create this Output. For example if we have an image
  /// model then it will take as input here an Input object with Image filled in.
  public var input: Clarifai_Api_Input {
    get {return _storage._input ?? Clarifai_Api_Input()}
    set {_uniqueStorage()._input = newValue}
  }
  /// Returns true if `input` has been explicitly set.
  public var hasInput: Bool {return _storage._input != nil}
  /// Clears the value of `input`. Subsequent reads from it will return its default value.
  public mutating func clearInput() {_uniqueStorage()._input = nil}

  /// The output data for this Output. For example if we have a concept model then the predicted
  /// concepts will appear here.
  public var data: Clarifai_Api_Data {
    get {return _storage._data ?? Clarifai_Api_Data()}
    set {_uniqueStorage()._data = newValue}
  }
  /// Returns true if `data` has been explicitly set.
  public var hasData: Bool {return _storage._data != nil}
  /// Clears the value of `data`. Subsequent reads from it will return its default value.
  public mutating func clearData() {_uniqueStorage()._data = nil}

  /// Number of prompt tokens as reported by the model or third-party API.
  public var promptTokens: UInt32 {
    get {return _storage._promptTokens}
    set {_uniqueStorage()._promptTokens = newValue}
  }

  /// Number of completion tokens as reported by the model or third-party API.
  public var completionTokens: UInt32 {
    get {return _storage._completionTokens}
    set {_uniqueStorage()._completionTokens = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// ScopeDeps
public struct Clarifai_Api_ScopeDeps {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The scope
  public var scope: String = String()

  /// Other scopes that are required.
  public var dependingScopes: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// EndpointDeps
public struct Clarifai_Api_EndpointDeps {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The fully qualified endpoint to
  public var endpoint: String = String()

  /// Other scopes that are required.
  public var dependingScopes: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Hit
public struct Clarifai_Api_Hit {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// This is the score for the ranked Hit results of the search query. This score is a number
  /// between 0.0 and 1.0 as it represents a confidence in the search Hit. For example, if you search
  /// for "car" and get a close matching Hit, the score should be close to 1.0. If you get a score
  /// of close to 0.0 that means it's very disimilar to your query, in this case NOT a "car". There
  /// is a special intermediate score of 0.5 that means that the Hit is not really correlated with
  /// your search query (ie. not similar or dissimlar to the query) which is a common occurrence
  /// when using negate queries.
  /// Note: some queries that are just filtering down your app of inputs may just return a score of
  /// 1.0 for all Hits.
  public var score: Float = 0

  /// This is the matched input returned from the search query. This will contain information about
  /// the Input such as the url, created_at time and trusted annotation information (for backwards
  /// compatibility with apps that existed before Annotations were introduced.
  public var input: Clarifai_Api_Input {
    get {return _input ?? Clarifai_Api_Input()}
    set {_input = newValue}
  }
  /// Returns true if `input` has been explicitly set.
  public var hasInput: Bool {return self._input != nil}
  /// Clears the value of `input`. Subsequent reads from it will return its default value.
  public mutating func clearInput() {self._input = nil}

  /// We also provide back the specific matched annotation for the above input. We do this in order
  /// to support more complex Annotation queries in the And message below. For example if we match
  /// the search results to a region in your input, or a frame in a video input, this annotation
  /// field will be that matched annotation info and the input will be the image/video that the user
  /// originally added which contains those regions / frames.
  public var annotation: Clarifai_Api_Annotation {
    get {return _annotation ?? Clarifai_Api_Annotation()}
    set {_annotation = newValue}
  }
  /// Returns true if `annotation` has been explicitly set.
  public var hasAnnotation: Bool {return self._annotation != nil}
  /// Clears the value of `annotation`. Subsequent reads from it will return its default value.
  public mutating func clearAnnotation() {self._annotation = nil}

  /// The customer-facing id of the user who owns the app the asset came from.
  public var userID: String = String()

  /// The cfid of the app the asset came from.
  public var appID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _input: Clarifai_Api_Input? = nil
  fileprivate var _annotation: Clarifai_Api_Annotation? = nil
}

public struct Clarifai_Api_HitCount {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The estimated total number of hits for the search query, not just the current page.
  public var estimatedTotal: UInt64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// This is the common building block of a query which is a sequence of And messages ANDed together.
/// Note that some fields are used too RANK results (affect the scores) and some are used to FILTER
/// results (unordered subset of your app's contents). In general, FILTER operations are more
/// efficient queries at scale and when combined with RANK operations can speed up search performance
/// as you effectively operate on a smaller sub-set of your entire app.
public struct Clarifai_Api_And {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// FILTER by input.data... information.
  /// This can include human provided concepts, geo location info, metadata, etc.
  /// This is effectively searching over only the trusted annotation attached to an input in your
  /// app. To search by more specific annotation fields use the Annotation object here.
  /// ########## Supported fields ##########
  ///  - data.concepts[].id
  ///  - data.concepts[].name
  ///  - data.concepts[].value
  ///  - data.geo.geo_box[].geo_point.latitude
  ///  - data.geo.geo_box[].geo_point.longitude
  ///  - data.geo.geo_limit.type
  ///  - data.geo.geo_limit.value
  ///  - data.geo.geo_point.latitude
  ///  - data.geo.geo_point.longitude
  ///  - data.image.url
  ///  - data.metadata.fields - filter by metadata. metadata key&value fields are OR-ed.
  ///  - dataset_ids[] - filter by dataset IDs
  ///  - id - filter by input ID
  ///  - status.code - filter by input status
  public var input: Clarifai_Api_Input {
    get {return _input ?? Clarifai_Api_Input()}
    set {_input = newValue}
  }
  /// Returns true if `input` has been explicitly set.
  public var hasInput: Bool {return self._input != nil}
  /// Clears the value of `input`. Subsequent reads from it will return its default value.
  public mutating func clearInput() {self._input = nil}

  /// RANK based predicted outputs from models such as custom trained models, pre-trained models,
  /// etc. This is also where you enter the image url for a visual search because what we're asking
  /// the system to do is find output embedding most visually similar to the provided input (that
  /// input being in And.output.input.data.image.url for example). This will return the Hits
  /// sorted by visual similarity (1.0 being very similar or exact match and 0.0 being very
  /// dissimlar). For a search by Output concept, this means we're asking the system to rank
  /// the Hits by confidence of our model's predicted Outputs. So for example if the model
  /// predicts an image is 0.95 likely there is a "dog" present, that should related directly
  /// to the score returned if you search for Output concept "dog" in your query. This provides
  /// a natural ranking to search results based on confidence of predictions from the models and
  /// is used when ANDing multiple of these types of RANK by Output queries together as well.
  ///
  /// ########## Supported fields ##########
  ///  - data.clusters[].id
  ///  - data.concepts[].id
  ///  - data.concepts[].name
  ///  - data.concepts[].value
  ///  - input.data.image.base64[]
  ///  - input.data.image.url
  ///  - input.id
  public var output: Clarifai_Api_Output {
    get {return _output ?? Clarifai_Api_Output()}
    set {_output = newValue}
  }
  /// Returns true if `output` has been explicitly set.
  public var hasOutput: Bool {return self._output != nil}
  /// Clears the value of `output`. Subsequent reads from it will return its default value.
  public mutating func clearOutput() {self._output = nil}

  /// If True then this will flip the meaning of this part of the
  /// query. This allow for queries such as dog AND ! metadata=={"blah":"value"}
  public var negate: Bool = false

  /// FILTER by annotation information. This is more flexible than just filtering by
  /// Input information because in the general case each input can have several annotations.
  /// Some example use cases for filtering by annotations:
  /// 1) find all the inputs annotated "dog" by worker_id = "XYZ"
  /// 2) find all the annotations associated with embed_model_version_id = "123"
  /// 3) find all the annotations that are trusted, etc.
  ///
  /// Since all the annotations under the hood are joined to the embedding model's annotation
  /// using worker_id's of other models like cluster models or concept models should be
  /// combinable with queries like visual search (a query with Output filled in).
  ///
  /// ########## Supported fields ##########
  ///  - annotation_info.fields - filter by annotation info
  ///  - data.concepts[].id
  ///  - data.concepts[].name
  ///  - data.concepts[].value
  ///  - data.geo.geo_box[].geo_point.latitude
  ///  - data.geo.geo_box[].geo_point.longitude
  ///  - data.geo.geo_limit.type
  ///  - data.geo.geo_limit.value
  ///  - data.geo.geo_point.latitude
  ///  - data.geo.geo_point.longitude
  ///  - data.image.url
  ///  - data.metadata.fields - filter by metadata. metadata key&value fields are OR-ed.
  ///  - input_id
  ///  - input_level
  ///  - model_version_id
  ///  - status.code
  ///  - task_id
  ///  - trusted
  ///  - user_id
  public var annotation: Clarifai_Api_Annotation {
    get {return _annotation ?? Clarifai_Api_Annotation()}
    set {_annotation = newValue}
  }
  /// Returns true if `annotation` has been explicitly set.
  public var hasAnnotation: Bool {return self._annotation != nil}
  /// Clears the value of `annotation`. Subsequent reads from it will return its default value.
  public mutating func clearAnnotation() {self._annotation = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _input: Clarifai_Api_Input? = nil
  fileprivate var _output: Clarifai_Api_Output? = nil
  fileprivate var _annotation: Clarifai_Api_Annotation? = nil
}

/// This is the search query used in /searches, model training requests, bulk data exports, etc.
public struct Clarifai_Api_Query {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The query syntax is simply a list of And operatiosn that will be ANDed together to fetch
  /// results which are returned to the user as Hit messages.
  ///
  /// Deprecated: Only used by the deprecated PostSearches endpoint. Use filters
  /// and ranks instead with PostInputsSearches or PostAnnotationsSearches.
  public var ands: [Clarifai_Api_And] = []

  /// This allows the query to override any default language the app was setup in when doing Concept
  /// based searches. This currently only affects public Models Output searches when those public
  /// Models have translations for their Concepts.
  public var language: String = String()

  /// filters in this query
  /// e.q. only fetch annotations that have certain metadata
  public var filters: [Clarifai_Api_Filter] = []

  /// rankings in this query
  /// e.g. visual search by a url
  public var ranks: [Clarifai_Api_Rank] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// This is the new Search object used in saved searches.
public struct Clarifai_Api_Search {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Search query.
  public var query: Clarifai_Api_Query {
    get {return _storage._query ?? Clarifai_Api_Query()}
    set {_uniqueStorage()._query = newValue}
  }
  /// Returns true if `query` has been explicitly set.
  public var hasQuery: Bool {return _storage._query != nil}
  /// Clears the value of `query`. Subsequent reads from it will return its default value.
  public mutating func clearQuery() {_uniqueStorage()._query = nil}

  /// Customer facing, external ID for search to be saved. Provided by the user, e.g. "saved-search-1.
  /// It is unique per application.
  public var id: String {
    get {return _storage._id}
    set {_uniqueStorage()._id = newValue}
  }

  /// Application that owns this saved search.
  public var applicationID: String {
    get {return _storage._applicationID}
    set {_uniqueStorage()._applicationID = newValue}
  }

  /// Human readable display name of the saved search.
  public var name: String {
    get {return _storage._name}
    set {_uniqueStorage()._name = newValue}
  }

  /// "As of" timestamp, indicating a time in the past as of which we want to
  /// retrieve the annotations satisfying the query.
  public var asOf: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._asOf ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._asOf = newValue}
  }
  /// Returns true if `asOf` has been explicitly set.
  public var hasAsOf: Bool {return _storage._asOf != nil}
  /// Clears the value of `asOf`. Subsequent reads from it will return its default value.
  public mutating func clearAsOf() {_uniqueStorage()._asOf = nil}

  /// Git hash of the code that ran the filter.
  public var gitHash: String {
    get {return _storage._gitHash}
    set {_uniqueStorage()._gitHash = newValue}
  }

  /// When the saved search was created.
  public var createdAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._createdAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._createdAt = newValue}
  }
  /// Returns true if `createdAt` has been explicitly set.
  public var hasCreatedAt: Bool {return _storage._createdAt != nil}
  /// Clears the value of `createdAt`. Subsequent reads from it will return its default value.
  public mutating func clearCreatedAt() {_uniqueStorage()._createdAt = nil}

  /// When the saved search was updated.
  public var modifiedAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._modifiedAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._modifiedAt = newValue}
  }
  /// Returns true if `modifiedAt` has been explicitly set.
  public var hasModifiedAt: Bool {return _storage._modifiedAt != nil}
  /// Clears the value of `modifiedAt`. Subsequent reads from it will return its default value.
  public mutating func clearModifiedAt() {_uniqueStorage()._modifiedAt = nil}

  /// The search algorithm to be used.
  /// Options are are 'nearest_neighbor', 'brute_force', and 'avg_concept_brute_force'
  /// The last two perform a brute force search visual search instead of a more scalable distributed
  /// nearest neighbor search and should be used by advanced users only.
  /// If not specified we default to nearest neighbor
  public var algorithm: String {
    get {return _storage._algorithm}
    set {_uniqueStorage()._algorithm = newValue}
  }

  /// If true, save this search, and exit without executing the search.
  /// If false execute the query
  public var save: Bool {
    get {return _storage._save}
    set {_uniqueStorage()._save = newValue}
  }

  /// Minimum value of confidence threshold score in result.
  /// Defaults to 0.0 which means we won't do any thresholding as all probabilities will
  /// likely be > 0.0.
  public var minValue: Float {
    get {return _storage._minValue}
    set {_uniqueStorage()._minValue = newValue}
  }

  /// The visibility field represents whether this message is privately/publicly visible.
  /// To be visible to the public the App that contains it AND the User that contains the App must
  /// also be publicly visible.
  public var visibility: Clarifai_Api_Visibility {
    get {return _storage._visibility ?? Clarifai_Api_Visibility()}
    set {_uniqueStorage()._visibility = newValue}
  }
  /// Returns true if `visibility` has been explicitly set.
  public var hasVisibility: Bool {return _storage._visibility != nil}
  /// Clears the value of `visibility`. Subsequent reads from it will return its default value.
  public mutating func clearVisibility() {_uniqueStorage()._visibility = nil}

  public var metric: Clarifai_Api_Search.Metric {
    get {return _storage._metric}
    set {_uniqueStorage()._metric = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Metric used for search. Can be EUCLIDEAN_DISTANCE (default) or COSINE_DISTANCE.
  /// Currently only brute force search supports non-eudlicean metrics.
  public enum Metric: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case notSet // = 0
    case euclideanDistance // = 1
    case cosineDistance // = 2
    case UNRECOGNIZED(Int)

    public init() {
      self = .notSet
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .notSet
      case 1: self = .euclideanDistance
      case 2: self = .cosineDistance
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .notSet: return 0
      case .euclideanDistance: return 1
      case .cosineDistance: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

#if swift(>=4.2)

extension Clarifai_Api_Search.Metric: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Clarifai_Api_Search.Metric] = [
    .notSet,
    .euclideanDistance,
    .cosineDistance,
  ]
}

#endif  // swift(>=4.2)

/// Filter
public struct Clarifai_Api_Filter {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// If True then this will flip the meaning of this part of the
  /// query. This allow for queries such as dog AND ! metadata=={"blah":"value"}
  public var negate: Bool = false

  /// FILTER by annotation information.
  /// ########## Supported fields ##########
  ///  # Filter by ID fields
  ///  - id                                      - example: `{"id": "xyz"}`
  ///  - input_id
  ///  - model_version_id
  ///  - task_id
  ///  - user_id
  ///
  ///  # Filter by worker fields such as model, workflow and user IDs
  ///  - worker.model.model_version.id
  ///  - worker.user.id
  ///  - worker.workflow.version.id
  ///
  ///  # Filter by other top-level fields
  ///  - annotation_info.fields                  - filter by annotation info
  ///  - input_level                             - filter only input-level annotations
  ///  - status.code                             - filter by annotation status code
  ///  - trusted                                 - filter only trusted annotations
  ///
  ///  # Filter by space-time info fields, i.e. region, frames and time-segments
  ///  - data                                    - filter only annotations without space-time info, e.g. classifications
  ///                                            - in order to enable this, you need to set the field to an empty object, i.e. `{"data": {}}`
  ///  - data.frames[].frame_info                - filter only frame annotations
  ///                                            - in order to enable this, you need to set the field to an empty object, i.e. `{"data": {"frames": [{"frame_info": {}}]}}`
  ///  - data.regions[].region_info.bounding_box - filter only bounding box annotations
  ///                                            - in order to enable this, you need to set the field to an empty object, i.e. `{"data": {"regions": [{"region_info": {"bounding_box":{}}}]}}`
  ///  - data.regions[].region_info.mask         - filter only mask annotations
  ///                                            - in order to enable this, you need to set the field to an empty object, i.e. `{"data": {"regions": [{"region_info": {"mask":{}}}]}}`
  ///  - data.regions[].region_info.point        - filter only point annotations
  ///                                            - in order to enable this, you need to set the field to an empty object, i.e. `{"data": {"regions": [{"region_info": {"point":{}}}]}}`
  ///  - data.regions[].region_info.polygon      - filter only polygon annotations
  ///                                            - in order to enable this, you need to set the field to an empty object, i.e. `{"data": {"regions": [{"region_info": {"polygon":{}}}]}}`
  ///  - data.regions[].region_info.span         - filter only span annotations
  ///                                            - in order to enable this, you need to set the field to an empty object, i.e. `{"data": {"regions": [{"region_info": {"span":{}}}]}}`
  ///  - data.regions[].track_id                 - filter annotations by track_id
  ///                                            - in order to enable this, you need to provide "track_id_value" i.e. `{"data": {"regions": [{"track_id" : "track_id_value"}]}}`
  ///  - data.time_segments[].time_info          - filter only time-segment annotations
  ///                                            - in order to enable this, you need to set the field to an empty object, i.e. `{"data": {"time_segments": [{"time_info": {}}]}}`
  ///
  ///  # Filter by other data fields
  ///  - data.clusters[].id
  ///  - data.concepts[].id
  ///  - data.concepts[].name
  ///  - data.concepts[].value
  ///  - data.geo.geo_box[].geo_point.latitude
  ///  - data.geo.geo_box[].geo_point.longitude
  ///  - data.geo.geo_limit.type
  ///  - data.geo.geo_limit.value
  ///  - data.geo.geo_point.latitude
  ///  - data.geo.geo_point.longitude
  ///  - data.metadata.fields                    - filter by metadata
  ///                                            - Important to note: metadata key&value fields are OR-ed.
  ///                                            - example with 1 metadata key: searching by
  ///                                                      `{
  ///                                                      `  "data": {
  ///                                                      `    "metadata": {
  ///                                                      `      "fields": {
  ///                                                      `        "foo": {
  ///                                                      `          "string_value": "bar"
  ///                                                      `        },
  ///                                                      `      }
  ///                                                      `    }
  ///                                                      `  }
  ///                                                      `}
  ///                                                      will result in a search condition like `metadata includes {"foo": "bar}`;
  ///                                            - example with 2 metadata keys: searching by
  ///                                                      `{
  ///                                                      `  "data": {
  ///                                                      `    "metadata": {
  ///                                                      `      "fields": {
  ///                                                      `        "foo1": {
  ///                                                      `          "string_value": "bar2"
  ///                                                      `        },
  ///                                                      `        "foo2": {
  ///                                                      `          "string_value": "bar2"
  ///                                                      `        }
  ///                                                      `      }
  ///                                                      `    }
  ///                                                      `  }
  ///                                                      `}
  ///                                                      will result in a search condition like `(metadata includes {"foo1": "bar1"}) OR (metadata includes {"foo2": "bar2"})`.
  ///  - data.text                               - filter only text annotations
  ///                                            - in order to enable this, you need to set the field to an empty object, i.e. `{"data": {"text": {}}}`
  public var annotation: Clarifai_Api_Annotation {
    get {return _annotation ?? Clarifai_Api_Annotation()}
    set {_annotation = newValue}
  }
  /// Returns true if `annotation` has been explicitly set.
  public var hasAnnotation: Bool {return self._annotation != nil}
  /// Clears the value of `annotation`. Subsequent reads from it will return its default value.
  public mutating func clearAnnotation() {self._annotation = nil}

  /// FILTER by input information.
  /// ########## Supported fields ##########
  ///  - data.audio                              - filter only audio inputs
  ///                                            - in order to enable this, you need to set the field to an empty object, i.e. `{"audio": {}}`
  ///  - data.image                              - filter only image inputs
  ///                                            - enable using `{"image": {}}`
  ///  - data.text                               - filter only text inputs
  ///                                            - enable using `{"text": {}}`
  ///  - data.video                              - filter only video inputs
  ///                                            - enable using `{"video": {}}`
  ///  - dataset_ids[]                           - filter by dataset IDs
  ///                                            - example: `{"dataset_ids": ["d1", "d2"]}` will filter for inputs in d1 OR d2
  ///  - status.code                             - filter by input status
  ///                                            - example: `{"status": {"code": 30000}}` to filter only for SUCCESS inputs
  public var input: Clarifai_Api_Input {
    get {return _input ?? Clarifai_Api_Input()}
    set {_input = newValue}
  }
  /// Returns true if `input` has been explicitly set.
  public var hasInput: Bool {return self._input != nil}
  /// Clears the value of `input`. Subsequent reads from it will return its default value.
  public mutating func clearInput() {self._input = nil}

  /// Filter by annotation last updated time range.
  public var lastUpdatedTimeRange: Clarifai_Api_TimeRange {
    get {return _lastUpdatedTimeRange ?? Clarifai_Api_TimeRange()}
    set {_lastUpdatedTimeRange = newValue}
  }
  /// Returns true if `lastUpdatedTimeRange` has been explicitly set.
  public var hasLastUpdatedTimeRange: Bool {return self._lastUpdatedTimeRange != nil}
  /// Clears the value of `lastUpdatedTimeRange`. Subsequent reads from it will return its default value.
  public mutating func clearLastUpdatedTimeRange() {self._lastUpdatedTimeRange = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _annotation: Clarifai_Api_Annotation? = nil
  fileprivate var _input: Clarifai_Api_Input? = nil
  fileprivate var _lastUpdatedTimeRange: Clarifai_Api_TimeRange? = nil
}

/// TimeRange
public struct Clarifai_Api_TimeRange {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Begin of the time range, optional, inclusive.
  public var startTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _startTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_startTime = newValue}
  }
  /// Returns true if `startTime` has been explicitly set.
  public var hasStartTime: Bool {return self._startTime != nil}
  /// Clears the value of `startTime`. Subsequent reads from it will return its default value.
  public mutating func clearStartTime() {self._startTime = nil}

  /// End of the time range, optional, inclusive.
  public var endTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _endTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_endTime = newValue}
  }
  /// Returns true if `endTime` has been explicitly set.
  public var hasEndTime: Bool {return self._endTime != nil}
  /// Clears the value of `endTime`. Subsequent reads from it will return its default value.
  public mutating func clearEndTime() {self._endTime = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _startTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _endTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

/// Rank
public struct Clarifai_Api_Rank {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// If True then this will flip the meaning of this part of the
  /// query. This allow for queries such as !dog
  public var negate: Bool = false

  /// RANK by annotation information.
  /// ########## Supported fields ##########
  ///  - data.concepts[].id
  ///  - data.concepts[].name
  ///  - data.concepts[].value
  ///  - data.embeddings[].num_dimensions
  ///  - data.embeddings[].vector[]
  ///  - data.image.base64[]
  ///  - data.image.url
  ///  - data.text.raw
  ///  - input_id
  ///  - model_version_id
  public var annotation: Clarifai_Api_Annotation {
    get {return _annotation ?? Clarifai_Api_Annotation()}
    set {_annotation = newValue}
  }
  /// Returns true if `annotation` has been explicitly set.
  public var hasAnnotation: Bool {return self._annotation != nil}
  /// Clears the value of `annotation`. Subsequent reads from it will return its default value.
  public mutating func clearAnnotation() {self._annotation = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _annotation: Clarifai_Api_Annotation? = nil
}

/// AnnotationSearchMetrics
public struct Clarifai_Api_AnnotationSearchMetrics {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The ground truth we are evaluating against
  public var groundTruth: Clarifai_Api_Search {
    get {return _groundTruth ?? Clarifai_Api_Search()}
    set {_groundTruth = newValue}
  }
  /// Returns true if `groundTruth` has been explicitly set.
  public var hasGroundTruth: Bool {return self._groundTruth != nil}
  /// Clears the value of `groundTruth`. Subsequent reads from it will return its default value.
  public mutating func clearGroundTruth() {self._groundTruth = nil}

  /// The set we are evaluating
  public var searchToEval: Clarifai_Api_Search {
    get {return _searchToEval ?? Clarifai_Api_Search()}
    set {_searchToEval = newValue}
  }
  /// Returns true if `searchToEval` has been explicitly set.
  public var hasSearchToEval: Bool {return self._searchToEval != nil}
  /// Clears the value of `searchToEval`. Subsequent reads from it will return its default value.
  public mutating func clearSearchToEval() {self._searchToEval = nil}

  /// The metric result
  public var metrics: Clarifai_Api_EvalMetrics {
    get {return _metrics ?? Clarifai_Api_EvalMetrics()}
    set {_metrics = newValue}
  }
  /// Returns true if `metrics` has been explicitly set.
  public var hasMetrics: Bool {return self._metrics != nil}
  /// Clears the value of `metrics`. Subsequent reads from it will return its default value.
  public mutating func clearMetrics() {self._metrics = nil}

  /// data is filled out with the concepts used for this evaluation
  public var data: Clarifai_Api_Data {
    get {return _data ?? Clarifai_Api_Data()}
    set {_data = newValue}
  }
  /// Returns true if `data` has been explicitly set.
  public var hasData: Bool {return self._data != nil}
  /// Clears the value of `data`. Subsequent reads from it will return its default value.
  public mutating func clearData() {self._data = nil}

  /// active_concept_count is the number of concepts for this evaluation
  public var activeConceptCount: UInt32 = 0

  /// The visibility field represents whether this message is privately/publicly visible.
  /// To be visible to the public the App that contains it AND the User that contains the App must
  /// also be publicly visible.
  public var visibility: Clarifai_Api_Visibility {
    get {return _visibility ?? Clarifai_Api_Visibility()}
    set {_visibility = newValue}
  }
  /// Returns true if `visibility` has been explicitly set.
  public var hasVisibility: Bool {return self._visibility != nil}
  /// Clears the value of `visibility`. Subsequent reads from it will return its default value.
  public mutating func clearVisibility() {self._visibility = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _groundTruth: Clarifai_Api_Search? = nil
  fileprivate var _searchToEval: Clarifai_Api_Search? = nil
  fileprivate var _metrics: Clarifai_Api_EvalMetrics? = nil
  fileprivate var _data: Clarifai_Api_Data? = nil
  fileprivate var _visibility: Clarifai_Api_Visibility? = nil
}

/// Text
public struct Clarifai_Api_Text {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// This is a raw text string.
  public var raw: String = String()

  /// Url to a text file
  public var url: String = String()

  public var allowDuplicateURL: Bool = false

  /// The hosted field lists original text hosted in Clarifai storage. This field is currently used
  /// only in response.
  public var hosted: Clarifai_Api_HostedURL {
    get {return _hosted ?? Clarifai_Api_HostedURL()}
    set {_hosted = newValue}
  }
  /// Returns true if `hosted` has been explicitly set.
  public var hasHosted: Bool {return self._hosted != nil}
  /// Clears the value of `hosted`. Subsequent reads from it will return its default value.
  public mutating func clearHosted() {self._hosted = nil}

  /// text info
  public var textInfo: Clarifai_Api_TextInfo {
    get {return _textInfo ?? Clarifai_Api_TextInfo()}
    set {_textInfo = newValue}
  }
  /// Returns true if `textInfo` has been explicitly set.
  public var hasTextInfo: Bool {return self._textInfo != nil}
  /// Clears the value of `textInfo`. Subsequent reads from it will return its default value.
  public mutating func clearTextInfo() {self._textInfo = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _hosted: Clarifai_Api_HostedURL? = nil
  fileprivate var _textInfo: Clarifai_Api_TextInfo? = nil
}

public struct Clarifai_Api_TextInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// count of characters in text
  public var charCount: Int32 = 0

  /// text encoding
  public var encoding: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// User
public struct Clarifai_Api_User {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: String {
    get {return _storage._id}
    set {_uniqueStorage()._id = newValue}
  }

  public var primaryEmail: String {
    get {return _storage._primaryEmail}
    set {_uniqueStorage()._primaryEmail = newValue}
  }

  public var firstName: String {
    get {return _storage._firstName}
    set {_uniqueStorage()._firstName = newValue}
  }

  public var lastName: String {
    get {return _storage._lastName}
    set {_uniqueStorage()._lastName = newValue}
  }

  public var companyName: String {
    get {return _storage._companyName}
    set {_uniqueStorage()._companyName = newValue}
  }

  public var jobTitle: String {
    get {return _storage._jobTitle}
    set {_uniqueStorage()._jobTitle = newValue}
  }

  public var jobRole: String {
    get {return _storage._jobRole}
    set {_uniqueStorage()._jobRole = newValue}
  }

  /// This specifies user intent when registering on clarifai
  public var intention: String {
    get {return _storage._intention}
    set {_uniqueStorage()._intention = newValue}
  }

  /// This specifies how one got to know about clarifai
  public var referralSource: String {
    get {return _storage._referralSource}
    set {_uniqueStorage()._referralSource = newValue}
  }

  public var billType: String {
    get {return _storage._billType}
    set {_uniqueStorage()._billType = newValue}
  }

  /// When the user was created. We follow the XXXX timestamp
  /// format. We use https://www.ietf.org/rfc/rfc3339.txt format:
  /// "2006-01-02T15:04:05.999999Z" so you can expect results like
  /// the following from the API:
  /// "2017-04-11T21:50:50.223962Z"
  public var createdAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._createdAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._createdAt = newValue}
  }
  /// Returns true if `createdAt` has been explicitly set.
  public var hasCreatedAt: Bool {return _storage._createdAt != nil}
  /// Clears the value of `createdAt`. Subsequent reads from it will return its default value.
  public mutating func clearCreatedAt() {_uniqueStorage()._createdAt = nil}

  public var dateGdprConsent: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._dateGdprConsent ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._dateGdprConsent = newValue}
  }
  /// Returns true if `dateGdprConsent` has been explicitly set.
  public var hasDateGdprConsent: Bool {return _storage._dateGdprConsent != nil}
  /// Clears the value of `dateGdprConsent`. Subsequent reads from it will return its default value.
  public mutating func clearDateGdprConsent() {_uniqueStorage()._dateGdprConsent = nil}

  public var dateTosConsent: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._dateTosConsent ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._dateTosConsent = newValue}
  }
  /// Returns true if `dateTosConsent` has been explicitly set.
  public var hasDateTosConsent: Bool {return _storage._dateTosConsent != nil}
  /// Clears the value of `dateTosConsent`. Subsequent reads from it will return its default value.
  public mutating func clearDateTosConsent() {_uniqueStorage()._dateTosConsent = nil}

  public var dateMarketingConsent: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._dateMarketingConsent ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._dateMarketingConsent = newValue}
  }
  /// Returns true if `dateMarketingConsent` has been explicitly set.
  public var hasDateMarketingConsent: Bool {return _storage._dateMarketingConsent != nil}
  /// Clears the value of `dateMarketingConsent`. Subsequent reads from it will return its default value.
  public mutating func clearDateMarketingConsent() {_uniqueStorage()._dateMarketingConsent = nil}

  public var datePiiConsent: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._datePiiConsent ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._datePiiConsent = newValue}
  }
  /// Returns true if `datePiiConsent` has been explicitly set.
  public var hasDatePiiConsent: Bool {return _storage._datePiiConsent != nil}
  /// Clears the value of `datePiiConsent`. Subsequent reads from it will return its default value.
  public mutating func clearDatePiiConsent() {_uniqueStorage()._datePiiConsent = nil}

  /// To handle arbitrary json metadata you can use a struct field:
  /// https://github.com/google/protobuf/blob/master/src/google/protobuf/struct.proto
  public var metadata: SwiftProtobuf.Google_Protobuf_Struct {
    get {return _storage._metadata ?? SwiftProtobuf.Google_Protobuf_Struct()}
    set {_uniqueStorage()._metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  public var hasMetadata: Bool {return _storage._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  public mutating func clearMetadata() {_uniqueStorage()._metadata = nil}

  public var emailAddresses: [Clarifai_Api_EmailAddress] {
    get {return _storage._emailAddresses}
    set {_uniqueStorage()._emailAddresses = newValue}
  }

  public var twoFactorAuthEnabled: Bool {
    get {return _storage._twoFactorAuthEnabled}
    set {_uniqueStorage()._twoFactorAuthEnabled = newValue}
  }

  public var teamsCount: UInt32 {
    get {return _storage._teamsCount}
    set {_uniqueStorage()._teamsCount = newValue}
  }

  /// Is starred by the requesting user (only showed on get/list requests)
  /// Please use PostUserStars/DeleteUserStars endpoints to star/unstar an user
  public var isStarred: Bool {
    get {return _storage._isStarred}
    set {_uniqueStorage()._isStarred = newValue}
  }

  /// How many users have starred the user (only showed on get/list requests)
  /// Computed value, not editable
  public var starCount: Int32 {
    get {return _storage._starCount}
    set {_uniqueStorage()._starCount = newValue}
  }

  /// The visibility field represents whether this message is privately/publicly visible.
  /// To be visible to the public the App that contains it AND the User that contains the App must
  /// also be publicly visible.
  public var visibility: Clarifai_Api_Visibility {
    get {return _storage._visibility ?? Clarifai_Api_Visibility()}
    set {_uniqueStorage()._visibility = newValue}
  }
  /// Returns true if `visibility` has been explicitly set.
  public var hasVisibility: Bool {return _storage._visibility != nil}
  /// Clears the value of `visibility`. Subsequent reads from it will return its default value.
  public mutating func clearVisibility() {_uniqueStorage()._visibility = nil}

  /// This is all the personal information of a user. GetUser/ListUsers will not return this
  /// information unless the caller has the UserAccounts_Get scope on their key or is the user
  /// themselves.
  public var userDetail: Clarifai_Api_UserDetail {
    get {return _storage._userDetail ?? Clarifai_Api_UserDetail()}
    set {_uniqueStorage()._userDetail = newValue}
  }
  /// Returns true if `userDetail` has been explicitly set.
  public var hasUserDetail: Bool {return _storage._userDetail != nil}
  /// Clears the value of `userDetail`. Subsequent reads from it will return its default value.
  public mutating func clearUserDetail() {_uniqueStorage()._userDetail = nil}

  /// Representative image for this User (a.k.a. Profile or cover photo)
  public var image: Clarifai_Api_Image {
    get {return _storage._image ?? Clarifai_Api_Image()}
    set {_uniqueStorage()._image = newValue}
  }
  /// Returns true if `image` has been explicitly set.
  public var hasImage: Bool {return _storage._image != nil}
  /// Clears the value of `image`. Subsequent reads from it will return its default value.
  public mutating func clearImage() {_uniqueStorage()._image = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// This message holds the confidential information from the User object that we don't want to expose
/// to other users. It will be accessible only from /users/{user_id}/account and with the User scopes.
public struct Clarifai_Api_UserDetail {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var primaryEmail: String {
    get {return _storage._primaryEmail}
    set {_uniqueStorage()._primaryEmail = newValue}
  }

  public var billType: String {
    get {return _storage._billType}
    set {_uniqueStorage()._billType = newValue}
  }

  public var dateGdprConsent: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._dateGdprConsent ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._dateGdprConsent = newValue}
  }
  /// Returns true if `dateGdprConsent` has been explicitly set.
  public var hasDateGdprConsent: Bool {return _storage._dateGdprConsent != nil}
  /// Clears the value of `dateGdprConsent`. Subsequent reads from it will return its default value.
  public mutating func clearDateGdprConsent() {_uniqueStorage()._dateGdprConsent = nil}

  public var dateTosConsent: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._dateTosConsent ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._dateTosConsent = newValue}
  }
  /// Returns true if `dateTosConsent` has been explicitly set.
  public var hasDateTosConsent: Bool {return _storage._dateTosConsent != nil}
  /// Clears the value of `dateTosConsent`. Subsequent reads from it will return its default value.
  public mutating func clearDateTosConsent() {_uniqueStorage()._dateTosConsent = nil}

  public var dateMarketingConsent: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._dateMarketingConsent ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._dateMarketingConsent = newValue}
  }
  /// Returns true if `dateMarketingConsent` has been explicitly set.
  public var hasDateMarketingConsent: Bool {return _storage._dateMarketingConsent != nil}
  /// Clears the value of `dateMarketingConsent`. Subsequent reads from it will return its default value.
  public mutating func clearDateMarketingConsent() {_uniqueStorage()._dateMarketingConsent = nil}

  public var datePiiConsent: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._datePiiConsent ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._datePiiConsent = newValue}
  }
  /// Returns true if `datePiiConsent` has been explicitly set.
  public var hasDatePiiConsent: Bool {return _storage._datePiiConsent != nil}
  /// Clears the value of `datePiiConsent`. Subsequent reads from it will return its default value.
  public mutating func clearDatePiiConsent() {_uniqueStorage()._datePiiConsent = nil}

  /// To handle arbitrary json metadata you can use a struct field:
  /// https://github.com/google/protobuf/blob/master/src/google/protobuf/struct.proto
  public var metadata: SwiftProtobuf.Google_Protobuf_Struct {
    get {return _storage._metadata ?? SwiftProtobuf.Google_Protobuf_Struct()}
    set {_uniqueStorage()._metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  public var hasMetadata: Bool {return _storage._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  public mutating func clearMetadata() {_uniqueStorage()._metadata = nil}

  public var emailAddresses: [Clarifai_Api_EmailAddress] {
    get {return _storage._emailAddresses}
    set {_uniqueStorage()._emailAddresses = newValue}
  }

  public var twoFactorAuthEnabled: Bool {
    get {return _storage._twoFactorAuthEnabled}
    set {_uniqueStorage()._twoFactorAuthEnabled = newValue}
  }

  public var teamsCount: UInt32 {
    get {return _storage._teamsCount}
    set {_uniqueStorage()._teamsCount = newValue}
  }

  public var country: String {
    get {return _storage._country}
    set {_uniqueStorage()._country = newValue}
  }

  public var state: String {
    get {return _storage._state}
    set {_uniqueStorage()._state = newValue}
  }

  public var commitmentValue: Clarifai_Api_CommitmentValue {
    get {return _storage._commitmentValue ?? Clarifai_Api_CommitmentValue()}
    set {_uniqueStorage()._commitmentValue = newValue}
  }
  /// Returns true if `commitmentValue` has been explicitly set.
  public var hasCommitmentValue: Bool {return _storage._commitmentValue != nil}
  /// Clears the value of `commitmentValue`. Subsequent reads from it will return its default value.
  public mutating func clearCommitmentValue() {_uniqueStorage()._commitmentValue = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// EmailAddress
public struct Clarifai_Api_EmailAddress {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var email: String = String()

  public var primary: Bool = false

  public var verified: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Password
public struct Clarifai_Api_Password {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// unencrypted password string
  public var plaintext: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// PasswordViolations
public struct Clarifai_Api_PasswordViolations {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// when new password length is shorter than minimum length set
  public var minimumLength: Bool = false

  /// when new password length is longer than maximum length set
  public var maximumLength: Bool = false

  /// there is no upper case letter in the new password when there should be at least one
  public var upperCaseNeeded: Bool = false

  /// there is no lower case letter in the new password when there should be at least one
  public var lowerCaseNeeded: Bool = false

  /// there is no numerics in the new password when there should be at least one
  public var numericNeeded: Bool = false

  /// there is no special character in the new password when there should be at least one
  public var nonAlphanumericNeeded: Bool = false

  /// when one of the N most recent old password is reused, N is specified by password_reuse_epoch in db.password_policies
  public var passwordReuse: Bool = false

  /// when either user's first, middle or last name is used in the new password
  public var excludeNames: Bool = false

  /// when first part of user's email (exact string or after removing special characters) is used in the new password
  public var excludeEmail: Bool = false

  /// when there are confusing letters in the new password, such as o (first character of 'omega') vs 0 (zero)
  public var noConfusingLetters: Bool = false

  /// when there are simple password patterns used, such as 12345678 or aaaaaaa1
  public var noSimplePasswords: Bool = false

  /// when there are common vocabs from the common vocab list used
  public var noCommonVocabs: Bool = false

  /// when the current password is contained in the new password or vice versa
  public var noOverlapWithOld: Bool = false

  /// when password has to be changed becauase it's too old
  public var passwordLifespan: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Commitment Value - used to track users' commitment amount and type
public struct Clarifai_Api_CommitmentValue {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The commitment value, in cents
  public var value: Int32 = 0

  /// The commitment type, can be either 'monthly' or 'annual'
  public var type: Clarifai_Api_CommitmentValue.CommitmentType = .typeNotSet

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum CommitmentType: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case typeNotSet // = 0
    case monthly // = 1
    case annual // = 2
    case UNRECOGNIZED(Int)

    public init() {
      self = .typeNotSet
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .typeNotSet
      case 1: self = .monthly
      case 2: self = .annual
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .typeNotSet: return 0
      case .monthly: return 1
      case .annual: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Clarifai_Api_CommitmentValue.CommitmentType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Clarifai_Api_CommitmentValue.CommitmentType] = [
    .typeNotSet,
    .monthly,
    .annual,
  ]
}

#endif  // swift(>=4.2)

/// Video
public struct Clarifai_Api_Video {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// This is a URL to a publicly accessible video file. The platform will download this file server
  /// side and then process.
  public var url: String {
    get {return _storage._url}
    set {_uniqueStorage()._url = newValue}
  }

  /// The base64 field is using video file bytes directly in the request.
  /// NOTE: if you're sending a json request, then this MUST be base64 encoded before sending (hence
  /// the name here).
  /// When using our grpc clients, you DO NOT need to base64 encode
  /// it yourself since the clients know how to do this for you automatically and will avoid the
  /// base64 encoding if they send a binary request.
  public var base64: Data {
    get {return _storage._base64}
    set {_uniqueStorage()._base64 = newValue}
  }

  public var allowDuplicateURL: Bool {
    get {return _storage._allowDuplicateURL}
    set {_uniqueStorage()._allowDuplicateURL = newValue}
  }

  /// URL of thumbnail image, which is currently frame at position of 1s. This field is currently
  /// used only in response.
  /// Deprecated in favour of thumbnail_hosted, which also contains alternate sizes of thumbnail
  public var thumbnailURL: String {
    get {return _storage._thumbnailURL}
    set {_uniqueStorage()._thumbnailURL = newValue}
  }

  /// The hosted field lists original video hosted in Clarifai storage. This field is currently used
  /// only in response.
  public var hosted: Clarifai_Api_HostedURL {
    get {return _storage._hosted ?? Clarifai_Api_HostedURL()}
    set {_uniqueStorage()._hosted = newValue}
  }
  /// Returns true if `hosted` has been explicitly set.
  public var hasHosted: Bool {return _storage._hosted != nil}
  /// Clears the value of `hosted`. Subsequent reads from it will return its default value.
  public mutating func clearHosted() {_uniqueStorage()._hosted = nil}

  /// The hosted field lists various sizes of the vide thumbnail hosted in Clarifai storage, with 'thumbnail' as the full size
  /// This field is currently used only in response.
  public var hostedThumbnail: Clarifai_Api_HostedURL {
    get {return _storage._hostedThumbnail ?? Clarifai_Api_HostedURL()}
    set {_uniqueStorage()._hostedThumbnail = newValue}
  }
  /// Returns true if `hostedThumbnail` has been explicitly set.
  public var hasHostedThumbnail: Bool {return _storage._hostedThumbnail != nil}
  /// Clears the value of `hostedThumbnail`. Subsequent reads from it will return its default value.
  public mutating func clearHostedThumbnail() {_uniqueStorage()._hostedThumbnail = nil}

  /// video info
  public var videoInfo: Clarifai_Api_VideoInfo {
    get {return _storage._videoInfo ?? Clarifai_Api_VideoInfo()}
    set {_uniqueStorage()._videoInfo = newValue}
  }
  /// Returns true if `videoInfo` has been explicitly set.
  public var hasVideoInfo: Bool {return _storage._videoInfo != nil}
  /// Clears the value of `videoInfo`. Subsequent reads from it will return its default value.
  public mutating func clearVideoInfo() {_uniqueStorage()._videoInfo = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Clarifai_Api_VideoInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// width
  public var width: Int32 = 0

  /// height
  public var height: Int32 = 0

  /// Frames per second of the video.
  public var fps: Float = 0

  /// video format
  public var videoFormat: String = String()

  /// video track bit rate
  public var bitRate: Int32 = 0

  /// video frame count
  public var frameCount: Int32 = 0

  /// video duration in seconds
  public var durationSeconds: Float = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Workflow
public struct Clarifai_Api_Workflow {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The workflows's unique id.
  public var id: String {
    get {return _storage._id}
    set {_uniqueStorage()._id = newValue}
  }

  /// The app the workflow belongs to
  public var appID: String {
    get {return _storage._appID}
    set {_uniqueStorage()._appID = newValue}
  }

  /// When the workflow was created. We follow the XXXX timestamp
  /// format. We use https://www.ietf.org/rfc/rfc3339.txt format:
  /// "2006-01-02T15:04:05.999999Z" so you can expect results like
  /// the following from the API:
  /// "2017-04-11T21:50:50.223962Z"
  public var createdAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._createdAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._createdAt = newValue}
  }
  /// Returns true if `createdAt` has been explicitly set.
  public var hasCreatedAt: Bool {return _storage._createdAt != nil}
  /// Clears the value of `createdAt`. Subsequent reads from it will return its default value.
  public mutating func clearCreatedAt() {_uniqueStorage()._createdAt = nil}

  /// The list of nodes retrieved from latest workflow version.
  /// Each node can specify an input node that it connects to in order to define the graph.
  public var nodes: [Clarifai_Api_WorkflowNode] {
    get {return _storage._nodes}
    set {_uniqueStorage()._nodes = newValue}
  }

  /// To handle arbitrary json metadata you can use a struct field:
  /// https://github.com/google/protobuf/blob/master/src/google/protobuf/struct.proto
  public var metadata: SwiftProtobuf.Google_Protobuf_Struct {
    get {return _storage._metadata ?? SwiftProtobuf.Google_Protobuf_Struct()}
    set {_uniqueStorage()._metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  public var hasMetadata: Bool {return _storage._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  public mutating func clearMetadata() {_uniqueStorage()._metadata = nil}

  /// The visibility field represents whether this message is privately/publicly visible.
  /// To be visible to the public the App that contains it AND the User that contains the App must
  /// also be publicly visible.
  public var visibility: Clarifai_Api_Visibility {
    get {return _storage._visibility ?? Clarifai_Api_Visibility()}
    set {_uniqueStorage()._visibility = newValue}
  }
  /// Returns true if `visibility` has been explicitly set.
  public var hasVisibility: Bool {return _storage._visibility != nil}
  /// Clears the value of `visibility`. Subsequent reads from it will return its default value.
  public mutating func clearVisibility() {_uniqueStorage()._visibility = nil}

  /// The user the workflow belongs to
  public var userID: String {
    get {return _storage._userID}
    set {_uniqueStorage()._userID = newValue}
  }

  /// When the workflow was last modified
  public var modifiedAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._modifiedAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._modifiedAt = newValue}
  }
  /// Returns true if `modifiedAt` has been explicitly set.
  public var hasModifiedAt: Bool {return _storage._modifiedAt != nil}
  /// Clears the value of `modifiedAt`. Subsequent reads from it will return its default value.
  public mutating func clearModifiedAt() {_uniqueStorage()._modifiedAt = nil}

  /// Info about the workflow version used to return the latest version when listing Workflows.
  public var version: Clarifai_Api_WorkflowVersion {
    get {return _storage._version ?? Clarifai_Api_WorkflowVersion()}
    set {_uniqueStorage()._version = newValue}
  }
  /// Returns true if `version` has been explicitly set.
  public var hasVersion: Bool {return _storage._version != nil}
  /// Clears the value of `version`. Subsequent reads from it will return its default value.
  public mutating func clearVersion() {_uniqueStorage()._version = nil}

  /// Is starred by the requesting user (only showed on get/list requests)
  /// Please use PostWorkflowStars/DeleteWorkflowStars endpoints to star/unstar a workflow
  public var isStarred: Bool {
    get {return _storage._isStarred}
    set {_uniqueStorage()._isStarred = newValue}
  }

  /// How many users have starred the workflow (only showed on get/list requests)
  /// Computed value, not editable
  public var starCount: Int32 {
    get {return _storage._starCount}
    set {_uniqueStorage()._starCount = newValue}
  }

  /// Short description about this workflow
  public var description_p: String {
    get {return _storage._description_p}
    set {_uniqueStorage()._description_p = newValue}
  }

  /// Notes for the workflow
  /// This field should be used for in-depth notes and supports up to 64Kbs.
  public var notes: String {
    get {return _storage._notes}
    set {_uniqueStorage()._notes = newValue}
  }

  /// Tags from use_cases category
  public var useCases: [String] {
    get {return _storage._useCases}
    set {_uniqueStorage()._useCases = newValue}
  }

  /// Tags for check consents
  public var checkConsents: [String] {
    get {return _storage._checkConsents}
    set {_uniqueStorage()._checkConsents = newValue}
  }

  /// bookmark info. When set, this workflow is a bookmarked workflow of this app.
  /// Info in this field will allow you to find/access original workflow.
  public var bookmarkOrigin: Clarifai_Api_BookmarkOrigin {
    get {return _storage._bookmarkOrigin ?? Clarifai_Api_BookmarkOrigin()}
    set {_uniqueStorage()._bookmarkOrigin = newValue}
  }
  /// Returns true if `bookmarkOrigin` has been explicitly set.
  public var hasBookmarkOrigin: Bool {return _storage._bookmarkOrigin != nil}
  /// Clears the value of `bookmarkOrigin`. Subsequent reads from it will return its default value.
  public mutating func clearBookmarkOrigin() {_uniqueStorage()._bookmarkOrigin = nil}

  /// Representative image for this workflow
  public var image: Clarifai_Api_Image {
    get {return _storage._image ?? Clarifai_Api_Image()}
    set {_uniqueStorage()._image = newValue}
  }
  /// Returns true if `image` has been explicitly set.
  public var hasImage: Bool {return _storage._image != nil}
  /// Clears the value of `image`. Subsequent reads from it will return its default value.
  public mutating func clearImage() {_uniqueStorage()._image = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// WorkflowVersion
public struct Clarifai_Api_WorkflowVersion {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Id of this version.
  public var id: String = String()

  /// Workflow id for this version.
  public var workflowID: String = String()

  /// When the version was created.
  /// The format is https://www.ietf.org/rfc/rfc3339.txt.
  /// Example: "2006-01-02T15:04:05.999999Z".
  public var createdAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _createdAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_createdAt = newValue}
  }
  /// Returns true if `createdAt` has been explicitly set.
  public var hasCreatedAt: Bool {return self._createdAt != nil}
  /// Clears the value of `createdAt`. Subsequent reads from it will return its default value.
  public mutating func clearCreatedAt() {self._createdAt = nil}

  /// Most recent time when the version was updated.
  /// The format is https://www.ietf.org/rfc/rfc3339.txt.
  /// Example: "2006-01-02T15:04:05.999999Z".
  public var modifiedAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _modifiedAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_modifiedAt = newValue}
  }
  /// Returns true if `modifiedAt` has been explicitly set.
  public var hasModifiedAt: Bool {return self._modifiedAt != nil}
  /// Clears the value of `modifiedAt`. Subsequent reads from it will return its default value.
  public mutating func clearModifiedAt() {self._modifiedAt = nil}

  /// The visibility field represents whether this message is privately/publicly visible.
  /// To be visible to the public the App that contains it AND the User that contains the App must
  /// also be publicly visible.
  public var visibility: Clarifai_Api_Visibility {
    get {return _visibility ?? Clarifai_Api_Visibility()}
    set {_visibility = newValue}
  }
  /// Returns true if `visibility` has been explicitly set.
  public var hasVisibility: Bool {return self._visibility != nil}
  /// Clears the value of `visibility`. Subsequent reads from it will return its default value.
  public mutating func clearVisibility() {self._visibility = nil}

  /// The list of nodes that make up the workflow version. Each node can specify an input node
  /// that it connects to in order to define the graph.
  public var nodes: [Clarifai_Api_WorkflowNode] = []

  /// To handle arbitrary json metadata you can use a struct field:
  /// https://github.com/google/protobuf/blob/master/src/google/protobuf/struct.proto
  public var metadata: SwiftProtobuf.Google_Protobuf_Struct {
    get {return _metadata ?? SwiftProtobuf.Google_Protobuf_Struct()}
    set {_metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  public var hasMetadata: Bool {return self._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  public mutating func clearMetadata() {self._metadata = nil}

  /// The app the workflow version belongs to.
  public var appID: String = String()

  /// The user the workflow version belongs to.
  public var userID: String = String()

  /// Short description about this workflow version
  public var description_p: String = String()

  /// License associated to this workflow version
  public var license: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _createdAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _modifiedAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _visibility: Clarifai_Api_Visibility? = nil
  fileprivate var _metadata: SwiftProtobuf.Google_Protobuf_Struct? = nil
}

/// WorkflowNode
public struct Clarifai_Api_WorkflowNode {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// An identifier for this node in the graph. This is used when connecting NodeInputs
  /// together.
  public var id: String = String()

  /// The model that will do the processing at this node. We only vlidate the model.id and
  /// model.model_version.id fields.
  public var model: Clarifai_Api_Model {
    get {return _model ?? Clarifai_Api_Model()}
    set {_model = newValue}
  }
  /// Returns true if `model` has been explicitly set.
  public var hasModel: Bool {return self._model != nil}
  /// Clears the value of `model`. Subsequent reads from it will return its default value.
  public mutating func clearModel() {self._model = nil}

  /// Each WorkflowNode can connect to multiple input nodes so that we can handle multi-model data
  /// and more complex workflow operations.
  public var nodeInputs: [Clarifai_Api_NodeInput] = []

  /// suppress the output for workflow prediction
  public var suppressOutput: Bool = false

  /// Used to override the output_info.data and output_info.params of the model specified by the node.
  /// Values for fields_map, message, and output_config are ignored.
  public var outputInfoOverride: Clarifai_Api_OutputInfo {
    get {return _outputInfoOverride ?? Clarifai_Api_OutputInfo()}
    set {_outputInfoOverride = newValue}
  }
  /// Returns true if `outputInfoOverride` has been explicitly set.
  public var hasOutputInfoOverride: Bool {return self._outputInfoOverride != nil}
  /// Clears the value of `outputInfoOverride`. Subsequent reads from it will return its default value.
  public mutating func clearOutputInfoOverride() {self._outputInfoOverride = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _model: Clarifai_Api_Model? = nil
  fileprivate var _outputInfoOverride: Clarifai_Api_OutputInfo? = nil
}

/// NodeInput represents inputs to a node of the graph.
public struct Clarifai_Api_NodeInput {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The id to a connected WorkflowNode which will be used as an input for current WorkflowNode.
  public var nodeID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// WorkflowResult
/// One result per input in the workflow.
public struct Clarifai_Api_WorkflowResult {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: String {
    get {return _storage._id}
    set {_uniqueStorage()._id = newValue}
  }

  public var status: Clarifai_Api_Status_Status {
    get {return _storage._status ?? Clarifai_Api_Status_Status()}
    set {_uniqueStorage()._status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  public var hasStatus: Bool {return _storage._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  public mutating func clearStatus() {_uniqueStorage()._status = nil}

  /// When the object was created. We follow the XXXX timestamp
  /// format. We use https://www.ietf.org/rfc/rfc3339.txt format:
  /// "2006-01-02T15:04:05.999999Z" so you can expect results like
  /// the following from the API:
  /// "2017-04-11T21:50:50.223962Z"
  public var createdAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._createdAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._createdAt = newValue}
  }
  /// Returns true if `createdAt` has been explicitly set.
  public var hasCreatedAt: Bool {return _storage._createdAt != nil}
  /// Clears the value of `createdAt`. Subsequent reads from it will return its default value.
  public mutating func clearCreatedAt() {_uniqueStorage()._createdAt = nil}

  /// The input that ran through the workflow to generate the outputs in this WorkflowResult.
  public var input: Clarifai_Api_Input {
    get {return _storage._input ?? Clarifai_Api_Input()}
    set {_uniqueStorage()._input = newValue}
  }
  /// Returns true if `input` has been explicitly set.
  public var hasInput: Bool {return _storage._input != nil}
  /// Clears the value of `input`. Subsequent reads from it will return its default value.
  public mutating func clearInput() {_uniqueStorage()._input = nil}

  /// For each model in the workflow we return an Output.
  public var outputs: [Clarifai_Api_Output] {
    get {return _storage._outputs}
    set {_uniqueStorage()._outputs = newValue}
  }

  /// Indicate if the output of this model is suppressed.
  public var suppressOutput: Bool {
    get {return _storage._suppressOutput}
    set {_uniqueStorage()._suppressOutput = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// WorkflowState
public struct Clarifai_Api_WorkflowState {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// A unique ID for the workflow state.
  /// To start saving a state in a PostWorkflowResults request set this ID to "init"
  /// and it will return a newly generated unique state id that you can then pass in subsequent
  /// PostWorkflowResults calls. These state expire after 5 minutes between calls.
  public var id: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// AppDuplication
public struct Clarifai_Api_AppDuplication {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The unique identifier of an app duplication job.
  public var id: String {
    get {return _storage._id}
    set {_uniqueStorage()._id = newValue}
  }

  /// The destination application where resources are written.
  ///
  /// If the destination does not exist, then the fields from the request are
  /// used to create the application. If a field is not set or not supported,
  /// then it will be copied from the source app, unless otherwise noted.
  ///
  /// Note: this field can be empty when reading app duplication jobs in cases
  /// where the app has been deleted or is just not visible to the caller.
  ///
  /// ########## Supported fields ##########
  ///  - description
  ///  - id      - if not set, then generated automatically
  ///  - user_id - if not set, then the calling user is used as the app owner
  public var destinationApp: Clarifai_Api_App {
    get {return _storage._destinationApp ?? Clarifai_Api_App()}
    set {_uniqueStorage()._destinationApp = newValue}
  }
  /// Returns true if `destinationApp` has been explicitly set.
  public var hasDestinationApp: Bool {return _storage._destinationApp != nil}
  /// Clears the value of `destinationApp`. Subsequent reads from it will return its default value.
  public mutating func clearDestinationApp() {_uniqueStorage()._destinationApp = nil}

  /// The ID of an existing app you want to copy data into.
  ///
  /// If not provided, then we will create a new application as the destination instead.
  /// The various new_app_* fields can be used to set fields of this new application.
  ///
  /// Deprecated: Use destination_app.id with an existing ID instead.
  public var existingAppID: String {
    get {return _storage._existingAppID}
    set {_uniqueStorage()._existingAppID = newValue}
  }

  /// The ID to use when creating a new application.
  /// You cannot set this field when copying into an existing app, i.e., when existing_app_is is set.
  ///
  /// If not provided, then it will be generated automatically.
  ///
  /// Deprecated: Use destination_app.id with a new ID instead.
  public var newAppID: String {
    get {return _storage._newAppID}
    set {_uniqueStorage()._newAppID = newValue}
  }

  /// The name to use when creating a new application.
  /// You cannot set this field when copying into an existing app, i.e., when existing_app_is is set.
  ///
  /// If not provided, then the ID of the new application is also used as the name.
  ///
  /// Deprecated: Application names are deprecated, use application IDs instead.
  public var newAppName: String {
    get {return _storage._newAppName}
    set {_uniqueStorage()._newAppName = newValue}
  }

  /// The status of the app duplication job.
  public var status: Clarifai_Api_Status_Status {
    get {return _storage._status ?? Clarifai_Api_Status_Status()}
    set {_uniqueStorage()._status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  public var hasStatus: Bool {return _storage._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  public mutating func clearStatus() {_uniqueStorage()._status = nil}

  /// The time when the app duplication job was created.
  public var createdAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._createdAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._createdAt = newValue}
  }
  /// Returns true if `createdAt` has been explicitly set.
  public var hasCreatedAt: Bool {return _storage._createdAt != nil}
  /// Clears the value of `createdAt`. Subsequent reads from it will return its default value.
  public mutating func clearCreatedAt() {_uniqueStorage()._createdAt = nil}

  /// The last time when the app duplication job status was updated.
  public var lastModifiedAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._lastModifiedAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._lastModifiedAt = newValue}
  }
  /// Returns true if `lastModifiedAt` has been explicitly set.
  public var hasLastModifiedAt: Bool {return _storage._lastModifiedAt != nil}
  /// Clears the value of `lastModifiedAt`. Subsequent reads from it will return its default value.
  public mutating func clearLastModifiedAt() {_uniqueStorage()._lastModifiedAt = nil}

  /// The filter specifies which resources are copied by the app duplication job.
  public var filter: Clarifai_Api_AppDuplicationFilters {
    get {return _storage._filter ?? Clarifai_Api_AppDuplicationFilters()}
    set {_uniqueStorage()._filter = newValue}
  }
  /// Returns true if `filter` has been explicitly set.
  public var hasFilter: Bool {return _storage._filter != nil}
  /// Clears the value of `filter`. Subsequent reads from it will return its default value.
  public mutating func clearFilter() {_uniqueStorage()._filter = nil}

  /// Copy progress for each resource type requested by the filter. Possible fields:
  ///  - inputs
  ///  - concepts
  ///  - annotations
  ///  - models
  ///  - workflows
  ///  - installed_module_versions
  public var progress: [Clarifai_Api_AppCopyProgress] {
    get {return _storage._progress}
    set {_uniqueStorage()._progress = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Clarifai_Api_AppCopyProgress {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var field: String = String()

  public var value: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// AppDuplicationFilters
public struct Clarifai_Api_AppDuplicationFilters {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Copy inputs. Requires that copy_concepts is also set.
  /// Note that this will still copy input-level annotations even if copy_annotations is not set.
  public var copyInputs: Bool = false

  /// Copy concepts.
  public var copyConcepts: Bool = false

  /// Copy annotations. Requires that copy_inputs and copy_concepts are also set.
  public var copyAnnotations: Bool = false

  /// Copy models. Requires that copy_concepts is also set.
  public var copyModels: Bool = false

  /// Copy workflows.
  public var copyWorkflows: Bool = false

  /// Copy installed module versions.
  public var copyInstalledModuleVersions: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// LabelOrder
public struct Clarifai_Api_LabelOrder {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// id of the order
  public var id: String {
    get {return _storage._id}
    set {_uniqueStorage()._id = newValue}
  }

  /// name of the order
  public var name: String {
    get {return _storage._name}
    set {_uniqueStorage()._name = newValue}
  }

  /// status of the order.
  /// pending (QA lead review the order),
  /// in progress (labeling in progress),
  /// ready for release (passed clarifai QA and client can review)
  /// success (released)
  public var status: Clarifai_Api_Status_Status {
    get {return _storage._status ?? Clarifai_Api_Status_Status()}
    set {_uniqueStorage()._status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  public var hasStatus: Bool {return _storage._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  public mutating func clearStatus() {_uniqueStorage()._status = nil}

  /// if set to true, automatically release the labels once passed clarifai review.
  public var autoRelease: Bool {
    get {return _storage._autoRelease}
    set {_uniqueStorage()._autoRelease = newValue}
  }

  /// allow input without any tag.
  public var allowEmptyTag: Bool {
    get {return _storage._allowEmptyTag}
    set {_uniqueStorage()._allowEmptyTag = newValue}
  }

  /// User desired estimation when the task should be done
  public var desiredFulfillTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._desiredFulfillTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._desiredFulfillTime = newValue}
  }
  /// Returns true if `desiredFulfillTime` has been explicitly set.
  public var hasDesiredFulfillTime: Bool {return _storage._desiredFulfillTime != nil}
  /// Clears the value of `desiredFulfillTime`. Subsequent reads from it will return its default value.
  public mutating func clearDesiredFulfillTime() {_uniqueStorage()._desiredFulfillTime = nil}

  /// Clarifai estimation when the task should be done .
  public var estimateFulfillTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._estimateFulfillTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._estimateFulfillTime = newValue}
  }
  /// Returns true if `estimateFulfillTime` has been explicitly set.
  public var hasEstimateFulfillTime: Bool {return _storage._estimateFulfillTime != nil}
  /// Clears the value of `estimateFulfillTime`. Subsequent reads from it will return its default value.
  public mutating func clearEstimateFulfillTime() {_uniqueStorage()._estimateFulfillTime = nil}

  /// task for this label order
  public var task: Clarifai_Api_Task {
    get {return _storage._task ?? Clarifai_Api_Task()}
    set {_uniqueStorage()._task = newValue}
  }
  /// Returns true if `task` has been explicitly set.
  public var hasTask: Bool {return _storage._task != nil}
  /// Clears the value of `task`. Subsequent reads from it will return its default value.
  public mutating func clearTask() {_uniqueStorage()._task = nil}

  /// When the label order was created.
  /// The format is https://www.ietf.org/rfc/rfc3339.txt.
  /// Example: "2006-01-02T15:04:05.999999Z".
  public var createdAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._createdAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._createdAt = newValue}
  }
  /// Returns true if `createdAt` has been explicitly set.
  public var hasCreatedAt: Bool {return _storage._createdAt != nil}
  /// Clears the value of `createdAt`. Subsequent reads from it will return its default value.
  public mutating func clearCreatedAt() {_uniqueStorage()._createdAt = nil}

  /// Most recent time when the label order was updated.
  /// The format is https://www.ietf.org/rfc/rfc3339.txt.
  /// Example: "2006-01-02T15:04:05.999999Z".
  public var modifiedAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._modifiedAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._modifiedAt = newValue}
  }
  /// Returns true if `modifiedAt` has been explicitly set.
  public var hasModifiedAt: Bool {return _storage._modifiedAt != nil}
  /// Clears the value of `modifiedAt`. Subsequent reads from it will return its default value.
  public mutating func clearModifiedAt() {_uniqueStorage()._modifiedAt = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Task is the work that needs to be done for labeling the inputs in an app.
public struct Clarifai_Api_Task {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Unique ID for the task.
  public var id: String {
    get {return _storage._id}
    set {_uniqueStorage()._id = newValue}
  }

  /// When the task was created.
  /// The format is https://www.ietf.org/rfc/rfc3339.txt.
  /// Example: "2006-01-02T15:04:05.999999Z".
  public var createdAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._createdAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._createdAt = newValue}
  }
  /// Returns true if `createdAt` has been explicitly set.
  public var hasCreatedAt: Bool {return _storage._createdAt != nil}
  /// Clears the value of `createdAt`. Subsequent reads from it will return its default value.
  public mutating func clearCreatedAt() {_uniqueStorage()._createdAt = nil}

  /// Most recent time when the task was updated.
  /// The format is https://www.ietf.org/rfc/rfc3339.txt.
  /// Example: "2006-01-02T15:04:05.999999Z".
  public var modifiedAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._modifiedAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._modifiedAt = newValue}
  }
  /// Returns true if `modifiedAt` has been explicitly set.
  public var hasModifiedAt: Bool {return _storage._modifiedAt != nil}
  /// Clears the value of `modifiedAt`. Subsequent reads from it will return its default value.
  public mutating func clearModifiedAt() {_uniqueStorage()._modifiedAt = nil}

  /// Task type.
  public var type: Clarifai_Api_Task.TaskType {
    get {return _storage._type}
    set {_uniqueStorage()._type = newValue}
  }

  /// Description of the task.
  public var description_p: String {
    get {return _storage._description_p}
    set {_uniqueStorage()._description_p = newValue}
  }

  /// Worker details.
  public var worker: Clarifai_Api_TaskWorker {
    get {return _storage._worker ?? Clarifai_Api_TaskWorker()}
    set {_uniqueStorage()._worker = newValue}
  }
  /// Returns true if `worker` has been explicitly set.
  public var hasWorker: Bool {return _storage._worker != nil}
  /// Clears the value of `worker`. Subsequent reads from it will return its default value.
  public mutating func clearWorker() {_uniqueStorage()._worker = nil}

  /// List of concept ids used in the work of this task.
  /// DEPRECATED: Use task.concepts instead.
  public var conceptIds: [String] {
    get {return _storage._conceptIds}
    set {_uniqueStorage()._conceptIds = newValue}
  }

  /// List of inputs used in this task will be taken from this source.
  public var inputSource: Clarifai_Api_TaskInputSource {
    get {return _storage._inputSource ?? Clarifai_Api_TaskInputSource()}
    set {_uniqueStorage()._inputSource = newValue}
  }
  /// Returns true if `inputSource` has been explicitly set.
  public var hasInputSource: Bool {return _storage._inputSource != nil}
  /// Clears the value of `inputSource`. Subsequent reads from it will return its default value.
  public mutating func clearInputSource() {_uniqueStorage()._inputSource = nil}

  /// For model predictions on video: Sample delay for video predicting (1 frame per N milliseconds)
  public var sampleMs: UInt32 {
    get {return _storage._sampleMs}
    set {_uniqueStorage()._sampleMs = newValue}
  }

  /// AI assistant details.
  public var aiAssistant: Clarifai_Api_TaskAIAssistant {
    get {return _storage._aiAssistant ?? Clarifai_Api_TaskAIAssistant()}
    set {_uniqueStorage()._aiAssistant = newValue}
  }
  /// Returns true if `aiAssistant` has been explicitly set.
  public var hasAiAssistant: Bool {return _storage._aiAssistant != nil}
  /// Clears the value of `aiAssistant`. Subsequent reads from it will return its default value.
  public mutating func clearAiAssistant() {_uniqueStorage()._aiAssistant = nil}

  /// Review details.
  public var review: Clarifai_Api_TaskReview {
    get {return _storage._review ?? Clarifai_Api_TaskReview()}
    set {_uniqueStorage()._review = newValue}
  }
  /// Returns true if `review` has been explicitly set.
  public var hasReview: Bool {return _storage._review != nil}
  /// Clears the value of `review`. Subsequent reads from it will return its default value.
  public mutating func clearReview() {_uniqueStorage()._review = nil}

  /// Status of this task.
  public var status: Clarifai_Api_Status_Status {
    get {return _storage._status ?? Clarifai_Api_Status_Status()}
    set {_uniqueStorage()._status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  public var hasStatus: Bool {return _storage._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  public mutating func clearStatus() {_uniqueStorage()._status = nil}

  /// Add a title for this task to quickly recognise it in a list of tasks.
  public var name: String {
    get {return _storage._name}
    set {_uniqueStorage()._name = newValue}
  }

  public var aiAssistParams: Clarifai_Api_AiAssistParameters {
    get {return _storage._aiAssistParams ?? Clarifai_Api_AiAssistParameters()}
    set {_uniqueStorage()._aiAssistParams = newValue}
  }
  /// Returns true if `aiAssistParams` has been explicitly set.
  public var hasAiAssistParams: Bool {return _storage._aiAssistParams != nil}
  /// Clears the value of `aiAssistParams`. Subsequent reads from it will return its default value.
  public mutating func clearAiAssistParams() {_uniqueStorage()._aiAssistParams = nil}

  /// The visibility field represents whether this message is privately/publicly visible.
  /// To be visible to the public the App that contains it AND the User that contains the App must
  /// also be publicly visible.
  public var visibility: Clarifai_Api_Visibility {
    get {return _storage._visibility ?? Clarifai_Api_Visibility()}
    set {_uniqueStorage()._visibility = newValue}
  }
  /// Returns true if `visibility` has been explicitly set.
  public var hasVisibility: Bool {return _storage._visibility != nil}
  /// Clears the value of `visibility`. Subsequent reads from it will return its default value.
  public mutating func clearVisibility() {_uniqueStorage()._visibility = nil}

  /// The app the task belongs to.
  public var appID: String {
    get {return _storage._appID}
    set {_uniqueStorage()._appID = newValue}
  }

  /// The user the task belongs to.
  public var userID: String {
    get {return _storage._userID}
    set {_uniqueStorage()._userID = newValue}
  }

  /// The label order the task belongs to.
  public var labelOrderID: String {
    get {return _storage._labelOrderID}
    set {_uniqueStorage()._labelOrderID = newValue}
  }

  /// Ignore Task.concept_ids field if Task.TaskConcept are supplied.
  public var concepts: [Clarifai_Api_TaskConcept] {
    get {return _storage._concepts}
    set {_uniqueStorage()._concepts = newValue}
  }

  /// Specify whether existing Annotations within the same app that are generated by other auto annotation tasks
  /// with the specified Concept from the selected Model or Workflow should deleted before executing the Task
  public var deletePreviousAnnotations: Bool {
    get {return _storage._deletePreviousAnnotations}
    set {_uniqueStorage()._deletePreviousAnnotations = newValue}
  }

  /// Tasks metrics are filled in upon user-request.
  public var metrics: Clarifai_Api_TaskMetrics {
    get {return _storage._metrics ?? Clarifai_Api_TaskMetrics()}
    set {_uniqueStorage()._metrics = newValue}
  }
  /// Returns true if `metrics` has been explicitly set.
  public var hasMetrics: Bool {return _storage._metrics != nil}
  /// Clears the value of `metrics`. Subsequent reads from it will return its default value.
  public mutating func clearMetrics() {_uniqueStorage()._metrics = nil}

  /// Priority of the task
  public var priority: Clarifai_Api_Task.TaskPriority {
    get {return _storage._priority}
    set {_uniqueStorage()._priority = newValue}
  }

  /// To handle arbitrary json metadata you can use a struct field:
  /// https://github.com/google/protobuf/blob/master/src/google/protobuf/struct.proto
  public var metadata: SwiftProtobuf.Google_Protobuf_Struct {
    get {return _storage._metadata ?? SwiftProtobuf.Google_Protobuf_Struct()}
    set {_uniqueStorage()._metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  public var hasMetadata: Bool {return _storage._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  public mutating func clearMetadata() {_uniqueStorage()._metadata = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum TaskType: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case typeNotSet // = 0

    /// Concepts classification tasks annotate concepts for the overall image, frame of video or section of text.
    case conceptsClassification // = 1

    /// Bounding box detection tasks annotate rectangular bounding box regions around each concept in an image, frame of video or section of text.
    case boundingBoxDetection // = 2

    /// Polygon detection tasks annotate free-form regions around concepts in an image, frame of video or section of text.
    case polygonDetection // = 3
    case UNRECOGNIZED(Int)

    public init() {
      self = .typeNotSet
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .typeNotSet
      case 1: self = .conceptsClassification
      case 2: self = .boundingBoxDetection
      case 3: self = .polygonDetection
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .typeNotSet: return 0
      case .conceptsClassification: return 1
      case .boundingBoxDetection: return 2
      case .polygonDetection: return 3
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public enum TaskPriority: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case notSet // = 0
    case low // = 1
    case medium // = 2
    case high // = 3
    case UNRECOGNIZED(Int)

    public init() {
      self = .notSet
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .notSet
      case 1: self = .low
      case 2: self = .medium
      case 3: self = .high
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .notSet: return 0
      case .low: return 1
      case .medium: return 2
      case .high: return 3
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

#if swift(>=4.2)

extension Clarifai_Api_Task.TaskType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Clarifai_Api_Task.TaskType] = [
    .typeNotSet,
    .conceptsClassification,
    .boundingBoxDetection,
    .polygonDetection,
  ]
}

extension Clarifai_Api_Task.TaskPriority: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Clarifai_Api_Task.TaskPriority] = [
    .notSet,
    .low,
    .medium,
    .high,
  ]
}

#endif  // swift(>=4.2)

/// AiAssistParameters
public struct Clarifai_Api_AiAssistParameters {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Min and max threshold values for approving annotations by default based on prediction score
  public var minThreshold: Float = 0

  public var maxThreshold: Float = 0

  /// ids of concept relations. Used in AI assist workflow
  public var conceptRelationIds: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// TaskWorker includes information about the workers that will work on this task.
public struct Clarifai_Api_TaskWorker {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Worker strategy.
  public var strategy: Clarifai_Api_TaskWorker.TaskWorkerStrategy = .workerStrategyNotSet

  /// Who will work on this task.
  /// DEPRECATED: Use workers.user.id instead.
  public var userIds: [String] = []

  /// Users who will work on this task.
  /// When the 'worker.users' field is additionally requested, then all user
  /// info is filled for the workers. Otherwise, only the user 'id' is filled.
  /// DEPRECATED: Use workers.user instead.
  public var users: [Clarifai_Api_User] = []

  /// Info based on the worker strategy,
  public var strategyInfo: Clarifai_Api_TaskWorker.OneOf_StrategyInfo? = nil

  public var partitionedStrategyInfo: Clarifai_Api_TaskWorkerPartitionedStrategyInfo {
    get {
      if case .partitionedStrategyInfo(let v)? = strategyInfo {return v}
      return Clarifai_Api_TaskWorkerPartitionedStrategyInfo()
    }
    set {strategyInfo = .partitionedStrategyInfo(newValue)}
  }

  /// Workers that will work on this task.
  ///
  /// For Auto Annotation Tasks:
  ///   the worker can be either a model or a workflow;
  ///   currently only supports 1 worker.
  /// For manual labeling Tasks:
  ///   the workers can only be users;
  ///   no limitation on number of workers.
  public var workers: [Clarifai_Api_Worker] = []

  /// Who is doing annotations - human Worker or auto-annotation via Model/Workflow.
  /// If set, worker must have be set accordingly to either human worker or model/workflow worker
  public var type: Clarifai_Api_TaskWorker.WorkerType = .notSet

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Info based on the worker strategy,
  public enum OneOf_StrategyInfo: Equatable {
    case partitionedStrategyInfo(Clarifai_Api_TaskWorkerPartitionedStrategyInfo)

  #if !swift(>=4.1)
    public static func ==(lhs: Clarifai_Api_TaskWorker.OneOf_StrategyInfo, rhs: Clarifai_Api_TaskWorker.OneOf_StrategyInfo) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.partitionedStrategyInfo, .partitionedStrategyInfo): return {
        guard case .partitionedStrategyInfo(let l) = lhs, case .partitionedStrategyInfo(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      }
    }
  #endif
  }

  public enum TaskWorkerStrategy: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case workerStrategyNotSet // = 0

    /// The inputs will be partitioned in several partitions.
    /// Each worker will label one or more input partitions.
    /// All inputs are assigned at task creation.
    case partitioned // = 2

    /// Each worker will label all inputs from input source.
    /// All inputs are assigned at task creation.
    case full // = 3

    /// Each worker will dynamically get 10 inputs assigned at a time.
    /// No inputs are assigned at task creation.
    case dynamic // = 4
    case UNRECOGNIZED(Int)

    public init() {
      self = .workerStrategyNotSet
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .workerStrategyNotSet
      case 2: self = .partitioned
      case 3: self = .full
      case 4: self = .dynamic
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .workerStrategyNotSet: return 0
      case .partitioned: return 2
      case .full: return 3
      case .dynamic: return 4
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public enum WorkerType: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// for backward compatibility when task is not setting any type and only sets workers
    case notSet // = 0

    /// only human workers
    case workerHuman // = 1

    /// auto-annotation tasks. Task must set worker as model or workflow
    case workerAuto // = 2
    case UNRECOGNIZED(Int)

    public init() {
      self = .notSet
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .notSet
      case 1: self = .workerHuman
      case 2: self = .workerAuto
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .notSet: return 0
      case .workerHuman: return 1
      case .workerAuto: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Clarifai_Api_TaskWorker.TaskWorkerStrategy: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Clarifai_Api_TaskWorker.TaskWorkerStrategy] = [
    .workerStrategyNotSet,
    .partitioned,
    .full,
    .dynamic,
  ]
}

extension Clarifai_Api_TaskWorker.WorkerType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Clarifai_Api_TaskWorker.WorkerType] = [
    .notSet,
    .workerHuman,
    .workerAuto,
  ]
}

#endif  // swift(>=4.2)

/// TaskWorkerPartitionedStrategyInfo
public struct Clarifai_Api_TaskWorkerPartitionedStrategyInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Define how the partitioning should work.
  public var type: Clarifai_Api_TaskWorkerPartitionedStrategyInfo.TaskWorkerPartitionedStrategy = .partitionedWorkerStrategyNotSet

  /// How many workers will label each input.
  public var workersPerInput: Int32 = 0

  /// In case of weighted partitioning, map user ids to weights.
  /// Each labeler will be assigned work proportional to its own weight as compared to the sum of total weight.
  ///
  /// EXAMPLE:
  /// If we have 3 workers, and weights = {1: 30, 2: 30, 3: 40},
  /// then first worker will have assigned 30% of the work,
  /// second worker will have assigned 30% of the work,
  /// and third worker will have assigned 40% of the work.
  /// You may use weights which add up to 100, but it's not necessary.
  /// For example, weights {1: 30, 2: 30, 3: 40} are equivalent with {1: 3, 2: 3, 3: 4}
  /// because they represent the same percentages: {1: 30%, 2: 30%, 3: 40%}.
  ///
  /// NOTE:
  /// Note that no worker should be assigned a weight percentage greater than 1/workers_per_input.
  /// It is mathematically impossible to partition the work in such a case.
  /// Why? Say, we have 3 workers. And workers_per_input = 2, i.e. each input must be labeled by 2 workers.
  /// Let's assign weights {1: 51%, 2: 25%, 3: 24%}.
  /// Note that first worker has a weight percentage higher than 1/workers_per_input = 1/2 = 50%.
  /// If we have 100 inputs, then a total of 100 * workers_per_input = 200 cumulative inputs will be labeled by these 3 workers.
  /// Worker 1 should label 102 cumulative inputs, while worker 2 and worker 3 will label 98 cumulative inputs together.
  /// No matter how we assign the 98 cumulative inputs, the 2 workers will be able to label up to 98 actual inputs.
  /// This means the remaining 2 inputs will be labeled only by worker 1. This contradicts the worker_per_input = 2 requirement.
  public var weights: SwiftProtobuf.Google_Protobuf_Struct {
    get {return _weights ?? SwiftProtobuf.Google_Protobuf_Struct()}
    set {_weights = newValue}
  }
  /// Returns true if `weights` has been explicitly set.
  public var hasWeights: Bool {return self._weights != nil}
  /// Clears the value of `weights`. Subsequent reads from it will return its default value.
  public mutating func clearWeights() {self._weights = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum TaskWorkerPartitionedStrategy: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case partitionedWorkerStrategyNotSet // = 0

    /// Each worker will label (approximately) the same number of inputs.
    case evenly // = 1

    /// Each worker will have an assigned weight.
    /// See weights field for more details.
    case weighted // = 2
    case UNRECOGNIZED(Int)

    public init() {
      self = .partitionedWorkerStrategyNotSet
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .partitionedWorkerStrategyNotSet
      case 1: self = .evenly
      case 2: self = .weighted
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .partitionedWorkerStrategyNotSet: return 0
      case .evenly: return 1
      case .weighted: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}

  fileprivate var _weights: SwiftProtobuf.Google_Protobuf_Struct? = nil
}

#if swift(>=4.2)

extension Clarifai_Api_TaskWorkerPartitionedStrategyInfo.TaskWorkerPartitionedStrategy: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Clarifai_Api_TaskWorkerPartitionedStrategyInfo.TaskWorkerPartitionedStrategy] = [
    .partitionedWorkerStrategyNotSet,
    .evenly,
    .weighted,
  ]
}

#endif  // swift(>=4.2)

/// TaskInputSource
public struct Clarifai_Api_TaskInputSource {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Type of input source.
  public var type: Clarifai_Api_TaskInputSource.TaskInputSourceType = .inputSourceTypeNotSet

  /// If type is SAVED_SEARCH, then this is the saved search id.
  public var id: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum TaskInputSourceType: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case inputSourceTypeNotSet // = 0

    /// Use all inputs in the app.
    case allInputs // = 1

    /// Use the inputs from a saved search.
    case savedSearch // = 2

    /// Inputs from a dataset.
    case dataset // = 3
    case UNRECOGNIZED(Int)

    public init() {
      self = .inputSourceTypeNotSet
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .inputSourceTypeNotSet
      case 1: self = .allInputs
      case 2: self = .savedSearch
      case 3: self = .dataset
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .inputSourceTypeNotSet: return 0
      case .allInputs: return 1
      case .savedSearch: return 2
      case .dataset: return 3
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Clarifai_Api_TaskInputSource.TaskInputSourceType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Clarifai_Api_TaskInputSource.TaskInputSourceType] = [
    .inputSourceTypeNotSet,
    .allInputs,
    .savedSearch,
    .dataset,
  ]
}

#endif  // swift(>=4.2)

/// TaskReview
public struct Clarifai_Api_TaskReview {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Task review strategy.
  public var strategy: Clarifai_Api_TaskReview.TaskReviewStrategy = .notSet

  /// Who will review this task.
  /// DEPRECATED: Use users.id instead.
  public var userIds: [String] = []

  /// Users who will review this task.
  /// When the 'review.users' field is additionally requested, then all user
  /// info is filled for the reviewers. Otherwise, only the user 'id' is filled.
  public var users: [Clarifai_Api_User] = []

  /// Info based on the review strategy,
  public var strategyInfo: Clarifai_Api_TaskReview.OneOf_StrategyInfo? = nil

  public var manualStrategyInfo: Clarifai_Api_TaskReviewManualStrategyInfo {
    get {
      if case .manualStrategyInfo(let v)? = strategyInfo {return v}
      return Clarifai_Api_TaskReviewManualStrategyInfo()
    }
    set {strategyInfo = .manualStrategyInfo(newValue)}
  }

  public var consensusStrategyInfo: Clarifai_Api_TaskReviewConsensusStrategyInfo {
    get {
      if case .consensusStrategyInfo(let v)? = strategyInfo {return v}
      return Clarifai_Api_TaskReviewConsensusStrategyInfo()
    }
    set {strategyInfo = .consensusStrategyInfo(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Info based on the review strategy,
  public enum OneOf_StrategyInfo: Equatable {
    case manualStrategyInfo(Clarifai_Api_TaskReviewManualStrategyInfo)
    case consensusStrategyInfo(Clarifai_Api_TaskReviewConsensusStrategyInfo)

  #if !swift(>=4.1)
    public static func ==(lhs: Clarifai_Api_TaskReview.OneOf_StrategyInfo, rhs: Clarifai_Api_TaskReview.OneOf_StrategyInfo) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.manualStrategyInfo, .manualStrategyInfo): return {
        guard case .manualStrategyInfo(let l) = lhs, case .manualStrategyInfo(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.consensusStrategyInfo, .consensusStrategyInfo): return {
        guard case .consensusStrategyInfo(let l) = lhs, case .consensusStrategyInfo(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public enum TaskReviewStrategy: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case notSet // = 0

    /// No review is needed.
    /// When a labeler labels an input, the annotations are immediately approved.
    case none // = 1

    /// Human reviewers will review the work done by labelers.
    case manual // = 2

    /// Automatically approve inputs when labelers reach consensus.
    /// If consensus is not reached, then it will fallback to human reviewers.
    case consensus // = 3
    case UNRECOGNIZED(Int)

    public init() {
      self = .notSet
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .notSet
      case 1: self = .none
      case 2: self = .manual
      case 3: self = .consensus
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .notSet: return 0
      case .none: return 1
      case .manual: return 2
      case .consensus: return 3
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Clarifai_Api_TaskReview.TaskReviewStrategy: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Clarifai_Api_TaskReview.TaskReviewStrategy] = [
    .notSet,
    .none,
    .manual,
    .consensus,
  ]
}

#endif  // swift(>=4.2)

/// TaskReviewManualStrategyInfo
public struct Clarifai_Api_TaskReviewManualStrategyInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// This field represents the percentage of inputs that will be reviewed by reviewers. It is a value between 0 and 1.
  public var samplePercentage: Float = 0

  /// Deprecated: Use consensus_strategy_info.approval_threshold_reviewers.
  public var approvalThreshold: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// TaskReviewConsensusStrategyInfo
public struct Clarifai_Api_TaskReviewConsensusStrategyInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Deprecated: Use approval_threshold_labelers.
  public var approvalThreshold: UInt32 = 0

  /// The number of labelers that need to agree in order to automatically approve an annotation.
  /// When 0, labelers consensus is disabled.
  /// When 1, the labels are automatically approved once a single labeler labels the input.
  /// When greater than 1, the labels are automatically approved when the specified number of labelers agree.
  /// If the number of labelers that agree is less than the specified number, then the input will reviewed by reviewers.
  public var approvalThresholdLabelers: UInt32 = 0

  /// The number of reviewers that need to agree in order to approve an input.
  /// Currently, the only allowed values are:
  /// 0  - when not set, it defaults to 1
  /// 1  - only a single reviewer needs to approve each labeled input
  /// -1 - an input will be approved when all reviewers approve it
  public var approvalThresholdReviewers: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// TaskAIAssistant
public struct Clarifai_Api_TaskAIAssistant {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The worker is helped by an AI assistant.
  /// This field is the workflow id which is used to assist the worker with predictions.
  /// If empty, then AI assistant is disabled.
  public var workflowID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Clarifai_Api_TaskAssignment {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: String {
    get {return _storage._id}
    set {_uniqueStorage()._id = newValue}
  }

  /// Creation time.
  /// The format is https://www.ietf.org/rfc/rfc3339.txt.
  /// Example: "2006-01-02T15:04:05.999999Z".
  public var createdAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._createdAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._createdAt = newValue}
  }
  /// Returns true if `createdAt` has been explicitly set.
  public var hasCreatedAt: Bool {return _storage._createdAt != nil}
  /// Clears the value of `createdAt`. Subsequent reads from it will return its default value.
  public mutating func clearCreatedAt() {_uniqueStorage()._createdAt = nil}

  /// Most recent modification time.
  /// The format is https://www.ietf.org/rfc/rfc3339.txt.
  /// Example: "2006-01-02T15:04:05.999999Z".
  public var modifiedAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._modifiedAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._modifiedAt = newValue}
  }
  /// Returns true if `modifiedAt` has been explicitly set.
  public var hasModifiedAt: Bool {return _storage._modifiedAt != nil}
  /// Clears the value of `modifiedAt`. Subsequent reads from it will return its default value.
  public mutating func clearModifiedAt() {_uniqueStorage()._modifiedAt = nil}

  /// Assigned worker.
  public var worker: Clarifai_Api_Worker {
    get {return _storage._worker ?? Clarifai_Api_Worker()}
    set {_uniqueStorage()._worker = newValue}
  }
  /// Returns true if `worker` has been explicitly set.
  public var hasWorker: Bool {return _storage._worker != nil}
  /// Clears the value of `worker`. Subsequent reads from it will return its default value.
  public mutating func clearWorker() {_uniqueStorage()._worker = nil}

  /// Assigned input.
  public var input: Clarifai_Api_Input {
    get {return _storage._input ?? Clarifai_Api_Input()}
    set {_uniqueStorage()._input = newValue}
  }
  /// Returns true if `input` has been explicitly set.
  public var hasInput: Bool {return _storage._input != nil}
  /// Clears the value of `input`. Subsequent reads from it will return its default value.
  public mutating func clearInput() {_uniqueStorage()._input = nil}

  /// Assignment status.
  /// Read as: This is the status of the work assigned to worker W, on input I in task T.
  public var status: Clarifai_Api_Status_Status {
    get {return _storage._status ?? Clarifai_Api_Status_Status()}
    set {_uniqueStorage()._status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  public var hasStatus: Bool {return _storage._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  public mutating func clearStatus() {_uniqueStorage()._status = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// TaskStatusCountPerUser can represent one of the following:
/// * count of task annotations created by a worker for each valid status,
/// * count of task inputs assigned to a worker  (i.e. task assignments) for each valid status
public struct Clarifai_Api_TaskStatusCountPerUser {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Deprecated: Use worker instead.
  public var userID: String = String()

  public var pending: UInt32 = 0

  public var awaitingReview: UInt32 = 0

  public var success: UInt32 = 0

  public var reviewDenied: UInt32 = 0

  public var awaitingConsensusReview: UInt32 = 0

  public var worker: Clarifai_Api_Worker {
    get {return _worker ?? Clarifai_Api_Worker()}
    set {_worker = newValue}
  }
  /// Returns true if `worker` has been explicitly set.
  public var hasWorker: Bool {return self._worker != nil}
  /// Clears the value of `worker`. Subsequent reads from it will return its default value.
  public mutating func clearWorker() {self._worker = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _worker: Clarifai_Api_Worker? = nil
}

public struct Clarifai_Api_ThresholdRange {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The range used to filter over concept values.
  /// e.g. GREATER_THAN_OR_EQUAL_TO 0.7 -> is_lower_inclusive = true, lower = 0.7, is_upper_inclusive = true, upper = 1.0
  /// e.g. (0.3, 0.75] -> is_lower_inclusive = false, lower = 0.3, is_upper_inclusive = true, upper = 0.75
  public var isLowerInclusive: Bool = false

  public var isUpperInclusive: Bool = false

  public var lower: Float = 0

  public var upper: Float = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Clarifai_Api_TaskConceptAutoAnnotationConfig {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Filter annotations by their annotation data type.
  /// This is a bit-mask field that holds multiple AnnotationDataType values that are combined in an OR fashion.
  /// Example: if annotation_data_types = 34, then we filter annotations that appear as a mask or a bounding box,
  /// because MASK = 32 and BOUNDING_BOX = 2.
  public var annotationDataTypes: UInt32 = 0

  /// Filter annotations by concept value.
  /// Only concepts that fit in the threshold will be used to generate annotations.
  public var thresholdRange: Clarifai_Api_ThresholdRange {
    get {return _thresholdRange ?? Clarifai_Api_ThresholdRange()}
    set {_thresholdRange = newValue}
  }
  /// Returns true if `thresholdRange` has been explicitly set.
  public var hasThresholdRange: Bool {return self._thresholdRange != nil}
  /// Clears the value of `thresholdRange`. Subsequent reads from it will return its default value.
  public mutating func clearThresholdRange() {self._thresholdRange = nil}

  /// The output annotations will be created using this status code.
  public var statusCode: Clarifai_Api_Status_StatusCode = .zero

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _thresholdRange: Clarifai_Api_ThresholdRange? = nil
}

public struct Clarifai_Api_TaskConcept {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// For auto annotation, id/name and value, user + app id must be specified. For other tasks, only the id field is required.
  public var concept: Clarifai_Api_Concept {
    get {return _concept ?? Clarifai_Api_Concept()}
    set {_concept = newValue}
  }
  /// Returns true if `concept` has been explicitly set.
  public var hasConcept: Bool {return self._concept != nil}
  /// Clears the value of `concept`. Subsequent reads from it will return its default value.
  public mutating func clearConcept() {self._concept = nil}

  public var autoAnnotationConfig: Clarifai_Api_TaskConceptAutoAnnotationConfig {
    get {return _autoAnnotationConfig ?? Clarifai_Api_TaskConceptAutoAnnotationConfig()}
    set {_autoAnnotationConfig = newValue}
  }
  /// Returns true if `autoAnnotationConfig` has been explicitly set.
  public var hasAutoAnnotationConfig: Bool {return self._autoAnnotationConfig != nil}
  /// Clears the value of `autoAnnotationConfig`. Subsequent reads from it will return its default value.
  public mutating func clearAutoAnnotationConfig() {self._autoAnnotationConfig = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _concept: Clarifai_Api_Concept? = nil
  fileprivate var _autoAnnotationConfig: Clarifai_Api_TaskConceptAutoAnnotationConfig? = nil
}

public struct Clarifai_Api_TaskMetrics {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var work: Clarifai_Api_TaskWorkMetrics {
    get {return _work ?? Clarifai_Api_TaskWorkMetrics()}
    set {_work = newValue}
  }
  /// Returns true if `work` has been explicitly set.
  public var hasWork: Bool {return self._work != nil}
  /// Clears the value of `work`. Subsequent reads from it will return its default value.
  public mutating func clearWork() {self._work = nil}

  public var review: Clarifai_Api_TaskReviewMetrics {
    get {return _review ?? Clarifai_Api_TaskReviewMetrics()}
    set {_review = newValue}
  }
  /// Returns true if `review` has been explicitly set.
  public var hasReview: Bool {return self._review != nil}
  /// Clears the value of `review`. Subsequent reads from it will return its default value.
  public mutating func clearReview() {self._review = nil}

  public var inputSource: Clarifai_Api_TaskInputSourceMetrics {
    get {return _inputSource ?? Clarifai_Api_TaskInputSourceMetrics()}
    set {_inputSource = newValue}
  }
  /// Returns true if `inputSource` has been explicitly set.
  public var hasInputSource: Bool {return self._inputSource != nil}
  /// Clears the value of `inputSource`. Subsequent reads from it will return its default value.
  public mutating func clearInputSource() {self._inputSource = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _work: Clarifai_Api_TaskWorkMetrics? = nil
  fileprivate var _review: Clarifai_Api_TaskReviewMetrics? = nil
  fileprivate var _inputSource: Clarifai_Api_TaskInputSourceMetrics? = nil
}

public struct Clarifai_Api_TaskWorkMetrics {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Estimated number of inputs that workers have worked on.
  public var inputsCountEstimated: UInt64 = 0

  /// Estimated percent of inputs that workers have worked on.
  /// This is a value between 0 and 100, where 0 = 0% and 100 = 100%.
  public var inputsPercentEstimated: UInt32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Clarifai_Api_TaskReviewMetrics {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Estimated number of fully reviewed inputs.
  /// An input is considered fully reviewed if it has been reviewed by all necessary reviewers.
  /// Example: if task has no review, then an input is considered fully reviewed right after it's labeled (as review is skipped).
  /// Example: if task has manual review with single-reviewer per input, then an input is considered fully reviewed when 1 reviewer has approved/rejected it.
  /// Example: if task has consensus review with 3 reviewers per input, then an input is considered fully reviewed when 3 reviewers have approved it or 1 reviewer has rejected it.
  public var inputsCountEstimated: UInt64 = 0

  /// Estimated percent of review work that was finished.
  /// This is a value between 0 and 100, where 0 = 0% and 100 = 100%.
  /// Calculated as inputs_count_estimated/task.metrics.input_source.inputs_count_estimated.
  /// As the counts are estimated, the percentage is also estimated.
  /// However, additional checks are made to ensure that 100% percentage is only returned when all inputs are reviewed - giving a guarantee that the 100% percentage is always accurate.
  public var inputsPercentEstimated: UInt32 = 0

  /// Estimated number of reviewed inputs per reviewer index.
  /// The reviewer indexes are based on task.review.users.
  /// An input is considered reviewed by a reviewer if:
  /// * the reviewer approved the input
  /// * the reviewer rejected the input
  /// Note that when a reviewer requests changes for an input, the input is sent to back to work again, so the whole work & review process is restarted.
  /// The reviewer will have to review the input again after work has been completed.
  /// As such, the review that requests changes for an input is immediately dis-regarded and not counted in this metric.
  public var inputsCountEstimatedPerReviewer: [UInt64] = []

  /// The number of inputs actually available for review for each reviewer.
  /// Most times, this equals task.metrics.input_source.inputs_count_estimated.
  /// Several situations may result in different values:
  /// * When task has no review, then this is 0 for each reviewer.
  /// * When task has auto-annotation, then this number equals the inputs that have been auto-annotated with AWAITING_REVIEW status. All other inputs are considered completed by the auto-annotation process.
  /// * When task has consensus review with approval_threshold_labelers > 0, then it's possible that labelers will approve inputs through consensus, which skips review. In this case, the number of inputs available for review is less than task.metrics.input_source.inputs_count_estimated.
  /// * When task has consensus review with approval_threshold_reviewers = 1, then all inputs are assigned only to one reviewer, so each reviewer will get only a part of the inputs to review. It's expected that the sum(inputs_reviewable_count_estimated) = task.metrics.input_source.inputs_count_estimated.
  /// * When task has consensus review with approval_threshold_reviewers = -1, then all inputs are assigned to all reviewers. However, if an input is rejected, then rejection is final and all other reviewers will not review it. In this case, the number of inputs available for review for other reviewers will be less than task.metrics.input_source.inputs_count_estimated.
  public var inputsReviewableCountEstimatedPerReviewer: [UInt64] = []

  /// Estimated percent of review work that was finished per reviewer.
  /// This is a value between 0 and 100, where 0 = 0% and 100 = 100%.
  /// Calculated as inputs_count_estimated_per_reviewer/inputs_reviewable_count_estimated_per_reviewer.
  /// As the counts are estimated, the percentage is also estimated.
  /// However, additional checks are made to ensure that 100% percentage is only returned when all inputs are reviewed - giving a guarantee that the 100% percentage is always accurate.
  public var inputsPercentEstimatedPerReviewer: [UInt32] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Clarifai_Api_TaskInputSourceMetrics {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Estimated number of inputs that are in the source of data
  public var inputsCountEstimated: UInt64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Role represents a list of permissions
public struct Clarifai_Api_Role {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: String = String()

  /// When the role was created.
  /// The format is https://www.ietf.org/rfc/rfc3339.txt.
  /// Example: "2006-01-02T15:04:05.999999Z".
  public var createdAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _createdAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_createdAt = newValue}
  }
  /// Returns true if `createdAt` has been explicitly set.
  public var hasCreatedAt: Bool {return self._createdAt != nil}
  /// Clears the value of `createdAt`. Subsequent reads from it will return its default value.
  public mutating func clearCreatedAt() {self._createdAt = nil}

  /// Most recent time when the role was updated.
  /// The format is https://www.ietf.org/rfc/rfc3339.txt.
  /// Example: "2006-01-02T15:04:05.999999Z".
  public var modifiedAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _modifiedAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_modifiedAt = newValue}
  }
  /// Returns true if `modifiedAt` has been explicitly set.
  public var hasModifiedAt: Bool {return self._modifiedAt != nil}
  /// Clears the value of `modifiedAt`. Subsequent reads from it will return its default value.
  public mutating func clearModifiedAt() {self._modifiedAt = nil}

  public var name: String = String()

  public var description_p: String = String()

  /// The low-level scopes this role has
  public var scopes: [String] = []

  /// The endpoint-level scopes this role has
  public var endpoints: [String] = []

  /// Type of the role 'team' or 'org'
  public var type: Clarifai_Api_RoleType = .team

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _createdAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _modifiedAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

/// Represents a group of users.
public struct Clarifai_Api_Team {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Identify the team (unique).
  public var id: String = String()

  /// When the team was created.
  /// The format is https://www.ietf.org/rfc/rfc3339.txt.
  /// Example: "2006-01-02T15:04:05.999999Z".
  public var createdAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _createdAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_createdAt = newValue}
  }
  /// Returns true if `createdAt` has been explicitly set.
  public var hasCreatedAt: Bool {return self._createdAt != nil}
  /// Clears the value of `createdAt`. Subsequent reads from it will return its default value.
  public mutating func clearCreatedAt() {self._createdAt = nil}

  /// Most recent time when the team was updated.
  /// The format is https://www.ietf.org/rfc/rfc3339.txt.
  /// Example: "2006-01-02T15:04:05.999999Z".
  public var modifiedAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _modifiedAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_modifiedAt = newValue}
  }
  /// Returns true if `modifiedAt` has been explicitly set.
  public var hasModifiedAt: Bool {return self._modifiedAt != nil}
  /// Clears the value of `modifiedAt`. Subsequent reads from it will return its default value.
  public mutating func clearModifiedAt() {self._modifiedAt = nil}

  /// Name the team.
  public var name: String = String()

  /// When a new application is assigned to the team without an explicit role, then the default role will be used
  public var defaultRoleID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _createdAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _modifiedAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

/// Collector is a data pathway from a CollectorSource to an app to collect data automatically.
/// For example, a CollectorSource
public struct Clarifai_Api_Collector {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Unique ID for the collector.
  public var id: String {
    get {return _storage._id}
    set {_uniqueStorage()._id = newValue}
  }

  /// Human readable description for the collector.
  public var description_p: String {
    get {return _storage._description_p}
    set {_uniqueStorage()._description_p = newValue}
  }

  /// When the collector is created. We follow the XXXX timestamp
  /// format. We use https://www.ietf.org/rfc/rfc3339.txt format:
  /// "2006-01-02T15:04:05.999999Z" so you can expect results like
  /// the following from the API:
  /// "2017-04-11T21:50:50.223962Z"
  public var createdAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._createdAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._createdAt = newValue}
  }
  /// Returns true if `createdAt` has been explicitly set.
  public var hasCreatedAt: Bool {return _storage._createdAt != nil}
  /// Clears the value of `createdAt`. Subsequent reads from it will return its default value.
  public mutating func clearCreatedAt() {_uniqueStorage()._createdAt = nil}

  /// This is a workflow to run inline in model predict calls. It should ONLY have very fast and
  /// light-weight models in it as it will effect the speed of the predictions being made.
  /// This workflow's purpose is to filter down the inputs to queue for the collector to process.
  /// The input to this workflow is going to be the OUTPUT of the model, not the input to the model
  /// since we want to encourage having fast workflows that can also take advantage of the model
  /// outputs to make deciions (for example: thresholding based on concepts). If the workflow
  /// output has any field that is non-empty then the input will be queued for the collector
  /// to process with the post_queue_workflow_id.
  ///
  /// As a simpler alternative, pre_queue_random_sample can be set to just use random sampling instead.
  public var preQueueWorkflowID: String {
    get {return _storage._preQueueWorkflowID}
    set {_uniqueStorage()._preQueueWorkflowID = newValue}
  }

  /// Instead of needing to create a new workflow for pre_queue_workflow_id, if just random sampling
  /// of the model inputs is required, then pre_queue_random_sample can be set to a value from (0-1]
  /// to denote the fraction of inputs to collect.
  public var preQueueRandomSample: Float {
    get {return _storage._preQueueRandomSample}
    set {_uniqueStorage()._preQueueRandomSample = newValue}
  }

  /// A workflow to run to after the collector is processing the queued input. This workflow
  /// uses the original input to the model as input to the workflow so that you can run additional
  /// models as well on that input to decide whether to queue the model or not. If the workflow
  /// output has any field that is non-empty then it will be passed on to POST /inputs to
  /// the destination app.
  public var postQueueWorkflowID: String {
    get {return _storage._postQueueWorkflowID}
    set {_uniqueStorage()._postQueueWorkflowID = newValue}
  }

  /// The source of the collector to feed data into this app.
  /// Note(zeiler): if we wanted more than one source per collector we could make this it's own
  /// object and introduce /collectors/{collector_id}/sources
  /// We will keep it simple for now and have just one source per collector since a user can make
  /// more than one collector in the same app anyways.
  public var collectorSource: Clarifai_Api_CollectorSource {
    get {return _storage._collectorSource ?? Clarifai_Api_CollectorSource()}
    set {_uniqueStorage()._collectorSource = newValue}
  }
  /// Returns true if `collectorSource` has been explicitly set.
  public var hasCollectorSource: Bool {return _storage._collectorSource != nil}
  /// Clears the value of `collectorSource`. Subsequent reads from it will return its default value.
  public mutating func clearCollectorSource() {_uniqueStorage()._collectorSource = nil}

  /// Status for the collector. This allows you to pause a collector without having to delete it as
  /// an example.
  public var status: Clarifai_Api_Status_Status {
    get {return _storage._status ?? Clarifai_Api_Status_Status()}
    set {_uniqueStorage()._status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  public var hasStatus: Bool {return _storage._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  public mutating func clearStatus() {_uniqueStorage()._status = nil}

  /// Whether to collect outputs or not. Default is false. If selected, outputs from the
  /// original model predict call will be posted as annotations along with the input with success status.
  public var collectOutputs: Bool {
    get {return _storage._collectOutputs}
    set {_uniqueStorage()._collectOutputs = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Configuration for the source to collect data from.
/// Only one of the fields can be present at a time.
public struct Clarifai_Api_CollectorSource {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Collect from the inputs passed in for PostModelOutputs predictions of a specific model.
  /// This does not apply to models used within workflows, only PostModelOutputs calls.
  public var apiPostModelOutputsCollectorSource: Clarifai_Api_APIPostModelOutputsCollectorSource {
    get {return _apiPostModelOutputsCollectorSource ?? Clarifai_Api_APIPostModelOutputsCollectorSource()}
    set {_apiPostModelOutputsCollectorSource = newValue}
  }
  /// Returns true if `apiPostModelOutputsCollectorSource` has been explicitly set.
  public var hasApiPostModelOutputsCollectorSource: Bool {return self._apiPostModelOutputsCollectorSource != nil}
  /// Clears the value of `apiPostModelOutputsCollectorSource`. Subsequent reads from it will return its default value.
  public mutating func clearApiPostModelOutputsCollectorSource() {self._apiPostModelOutputsCollectorSource = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _apiPostModelOutputsCollectorSource: Clarifai_Api_APIPostModelOutputsCollectorSource? = nil
}

/// This is configuration for using the inputs send for model prediction in our API as
/// as the source for data.
public struct Clarifai_Api_APIPostModelOutputsCollectorSource {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// To define the model that we should collect from we need to specify the following 4 IDs:
  /// The User ID of the model we want to collect from.
  /// This is User B in the example.
  public var modelUserID: String = String()

  /// The App ID of the model we want to collect from.
  public var modelAppID: String = String()

  /// The Model ID of the model we want to collect from.
  public var modelID: String = String()

  /// The Version ID of the model we want to collect from.
  public var modelVersionID: String = String()

  /// This key is used to POST /inputs into your app by the collector. It can be an API key or a
  /// PAT. This needs the permissions that are needed for POST /inputs for the app_id this
  /// Collector is defined in.
  public var postInputsKeyID: String = String()

  /// This is a private field that defaults to the app owner for public users.
  /// If this is left blank then this collector will collect from ALL users calling the given model.
  public var callerUserID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// StatValue
public struct Clarifai_Api_StatValue {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The time of the event. Defaults to now().
  public var time: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _time ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_time = newValue}
  }
  /// Returns true if `time` has been explicitly set.
  public var hasTime: Bool {return self._time != nil}
  /// Clears the value of `time`. Subsequent reads from it will return its default value.
  public mutating func clearTime() {self._time = nil}

  /// A value for the metric you're recording.
  public var value: Float = 0

  /// List of tags to attach to this stat. Each should contain one colon so that the first part will
  /// be used as a tag group while the second being the tag itself. For example: ["task_id:a",
  /// "worker_id:1"]. These tag groups like "task_id" or "worker_id" are important for aggregating
  /// values in the StatValueAggregateQuery.
  public var tags: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _time: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

/// StatValueAggregateResult
public struct Clarifai_Api_StatValueAggregateResult {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The list of repeated aggregate values and their counts.
  public var statValueAggregates: [Clarifai_Api_StatValueAggregate] = []

  /// The query that created these results.
  public var statValueAggregateQuery: Clarifai_Api_StatValueAggregateQuery {
    get {return _statValueAggregateQuery ?? Clarifai_Api_StatValueAggregateQuery()}
    set {_statValueAggregateQuery = newValue}
  }
  /// Returns true if `statValueAggregateQuery` has been explicitly set.
  public var hasStatValueAggregateQuery: Bool {return self._statValueAggregateQuery != nil}
  /// Clears the value of `statValueAggregateQuery`. Subsequent reads from it will return its default value.
  public mutating func clearStatValueAggregateQuery() {self._statValueAggregateQuery = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _statValueAggregateQuery: Clarifai_Api_StatValueAggregateQuery? = nil
}

/// StatValueAggregate
public struct Clarifai_Api_StatValueAggregate {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The time of the aggregation. For example, if you aggregate over "HOUR" buckets then you can
  /// expect each hour that has atleast one value (matching the rest of your query fields) will have
  /// a StatValueAggregate with the time filled into that hour.
  public var time: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _time ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_time = newValue}
  }
  /// Returns true if `time` has been explicitly set.
  public var hasTime: Bool {return self._time != nil}
  /// Clears the value of `time`. Subsequent reads from it will return its default value.
  public mutating func clearTime() {self._time = nil}

  /// The value aggregated according to the stat_value_agg_type
  public var aggregateValue: Float = 0

  /// The count of the stat values that were used in this aggregation.
  public var count: UInt64 = 0

  /// The tags for this aggregated_value and count. This will be filled in if tag groups were used in
  /// the query to group aggregations.
  public var tags: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _time: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

/// StatValueAggregateQuery
public struct Clarifai_Api_StatValueAggregateQuery {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// These tags are used to filter down the values before they are aggregated. For example,
  /// if you want to aggregate values for "task_id:a" you could specify that as a tag here.
  public var tags: [String] = []

  /// These are tag groups to aggregate over. So for example if you added stat values with tags
  /// "task_id:a" and others with "task_id:b", then added ["task_id"] to the task group, it the
  /// aggregation would return StatValueAggregate values for each task_id. If you provide more than
  /// one tag_group the response will return all rolled up combinations of them. For example
  /// ["task_id", "something"] where "something:1" and "something:2" were used as tags for some
  /// values then you'd get StatValueAggregate values back for:
  /// task_id | something
  /// a       | 1
  /// a       | 2
  /// b       | 1
  /// b       | 1
  public var tagGroups: [String] = []

  /// Aggregation function to use over the values. Count(value) is also always returns.
  /// Defaults to 'sum' if not provided.
  public var statValueAggType: Clarifai_Api_StatValueAggType = .sum

  /// Aggregation bins for time where the values will be aggregated at this bin granualarity.
  /// And the "time" field will be returned in StatValueAggregate object.
  /// If not provided then bins are not used, and all time is aggregated over.
  public var statTimeAggType: Clarifai_Api_StatTimeAggType = .noTimeAgg

  /// If provided the time range over which values will be >= this time. If not provided then
  /// all values will be used back to start of time.
  public var startTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _startTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_startTime = newValue}
  }
  /// Returns true if `startTime` has been explicitly set.
  public var hasStartTime: Bool {return self._startTime != nil}
  /// Clears the value of `startTime`. Subsequent reads from it will return its default value.
  public mutating func clearStartTime() {self._startTime = nil}

  /// If provided the time range over which values will be <= this time. If not provided then all
  /// values will be used up until now().
  public var endTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _endTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_endTime = newValue}
  }
  /// Returns true if `endTime` has been explicitly set.
  public var hasEndTime: Bool {return self._endTime != nil}
  /// Clears the value of `endTime`. Subsequent reads from it will return its default value.
  public mutating func clearEndTime() {self._endTime = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _startTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _endTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

/// PCAProjectionComparator
public struct Clarifai_Api_PCAProjectionComparator {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Within what distance do we consider two annotations duplicates
  public var distanceThreshold: Float = 0

  /// What cluster model version generated these
  public var modelVersionID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// DuplicateAnnotationsResults
public struct Clarifai_Api_DuplicateAnnotationsResults {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var duplicateCfid: [String] = []

  public var uniqueCount: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Visibility represents how visible the given resource is to other users.
/// When authenticating a request we can tell if a user is a collaborator or a teammate for the
/// the app that contains the resource and set their allowed visibility. We use that to restrict
/// what they are allowed to see:
/// If AllowedVisibility is PRIVATE then we allow PRIVATE (10), ORG (30), PUBLIC (50)
/// If AllowedVisibility is ORG then we allow ORG (30), PUBLIC (50)
/// If AllowedVisibility is PUBLIC then we allow PUBLIC (50) only.
public struct Clarifai_Api_Visibility {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var gettable: Clarifai_Api_Visibility.Gettable = .unknownVisibility

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Gettable defined the level of access for GET operations for this resource.
  public enum Gettable: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// Default value not allowed.
    case unknownVisibility // = 0

    /// PRIVATE requires collaborator or team permissions in order to GET this resource.
    case `private` // = 10

    /// ORG requires you to be in the same org in order to GET this resource, but don't have to be a
    /// teammate or collaborator.
    case org // = 30

    /// PUBLIC opens up GET access to the resource to any user on the platform even if they are not
    /// a teammate or collaborator.
    case `public` // = 50
    case UNRECOGNIZED(Int)

    public init() {
      self = .unknownVisibility
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknownVisibility
      case 10: self = .private
      case 30: self = .org
      case 50: self = .public
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unknownVisibility: return 0
      case .private: return 10
      case .org: return 30
      case .public: return 50
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Clarifai_Api_Visibility.Gettable: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Clarifai_Api_Visibility.Gettable] = [
    .unknownVisibility,
    .private,
    .org,
    .public,
  ]
}

#endif  // swift(>=4.2)

public struct Clarifai_Api_FullTag {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Display name of the tag. Ex. "English"
  public var name: String = String()

  /// Id value for referencing. Ex. "en"
  public var id: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// TimeSegment
public struct Clarifai_Api_TimeSegment {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// A unique id for the time segment.
  public var id: String = String()

  public var data: Clarifai_Api_Data {
    get {return _data ?? Clarifai_Api_Data()}
    set {_data = newValue}
  }
  /// Returns true if `data` has been explicitly set.
  public var hasData: Bool {return self._data != nil}
  /// Clears the value of `data`. Subsequent reads from it will return its default value.
  public mutating func clearData() {self._data = nil}

  public var timeInfo: Clarifai_Api_TimeInfo {
    get {return _timeInfo ?? Clarifai_Api_TimeInfo()}
    set {_timeInfo = newValue}
  }
  /// Returns true if `timeInfo` has been explicitly set.
  public var hasTimeInfo: Bool {return self._timeInfo != nil}
  /// Clears the value of `timeInfo`. Subsequent reads from it will return its default value.
  public mutating func clearTimeInfo() {self._timeInfo = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _data: Clarifai_Api_Data? = nil
  fileprivate var _timeInfo: Clarifai_Api_TimeInfo? = nil
}

/// TimeInfo
public struct Clarifai_Api_TimeInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Number of frames
  public var numFrames: UInt32 = 0

  /// Timestamp where track begins.
  public var beginTime: Float = 0

  /// Timestamp where track ends.
  public var endTime: Float = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// DatasetStar
public struct Clarifai_Api_DatasetStar {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var datasetID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// ModuleStar
public struct Clarifai_Api_ModuleStar {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Module id of the star
  public var moduleID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// An app module that a user created in our app module marketplace.
public struct Clarifai_Api_Module {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// A unique ID for this app module.
  public var id: String {
    get {return _storage._id}
    set {_uniqueStorage()._id = newValue}
  }

  /// A short description for this app module to be used in grids of modules.
  public var description_p: String {
    get {return _storage._description_p}
    set {_uniqueStorage()._description_p = newValue}
  }

  /// When the app module was created.
  public var createdAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._createdAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._createdAt = newValue}
  }
  /// Returns true if `createdAt` has been explicitly set.
  public var hasCreatedAt: Bool {return _storage._createdAt != nil}
  /// Clears the value of `createdAt`. Subsequent reads from it will return its default value.
  public mutating func clearCreatedAt() {_uniqueStorage()._createdAt = nil}

  /// When the app module was last modified.
  public var modifiedAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._modifiedAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._modifiedAt = newValue}
  }
  /// Returns true if `modifiedAt` has been explicitly set.
  public var hasModifiedAt: Bool {return _storage._modifiedAt != nil}
  /// Clears the value of `modifiedAt`. Subsequent reads from it will return its default value.
  public mutating func clearModifiedAt() {_uniqueStorage()._modifiedAt = nil}

  /// The visibility field represents whether this message is privately/publicly visible.
  /// To be visible to the public the App that contains it AND the User that contains the App must
  /// also be publicly visible.
  /// Defaults to PRIVATE if not provided.
  public var visibility: Clarifai_Api_Visibility {
    get {return _storage._visibility ?? Clarifai_Api_Visibility()}
    set {_uniqueStorage()._visibility = newValue}
  }
  /// Returns true if `visibility` has been explicitly set.
  public var hasVisibility: Bool {return _storage._visibility != nil}
  /// Clears the value of `visibility`. Subsequent reads from it will return its default value.
  public mutating func clearVisibility() {_uniqueStorage()._visibility = nil}

  /// To handle arbitrary json metadata you can use a struct field:
  /// https://github.com/google/protobuf/blob/master/src/google/protobuf/struct.proto
  /// This is an optional arg.
  public var metadata: SwiftProtobuf.Google_Protobuf_Struct {
    get {return _storage._metadata ?? SwiftProtobuf.Google_Protobuf_Struct()}
    set {_uniqueStorage()._metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  public var hasMetadata: Bool {return _storage._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  public mutating func clearMetadata() {_uniqueStorage()._metadata = nil}

  /// The creator of the app module.
  public var userID: String {
    get {return _storage._userID}
    set {_uniqueStorage()._userID = newValue}
  }

  /// The app_id this module was created in.
  public var appID: String {
    get {return _storage._appID}
    set {_uniqueStorage()._appID = newValue}
  }

  /// A ModuleVersion which is used when listing modules to include the latest module version
  /// in the response.
  public var moduleVersion: Clarifai_Api_ModuleVersion {
    get {return _storage._moduleVersion ?? Clarifai_Api_ModuleVersion()}
    set {_uniqueStorage()._moduleVersion = newValue}
  }
  /// Returns true if `moduleVersion` has been explicitly set.
  public var hasModuleVersion: Bool {return _storage._moduleVersion != nil}
  /// Clears the value of `moduleVersion`. Subsequent reads from it will return its default value.
  public mutating func clearModuleVersion() {_uniqueStorage()._moduleVersion = nil}

  /// Is starred by the requesting user (only showed on get/list requests)
  /// Please use PostModuleStars/DeleteModuleStars endpoints to star/unstar a module
  public var isStarred: Bool {
    get {return _storage._isStarred}
    set {_uniqueStorage()._isStarred = newValue}
  }

  /// How many users have starred the module (only showed on get/list requests)
  /// Computed value, not editable
  public var starCount: Int32 {
    get {return _storage._starCount}
    set {_uniqueStorage()._starCount = newValue}
  }

  /// bookmark info. When set, this module is a bookmarked module of this app.
  /// Info in this field will allow you to find/access original module.
  public var bookmarkOrigin: Clarifai_Api_BookmarkOrigin {
    get {return _storage._bookmarkOrigin ?? Clarifai_Api_BookmarkOrigin()}
    set {_uniqueStorage()._bookmarkOrigin = newValue}
  }
  /// Returns true if `bookmarkOrigin` has been explicitly set.
  public var hasBookmarkOrigin: Bool {return _storage._bookmarkOrigin != nil}
  /// Clears the value of `bookmarkOrigin`. Subsequent reads from it will return its default value.
  public mutating func clearBookmarkOrigin() {_uniqueStorage()._bookmarkOrigin = nil}

  /// Representative image for this module
  public var image: Clarifai_Api_Image {
    get {return _storage._image ?? Clarifai_Api_Image()}
    set {_uniqueStorage()._image = newValue}
  }
  /// Returns true if `image` has been explicitly set.
  public var hasImage: Bool {return _storage._image != nil}
  /// Clears the value of `image`. Subsequent reads from it will return its default value.
  public mutating func clearImage() {_uniqueStorage()._image = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// A specific version of an app module that is available for assigning to apps.
public struct Clarifai_Api_ModuleVersion {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// A name for this version like 1_0, 1_1_0, etc.
  public var id: String = String()

  /// The module this version belongs to.
  public var moduleID: String = String()

  /// The app_id this module version belongs to.
  public var appID: String = String()

  /// The user_id this module version belongs to.
  public var userID: String = String()

  /// A short description for this version.
  public var description_p: String = String()

  /// A markdown formatted string to detailed description of the app module.
  /// This is within each version so that it can be change version to version.
  public var notes: String = String()

  /// When the app module version was created.
  public var createdAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _createdAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_createdAt = newValue}
  }
  /// Returns true if `createdAt` has been explicitly set.
  public var hasCreatedAt: Bool {return self._createdAt != nil}
  /// Clears the value of `createdAt`. Subsequent reads from it will return its default value.
  public mutating func clearCreatedAt() {self._createdAt = nil}

  /// When the app module version was last modified.
  public var modifiedAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _modifiedAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_modifiedAt = newValue}
  }
  /// Returns true if `modifiedAt` has been explicitly set.
  public var hasModifiedAt: Bool {return self._modifiedAt != nil}
  /// Clears the value of `modifiedAt`. Subsequent reads from it will return its default value.
  public mutating func clearModifiedAt() {self._modifiedAt = nil}

  /// The code repo of the streamlit app.
  /// If you are still developing your Module you should create a ModuleVersion
  /// with an empty git_commit_url and then create an InstalledModuleVersion
  /// with a pre-deployed deploy_url (such as localhost or streamlit cloud).
  /// Once you are ready to create a production, create a new ModuleVersion with
  /// the ready git url to a specific commit that you would like to be reviewed by the
  /// Clarifai team for approval within our community. You cannot publish a ModuleVersion
  /// is reviewed and approved. Please only provide the git_commit_url when you're
  /// ready for a review. This url needs to include a specific commit, for example:
  /// https://github.com/user/repo/commit/767ff9c08ba3429c8e7b8825da148555
  public var gitCommitURL: String = String()

  public var moduleNav: Clarifai_Api_ModuleVersion.ModuleNav {
    get {return _moduleNav ?? Clarifai_Api_ModuleVersion.ModuleNav()}
    set {_moduleNav = newValue}
  }
  /// Returns true if `moduleNav` has been explicitly set.
  public var hasModuleNav: Bool {return self._moduleNav != nil}
  /// Clears the value of `moduleNav`. Subsequent reads from it will return its default value.
  public mutating func clearModuleNav() {self._moduleNav = nil}

  /// A boolean to mark if Clarifai has approved this app version.
  /// This cannot be set in the request to True.
  public var approved: Bool = false

  /// The visibility field represents whether this message is privately/publicly visible.
  /// To be visible to the public the App that contains it AND the User that contains the App must
  /// also be publicly visible.
  /// Defaults to PRIVATE if not provided.
  public var visibility: Clarifai_Api_Visibility {
    get {return _visibility ?? Clarifai_Api_Visibility()}
    set {_visibility = newValue}
  }
  /// Returns true if `visibility` has been explicitly set.
  public var hasVisibility: Bool {return self._visibility != nil}
  /// Clears the value of `visibility`. Subsequent reads from it will return its default value.
  public mutating func clearVisibility() {self._visibility = nil}

  /// To handle arbitrary json metadata you can use a struct field:
  /// https://github.com/google/protobuf/blob/master/src/google/protobuf/struct.proto
  /// This is an optional arg.
  public var metadata: SwiftProtobuf.Google_Protobuf_Struct {
    get {return _metadata ?? SwiftProtobuf.Google_Protobuf_Struct()}
    set {_metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  public var hasMetadata: Bool {return self._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  public mutating func clearMetadata() {self._metadata = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public struct ModuleSubNav {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// This is the display title for a navbar element to link to a specific page.
    /// The name for this subnav element to show in the sidebar.
    public var title: String = String()

    /// The query param name
    public var queryKey: String = String()

    /// The query param value
    public var queryValue: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public struct ModuleNav {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// This is the left side title for this module and for browser tab title of the module.
    /// We have this in the version so that users can change those settings
    /// when releasing a new version of their module.
    public var title: String = String()

    /// A list of subnav elements to put under the module title.
    public var moduleSubNavs: [Clarifai_Api_ModuleVersion.ModuleSubNav] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}

  fileprivate var _createdAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _modifiedAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _moduleNav: Clarifai_Api_ModuleVersion.ModuleNav? = nil
  fileprivate var _visibility: Clarifai_Api_Visibility? = nil
  fileprivate var _metadata: SwiftProtobuf.Google_Protobuf_Struct? = nil
}

public struct Clarifai_Api_InstalledModuleVersion {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// A unique id for this install. This will be used in the browser url.
  public var id: String {
    get {return _storage._id}
    set {_uniqueStorage()._id = newValue}
  }

  /// The installed module version provided here so that we users don't need to do an additional
  /// fetch. When creating a new InstalledModuleVersion you should provide the:
  /// module_version.user_id
  /// module_version.app_id
  /// module_version.module_id
  /// module_version.id
  /// in order to uniquely define which module version.
  public var moduleVersion: Clarifai_Api_ModuleVersion {
    get {return _storage._moduleVersion ?? Clarifai_Api_ModuleVersion()}
    set {_uniqueStorage()._moduleVersion = newValue}
  }
  /// Returns true if `moduleVersion` has been explicitly set.
  public var hasModuleVersion: Bool {return _storage._moduleVersion != nil}
  /// Clears the value of `moduleVersion`. Subsequent reads from it will return its default value.
  public mutating func clearModuleVersion() {_uniqueStorage()._moduleVersion = nil}

  /// The app_id the ModuleVersion is installed into (not necessary where the ModuleVersion was
  /// created). This doesn't have to be provided in requests to install, but will be returned in
  /// responses.
  public var appID: String {
    get {return _storage._appID}
    set {_uniqueStorage()._appID = newValue}
  }

  /// The user that the app belongs to where the ModuleVersion is installed into (not necessary where
  /// the ModuleVersion was created). This doesn't have to be provided in requests to install, but
  /// will be returned in responses.
  public var userID: String {
    get {return _storage._userID}
    set {_uniqueStorage()._userID = newValue}
  }

  /// When the install was created.
  public var createdAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._createdAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._createdAt = newValue}
  }
  /// Returns true if `createdAt` has been explicitly set.
  public var hasCreatedAt: Bool {return _storage._createdAt != nil}
  /// Clears the value of `createdAt`. Subsequent reads from it will return its default value.
  public mutating func clearCreatedAt() {_uniqueStorage()._createdAt = nil}

  /// When the install was last modified.
  public var modifiedAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._modifiedAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._modifiedAt = newValue}
  }
  /// Returns true if `modifiedAt` has been explicitly set.
  public var hasModifiedAt: Bool {return _storage._modifiedAt != nil}
  /// Clears the value of `modifiedAt`. Subsequent reads from it will return its default value.
  public mutating func clearModifiedAt() {_uniqueStorage()._modifiedAt = nil}

  /// The URL of where this app module version is deployed.
  /// If you provide this deploy_url when creating the install then it will
  /// be treated as a pre-deployed module. You can only use a pre-deployed module
  /// in when installing to an app_id that you own as the creator of the module.
  /// If you want to install someone elses module or to rely on Clarifai deploying
  /// your module for you, leave deploy_url empty when creating the install.
  /// If it is left empty, then deployment will occur when this module version is
  /// installed into an app using the git_commit_url of the ModuleVersion.
  public var deployURL: String {
    get {return _storage._deployURL}
    set {_uniqueStorage()._deployURL = newValue}
  }

  /// The visibility field represents whether this message is privately/publicly visible.
  /// To be visible to the public the App that contains it AND the User that contains the App must
  /// also be publicly visible. For the InstalledModuleVersion this allows the app owner who
  /// installed the module version to decide if they want other users of their app to have
  /// the added functionality that the modules version provides to their app.
  /// Defaults to PRIVATE if not provided.
  public var visibility: Clarifai_Api_Visibility {
    get {return _storage._visibility ?? Clarifai_Api_Visibility()}
    set {_uniqueStorage()._visibility = newValue}
  }
  /// Returns true if `visibility` has been explicitly set.
  public var hasVisibility: Bool {return _storage._visibility != nil}
  /// Clears the value of `visibility`. Subsequent reads from it will return its default value.
  public mutating func clearVisibility() {_uniqueStorage()._visibility = nil}

  /// The key ID to use for making requests to the API for this module.
  /// This key is associated to this installed module version by PostInstalledModuleVersionsKey
  /// request. The key is associated with the CALLER not the App Owner where this module is installed
  /// nor the author of the module. This allows the module to act on behalf of the caller at all
  /// times so we get proper permissions the caller has (such as if they are stranger, teammate or
  /// collaborator). This key should be a personal access token to enable modules to work across apps
  /// and have necessary abilities beyond what app-specific keys offer.
  public var keyID: String {
    get {return _storage._keyID}
    set {_uniqueStorage()._keyID = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Clarifai_Api_BulkOperation {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// id of the Bulk Operation task
  public var id: String {
    get {return _storage._id}
    set {_uniqueStorage()._id = newValue}
  }

  /// Input Source could be list of input ids or a Search whose results will be a list of input ids.
  /// InputIDs:
  ///      List of input ids to which operation to be applied
  /// clarifai.api.Search:
  ///      A Search(either filter or rank with min value) to allow filtering down the entire app's
  ///      sub-assets(image, region in image, frame in video, region in frame in video)
  ///      and perform operation to only the results of this search query. See our search
  ///      documentation for more details about the search Query message.
  ///      For eg., filters the asset/sub-asset matching the search and performs specified operation.
  /// Dataset:
  ///      A dataset, whose inputs will have the operation applied to. This does not support dataset versions.
  public var inputSource: OneOf_InputSource? {
    get {return _storage._inputSource}
    set {_uniqueStorage()._inputSource = newValue}
  }

  public var inputIds: Clarifai_Api_InputIDs {
    get {
      if case .inputIds(let v)? = _storage._inputSource {return v}
      return Clarifai_Api_InputIDs()
    }
    set {_uniqueStorage()._inputSource = .inputIds(newValue)}
  }

  public var search: Clarifai_Api_Search {
    get {
      if case .search(let v)? = _storage._inputSource {return v}
      return Clarifai_Api_Search()
    }
    set {_uniqueStorage()._inputSource = .search(newValue)}
  }

  public var dataset: Clarifai_Api_Dataset {
    get {
      if case .dataset(let v)? = _storage._inputSource {return v}
      return Clarifai_Api_Dataset()
    }
    set {_uniqueStorage()._inputSource = .dataset(newValue)}
  }

  /// Annotation Source can be a Search whose results will be a list of annotation ids.
  public var annotationSource: OneOf_AnnotationSource? {
    get {return _storage._annotationSource}
    set {_uniqueStorage()._annotationSource = newValue}
  }

  public var annotationSearch: Clarifai_Api_Search {
    get {
      if case .annotationSearch(let v)? = _storage._annotationSource {return v}
      return Clarifai_Api_Search()
    }
    set {_uniqueStorage()._annotationSource = .annotationSearch(newValue)}
  }

  /// Operation to perform
  public var operation: Clarifai_Api_Operation {
    get {return _storage._operation ?? Clarifai_Api_Operation()}
    set {_uniqueStorage()._operation = newValue}
  }
  /// Returns true if `operation` has been explicitly set.
  public var hasOperation: Bool {return _storage._operation != nil}
  /// Clears the value of `operation`. Subsequent reads from it will return its default value.
  public mutating func clearOperation() {_uniqueStorage()._operation = nil}

  /// Application ID that this Operation was created from
  public var appID: String {
    get {return _storage._appID}
    set {_uniqueStorage()._appID = newValue}
  }

  /// Status (pending, in-progress, completed, failed) of the operation
  public var status: Clarifai_Api_Status_Status {
    get {return _storage._status ?? Clarifai_Api_Status_Status()}
    set {_uniqueStorage()._status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  public var hasStatus: Bool {return _storage._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  public mutating func clearStatus() {_uniqueStorage()._status = nil}

  /// Progress of an on-going Bulk Operation task
  public var progress: Clarifai_Api_Progress {
    get {return _storage._progress ?? Clarifai_Api_Progress()}
    set {_uniqueStorage()._progress = newValue}
  }
  /// Returns true if `progress` has been explicitly set.
  public var hasProgress: Bool {return _storage._progress != nil}
  /// Clears the value of `progress`. Subsequent reads from it will return its default value.
  public mutating func clearProgress() {_uniqueStorage()._progress = nil}

  /// User id that created this operation
  public var createdBy: String {
    get {return _storage._createdBy}
    set {_uniqueStorage()._createdBy = newValue}
  }

  /// When the operation was created. We follow the XXXX timestamp
  /// format. We use https://www.ietf.org/rfc/rfc3339.txt format:
  /// "2006-01-02T15:04:05.999999Z" so you can expect results like
  /// the following from the API:
  /// "2017-04-11T21:50:50.223962Z"
  public var createdAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._createdAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._createdAt = newValue}
  }
  /// Returns true if `createdAt` has been explicitly set.
  public var hasCreatedAt: Bool {return _storage._createdAt != nil}
  /// Clears the value of `createdAt`. Subsequent reads from it will return its default value.
  public mutating func clearCreatedAt() {_uniqueStorage()._createdAt = nil}

  /// Last time the status got updated
  public var lastModifiedAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._lastModifiedAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._lastModifiedAt = newValue}
  }
  /// Returns true if `lastModifiedAt` has been explicitly set.
  public var hasLastModifiedAt: Bool {return _storage._lastModifiedAt != nil}
  /// Clears the value of `lastModifiedAt`. Subsequent reads from it will return its default value.
  public mutating func clearLastModifiedAt() {_uniqueStorage()._lastModifiedAt = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Input Source could be list of input ids or a Search whose results will be a list of input ids.
  /// InputIDs:
  ///      List of input ids to which operation to be applied
  /// clarifai.api.Search:
  ///      A Search(either filter or rank with min value) to allow filtering down the entire app's
  ///      sub-assets(image, region in image, frame in video, region in frame in video)
  ///      and perform operation to only the results of this search query. See our search
  ///      documentation for more details about the search Query message.
  ///      For eg., filters the asset/sub-asset matching the search and performs specified operation.
  /// Dataset:
  ///      A dataset, whose inputs will have the operation applied to. This does not support dataset versions.
  public enum OneOf_InputSource: Equatable {
    case inputIds(Clarifai_Api_InputIDs)
    case search(Clarifai_Api_Search)
    case dataset(Clarifai_Api_Dataset)

  #if !swift(>=4.1)
    public static func ==(lhs: Clarifai_Api_BulkOperation.OneOf_InputSource, rhs: Clarifai_Api_BulkOperation.OneOf_InputSource) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.inputIds, .inputIds): return {
        guard case .inputIds(let l) = lhs, case .inputIds(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.search, .search): return {
        guard case .search(let l) = lhs, case .search(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.dataset, .dataset): return {
        guard case .dataset(let l) = lhs, case .dataset(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  /// Annotation Source can be a Search whose results will be a list of annotation ids.
  public enum OneOf_AnnotationSource: Equatable {
    case annotationSearch(Clarifai_Api_Search)

  #if !swift(>=4.1)
    public static func ==(lhs: Clarifai_Api_BulkOperation.OneOf_AnnotationSource, rhs: Clarifai_Api_BulkOperation.OneOf_AnnotationSource) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.annotationSearch, .annotationSearch): return {
        guard case .annotationSearch(let l) = lhs, case .annotationSearch(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      }
    }
  #endif
  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Clarifai_Api_InputIDs {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var inputIds: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Clarifai_Api_Progress {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var processed: UInt32 = 0

  public var lastProcessedID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Clarifai_Api_Operation {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Bulk Operations supported:
  /// Concepts:
  ///    Operations: add_concepts, delete_concepts
  ///    AddConcepts:
  ///        If new concepts are given, add concepts operation creates new concepts in the app and adds them to the given inputs' annotations.
  ///        If the given concept already exist, the label value of the concept is updated with the given value.
  ///    DeleteConcepts:
  ///        Remove the matching concept(s) for all the inputs in input source (mentioned above).
  ///        If user IDs are set, concepts will be deleted only from annotations created by given user ids.
  ///        If the user IDs are not set, the list will be automatically set with 1 element that is the caller user ID.
  ///    Input Source:
  ///        Input ids of assets(images) (or) search on sub-assets(region in image, frame in video, region in frame in video)
  /// Metadata:
  ///    Operations: add_metadata, delete_metadata
  ///    AddMetadata:
  ///        Add the provided metadata to the input level annotation for all the inputs in input source (mentioned above).
  ///        If the key(s) already exists, it will overwrite the key(s) with the corresponding new value(s).
  ///    DeleteMetadata:
  ///        Remove the key, value pairs that match the given metadata from the existing input level Annotations' metadata
  ///        for all the inputs in input source (mentioned above).
  ///    Input Source:
  ///        Input ids of assets(images, videos) (or) search on sub-assets(region in image, frame in video, region in frame in video)
  /// Geo:
  ///    Operations: overwrite_geo, delete_geo
  ///    OverwriteGeo:
  ///        Add the provided geo info for all the inputs in input source (mentioned above).
  ///    DeleteGeo:
  ///        Delete Geo info for all the inputs in input source (mentioned above).
  ///    Input Source:
  ///        Input ids of assets(images, videos) (or) search on sub-assets(region in image, frame in video, region in frame in video)
  /// Dataset Inputs:
  ///    Operations: add_to_dataset, delete_from_dataset, split_into_datasets
  ///    AddToDataset:
  ///        Add inputs to a dataset
  ///    DeleteFromDataset:
  ///        Delete inputs from a dataset
  ///    SplitIntoDatasets:
  ///        Randomly split inputs into provided dataset ID's with provided percentages.
  public var operation: Clarifai_Api_Operation.OneOf_Operation? = nil

  public var addConcepts: Clarifai_Api_AddConcepts {
    get {
      if case .addConcepts(let v)? = operation {return v}
      return Clarifai_Api_AddConcepts()
    }
    set {operation = .addConcepts(newValue)}
  }

  public var deleteConcepts: Clarifai_Api_DeleteConcepts {
    get {
      if case .deleteConcepts(let v)? = operation {return v}
      return Clarifai_Api_DeleteConcepts()
    }
    set {operation = .deleteConcepts(newValue)}
  }

  public var addMetadata: Clarifai_Api_AddMetadata {
    get {
      if case .addMetadata(let v)? = operation {return v}
      return Clarifai_Api_AddMetadata()
    }
    set {operation = .addMetadata(newValue)}
  }

  public var deleteMetadata: Clarifai_Api_DeleteMetadata {
    get {
      if case .deleteMetadata(let v)? = operation {return v}
      return Clarifai_Api_DeleteMetadata()
    }
    set {operation = .deleteMetadata(newValue)}
  }

  public var overwriteGeo: Clarifai_Api_OverwriteGeo {
    get {
      if case .overwriteGeo(let v)? = operation {return v}
      return Clarifai_Api_OverwriteGeo()
    }
    set {operation = .overwriteGeo(newValue)}
  }

  public var deleteGeo: Clarifai_Api_DeleteGeo {
    get {
      if case .deleteGeo(let v)? = operation {return v}
      return Clarifai_Api_DeleteGeo()
    }
    set {operation = .deleteGeo(newValue)}
  }

  public var deleteFromDataset: Clarifai_Api_DeleteFromDataset {
    get {
      if case .deleteFromDataset(let v)? = operation {return v}
      return Clarifai_Api_DeleteFromDataset()
    }
    set {operation = .deleteFromDataset(newValue)}
  }

  public var addToDataset: Clarifai_Api_AddToDataset {
    get {
      if case .addToDataset(let v)? = operation {return v}
      return Clarifai_Api_AddToDataset()
    }
    set {operation = .addToDataset(newValue)}
  }

  public var splitIntoDatasets: Clarifai_Api_SplitIntoDatasets {
    get {
      if case .splitIntoDatasets(let v)? = operation {return v}
      return Clarifai_Api_SplitIntoDatasets()
    }
    set {operation = .splitIntoDatasets(newValue)}
  }

  /// Bulk Operations for Annotations:
  /// Operations: delete_annotations
  /// DeleteAnnotations:
  ///    Delete all the annotations matching the provided annotation source
  public var annotationOperation: Clarifai_Api_Operation.OneOf_AnnotationOperation? = nil

  public var deleteAnnotations: Clarifai_Api_DeleteAnnotations {
    get {
      if case .deleteAnnotations(let v)? = annotationOperation {return v}
      return Clarifai_Api_DeleteAnnotations()
    }
    set {annotationOperation = .deleteAnnotations(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Bulk Operations supported:
  /// Concepts:
  ///    Operations: add_concepts, delete_concepts
  ///    AddConcepts:
  ///        If new concepts are given, add concepts operation creates new concepts in the app and adds them to the given inputs' annotations.
  ///        If the given concept already exist, the label value of the concept is updated with the given value.
  ///    DeleteConcepts:
  ///        Remove the matching concept(s) for all the inputs in input source (mentioned above).
  ///        If user IDs are set, concepts will be deleted only from annotations created by given user ids.
  ///        If the user IDs are not set, the list will be automatically set with 1 element that is the caller user ID.
  ///    Input Source:
  ///        Input ids of assets(images) (or) search on sub-assets(region in image, frame in video, region in frame in video)
  /// Metadata:
  ///    Operations: add_metadata, delete_metadata
  ///    AddMetadata:
  ///        Add the provided metadata to the input level annotation for all the inputs in input source (mentioned above).
  ///        If the key(s) already exists, it will overwrite the key(s) with the corresponding new value(s).
  ///    DeleteMetadata:
  ///        Remove the key, value pairs that match the given metadata from the existing input level Annotations' metadata
  ///        for all the inputs in input source (mentioned above).
  ///    Input Source:
  ///        Input ids of assets(images, videos) (or) search on sub-assets(region in image, frame in video, region in frame in video)
  /// Geo:
  ///    Operations: overwrite_geo, delete_geo
  ///    OverwriteGeo:
  ///        Add the provided geo info for all the inputs in input source (mentioned above).
  ///    DeleteGeo:
  ///        Delete Geo info for all the inputs in input source (mentioned above).
  ///    Input Source:
  ///        Input ids of assets(images, videos) (or) search on sub-assets(region in image, frame in video, region in frame in video)
  /// Dataset Inputs:
  ///    Operations: add_to_dataset, delete_from_dataset, split_into_datasets
  ///    AddToDataset:
  ///        Add inputs to a dataset
  ///    DeleteFromDataset:
  ///        Delete inputs from a dataset
  ///    SplitIntoDatasets:
  ///        Randomly split inputs into provided dataset ID's with provided percentages.
  public enum OneOf_Operation: Equatable {
    case addConcepts(Clarifai_Api_AddConcepts)
    case deleteConcepts(Clarifai_Api_DeleteConcepts)
    case addMetadata(Clarifai_Api_AddMetadata)
    case deleteMetadata(Clarifai_Api_DeleteMetadata)
    case overwriteGeo(Clarifai_Api_OverwriteGeo)
    case deleteGeo(Clarifai_Api_DeleteGeo)
    case deleteFromDataset(Clarifai_Api_DeleteFromDataset)
    case addToDataset(Clarifai_Api_AddToDataset)
    case splitIntoDatasets(Clarifai_Api_SplitIntoDatasets)

  #if !swift(>=4.1)
    public static func ==(lhs: Clarifai_Api_Operation.OneOf_Operation, rhs: Clarifai_Api_Operation.OneOf_Operation) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.addConcepts, .addConcepts): return {
        guard case .addConcepts(let l) = lhs, case .addConcepts(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.deleteConcepts, .deleteConcepts): return {
        guard case .deleteConcepts(let l) = lhs, case .deleteConcepts(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.addMetadata, .addMetadata): return {
        guard case .addMetadata(let l) = lhs, case .addMetadata(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.deleteMetadata, .deleteMetadata): return {
        guard case .deleteMetadata(let l) = lhs, case .deleteMetadata(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.overwriteGeo, .overwriteGeo): return {
        guard case .overwriteGeo(let l) = lhs, case .overwriteGeo(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.deleteGeo, .deleteGeo): return {
        guard case .deleteGeo(let l) = lhs, case .deleteGeo(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.deleteFromDataset, .deleteFromDataset): return {
        guard case .deleteFromDataset(let l) = lhs, case .deleteFromDataset(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.addToDataset, .addToDataset): return {
        guard case .addToDataset(let l) = lhs, case .addToDataset(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.splitIntoDatasets, .splitIntoDatasets): return {
        guard case .splitIntoDatasets(let l) = lhs, case .splitIntoDatasets(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  /// Bulk Operations for Annotations:
  /// Operations: delete_annotations
  /// DeleteAnnotations:
  ///    Delete all the annotations matching the provided annotation source
  public enum OneOf_AnnotationOperation: Equatable {
    case deleteAnnotations(Clarifai_Api_DeleteAnnotations)

  #if !swift(>=4.1)
    public static func ==(lhs: Clarifai_Api_Operation.OneOf_AnnotationOperation, rhs: Clarifai_Api_Operation.OneOf_AnnotationOperation) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.deleteAnnotations, .deleteAnnotations): return {
        guard case .deleteAnnotations(let l) = lhs, case .deleteAnnotations(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      }
    }
  #endif
  }

  public init() {}
}

public struct Clarifai_Api_AddConcepts {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var concepts: [Clarifai_Api_Concept] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Clarifai_Api_DeleteConcepts {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var concepts: [Clarifai_Api_Concept] = []

  public var userIds: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Clarifai_Api_AddMetadata {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// To handle arbitrary json metadata you can use a struct field:
  /// https://github.com/google/protobuf/blob/master/src/google/protobuf/struct.proto
  public var metadata: SwiftProtobuf.Google_Protobuf_Struct {
    get {return _metadata ?? SwiftProtobuf.Google_Protobuf_Struct()}
    set {_metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  public var hasMetadata: Bool {return self._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  public mutating func clearMetadata() {self._metadata = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _metadata: SwiftProtobuf.Google_Protobuf_Struct? = nil
}

public struct Clarifai_Api_DeleteMetadata {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// To handle arbitrary json metadata you can use a struct field:
  /// https://github.com/google/protobuf/blob/master/src/google/protobuf/struct.proto
  public var metadata: SwiftProtobuf.Google_Protobuf_Struct {
    get {return _metadata ?? SwiftProtobuf.Google_Protobuf_Struct()}
    set {_metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  public var hasMetadata: Bool {return self._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  public mutating func clearMetadata() {self._metadata = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _metadata: SwiftProtobuf.Google_Protobuf_Struct? = nil
}

public struct Clarifai_Api_OverwriteGeo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Geo info
  public var geo: Clarifai_Api_Geo {
    get {return _geo ?? Clarifai_Api_Geo()}
    set {_geo = newValue}
  }
  /// Returns true if `geo` has been explicitly set.
  public var hasGeo: Bool {return self._geo != nil}
  /// Clears the value of `geo`. Subsequent reads from it will return its default value.
  public mutating func clearGeo() {self._geo = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _geo: Clarifai_Api_Geo? = nil
}

public struct Clarifai_Api_DeleteGeo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Clarifai_Api_AddToDataset {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var datasetID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Clarifai_Api_DeleteFromDataset {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var datasetID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Clarifai_Api_SplitIntoDatasets {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var datasetSplits: [Clarifai_Api_DatasetSplit] = []

  public var method: Clarifai_Api_SplitIntoDatasets.DatasetSplitMethod = .notSet

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum DatasetSplitMethod: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case notSet // = 0

    /// We will randomly split inputs into the datasets
    case randomPercentageSplit // = 1
    case UNRECOGNIZED(Int)

    public init() {
      self = .notSet
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .notSet
      case 1: self = .randomPercentageSplit
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .notSet: return 0
      case .randomPercentageSplit: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Clarifai_Api_SplitIntoDatasets.DatasetSplitMethod: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Clarifai_Api_SplitIntoDatasets.DatasetSplitMethod] = [
    .notSet,
    .randomPercentageSplit,
  ]
}

#endif  // swift(>=4.2)

public struct Clarifai_Api_DatasetSplit {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Expected to have ID
  public var dataset: Clarifai_Api_Dataset {
    get {return _dataset ?? Clarifai_Api_Dataset()}
    set {_dataset = newValue}
  }
  /// Returns true if `dataset` has been explicitly set.
  public var hasDataset: Bool {return self._dataset != nil}
  /// Clears the value of `dataset`. Subsequent reads from it will return its default value.
  public mutating func clearDataset() {self._dataset = nil}

  public var methodInfo: Clarifai_Api_DatasetSplit.OneOf_MethodInfo? = nil

  /// For RANDOM_PERCENTAGE_SPLIT.
  /// Values from (0,100]
  public var percentage: UInt32 {
    get {
      if case .percentage(let v)? = methodInfo {return v}
      return 0
    }
    set {methodInfo = .percentage(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_MethodInfo: Equatable {
    /// For RANDOM_PERCENTAGE_SPLIT.
    /// Values from (0,100]
    case percentage(UInt32)

  #if !swift(>=4.1)
    public static func ==(lhs: Clarifai_Api_DatasetSplit.OneOf_MethodInfo, rhs: Clarifai_Api_DatasetSplit.OneOf_MethodInfo) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.percentage, .percentage): return {
        guard case .percentage(let l) = lhs, case .percentage(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      }
    }
  #endif
  }

  public init() {}

  fileprivate var _dataset: Clarifai_Api_Dataset? = nil
}

/// This operation takes no data (payload).
public struct Clarifai_Api_DeleteAnnotations {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Clarifai_Api_InputsAddJob {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// id of the job
  public var id: String {
    get {return _storage._id}
    set {_uniqueStorage()._id = newValue}
  }

  /// If call back url is set, we will send a Post request to this endpoint with job status.
  public var callBackURL: String {
    get {return _storage._callBackURL}
    set {_uniqueStorage()._callBackURL = newValue}
  }

  /// Personal Access Token to the application to which inputs are added
  public var appPat: String {
    get {return _storage._appPat}
    set {_uniqueStorage()._appPat = newValue}
  }

  /// Progress of an on-going Input Ingestion task
  public var progress: Clarifai_Api_InputsAddJobProgress {
    get {return _storage._progress ?? Clarifai_Api_InputsAddJobProgress()}
    set {_uniqueStorage()._progress = newValue}
  }
  /// Returns true if `progress` has been explicitly set.
  public var hasProgress: Bool {return _storage._progress != nil}
  /// Clears the value of `progress`. Subsequent reads from it will return its default value.
  public mutating func clearProgress() {_uniqueStorage()._progress = nil}

  /// When the job was created.
  /// The format is https://www.ietf.org/rfc/rfc3339.txt.
  /// Example: "2006-01-02T15:04:05.999999Z".
  public var createdAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._createdAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._createdAt = newValue}
  }
  /// Returns true if `createdAt` has been explicitly set.
  public var hasCreatedAt: Bool {return _storage._createdAt != nil}
  /// Clears the value of `createdAt`. Subsequent reads from it will return its default value.
  public mutating func clearCreatedAt() {_uniqueStorage()._createdAt = nil}

  /// Most recent time when the job was updated.
  /// The format is https://www.ietf.org/rfc/rfc3339.txt.
  /// Example: "2006-01-02T15:04:05.999999Z".
  public var modifiedAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._modifiedAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._modifiedAt = newValue}
  }
  /// Returns true if `modifiedAt` has been explicitly set.
  public var hasModifiedAt: Bool {return _storage._modifiedAt != nil}
  /// Clears the value of `modifiedAt`. Subsequent reads from it will return its default value.
  public mutating func clearModifiedAt() {_uniqueStorage()._modifiedAt = nil}

  /// Sub-jobs that extract inputs from the cloud and/or archives
  public var extractionJobs: [Clarifai_Api_InputsExtractionJob] {
    get {return _storage._extractionJobs}
    set {_uniqueStorage()._extractionJobs = newValue}
  }

  /// Archive uploads
  public var uploads: [Clarifai_Api_Upload] {
    get {return _storage._uploads}
    set {_uniqueStorage()._uploads = newValue}
  }

  /// Status of the job
  public var status: Clarifai_Api_Status_Status {
    get {return _storage._status ?? Clarifai_Api_Status_Status()}
    set {_uniqueStorage()._status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  public var hasStatus: Bool {return _storage._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  public mutating func clearStatus() {_uniqueStorage()._status = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Clarifai_Api_InputsAddJobProgress {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var pendingCount: UInt64 = 0

  public var inProgressCount: UInt64 = 0

  public var successCount: UInt64 = 0

  public var failedCount: UInt64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Clarifai_Api_Upload {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// ID of upload
  public var id: String {
    get {return _storage._id}
    set {_uniqueStorage()._id = newValue}
  }

  /// When the upload was started.
  /// The format is https://www.ietf.org/rfc/rfc3339.txt.
  /// Example: "2006-01-02T15:04:05.999999Z".
  public var createdAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._createdAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._createdAt = newValue}
  }
  /// Returns true if `createdAt` has been explicitly set.
  public var hasCreatedAt: Bool {return _storage._createdAt != nil}
  /// Clears the value of `createdAt`. Subsequent reads from it will return its default value.
  public mutating func clearCreatedAt() {_uniqueStorage()._createdAt = nil}

  /// Most recent time when the upload was updated.
  /// The format is https://www.ietf.org/rfc/rfc3339.txt.
  /// Example: "2006-01-02T15:04:05.999999Z".
  public var modifiedAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._modifiedAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._modifiedAt = newValue}
  }
  /// Returns true if `modifiedAt` has been explicitly set.
  public var hasModifiedAt: Bool {return _storage._modifiedAt != nil}
  /// Clears the value of `modifiedAt`. Subsequent reads from it will return its default value.
  public mutating func clearModifiedAt() {_uniqueStorage()._modifiedAt = nil}

  /// When the upload will expire and be deleted
  /// The format is https://www.ietf.org/rfc/rfc3339.txt.
  /// Example: "2006-01-02T15:04:05.999999Z".
  public var expiresAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._expiresAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._expiresAt = newValue}
  }
  /// Returns true if `expiresAt` has been explicitly set.
  public var hasExpiresAt: Bool {return _storage._expiresAt != nil}
  /// Clears the value of `expiresAt`. Subsequent reads from it will return its default value.
  public mutating func clearExpiresAt() {_uniqueStorage()._expiresAt = nil}

  /// Status of the upload
  public var status: Clarifai_Api_Status_Status {
    get {return _storage._status ?? Clarifai_Api_Status_Status()}
    set {_uniqueStorage()._status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  public var hasStatus: Bool {return _storage._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  public mutating func clearStatus() {_uniqueStorage()._status = nil}

  /// name of uploaded content (e.g. filename)
  public var contentName: String {
    get {return _storage._contentName}
    set {_uniqueStorage()._contentName = newValue}
  }

  /// Total size of the upload content
  public var contentLength: UInt64 {
    get {return _storage._contentLength}
    set {_uniqueStorage()._contentLength = newValue}
  }

  /// Url of uploaded content
  public var contentURL: String {
    get {return _storage._contentURL}
    set {_uniqueStorage()._contentURL = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Clarifai_Api_UploadContentPart {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var rangeStart: UInt64 = 0

  public var partNumber: Int64 = 0

  public var data: Data = Data()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Clarifai_Api_InputsExtractionJob {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var status: Clarifai_Api_Status_Status {
    get {return _storage._status ?? Clarifai_Api_Status_Status()}
    set {_uniqueStorage()._status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  public var hasStatus: Bool {return _storage._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  public mutating func clearStatus() {_uniqueStorage()._status = nil}

  /// ID of extraction job
  public var id: String {
    get {return _storage._id}
    set {_uniqueStorage()._id = newValue}
  }

  /// Url of archive or bucket
  public var url: String {
    get {return _storage._url}
    set {_uniqueStorage()._url = newValue}
  }

  /// Progress counts of the job
  public var progress: Clarifai_Api_InputsExtractionJobProgress {
    get {return _storage._progress ?? Clarifai_Api_InputsExtractionJobProgress()}
    set {_uniqueStorage()._progress = newValue}
  }
  /// Returns true if `progress` has been explicitly set.
  public var hasProgress: Bool {return _storage._progress != nil}
  /// Clears the value of `progress`. Subsequent reads from it will return its default value.
  public mutating func clearProgress() {_uniqueStorage()._progress = nil}

  /// When the extraction job was started.
  /// The format is https://www.ietf.org/rfc/rfc3339.txt.
  /// Example: "2006-01-02T15:04:05.999999Z".
  public var createdAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._createdAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._createdAt = newValue}
  }
  /// Returns true if `createdAt` has been explicitly set.
  public var hasCreatedAt: Bool {return _storage._createdAt != nil}
  /// Clears the value of `createdAt`. Subsequent reads from it will return its default value.
  public mutating func clearCreatedAt() {_uniqueStorage()._createdAt = nil}

  /// Most recent time when the extraction job was updated.
  /// The format is https://www.ietf.org/rfc/rfc3339.txt.
  /// Example: "2006-01-02T15:04:05.999999Z".
  public var modifiedAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._modifiedAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._modifiedAt = newValue}
  }
  /// Returns true if `modifiedAt` has been explicitly set.
  public var hasModifiedAt: Bool {return _storage._modifiedAt != nil}
  /// Clears the value of `modifiedAt`. Subsequent reads from it will return its default value.
  public mutating func clearModifiedAt() {_uniqueStorage()._modifiedAt = nil}

  /// How to handle input ID conflicts.
  public var inputIDConflictResolution: Clarifai_Api_InputIDConflictResolution {
    get {return _storage._inputIDConflictResolution}
    set {_uniqueStorage()._inputIDConflictResolution = newValue}
  }

  /// Fields set in the template are added to all generated inputs
  public var inputTemplate: Clarifai_Api_Input {
    get {return _storage._inputTemplate ?? Clarifai_Api_Input()}
    set {_uniqueStorage()._inputTemplate = newValue}
  }
  /// Returns true if `inputTemplate` has been explicitly set.
  public var hasInputTemplate: Bool {return _storage._inputTemplate != nil}
  /// Clears the value of `inputTemplate`. Subsequent reads from it will return its default value.
  public mutating func clearInputTemplate() {_uniqueStorage()._inputTemplate = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Clarifai_Api_InputsExtractionJobProgress {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var audioInputsCount: UInt64 = 0

  public var imageInputsCount: UInt64 = 0

  public var videoInputsCount: UInt64 = 0

  public var textInputsCount: UInt64 = 0

  public var pendingArchivesCount: UInt64 = 0

  public var inProgressArchivesCount: UInt64 = 0

  public var completedArchivesCount: UInt64 = 0

  public var failedArchivesCount: UInt64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Clarifai_Api_InputsDataSource {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Collect statistics about created inputs in job with given ID.
  /// On Post call:
  /// * If job ID is empty, then job is automatically created with random ID.
  /// * If job ID is non-empty, then a new job will be created with given ID.
  public var inputsAddJobID: String = String()

  public var url: Clarifai_Api_DataSourceURL {
    get {return _url ?? Clarifai_Api_DataSourceURL()}
    set {_url = newValue}
  }
  /// Returns true if `url` has been explicitly set.
  public var hasURL: Bool {return self._url != nil}
  /// Clears the value of `url`. Subsequent reads from it will return its default value.
  public mutating func clearURL() {self._url = nil}

  /// How to handle input ID conflicts.
  public var inputIDConflictResolution: Clarifai_Api_InputIDConflictResolution = .notSet

  /// Fields set in the template will also be added to all generated inputs
  public var inputTemplate: Clarifai_Api_Input {
    get {return _inputTemplate ?? Clarifai_Api_Input()}
    set {_inputTemplate = newValue}
  }
  /// Returns true if `inputTemplate` has been explicitly set.
  public var hasInputTemplate: Bool {return self._inputTemplate != nil}
  /// Clears the value of `inputTemplate`. Subsequent reads from it will return its default value.
  public mutating func clearInputTemplate() {self._inputTemplate = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _url: Clarifai_Api_DataSourceURL? = nil
  fileprivate var _inputTemplate: Clarifai_Api_Input? = nil
}

public struct Clarifai_Api_DataSourceURL {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Supported providers are AWS S3, Azure blob, GCP cloud storage.
  public var url: String = String()

  /// Credentials that would allow access to the provided url
  public var credentials: Clarifai_Api_DataSourceCredentials {
    get {return _credentials ?? Clarifai_Api_DataSourceCredentials()}
    set {_credentials = newValue}
  }
  /// Returns true if `credentials` has been explicitly set.
  public var hasCredentials: Bool {return self._credentials != nil}
  /// Clears the value of `credentials`. Subsequent reads from it will return its default value.
  public mutating func clearCredentials() {self._credentials = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _credentials: Clarifai_Api_DataSourceCredentials? = nil
}

public struct Clarifai_Api_DataSourceCredentials {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var credentials: Clarifai_Api_DataSourceCredentials.OneOf_Credentials? = nil

  /// AWS S3 credentials for authentication.
  public var s3Creds: Clarifai_Api_AWSCreds {
    get {
      if case .s3Creds(let v)? = credentials {return v}
      return Clarifai_Api_AWSCreds()
    }
    set {credentials = .s3Creds(newValue)}
  }

  /// GCP Cloud Storage uses service account key data(creds.json) as Byte array for authentication.
  public var gcpCreds: Data {
    get {
      if case .gcpCreds(let v)? = credentials {return v}
      return Data()
    }
    set {credentials = .gcpCreds(newValue)}
  }

  /// Azure Blob credentials for authentication.
  public var azureBlobCreds: Clarifai_Api_AzureBlobCreds {
    get {
      if case .azureBlobCreds(let v)? = credentials {return v}
      return Clarifai_Api_AzureBlobCreds()
    }
    set {credentials = .azureBlobCreds(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Credentials: Equatable {
    /// AWS S3 credentials for authentication.
    case s3Creds(Clarifai_Api_AWSCreds)
    /// GCP Cloud Storage uses service account key data(creds.json) as Byte array for authentication.
    case gcpCreds(Data)
    /// Azure Blob credentials for authentication.
    case azureBlobCreds(Clarifai_Api_AzureBlobCreds)

  #if !swift(>=4.1)
    public static func ==(lhs: Clarifai_Api_DataSourceCredentials.OneOf_Credentials, rhs: Clarifai_Api_DataSourceCredentials.OneOf_Credentials) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.s3Creds, .s3Creds): return {
        guard case .s3Creds(let l) = lhs, case .s3Creds(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.gcpCreds, .gcpCreds): return {
        guard case .gcpCreds(let l) = lhs, case .gcpCreds(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.azureBlobCreds, .azureBlobCreds): return {
        guard case .azureBlobCreds(let l) = lhs, case .azureBlobCreds(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

/// AWS S3 storage credentials.
public struct Clarifai_Api_AWSCreds {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var region: String = String()

  public var id: String = String()

  public var secret: String = String()

  public var token: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Azure Blob storage credentials.
public struct Clarifai_Api_AzureBlobCreds {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var accountName: String = String()

  public var accountKey: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Clarifai_Api_InputsUpload {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Collect statistics about created inputs in job with given ID.
  /// * If job ID is empty, then job is automatically created with random ID.
  /// * If job ID is non-empty, then a new job will be created with given ID.
  public var inputsAddJobID: String = String()

  /// Personal Access Token to the application to which inputs are added
  /// Deprecated: No need to send app_pat, it will be generated internally if not present
  public var appPat: String = String()

  public var upload: Clarifai_Api_Upload {
    get {return _upload ?? Clarifai_Api_Upload()}
    set {_upload = newValue}
  }
  /// Returns true if `upload` has been explicitly set.
  public var hasUpload: Bool {return self._upload != nil}
  /// Clears the value of `upload`. Subsequent reads from it will return its default value.
  public mutating func clearUpload() {self._upload = nil}

  /// How to handle input ID conflicts.
  public var inputIDConflictResolution: Clarifai_Api_InputIDConflictResolution = .notSet

  /// Fields set in the template will also be added to all generated inputs
  public var inputTemplate: Clarifai_Api_Input {
    get {return _inputTemplate ?? Clarifai_Api_Input()}
    set {_inputTemplate = newValue}
  }
  /// Returns true if `inputTemplate` has been explicitly set.
  public var hasInputTemplate: Bool {return self._inputTemplate != nil}
  /// Clears the value of `inputTemplate`. Subsequent reads from it will return its default value.
  public mutating func clearInputTemplate() {self._inputTemplate = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _upload: Clarifai_Api_Upload? = nil
  fileprivate var _inputTemplate: Clarifai_Api_Input? = nil
}

public struct Clarifai_Api_BookmarkOrigin {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// original resource id
  public var id: String = String()

  /// original resource app id
  public var appID: String = String()

  /// original resource user id
  public var userID: String = String()

  /// resource type.
  public var resourceType: Clarifai_Api_BookmarkOrigin.BookmarkType = .unknown

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum BookmarkType: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case unknown // = 0
    case model // = 1
    case workflow // = 2
    case dataset // = 3
    case module // = 4
    case UNRECOGNIZED(Int)

    public init() {
      self = .unknown
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknown
      case 1: self = .model
      case 2: self = .workflow
      case 3: self = .dataset
      case 4: self = .module
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unknown: return 0
      case .model: return 1
      case .workflow: return 2
      case .dataset: return 3
      case .module: return 4
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Clarifai_Api_BookmarkOrigin.BookmarkType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Clarifai_Api_BookmarkOrigin.BookmarkType] = [
    .unknown,
    .model,
    .workflow,
    .dataset,
    .module,
  ]
}

#endif  // swift(>=4.2)

/// A worker for compute within a nodepool of instances.
/// This asks the API for work
public struct Clarifai_Api_Runner {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// A unique ID for this runner.
  /// This is a UUID since runners can be automatically orchestrated.
  public var id: String {
    get {return _storage._id}
    set {_uniqueStorage()._id = newValue}
  }

  /// short description about the runner.
  public var description_p: String {
    get {return _storage._description_p}
    set {_uniqueStorage()._description_p = newValue}
  }

  /// When the runner was created.
  public var createdAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._createdAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._createdAt = newValue}
  }
  /// Returns true if `createdAt` has been explicitly set.
  public var hasCreatedAt: Bool {return _storage._createdAt != nil}
  /// Clears the value of `createdAt`. Subsequent reads from it will return its default value.
  public mutating func clearCreatedAt() {_uniqueStorage()._createdAt = nil}

  /// When the runner was last modified.
  public var modifiedAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._modifiedAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._modifiedAt = newValue}
  }
  /// Returns true if `modifiedAt` has been explicitly set.
  public var hasModifiedAt: Bool {return _storage._modifiedAt != nil}
  /// Clears the value of `modifiedAt`. Subsequent reads from it will return its default value.
  public mutating func clearModifiedAt() {_uniqueStorage()._modifiedAt = nil}

  /// To handle arbitrary json metadata you can use a struct field:
  /// https://github.com/google/protobuf/blob/master/src/google/protobuf/struct.proto
  /// This is an optional arg.
  public var metadata: SwiftProtobuf.Google_Protobuf_Struct {
    get {return _storage._metadata ?? SwiftProtobuf.Google_Protobuf_Struct()}
    set {_uniqueStorage()._metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  public var hasMetadata: Bool {return _storage._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  public mutating func clearMetadata() {_uniqueStorage()._metadata = nil}

  /// Labels to match in order to find work.
  public var labels: [String] {
    get {return _storage._labels}
    set {_uniqueStorage()._labels = newValue}
  }

  /// Instead of just matching on labels we might want to have more explicit matching of what
  /// work this runner is looking for.
  /// The thing that the autoscaling config applies to for this nodepool.
  public var worker: Clarifai_Api_Worker {
    get {return _storage._worker ?? Clarifai_Api_Worker()}
    set {_uniqueStorage()._worker = newValue}
  }
  /// Returns true if `worker` has been explicitly set.
  public var hasWorker: Bool {return _storage._worker != nil}
  /// Clears the value of `worker`. Subsequent reads from it will return its default value.
  public mutating func clearWorker() {_uniqueStorage()._worker = nil}

  /// Runners are defined within nodepools so this field needs the id and user_id of the nodepool
  /// to be provided when creating a Runner.
  /// This nodepool must be accessible to you or an org you are part of.
  public var nodepool: Clarifai_Api_Nodepool {
    get {return _storage._nodepool ?? Clarifai_Api_Nodepool()}
    set {_uniqueStorage()._nodepool = newValue}
  }
  /// Returns true if `nodepool` has been explicitly set.
  public var hasNodepool: Bool {return _storage._nodepool != nil}
  /// Clears the value of `nodepool`. Subsequent reads from it will return its default value.
  public mutating func clearNodepool() {_uniqueStorage()._nodepool = nil}

  /////////////////////////////
  /// Need resources on the runner so we can schedule this Runner into the Nodepool.
  /// If this runner is being orchestrated for a model then the orchestrator will set this to the
  /// model resource requirements. If a workflow then it'll compute those requirements and set
  /// populate this resource field.
  /// Having this on the underlying object like Model and Workflow allows us to represent the minimum
  /// requirements on those object, which may be less than what the Runner allocates (as a safety
  /// margin for the runner to for sure run the resource).
  public var computeInfo: Clarifai_Api_ComputeInfo {
    get {return _storage._computeInfo ?? Clarifai_Api_ComputeInfo()}
    set {_uniqueStorage()._computeInfo = newValue}
  }
  /// Returns true if `computeInfo` has been explicitly set.
  public var hasComputeInfo: Bool {return _storage._computeInfo != nil}
  /// Clears the value of `computeInfo`. Subsequent reads from it will return its default value.
  public mutating func clearComputeInfo() {_uniqueStorage()._computeInfo = nil}

  /// Number of replicas that this runner should have up.
  /// We keep it separate from ComputeInfo which defines how many resources each replica needs.
  public var numReplicas: UInt32 {
    get {return _storage._numReplicas}
    set {_uniqueStorage()._numReplicas = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// A nodepool is a set of nodes dedicated for a given user's compute needs.
/// This compute will typically be consumed by runners and in the future other objects
/// like UI modules may be assigned to node pools.
public struct Clarifai_Api_Nodepool {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The user defined ID of the nodepool.
  public var id: String = String()

  /// Short description about the nodepool.
  public var description_p: String = String()

  /// When the nodepool was created.
  public var createdAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _createdAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_createdAt = newValue}
  }
  /// Returns true if `createdAt` has been explicitly set.
  public var hasCreatedAt: Bool {return self._createdAt != nil}
  /// Clears the value of `createdAt`. Subsequent reads from it will return its default value.
  public mutating func clearCreatedAt() {self._createdAt = nil}

  /// When the nodepool was last modified.
  public var modifiedAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _modifiedAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_modifiedAt = newValue}
  }
  /// Returns true if `modifiedAt` has been explicitly set.
  public var hasModifiedAt: Bool {return self._modifiedAt != nil}
  /// Clears the value of `modifiedAt`. Subsequent reads from it will return its default value.
  public mutating func clearModifiedAt() {self._modifiedAt = nil}

  /// Which cluster this nodepool is within.
  public var computeCluster: Clarifai_Api_ComputeCluster {
    get {return _computeCluster ?? Clarifai_Api_ComputeCluster()}
    set {_computeCluster = newValue}
  }
  /// Returns true if `computeCluster` has been explicitly set.
  public var hasComputeCluster: Bool {return self._computeCluster != nil}
  /// Clears the value of `computeCluster`. Subsequent reads from it will return its default value.
  public mutating func clearComputeCluster() {self._computeCluster = nil}

  public var nodeCapacityType: Clarifai_Api_NodeCapacityType {
    get {return _nodeCapacityType ?? Clarifai_Api_NodeCapacityType()}
    set {_nodeCapacityType = newValue}
  }
  /// Returns true if `nodeCapacityType` has been explicitly set.
  public var hasNodeCapacityType: Bool {return self._nodeCapacityType != nil}
  /// Clears the value of `nodeCapacityType`. Subsequent reads from it will return its default value.
  public mutating func clearNodeCapacityType() {self._nodeCapacityType = nil}

  public var instanceTypes: [Clarifai_Api_InstanceType] = []

  /// Minimum number of instances in this nodepool. This allows the nodepool to scale down to this
  /// amount. This is the user desired minimum.
  public var minInstances: UInt32 = 0

  /// An upper limit on the number of instances in this nodepool. This allows the nodepool to scale
  /// up to this amount. This is the user desired maximum.
  public var maxInstances: UInt32 = 0

  /// The actual minimum number of instances. Enforced by the user's plan limits.
  public var enforcedMinInstances: UInt32 = 0

  /// The actual maximum number of instances. Enforced by the user's plan limits.
  public var enforcedMaxInstances: UInt32 = 0

  /// The visibility field represents whether this message is privately/publicly visible.
  /// To be visible to the public the App that contains it AND the User that contains the App must
  /// also be publicly visible.
  public var visibility: Clarifai_Api_Visibility {
    get {return _visibility ?? Clarifai_Api_Visibility()}
    set {_visibility = newValue}
  }
  /// Returns true if `visibility` has been explicitly set.
  public var hasVisibility: Bool {return self._visibility != nil}
  /// Clears the value of `visibility`. Subsequent reads from it will return its default value.
  public mutating func clearVisibility() {self._visibility = nil}

  /// To handle arbitrary json metadata:
  /// https://github.com/google/protobuf/blob/master/src/google/protobuf/struct.proto
  public var metadata: SwiftProtobuf.Google_Protobuf_Struct {
    get {return _metadata ?? SwiftProtobuf.Google_Protobuf_Struct()}
    set {_metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  public var hasMetadata: Bool {return self._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  public mutating func clearMetadata() {self._metadata = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _createdAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _modifiedAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _computeCluster: Clarifai_Api_ComputeCluster? = nil
  fileprivate var _nodeCapacityType: Clarifai_Api_NodeCapacityType? = nil
  fileprivate var _visibility: Clarifai_Api_Visibility? = nil
  fileprivate var _metadata: SwiftProtobuf.Google_Protobuf_Struct? = nil
}

/// Type of nodes that are ok for instances in this pool.
/// If both spot and on-demand are provided then the runner will be able to run on either
/// with a preference for spot until they are not available.
public struct Clarifai_Api_NodeCapacityType {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var capacityTypes: [Clarifai_Api_NodeCapacityType.CapacityType] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum CapacityType: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case uknownCapacityType // = 0
    case onDemandType // = 1
    case spotType // = 2
    case UNRECOGNIZED(Int)

    public init() {
      self = .uknownCapacityType
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .uknownCapacityType
      case 1: self = .onDemandType
      case 2: self = .spotType
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .uknownCapacityType: return 0
      case .onDemandType: return 1
      case .spotType: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Clarifai_Api_NodeCapacityType.CapacityType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Clarifai_Api_NodeCapacityType.CapacityType] = [
    .uknownCapacityType,
    .onDemandType,
    .spotType,
  ]
}

#endif  // swift(>=4.2)

/// The instance types that will be available in this pool of nodes.
/// Clarifai offers multiple different choices that combine cpu cores, memory and accelerator.
public struct Clarifai_Api_InstanceType {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: String = String()

  /// Short description of instance type.
  public var description_p: String = String()

  public var computeInfo: Clarifai_Api_ComputeInfo {
    get {return _computeInfo ?? Clarifai_Api_ComputeInfo()}
    set {_computeInfo = newValue}
  }
  /// Returns true if `computeInfo` has been explicitly set.
  public var hasComputeInfo: Bool {return self._computeInfo != nil}
  /// Clears the value of `computeInfo`. Subsequent reads from it will return its default value.
  public mutating func clearComputeInfo() {self._computeInfo = nil}

  public var price: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _computeInfo: Clarifai_Api_ComputeInfo? = nil
}

/// CloudProvider represents the entity that provides the infrastructure where the Nodepools are deployed.
/// This could be a public cloud provider like AWS, GCP, Azure, etc., or a self-hosted infrastructure.
public struct Clarifai_Api_CloudProvider {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Unique identifier of the cloud provider.
  public var id: String = String()

  /// Name of the cloud provider.
  public var name: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// We define a cluster here to be used in Nodepools and by the cloud provider.
/// There will be one cloud provider per Cluster.
/// This allows us to define Clusters that are VPCs within one physical cloud and have that
/// managed by one cloud provider which can list all nodepools for that VPC to deploy them and
/// orchestrate work within them.
public struct Clarifai_Api_ComputeCluster {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: String {
    get {return _storage._id}
    set {_uniqueStorage()._id = newValue}
  }

  /// Short description of cluster region.
  public var description_p: String {
    get {return _storage._description_p}
    set {_uniqueStorage()._description_p = newValue}
  }

  /// The cloud provider where this cluster is hosted.
  /// Some example cloud provider IDs may be aws, gcp, azure, local, kubernetes, etc.
  public var cloudProvider: Clarifai_Api_CloudProvider {
    get {return _storage._cloudProvider ?? Clarifai_Api_CloudProvider()}
    set {_uniqueStorage()._cloudProvider = newValue}
  }
  /// Returns true if `cloudProvider` has been explicitly set.
  public var hasCloudProvider: Bool {return _storage._cloudProvider != nil}
  /// Clears the value of `cloudProvider`. Subsequent reads from it will return its default value.
  public mutating func clearCloudProvider() {_uniqueStorage()._cloudProvider = nil}

  /// The region. The naming here depends on the cluster choice above and will be validated
  /// against which clusters+regions that Clarifai currently supports.
  public var region: String {
    get {return _storage._region}
    set {_uniqueStorage()._region = newValue}
  }

  /// The user/org that this compute cluster belongs to.
  public var userID: String {
    get {return _storage._userID}
    set {_uniqueStorage()._userID = newValue}
  }

  /// When the compute cluster was created.
  public var createdAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._createdAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._createdAt = newValue}
  }
  /// Returns true if `createdAt` has been explicitly set.
  public var hasCreatedAt: Bool {return _storage._createdAt != nil}
  /// Clears the value of `createdAt`. Subsequent reads from it will return its default value.
  public mutating func clearCreatedAt() {_uniqueStorage()._createdAt = nil}

  /// When the compute cluster was last modified.
  public var modifiedAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._modifiedAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._modifiedAt = newValue}
  }
  /// Returns true if `modifiedAt` has been explicitly set.
  public var hasModifiedAt: Bool {return _storage._modifiedAt != nil}
  /// Clears the value of `modifiedAt`. Subsequent reads from it will return its default value.
  public mutating func clearModifiedAt() {_uniqueStorage()._modifiedAt = nil}

  /// The visibility field represents whether this message is privately/publicly visible.
  /// To be visible to the public the App that contains it AND the User that contains the App must
  /// also be publicly visible.
  public var visibility: Clarifai_Api_Visibility {
    get {return _storage._visibility ?? Clarifai_Api_Visibility()}
    set {_uniqueStorage()._visibility = newValue}
  }
  /// Returns true if `visibility` has been explicitly set.
  public var hasVisibility: Bool {return _storage._visibility != nil}
  /// Clears the value of `visibility`. Subsequent reads from it will return its default value.
  public mutating func clearVisibility() {_uniqueStorage()._visibility = nil}

  /// We offer different types of compute clusters such as:
  /// 'shared' which only Clarifai can create.
  /// 'dedicated' where you're in control of defining the nodepools within the cluster
  /// 'local-dev' which means you're responsible for starting runners manually which is great for local
  /// development but not recommended for production use cases.
  public var clusterType: String {
    get {return _storage._clusterType}
    set {_uniqueStorage()._clusterType = newValue}
  }

  /// Managed by represents who is responsible for the cluster.
  /// This is currently either "clarifai" where we fully manage the infrastructure.
  /// Or, "user" where the user is responsible for the underlying infrastructure.
  public var managedBy: String {
    get {return _storage._managedBy}
    set {_uniqueStorage()._managedBy = newValue}
  }

  /// Key to use within the compute cluster for all requests to the API.
  /// You can post with the key.id filled in to set the key for the compute cluster.
  /// The responses will intentionaly only return the description of the key for security
  /// purposes since you may have other people through orgs/teams having access to this compute
  /// cluster who should not view your key.
  /// This must be a valid key created before creating the ComputeCluster.
  /// Deleting this key will not be prevented, which means all resources in this ComputeCluster
  /// will lose connection to the API, so delete keys at your own risk.
  /// The user_id who owns the key must match the user_id provided in the ComputeCluster.
  public var key: Clarifai_Api_Key {
    get {return _storage._key ?? Clarifai_Api_Key()}
    set {_uniqueStorage()._key = newValue}
  }
  /// Returns true if `key` has been explicitly set.
  public var hasKey: Bool {return _storage._key != nil}
  /// Clears the value of `key`. Subsequent reads from it will return its default value.
  public mutating func clearKey() {_uniqueStorage()._key = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// These are the resource needs of a given API object such as a model.
/// This is what they require as a minimum to run and will be used upon scheduling
/// as the request and limit for the k8s pod. If we want to separate limits and requests in the
/// future we can allow setting a limits ComputeInfo and a requests ComputeInfo.
public struct Clarifai_Api_ComputeInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Amount of CPUs to use. This follows kubernetes notation like: "1", "100m", "4.5", etc.
  /// See https://kubernetes.io/docs/reference/kubernetes-api/common-definitions/quantity/
  public var cpuLimit: String = String()

  /// Amount of CPU memory to use as a minimum. This follows kubernetes notation like:
  /// 1Ki, 1500Mi, 3Gi, 4Ti, etc.
  /// See https://kubernetes.io/docs/reference/kubernetes-api/common-definitions/quantity/
  public var cpuMemory: String = String()

  /// Amount of GPU/TPUs to use.
  public var numAccelerators: UInt32 = 0

  /// Amount of accelerator/GPU memory to use as a minimum.
  /// This is defined per accelerator.
  /// This follows the format used by kubernetes like 1Ki, 2Mi, 3Gi, 4Ti.
  /// See https://kubernetes.io/docs/reference/kubernetes-api/common-definitions/quantity/
  public var acceleratorMemory: String = String()

  /// Or should it be removed completely and use the nodepool accelerator type itself.
  /// These are the supported accelerators that the model can run on.
  public var acceleratorType: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// It might be better to do this as runner autoscaling so that resources
/// of a model are very simply what that model needs at minimum.
/// Note that resources for things like modes inside runners are not
/// related to how many replicas of those runners are needed to handle traffic.
public struct Clarifai_Api_AutoscaleConfig {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The minimum number of replicas for the runner to have.
  /// Defaults to 0 which means autoscaling can scale down to zero.
  /// If you want a replica always up then set to >= 1.
  public var minReplicas: UInt32 = 0

  /// The maximium number of replicas to scale up the runner to.
  public var maxReplicas: UInt32 = 0

  /// The number of seconds of traffic history to consider when autoscaling.
  public var trafficHistorySeconds: UInt32 = 0

  /// The time to wait before scaling down after the last request.
  public var scaleDownDelaySeconds: UInt32 = 0

  /// The time to wait between scaling up replicas without burst traffic.
  public var scaleUpDelaySeconds: UInt32 = 0

  /// Depending on your plan you may be able to enable packing of resources into a single node
  /// for more compute and cost efficiency.
  public var disablePacking: Bool = false

  /// The idle time before scaling down to zero
  public var scaleToZeroDelaySeconds: UInt32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// A deployment allows you to configure how runners for a particular type of resource will
/// scale up and down. These are unique per user_id, nodepool and model so for differnet nodepools
/// you can scale differently.
public struct Clarifai_Api_Deployment {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// An id for this configured deployment.
  public var id: String {
    get {return _storage._id}
    set {_uniqueStorage()._id = newValue}
  }

  /// The user who owns the deployment. These live in the user/org account.
  public var userID: String {
    get {return _storage._userID}
    set {_uniqueStorage()._userID = newValue}
  }

  /// How to autoscale the object.
  public var autoscaleConfig: Clarifai_Api_AutoscaleConfig {
    get {return _storage._autoscaleConfig ?? Clarifai_Api_AutoscaleConfig()}
    set {_uniqueStorage()._autoscaleConfig = newValue}
  }
  /// Returns true if `autoscaleConfig` has been explicitly set.
  public var hasAutoscaleConfig: Bool {return _storage._autoscaleConfig != nil}
  /// Clears the value of `autoscaleConfig`. Subsequent reads from it will return its default value.
  public mutating func clearAutoscaleConfig() {_uniqueStorage()._autoscaleConfig = nil}

  /// You can configure different autoscaling per nodepool(s).
  /// These nodepools have to be also owned by the same user_id/org as this deployment.
  /// If there is more than one nodepool we use the model's ComputeInfo to match
  /// with what the nodepool provides to decide which one can handle it combined with the
  /// NodepoolRank below. Note: even within a single nodepool if it is heterogeneous then
  /// we need a way to rank scheduling choices when we don't know how to decide (like a model
  /// supports
  public var nodepools: [Clarifai_Api_Nodepool] {
    get {return _storage._nodepools}
    set {_uniqueStorage()._nodepools = newValue}
  }

  public var schedulingChoice: Clarifai_Api_Deployment.SchedulingChoice {
    get {return _storage._schedulingChoice}
    set {_uniqueStorage()._schedulingChoice = newValue}
  }

  /// The visibility field represents whether this message is privately/publicly visible.
  /// To be visible to the public the App that contains it AND the User that contains the App must
  /// also be publicly visible.
  public var visibility: Clarifai_Api_Visibility {
    get {return _storage._visibility ?? Clarifai_Api_Visibility()}
    set {_uniqueStorage()._visibility = newValue}
  }
  /// Returns true if `visibility` has been explicitly set.
  public var hasVisibility: Bool {return _storage._visibility != nil}
  /// Clears the value of `visibility`. Subsequent reads from it will return its default value.
  public mutating func clearVisibility() {_uniqueStorage()._visibility = nil}

  /// To handle arbitrary json metadata:
  /// https://github.com/google/protobuf/blob/master/src/google/protobuf/struct.proto
  public var metadata: SwiftProtobuf.Google_Protobuf_Struct {
    get {return _storage._metadata ?? SwiftProtobuf.Google_Protobuf_Struct()}
    set {_uniqueStorage()._metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  public var hasMetadata: Bool {return _storage._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  public mutating func clearMetadata() {_uniqueStorage()._metadata = nil}

  /// Short description of deployment.
  public var description_p: String {
    get {return _storage._description_p}
    set {_uniqueStorage()._description_p = newValue}
  }

  /// The thing that the autoscaling config applies to for this nodepool.
  /// For a given user_id, nodepool_id, and object ID we can only have one deployment as it defines
  public var worker: Clarifai_Api_Worker {
    get {return _storage._worker ?? Clarifai_Api_Worker()}
    set {_uniqueStorage()._worker = newValue}
  }
  /// Returns true if `worker` has been explicitly set.
  public var hasWorker: Bool {return _storage._worker != nil}
  /// Clears the value of `worker`. Subsequent reads from it will return its default value.
  public mutating func clearWorker() {_uniqueStorage()._worker = nil}

  /// When the deployment was created.
  public var createdAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._createdAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._createdAt = newValue}
  }
  /// Returns true if `createdAt` has been explicitly set.
  public var hasCreatedAt: Bool {return _storage._createdAt != nil}
  /// Clears the value of `createdAt`. Subsequent reads from it will return its default value.
  public mutating func clearCreatedAt() {_uniqueStorage()._createdAt = nil}

  /// When the deployment was last modified.
  public var modifiedAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._modifiedAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._modifiedAt = newValue}
  }
  /// Returns true if `modifiedAt` has been explicitly set.
  public var hasModifiedAt: Bool {return _storage._modifiedAt != nil}
  /// Clears the value of `modifiedAt`. Subsequent reads from it will return its default value.
  public mutating func clearModifiedAt() {_uniqueStorage()._modifiedAt = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// In some scenarios it may not be obvous how we should schedule a resource to underlying nodes
  /// within the nodepool(s) above. The SchedulerChoice allows us to specify how to decide which
  /// nodepool to use when there are multiple nodepools and how to decide which type of node
  /// within a nodepool if there are multiple types.
  /// If here are multiple nondepools then a decision on which to use comes into play
  /// if it is not specified in the prediction request.
  /// Even with a single nodepool a choice may come up such as when a resource that needs scheduling
  /// has not specified the accelerator types it supports and the nodepool has multiple types.
  public enum SchedulingChoice: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case unknownSchedulingChoice // = 0

    /// fail if there is any ambiguity.
    case fail // = 1

    /// randomly pick amongst the nodepools/nodes to assign.
    case random // = 2

    /// choose the compute that is cheaper
    case price // = 3

    /// schedule to the fastest known iption.
    case performance // = 4

    /// optimize based on network latency.
    case network // = 5

    /// send to the least used nodepool based on it's capacity.
    case utilization // = 6

    /// choose spot instances over on-demand
    case preferSpot // = 7

    /// choose on-demand instances over spot.
    case preferOndemand // = 8
    case UNRECOGNIZED(Int)

    public init() {
      self = .unknownSchedulingChoice
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknownSchedulingChoice
      case 1: self = .fail
      case 2: self = .random
      case 3: self = .price
      case 4: self = .performance
      case 5: self = .network
      case 6: self = .utilization
      case 7: self = .preferSpot
      case 8: self = .preferOndemand
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unknownSchedulingChoice: return 0
      case .fail: return 1
      case .random: return 2
      case .price: return 3
      case .performance: return 4
      case .network: return 5
      case .utilization: return 6
      case .preferSpot: return 7
      case .preferOndemand: return 8
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

#if swift(>=4.2)

extension Clarifai_Api_Deployment.SchedulingChoice: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Clarifai_Api_Deployment.SchedulingChoice] = [
    .unknownSchedulingChoice,
    .fail,
    .random,
    .price,
    .performance,
    .network,
    .utilization,
    .preferSpot,
    .preferOndemand,
  ]
}

#endif  // swift(>=4.2)

///////////////////////////////////////////
/// Don't need RunnerSelector if we're opening up endpoints for deployments.
///////////////////////////////////////////
/// The RunnerSelector is an optional field we can provide during runtime
/// of model/workflow predictions to specify which particular runner we want to process the work.
/// This can optionally be used to select a particular nodepool and then within that nodepool
/// a particular runner.
public struct Clarifai_Api_RunnerSelector {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// A particular nodepool for the resource to be run within. This request the id and user_id of
  /// the nodepool to be specified. Runners will be scaled according to a deployment for the given
  /// resource to be run. There should not be more than one deployment in this nodepool for the
  /// particular resource to run. If no deployments then default autoscaling will be used.
  public var nodepool: Clarifai_Api_Nodepool {
    get {return _storage._nodepool ?? Clarifai_Api_Nodepool()}
    set {_uniqueStorage()._nodepool = newValue}
  }
  /// Returns true if `nodepool` has been explicitly set.
  public var hasNodepool: Bool {return _storage._nodepool != nil}
  /// Clears the value of `nodepool`. Subsequent reads from it will return its default value.
  public mutating func clearNodepool() {_uniqueStorage()._nodepool = nil}

  /// Optionally a partcular runner within the nodepool.
  public var runner: Clarifai_Api_Runner {
    get {return _storage._runner ?? Clarifai_Api_Runner()}
    set {_uniqueStorage()._runner = newValue}
  }
  /// Returns true if `runner` has been explicitly set.
  public var hasRunner: Bool {return _storage._runner != nil}
  /// Clears the value of `runner`. Subsequent reads from it will return its default value.
  public mutating func clearRunner() {_uniqueStorage()._runner = nil}

  /// Optionally a partcular deployment within the nodepool.
  public var deployment: Clarifai_Api_Deployment {
    get {return _storage._deployment ?? Clarifai_Api_Deployment()}
    set {_uniqueStorage()._deployment = newValue}
  }
  /// Returns true if `deployment` has been explicitly set.
  public var hasDeployment: Bool {return _storage._deployment != nil}
  /// Clears the value of `deployment`. Subsequent reads from it will return its default value.
  public mutating func clearDeployment() {_uniqueStorage()._deployment = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Processing info tells the runner how to process a RunnerItem
public struct Clarifai_Api_ProcessingInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The type of method witin the runner to call.
  public var runnerMethodType: Clarifai_Api_RunnerMethodType = .unknown

  /// A status of the processing. We use this for signalling end of a request stream, a runner
  /// item's processing should be cancelled, etc.
  public var status: Clarifai_Api_Status_Status {
    get {return _status ?? Clarifai_Api_Status_Status()}
    set {_status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  public var hasStatus: Bool {return self._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  public mutating func clearStatus() {self._status = nil}

  /// Internal field to track processing. Runners will not have access to this.
  public var processingID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _status: Clarifai_Api_Status_Status? = nil
}

/// AuditLogTarget is a resource on which an operation recorded in an
/// audit log was performed.
public struct Clarifai_Api_AuditLogTarget {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var target: Clarifai_Api_AuditLogTarget.OneOf_Target? = nil

  public var user: Clarifai_Api_User {
    get {
      if case .user(let v)? = target {return v}
      return Clarifai_Api_User()
    }
    set {target = .user(newValue)}
  }

  public var role: Clarifai_Api_Role {
    get {
      if case .role(let v)? = target {return v}
      return Clarifai_Api_Role()
    }
    set {target = .role(newValue)}
  }

  public var team: Clarifai_Api_Team {
    get {
      if case .team(let v)? = target {return v}
      return Clarifai_Api_Team()
    }
    set {target = .team(newValue)}
  }

  public var app: Clarifai_Api_App {
    get {
      if case .app(let v)? = target {return v}
      return Clarifai_Api_App()
    }
    set {target = .app(newValue)}
  }

  public var module: Clarifai_Api_Module {
    get {
      if case .module(let v)? = target {return v}
      return Clarifai_Api_Module()
    }
    set {target = .module(newValue)}
  }

  public var moduleVersion: Clarifai_Api_ModuleVersion {
    get {
      if case .moduleVersion(let v)? = target {return v}
      return Clarifai_Api_ModuleVersion()
    }
    set {target = .moduleVersion(newValue)}
  }

  public var workflow: Clarifai_Api_Workflow {
    get {
      if case .workflow(let v)? = target {return v}
      return Clarifai_Api_Workflow()
    }
    set {target = .workflow(newValue)}
  }

  public var workflowVersion: Clarifai_Api_WorkflowVersion {
    get {
      if case .workflowVersion(let v)? = target {return v}
      return Clarifai_Api_WorkflowVersion()
    }
    set {target = .workflowVersion(newValue)}
  }

  public var model: Clarifai_Api_Model {
    get {
      if case .model(let v)? = target {return v}
      return Clarifai_Api_Model()
    }
    set {target = .model(newValue)}
  }

  public var modelVersion: Clarifai_Api_ModelVersion {
    get {
      if case .modelVersion(let v)? = target {return v}
      return Clarifai_Api_ModelVersion()
    }
    set {target = .modelVersion(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Target: Equatable {
    case user(Clarifai_Api_User)
    case role(Clarifai_Api_Role)
    case team(Clarifai_Api_Team)
    case app(Clarifai_Api_App)
    case module(Clarifai_Api_Module)
    case moduleVersion(Clarifai_Api_ModuleVersion)
    case workflow(Clarifai_Api_Workflow)
    case workflowVersion(Clarifai_Api_WorkflowVersion)
    case model(Clarifai_Api_Model)
    case modelVersion(Clarifai_Api_ModelVersion)

  #if !swift(>=4.1)
    public static func ==(lhs: Clarifai_Api_AuditLogTarget.OneOf_Target, rhs: Clarifai_Api_AuditLogTarget.OneOf_Target) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.user, .user): return {
        guard case .user(let l) = lhs, case .user(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.role, .role): return {
        guard case .role(let l) = lhs, case .role(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.team, .team): return {
        guard case .team(let l) = lhs, case .team(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.app, .app): return {
        guard case .app(let l) = lhs, case .app(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.module, .module): return {
        guard case .module(let l) = lhs, case .module(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.moduleVersion, .moduleVersion): return {
        guard case .moduleVersion(let l) = lhs, case .moduleVersion(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.workflow, .workflow): return {
        guard case .workflow(let l) = lhs, case .workflow(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.workflowVersion, .workflowVersion): return {
        guard case .workflowVersion(let l) = lhs, case .workflowVersion(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.model, .model): return {
        guard case .model(let l) = lhs, case .model(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.modelVersion, .modelVersion): return {
        guard case .modelVersion(let l) = lhs, case .modelVersion(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

/// AuditLogEntry is a single operation recorded in an audit log.
public struct Clarifai_Api_AuditLogEntry {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Time of the operation.
  public var timestamp: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _timestamp ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_timestamp = newValue}
  }
  /// Returns true if `timestamp` has been explicitly set.
  public var hasTimestamp: Bool {return self._timestamp != nil}
  /// Clears the value of `timestamp`. Subsequent reads from it will return its default value.
  public mutating func clearTimestamp() {self._timestamp = nil}

  /// User that performed the operation.
  public var user: Clarifai_Api_User {
    get {return _user ?? Clarifai_Api_User()}
    set {_user = newValue}
  }
  /// Returns true if `user` has been explicitly set.
  public var hasUser: Bool {return self._user != nil}
  /// Clears the value of `user`. Subsequent reads from it will return its default value.
  public mutating func clearUser() {self._user = nil}

  /// Type of operation that was performed.
  public var operation: Clarifai_Api_EventType = .notSet

  /// A human-readable description of the operation.
  public var description_p: String = String()

  /// Targets of the operation. For example,
  /// - when creating a new model, the targets would be the application and the model,
  /// - when adding a team member, the targets would be the team and the member.
  public var targets: [Clarifai_Api_AuditLogTarget] = []

  /// Additional human-readable details of the operation. For example,
  /// when patching a resource, these would list what was changed.
  public var details: [String] = []

  /// Was the operation successful?
  public var success: Bool = false

  /// Request that triggered the operation.
  public var reqID: String = String()

  /// IP address where the request originated from.
  public var sourceIp: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _timestamp: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _user: Clarifai_Api_User? = nil
}

/// AuditLogQuery is a query for audit log entries.
public struct Clarifai_Api_AuditLogQuery {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Query operations within this time range.
  public var timestampFrom: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _timestampFrom ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_timestampFrom = newValue}
  }
  /// Returns true if `timestampFrom` has been explicitly set.
  public var hasTimestampFrom: Bool {return self._timestampFrom != nil}
  /// Clears the value of `timestampFrom`. Subsequent reads from it will return its default value.
  public mutating func clearTimestampFrom() {self._timestampFrom = nil}

  public var timestampTo: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _timestampTo ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_timestampTo = newValue}
  }
  /// Returns true if `timestampTo` has been explicitly set.
  public var hasTimestampTo: Bool {return self._timestampTo != nil}
  /// Clears the value of `timestampTo`. Subsequent reads from it will return its default value.
  public mutating func clearTimestampTo() {self._timestampTo = nil}

  /// Query operations by these users.
  public var userIds: [String] = []

  /// Query these types of operations.
  public var operations: [Clarifai_Api_EventType] = []

  /// Query operations with these targets.
  public var targets: [Clarifai_Api_AuditLogTarget] = []

  /// Query operations by success.
  public var success: SwiftProtobuf.Google_Protobuf_BoolValue {
    get {return _success ?? SwiftProtobuf.Google_Protobuf_BoolValue()}
    set {_success = newValue}
  }
  /// Returns true if `success` has been explicitly set.
  public var hasSuccess: Bool {return self._success != nil}
  /// Clears the value of `success`. Subsequent reads from it will return its default value.
  public mutating func clearSuccess() {self._success = nil}

  /// Query operations by source IP address.
  public var sourceIps: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _timestampFrom: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _timestampTo: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _success: SwiftProtobuf.Google_Protobuf_BoolValue? = nil
}

public struct Clarifai_Api_WorkflowVersionEvaluationMetric {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: String = String()

  public var summary: String = String()

  public var description_p: String = String()

  /// Metric data type - string, float, int
  public var dataType: Clarifai_Api_WorkflowVersionEvaluationMetric.DataType = .notSet

  public var visualisationType: Clarifai_Api_WorkflowVersionEvaluationMetric.VisualisationType = .visualizationTypeNotSet

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Enum for data types
  public enum DataType: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case notSet // = 0
    case float // = 1
    case UNRECOGNIZED(Int)

    public init() {
      self = .notSet
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .notSet
      case 1: self = .float
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .notSet: return 0
      case .float: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  /// Enum for visualization types
  public enum VisualisationType: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case visualizationTypeNotSet // = 0
    case confusionMatrix // = 1
    case precisionRecallCurve // = 2
    case rocAucCurve // = 3
    case UNRECOGNIZED(Int)

    public init() {
      self = .visualizationTypeNotSet
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .visualizationTypeNotSet
      case 1: self = .confusionMatrix
      case 2: self = .precisionRecallCurve
      case 3: self = .rocAucCurve
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .visualizationTypeNotSet: return 0
      case .confusionMatrix: return 1
      case .precisionRecallCurve: return 2
      case .rocAucCurve: return 3
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Clarifai_Api_WorkflowVersionEvaluationMetric.DataType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Clarifai_Api_WorkflowVersionEvaluationMetric.DataType] = [
    .notSet,
    .float,
  ]
}

extension Clarifai_Api_WorkflowVersionEvaluationMetric.VisualisationType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Clarifai_Api_WorkflowVersionEvaluationMetric.VisualisationType] = [
    .visualizationTypeNotSet,
    .confusionMatrix,
    .precisionRecallCurve,
    .rocAucCurve,
  ]
}

#endif  // swift(>=4.2)

public struct Clarifai_Api_WorkflowVersionEvaluationTemplate {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: String = String()

  public var description_p: String = String()

  /// Applicable for the task types like TextClassification, TextGeneration, etc
  public var taskTypes: [Clarifai_Api_WorkflowVersionEvaluationTemplate.TaskType] = []

  /// The Workflow Evaluation template metrics
  public var workflowVersionEvaluationMetrics: [Clarifai_Api_WorkflowVersionEvaluationMetric] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum TaskType: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case notSet // = 0
    case textClassification // = 1
    case UNRECOGNIZED(Int)

    public init() {
      self = .notSet
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .notSet
      case 1: self = .textClassification
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .notSet: return 0
      case .textClassification: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Clarifai_Api_WorkflowVersionEvaluationTemplate.TaskType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Clarifai_Api_WorkflowVersionEvaluationTemplate.TaskType] = [
    .notSet,
    .textClassification,
  ]
}

#endif  // swift(>=4.2)

/// ComputePlaneMetrics captures the compute plane metrics to send back to the control plane.
/// Each message should have the meta filled and one or more of the other fields.
public struct Clarifai_Api_ComputePlaneMetrics {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Who and where the metrics are from.
  public var meta: Clarifai_Api_ComputeSourceMetadata {
    get {return _storage._meta ?? Clarifai_Api_ComputeSourceMetadata()}
    set {_uniqueStorage()._meta = newValue}
  }
  /// Returns true if `meta` has been explicitly set.
  public var hasMeta: Bool {return _storage._meta != nil}
  /// Clears the value of `meta`. Subsequent reads from it will return its default value.
  public mutating func clearMeta() {_uniqueStorage()._meta = nil}

  /// e.g. aws, azure, on-prem.
  public var cloud: String {
    get {return _storage._cloud}
    set {_uniqueStorage()._cloud = newValue}
  }

  /// e.g. us-east, us-west.
  public var region: String {
    get {return _storage._region}
    set {_uniqueStorage()._region = newValue}
  }

  /// e.g. t3a.medium, g5.xlarge.
  public var instanceType: String {
    get {return _storage._instanceType}
    set {_uniqueStorage()._instanceType = newValue}
  }

  /// e.g. spot, on-demand.
  public var reservationType: String {
    get {return _storage._reservationType}
    set {_uniqueStorage()._reservationType = newValue}
  }

  /// Metrics billing
  public var reservationPrice: Float {
    get {return _storage._reservationPrice}
    set {_uniqueStorage()._reservationPrice = newValue}
  }

  /// Runtime in seconds.
  public var runtimeS: Int32 {
    get {return _storage._runtimeS}
    set {_uniqueStorage()._runtimeS = newValue}
  }

  /// Metrics for latency.
  public var timestamp: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._timestamp ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._timestamp = newValue}
  }
  /// Returns true if `timestamp` has been explicitly set.
  public var hasTimestamp: Bool {return _storage._timestamp != nil}
  /// Clears the value of `timestamp`. Subsequent reads from it will return its default value.
  public mutating func clearTimestamp() {_uniqueStorage()._timestamp = nil}

  /// e.g. NodeProvisioned, NodeTerminated, ModelDeployed, ModelScheduled, ModelReady.
  public var eventType: String {
    get {return _storage._eventType}
    set {_uniqueStorage()._eventType = newValue}
  }

  /// GPU metrics.
  public var gpuMetrics: [Clarifai_Api_GpuMetrics] {
    get {return _storage._gpuMetrics}
    set {_uniqueStorage()._gpuMetrics = newValue}
  }

  /// Hostname of the node.
  public var hostname: String {
    get {return _storage._hostname}
    set {_uniqueStorage()._hostname = newValue}
  }

  /// CPU metrics.
  public var cpuMetrics: [Clarifai_Api_CpuMetrics] {
    get {return _storage._cpuMetrics}
    set {_uniqueStorage()._cpuMetrics = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Clarifai_Api_GpuMetrics {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// GPU UUID.
  public var uuid: String = String()

  /// GPU model name. e.g. NVIDIA_A10G
  public var modelName: String = String()

  /// GPU utilization. e.g. DCGM_FI_DEV_GPU_UTIL
  public var utilizationPct: Float = 0

  /// Tensor utilization. e.g. DCGM_FI_PROF_PIPE_TENSOR_ACTIVE
  public var tensorUtilizationPct: Float = 0

  /// Memory utilization. e.g. DCGM_FI_PROF_DRAM_ACTIVE
  public var memoryUtilizationPct: Float = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Clarifai_Api_CpuMetrics {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Time of the event.
  public var timestamp: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _timestamp ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_timestamp = newValue}
  }
  /// Returns true if `timestamp` has been explicitly set.
  public var hasTimestamp: Bool {return self._timestamp != nil}
  /// Clears the value of `timestamp`. Subsequent reads from it will return its default value.
  public mutating func clearTimestamp() {self._timestamp = nil}

  /// CPU utilization.
  public var cpuUtilizationPct: Float = 0

  /// Memory utilization.
  public var memoryUtilizationPct: Float = 0

  /// CPU millicores.
  public var millicores: Int64 = 0

  /// Memory bytes.
  public var memoryBytes: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _timestamp: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

/// LogEntry is a single technical log entry (e.g. service log, stack traces, etc).
public struct Clarifai_Api_LogEntry {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Text of the log entry.
  public var message: String = String()

  /// The type of log entry. Examples: model, agent, build, training.
  public var logType: String = String()

  /// URL to log file or stream.
  public var url: String = String()

  /// Who and where the metrics are from.
  public var meta: Clarifai_Api_ComputeSourceMetadata {
    get {return _meta ?? Clarifai_Api_ComputeSourceMetadata()}
    set {_meta = newValue}
  }
  /// Returns true if `meta` has been explicitly set.
  public var hasMeta: Bool {return self._meta != nil}
  /// Clears the value of `meta`. Subsequent reads from it will return its default value.
  public mutating func clearMeta() {self._meta = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _meta: Clarifai_Api_ComputeSourceMetadata? = nil
}

/// ComputeSourceMetadata describes the source of something computed. The who and where.
public struct Clarifai_Api_ComputeSourceMetadata {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The user app id, if any.
  public var userAppID: Clarifai_Api_UserAppIDSet {
    get {return _userAppID ?? Clarifai_Api_UserAppIDSet()}
    set {_userAppID = newValue}
  }
  /// Returns true if `userAppID` has been explicitly set.
  public var hasUserAppID: Bool {return self._userAppID != nil}
  /// Clears the value of `userAppID`. Subsequent reads from it will return its default value.
  public mutating func clearUserAppID() {self._userAppID = nil}

  /// The Model ID, if any.
  public var modelID: String = String()

  /// The Version ID, if any.
  public var modelVersionID: String = String()

  /// Workflow Id, if any.
  public var workflowID: String = String()

  /// Compute Cluster, Nodepool, Runner.
  public var computeClusterID: String = String()

  public var nodepoolID: String = String()

  public var runnerID: String = String()

  /// Pipeline related data, if any
  public var pipelineID: String = String()

  public var pipelineVersionID: String = String()

  public var pipelineVersionRunID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _userAppID: Clarifai_Api_UserAppIDSet? = nil
}

public struct Clarifai_Api_WorkflowVersionEvaluation {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Customer-Facing / External ID of the workflow version evaluation.
  public var id: String {
    get {return _storage._id}
    set {_uniqueStorage()._id = newValue}
  }

  /// The ID of the workflow that is used for evaluation.
  public var workflowID: String {
    get {return _storage._workflowID}
    set {_uniqueStorage()._workflowID = newValue}
  }

  /// The version of the workflow that is used for evaluation.
  public var workflowVersionID: String {
    get {return _storage._workflowVersionID}
    set {_uniqueStorage()._workflowVersionID = newValue}
  }

  /// The ID of the ground-truth dataset that is used for evaluation.
  public var groundTruthDatasetID: String {
    get {return _storage._groundTruthDatasetID}
    set {_uniqueStorage()._groundTruthDatasetID = newValue}
  }

  /// The version ID of the ground-truth dataset that is used for evaluation.
  public var groundTruthDatasetVersionID: String {
    get {return _storage._groundTruthDatasetVersionID}
    set {_uniqueStorage()._groundTruthDatasetVersionID = newValue}
  }

  /// The ID of the prediction dataset that is used for evaluation.
  public var predictionsDatasetID: String {
    get {return _storage._predictionsDatasetID}
    set {_uniqueStorage()._predictionsDatasetID = newValue}
  }

  /// The version ID of the prediction dataset that is used for evaluation.
  public var predictionsDatasetVersionID: String {
    get {return _storage._predictionsDatasetVersionID}
    set {_uniqueStorage()._predictionsDatasetVersionID = newValue}
  }

  /// Evaluation Template ID
  public var evaluationTemplateID: String {
    get {return _storage._evaluationTemplateID}
    set {_uniqueStorage()._evaluationTemplateID = newValue}
  }

  /// The evaluation results
  public var workflowEvaluationResult: Clarifai_Api_WorkflowEvaluationResult {
    get {return _storage._workflowEvaluationResult ?? Clarifai_Api_WorkflowEvaluationResult()}
    set {_uniqueStorage()._workflowEvaluationResult = newValue}
  }
  /// Returns true if `workflowEvaluationResult` has been explicitly set.
  public var hasWorkflowEvaluationResult: Bool {return _storage._workflowEvaluationResult != nil}
  /// Clears the value of `workflowEvaluationResult`. Subsequent reads from it will return its default value.
  public mutating func clearWorkflowEvaluationResult() {_uniqueStorage()._workflowEvaluationResult = nil}

  /// Status of the evaluation
  public var status: Clarifai_Api_Status_Status {
    get {return _storage._status ?? Clarifai_Api_Status_Status()}
    set {_uniqueStorage()._status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  public var hasStatus: Bool {return _storage._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  public mutating func clearStatus() {_uniqueStorage()._status = nil}

  /// When the workflow version evaluation was created.
  public var createdAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._createdAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._createdAt = newValue}
  }
  /// Returns true if `createdAt` has been explicitly set.
  public var hasCreatedAt: Bool {return _storage._createdAt != nil}
  /// Clears the value of `createdAt`. Subsequent reads from it will return its default value.
  public mutating func clearCreatedAt() {_uniqueStorage()._createdAt = nil}

  /// When the workflow version evaluation was modified.
  public var modifiedAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._modifiedAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._modifiedAt = newValue}
  }
  /// Returns true if `modifiedAt` has been explicitly set.
  public var hasModifiedAt: Bool {return _storage._modifiedAt != nil}
  /// Clears the value of `modifiedAt`. Subsequent reads from it will return its default value.
  public mutating func clearModifiedAt() {_uniqueStorage()._modifiedAt = nil}

  /// The ID of the node that is being evaluated.
  public var targetNodeID: String {
    get {return _storage._targetNodeID}
    set {_uniqueStorage()._targetNodeID = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Clarifai_Api_WorkflowEvaluationResult {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The summary of the evaluation result.
  public var summary: Clarifai_Api_WorkflowEvaluationResultSummary {
    get {return _summary ?? Clarifai_Api_WorkflowEvaluationResultSummary()}
    set {_summary = newValue}
  }
  /// Returns true if `summary` has been explicitly set.
  public var hasSummary: Bool {return self._summary != nil}
  /// Clears the value of `summary`. Subsequent reads from it will return its default value.
  public mutating func clearSummary() {self._summary = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _summary: Clarifai_Api_WorkflowEvaluationResultSummary? = nil
}

public struct Clarifai_Api_WorkflowEvaluationResultSummary {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The evaluation metrics.
  public var evaluationMetricValues: [Clarifai_Api_EvaluationMetricValue] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Clarifai_Api_EvaluationMetricValue {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The metric values
  public var evaluationMetricID: String = String()

  /// Aggregated metric value
  public var metricValue: Clarifai_Api_MetricValue {
    get {return _metricValue ?? Clarifai_Api_MetricValue()}
    set {_metricValue = newValue}
  }
  /// Returns true if `metricValue` has been explicitly set.
  public var hasMetricValue: Bool {return self._metricValue != nil}
  /// Clears the value of `metricValue`. Subsequent reads from it will return its default value.
  public mutating func clearMetricValue() {self._metricValue = nil}

  /// explanation for the value
  public var explanation: String = String()

  /// Metric values for each concept
  public var perConceptValues: Dictionary<String,Clarifai_Api_MetricValue> = [:]

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _metricValue: Clarifai_Api_MetricValue? = nil
}

public struct Clarifai_Api_MetricValue {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var metricValue: Clarifai_Api_MetricValue.OneOf_MetricValue? = nil

  public var stringValue: String {
    get {
      if case .stringValue(let v)? = metricValue {return v}
      return String()
    }
    set {metricValue = .stringValue(newValue)}
  }

  public var floatValue: Float {
    get {
      if case .floatValue(let v)? = metricValue {return v}
      return 0
    }
    set {metricValue = .floatValue(newValue)}
  }

  public var intValue: Int32 {
    get {
      if case .intValue(let v)? = metricValue {return v}
      return 0
    }
    set {metricValue = .intValue(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_MetricValue: Equatable {
    case stringValue(String)
    case floatValue(Float)
    case intValue(Int32)

  #if !swift(>=4.1)
    public static func ==(lhs: Clarifai_Api_MetricValue.OneOf_MetricValue, rhs: Clarifai_Api_MetricValue.OneOf_MetricValue) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.stringValue, .stringValue): return {
        guard case .stringValue(let l) = lhs, case .stringValue(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.floatValue, .floatValue): return {
        guard case .floatValue(let l) = lhs, case .floatValue(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.intValue, .intValue): return {
        guard case .intValue(let l) = lhs, case .intValue(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

public struct Clarifai_Api_ArgoOrchestrationSpec {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The API version of the orchestration specification.
  /// Example: "argoproj.io/v1alpha1", "argoproj.io/v1beta1"
  public var apiVersion: String = String()

  /// The JSON representation of the Argo orchestration specification.
  public var specJson: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Clarifai_Api_OrchestrationSpec {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var orchestration: Clarifai_Api_OrchestrationSpec.OneOf_Orchestration? = nil

  /// Argo orchestration specification
  public var argoOrchestrationSpec: Clarifai_Api_ArgoOrchestrationSpec {
    get {
      if case .argoOrchestrationSpec(let v)? = orchestration {return v}
      return Clarifai_Api_ArgoOrchestrationSpec()
    }
    set {orchestration = .argoOrchestrationSpec(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Orchestration: Equatable {
    /// Argo orchestration specification
    case argoOrchestrationSpec(Clarifai_Api_ArgoOrchestrationSpec)

  #if !swift(>=4.1)
    public static func ==(lhs: Clarifai_Api_OrchestrationSpec.OneOf_Orchestration, rhs: Clarifai_Api_OrchestrationSpec.OneOf_Orchestration) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.argoOrchestrationSpec, .argoOrchestrationSpec): return {
        guard case .argoOrchestrationSpec(let l) = lhs, case .argoOrchestrationSpec(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      }
    }
  #endif
  }

  public init() {}
}

public struct Clarifai_Api_PipelineVersion {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: String = String()

  /// The app the pipeline version belongs to.
  public var appID: String = String()

  /// The user the pipeline version belongs to.
  public var userID: String = String()

  /// Orchestration Specification using oneof
  public var orchestrationSpec: Clarifai_Api_OrchestrationSpec {
    get {return _orchestrationSpec ?? Clarifai_Api_OrchestrationSpec()}
    set {_orchestrationSpec = newValue}
  }
  /// Returns true if `orchestrationSpec` has been explicitly set.
  public var hasOrchestrationSpec: Bool {return self._orchestrationSpec != nil}
  /// Clears the value of `orchestrationSpec`. Subsequent reads from it will return its default value.
  public mutating func clearOrchestrationSpec() {self._orchestrationSpec = nil}

  /// Pipeline's Id
  public var pipelineID: String = String()

  /// Short description about this pipeline version
  public var description_p: String = String()

  /// The visibility field represents whether this message is privately/publicly visible.
  /// To be visible to the public the App that contains it AND the User that contains the App must
  /// also be publicly visible.
  public var visibility: Clarifai_Api_Visibility {
    get {return _visibility ?? Clarifai_Api_Visibility()}
    set {_visibility = newValue}
  }
  /// Returns true if `visibility` has been explicitly set.
  public var hasVisibility: Bool {return self._visibility != nil}
  /// Clears the value of `visibility`. Subsequent reads from it will return its default value.
  public mutating func clearVisibility() {self._visibility = nil}

  /// To handle arbitrary json metadata, use a struct field
  /// https://github.com/google/protobuf/blob/master/src/google/protobuf/struct.proto
  public var metadata: SwiftProtobuf.Google_Protobuf_Struct {
    get {return _metadata ?? SwiftProtobuf.Google_Protobuf_Struct()}
    set {_metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  public var hasMetadata: Bool {return self._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  public mutating func clearMetadata() {self._metadata = nil}

  /// When the pipeline was created
  public var createdAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _createdAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_createdAt = newValue}
  }
  /// Returns true if `createdAt` has been explicitly set.
  public var hasCreatedAt: Bool {return self._createdAt != nil}
  /// Clears the value of `createdAt`. Subsequent reads from it will return its default value.
  public mutating func clearCreatedAt() {self._createdAt = nil}

  /// When the pipeline was last modified
  public var modifiedAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _modifiedAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_modifiedAt = newValue}
  }
  /// Returns true if `modifiedAt` has been explicitly set.
  public var hasModifiedAt: Bool {return self._modifiedAt != nil}
  /// Clears the value of `modifiedAt`. Subsequent reads from it will return its default value.
  public mutating func clearModifiedAt() {self._modifiedAt = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _orchestrationSpec: Clarifai_Api_OrchestrationSpec? = nil
  fileprivate var _visibility: Clarifai_Api_Visibility? = nil
  fileprivate var _metadata: SwiftProtobuf.Google_Protobuf_Struct? = nil
  fileprivate var _createdAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _modifiedAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

public struct Clarifai_Api_OrchestrationStatus {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Oneof field for extensibility, supporting different orchestration systems
  public var statusDetails: Clarifai_Api_OrchestrationStatus.OneOf_StatusDetails? = nil

  /// Status for Argo Workflow
  public var argoStatus: Clarifai_Api_ArgoOrchestrationStatus {
    get {
      if case .argoStatus(let v)? = statusDetails {return v}
      return Clarifai_Api_ArgoOrchestrationStatus()
    }
    set {statusDetails = .argoStatus(newValue)}
  }

  /// This will help us with filtering the PipelineVersionRuns based on status
  public var status: Clarifai_Api_Status_Status {
    get {return _status ?? Clarifai_Api_Status_Status()}
    set {_status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  public var hasStatus: Bool {return self._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  public mutating func clearStatus() {self._status = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Oneof field for extensibility, supporting different orchestration systems
  public enum OneOf_StatusDetails: Equatable {
    /// Status for Argo Workflow
    case argoStatus(Clarifai_Api_ArgoOrchestrationStatus)

  #if !swift(>=4.1)
    public static func ==(lhs: Clarifai_Api_OrchestrationStatus.OneOf_StatusDetails, rhs: Clarifai_Api_OrchestrationStatus.OneOf_StatusDetails) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.argoStatus, .argoStatus): return {
        guard case .argoStatus(let l) = lhs, case .argoStatus(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      }
    }
  #endif
  }

  public init() {}

  fileprivate var _status: Clarifai_Api_Status_Status? = nil
}

/// Argo Workflow Status message
public struct Clarifai_Api_ArgoOrchestrationStatus {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Refer https://pkg.go.dev/github.com/argoproj/argo-workflows/v3/pkg/apis/workflow/v1alpha1#WorkflowStatus
  public var status: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Clarifai_Api_PipelineVersionRun {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: String {
    get {return _storage._id}
    set {_uniqueStorage()._id = newValue}
  }

  /// Pipeline Version associated with this run
  public var pipelineVersion: Clarifai_Api_PipelineVersion {
    get {return _storage._pipelineVersion ?? Clarifai_Api_PipelineVersion()}
    set {_uniqueStorage()._pipelineVersion = newValue}
  }
  /// Returns true if `pipelineVersion` has been explicitly set.
  public var hasPipelineVersion: Bool {return _storage._pipelineVersion != nil}
  /// Clears the value of `pipelineVersion`. Subsequent reads from it will return its default value.
  public mutating func clearPipelineVersion() {_uniqueStorage()._pipelineVersion = nil}

  /// Nodepool(s) used for the Pipeline Version Run
  public var nodepools: [Clarifai_Api_Nodepool] {
    get {return _storage._nodepools}
    set {_uniqueStorage()._nodepools = newValue}
  }

  /// Orchestration Status for this run, supporting multiple orchestration systems
  public var orchestrationStatus: Clarifai_Api_OrchestrationStatus {
    get {return _storage._orchestrationStatus ?? Clarifai_Api_OrchestrationStatus()}
    set {_uniqueStorage()._orchestrationStatus = newValue}
  }
  /// Returns true if `orchestrationStatus` has been explicitly set.
  public var hasOrchestrationStatus: Bool {return _storage._orchestrationStatus != nil}
  /// Clears the value of `orchestrationStatus`. Subsequent reads from it will return its default value.
  public mutating func clearOrchestrationStatus() {_uniqueStorage()._orchestrationStatus = nil}

  /// The user the pipeline belongs to
  public var userID: String {
    get {return _storage._userID}
    set {_uniqueStorage()._userID = newValue}
  }

  /// The app the pipeline belongs to
  public var appID: String {
    get {return _storage._appID}
    set {_uniqueStorage()._appID = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "clarifai.api"

extension Clarifai_Api_WorkflowModelUseCase: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "WORKFLOW_MODEL_USE_CASE_NOT_SET"),
    1: .same(proto: "CLASSIFICATION"),
    2: .same(proto: "DETECTION"),
  ]
}

extension Clarifai_Api_DatasetVersionRequestOrigin: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "DATASET_VERSION_REQUEST_ORIGIN_NOT_SET"),
    1: .same(proto: "MANUAL"),
    2: .same(proto: "TRAINING"),
    3: .same(proto: "EVAL_GROUND_TRUTH"),
    4: .same(proto: "EVAL_PREDICTIONS"),
  ]
}

extension Clarifai_Api_DatasetVersionMetricsGroupType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "DATASET_VERSION_METRICS_GROUP_TYPE_NOT_SET"),
    2: .same(proto: "INPUT_TYPE"),
    10: .same(proto: "CONCEPT_ID"),
    11: .same(proto: "CONCEPTS_COUNT"),
    20: .same(proto: "BOUNDING_BOXES_COUNT"),
    21: .same(proto: "POLYGONS_COUNT"),
    22: .same(proto: "POINTS_COUNT"),
    23: .same(proto: "MASKS_COUNT"),
    30: .same(proto: "PIXELS_COUNT"),
    31: .same(proto: "ASPECT_RATIO"),
  ]
}

extension Clarifai_Api_DatasetVersionExportFormat: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "DATASET_VERSION_EXPORT_FORMAT_NOT_SET"),
    1: .same(proto: "CLARIFAI_DATA_PROTOBUF"),
    2: .same(proto: "COCO"),
    3: .same(proto: "CLARIFAI_DATA_JSON"),
  ]
}

extension Clarifai_Api_ExpirationAction: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "EXPIRATION_ACTION_NOT_SET"),
    1: .same(proto: "DELAY"),
    2: .same(proto: "EXPIRY"),
  ]
}

extension Clarifai_Api_LicenseScope: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "LICENSE_SCOPE_NOT_SET"),
    1: .same(proto: "PREDICT"),
    2: .same(proto: "TRAIN"),
    3: .same(proto: "SEARCH"),
  ]
}

extension Clarifai_Api_LicenseType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN_LICENSE_TYPE"),
    1: .same(proto: "FIRST_PARTY"),
    2: .same(proto: "OPEN_SOURCE"),
    3: .same(proto: "CLOSED_SOURCE"),
  ]
}

extension Clarifai_Api_DataType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNDEFINED"),
    1: .same(proto: "STRING"),
    2: .same(proto: "UINT8"),
    3: .same(proto: "INT32"),
    4: .same(proto: "INT64"),
    5: .same(proto: "FP32"),
  ]
}

extension Clarifai_Api_ValueComparator: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "CONCEPT_THRESHOLD_NOT_SET"),
    1: .same(proto: "GREATER_THAN"),
    2: .same(proto: "GREATER_THAN_OR_EQUAL"),
    3: .same(proto: "LESS_THAN"),
    4: .same(proto: "LESS_THAN_OR_EQUAL"),
    5: .same(proto: "EQUAL"),
  ]
}

extension Clarifai_Api_EvaluationType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "Undefined"),
    1: .same(proto: "Classification"),
    2: .same(proto: "Detection"),
    3: .same(proto: "Segmentation"),
    4: .same(proto: "Clustering"),
    5: .same(proto: "Tracker"),
    6: .same(proto: "Generation"),
  ]
}

extension Clarifai_Api_APIEventType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "API_EVENT_TYPE_NOT_SET"),
    1: .same(proto: "ON_PREM_PREDICT"),
    2: .same(proto: "ON_PREM_TRAIN"),
    3: .same(proto: "ON_PREM_SEARCH"),
  ]
}

extension Clarifai_Api_UsageIntervalType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "undef"),
    1: .same(proto: "day"),
    2: .same(proto: "month"),
    3: .same(proto: "year"),
  ]
}

extension Clarifai_Api_AnnotationDataType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "ANNOTATION_DATA_TYPE_NOT_SET"),
    1: .same(proto: "TAG"),
    2: .same(proto: "BOUNDING_BOX"),
    4: .same(proto: "POLYGON"),
    8: .same(proto: "POINT"),
    16: .same(proto: "SPAN"),
    32: .same(proto: "MASK"),
  ]
}

extension Clarifai_Api_RoleType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "TEAM"),
    1: .same(proto: "ORG"),
  ]
}

extension Clarifai_Api_StatValueAggType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "SUM"),
    1: .same(proto: "AVG"),
  ]
}

extension Clarifai_Api_StatTimeAggType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NO_TIME_AGG"),
    1: .same(proto: "YEAR"),
    2: .same(proto: "MONTH"),
    3: .same(proto: "WEEK"),
    4: .same(proto: "DAY"),
    5: .same(proto: "HOUR"),
    6: .same(proto: "MINUTE"),
  ]
}

extension Clarifai_Api_ValidationErrorType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "VALIDATION_ERROR_TYPE_NOT_SET"),
    1: .same(proto: "RESTRICTED"),
    2: .same(proto: "DATABASE"),
    3: .same(proto: "FORMAT"),
  ]
}

extension Clarifai_Api_InputIDConflictResolution: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "INPUT_ID_CONFLICT_RESOLUTION_NOT_SET"),
    1: .same(proto: "SKIP"),
    2: .same(proto: "SUFFIX"),
  ]
}

extension Clarifai_Api_RunnerMethodType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN"),
    1: .same(proto: "UNARY_UNARY"),
    2: .same(proto: "UNARY_STREAMING"),
    3: .same(proto: "STREAMING_UNARY"),
    4: .same(proto: "STREAMING_STREAMING"),
  ]
}

extension Clarifai_Api_EventType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "EVENT_TYPE_NOT_SET"),
    100: .same(proto: "ORGANIZATION_MEMBER_ADD"),
    101: .same(proto: "ORGANIZATION_MEMBER_CHANGE"),
    102: .same(proto: "ORGANIZATION_MEMBER_REMOVE"),
    103: .same(proto: "ORGANIZATION_MEMBER_INVITATION_CREATE"),
    104: .same(proto: "ORGANIZATION_MEMBER_INVITATION_CANCEL"),
    105: .same(proto: "ORGANIZATION_MEMBER_INVITATION_ACCEPT"),
    106: .same(proto: "ORGANIZATION_MEMBER_INVITATION_DECLINE"),
    107: .same(proto: "ORGANIZATION_TEAM_CREATE"),
    108: .same(proto: "ORGANIZATION_TEAM_UPDATE"),
    109: .same(proto: "ORGANIZATION_TEAM_DELETE"),
    110: .same(proto: "ORGANIZATION_TEAM_MEMBER_ADD"),
    111: .same(proto: "ORGANIZATION_TEAM_MEMBER_REMOVE"),
    112: .same(proto: "ORGANIZATION_TEAM_APP_ADD"),
    113: .same(proto: "ORGANIZATION_TEAM_APP_REMOVE"),
    200: .same(proto: "MODULE_CREATE"),
    201: .same(proto: "MODULE_UPDATE"),
    202: .same(proto: "MODULE_DELETE"),
    203: .same(proto: "MODULE_VERSION_CREATE"),
    204: .same(proto: "MODULE_VERSION_UPDATE"),
    205: .same(proto: "MODULE_VERSION_DELETE"),
    300: .same(proto: "MODEL_CREATE"),
    301: .same(proto: "MODEL_UPDATE"),
    302: .same(proto: "MODEL_DELETE"),
    303: .same(proto: "MODEL_VERSION_CREATE"),
    304: .same(proto: "MODEL_VERSION_UPDATE"),
    305: .same(proto: "MODEL_VERSION_DELETE"),
    400: .same(proto: "WORKFLOW_CREATE"),
    401: .same(proto: "WORKFLOW_UPDATE"),
    402: .same(proto: "WORKFLOW_DELETE"),
    403: .same(proto: "WORKFLOW_VERSION_CREATE"),
    404: .same(proto: "WORKFLOW_VERSION_UPDATE"),
    405: .same(proto: "WORKFLOW_VERSION_DELETE"),
    600: .same(proto: "APPLICATION_CREATE"),
    601: .same(proto: "APPLICATION_UPDATE"),
    602: .same(proto: "APPLICATION_DELETE"),
    700: .same(proto: "COLLABORATOR_ADD"),
    701: .same(proto: "COLLABORATOR_UPDATE"),
    702: .same(proto: "COLLABORATOR_REMOVE"),
    800: .same(proto: "USER_UPDATE"),
  ]
}

extension Clarifai_Api_Annotation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Annotation"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .standard(proto: "input_id"),
    3: .same(proto: "data"),
    13: .standard(proto: "annotation_info"),
    15: .standard(proto: "user_id"),
    16: .standard(proto: "model_version_id"),
    14: .standard(proto: "embed_model_version_id"),
    7: .same(proto: "status"),
    8: .standard(proto: "created_at"),
    9: .standard(proto: "modified_at"),
    10: .same(proto: "trusted"),
    17: .standard(proto: "input_level"),
    18: .standard(proto: "consensus_info"),
    19: .standard(proto: "task_id"),
    21: .same(proto: "worker"),
  ]

  fileprivate class _StorageClass {
    var _id: String = String()
    var _inputID: String = String()
    var _data: Clarifai_Api_Data? = nil
    var _annotationInfo: SwiftProtobuf.Google_Protobuf_Struct? = nil
    var _userID: String = String()
    var _modelVersionID: String = String()
    var _embedModelVersionID: String = String()
    var _status: Clarifai_Api_Status_Status? = nil
    var _createdAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _modifiedAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _trusted: Bool = false
    var _inputLevel: Bool = false
    var _consensusInfo: SwiftProtobuf.Google_Protobuf_Struct? = nil
    var _taskID: String = String()
    var _worker: Clarifai_Api_Worker? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _id = source._id
      _inputID = source._inputID
      _data = source._data
      _annotationInfo = source._annotationInfo
      _userID = source._userID
      _modelVersionID = source._modelVersionID
      _embedModelVersionID = source._embedModelVersionID
      _status = source._status
      _createdAt = source._createdAt
      _modifiedAt = source._modifiedAt
      _trusted = source._trusted
      _inputLevel = source._inputLevel
      _consensusInfo = source._consensusInfo
      _taskID = source._taskID
      _worker = source._worker
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._id) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._inputID) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._data) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._status) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._createdAt) }()
        case 9: try { try decoder.decodeSingularMessageField(value: &_storage._modifiedAt) }()
        case 10: try { try decoder.decodeSingularBoolField(value: &_storage._trusted) }()
        case 13: try { try decoder.decodeSingularMessageField(value: &_storage._annotationInfo) }()
        case 14: try { try decoder.decodeSingularStringField(value: &_storage._embedModelVersionID) }()
        case 15: try { try decoder.decodeSingularStringField(value: &_storage._userID) }()
        case 16: try { try decoder.decodeSingularStringField(value: &_storage._modelVersionID) }()
        case 17: try { try decoder.decodeSingularBoolField(value: &_storage._inputLevel) }()
        case 18: try { try decoder.decodeSingularMessageField(value: &_storage._consensusInfo) }()
        case 19: try { try decoder.decodeSingularStringField(value: &_storage._taskID) }()
        case 21: try { try decoder.decodeSingularMessageField(value: &_storage._worker) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._id.isEmpty {
        try visitor.visitSingularStringField(value: _storage._id, fieldNumber: 1)
      }
      if !_storage._inputID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._inputID, fieldNumber: 2)
      }
      try { if let v = _storage._data {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._status {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      } }()
      try { if let v = _storage._createdAt {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      } }()
      try { if let v = _storage._modifiedAt {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      } }()
      if _storage._trusted != false {
        try visitor.visitSingularBoolField(value: _storage._trusted, fieldNumber: 10)
      }
      try { if let v = _storage._annotationInfo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
      } }()
      if !_storage._embedModelVersionID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._embedModelVersionID, fieldNumber: 14)
      }
      if !_storage._userID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._userID, fieldNumber: 15)
      }
      if !_storage._modelVersionID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._modelVersionID, fieldNumber: 16)
      }
      if _storage._inputLevel != false {
        try visitor.visitSingularBoolField(value: _storage._inputLevel, fieldNumber: 17)
      }
      try { if let v = _storage._consensusInfo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 18)
      } }()
      if !_storage._taskID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._taskID, fieldNumber: 19)
      }
      try { if let v = _storage._worker {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 21)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_Annotation, rhs: Clarifai_Api_Annotation) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._id != rhs_storage._id {return false}
        if _storage._inputID != rhs_storage._inputID {return false}
        if _storage._data != rhs_storage._data {return false}
        if _storage._annotationInfo != rhs_storage._annotationInfo {return false}
        if _storage._userID != rhs_storage._userID {return false}
        if _storage._modelVersionID != rhs_storage._modelVersionID {return false}
        if _storage._embedModelVersionID != rhs_storage._embedModelVersionID {return false}
        if _storage._status != rhs_storage._status {return false}
        if _storage._createdAt != rhs_storage._createdAt {return false}
        if _storage._modifiedAt != rhs_storage._modifiedAt {return false}
        if _storage._trusted != rhs_storage._trusted {return false}
        if _storage._inputLevel != rhs_storage._inputLevel {return false}
        if _storage._consensusInfo != rhs_storage._consensusInfo {return false}
        if _storage._taskID != rhs_storage._taskID {return false}
        if _storage._worker != rhs_storage._worker {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_Worker: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Worker"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "user"),
    2: .same(proto: "model"),
    3: .same(proto: "workflow"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Clarifai_Api_User?
        var hadOneofValue = false
        if let current = self.worker {
          hadOneofValue = true
          if case .user(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.worker = .user(v)
        }
      }()
      case 2: try {
        var v: Clarifai_Api_Model?
        var hadOneofValue = false
        if let current = self.worker {
          hadOneofValue = true
          if case .model(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.worker = .model(v)
        }
      }()
      case 3: try {
        var v: Clarifai_Api_Workflow?
        var hadOneofValue = false
        if let current = self.worker {
          hadOneofValue = true
          if case .workflow(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.worker = .workflow(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.worker {
    case .user?: try {
      guard case .user(let v)? = self.worker else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .model?: try {
      guard case .model(let v)? = self.worker else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .workflow?: try {
      guard case .workflow(let v)? = self.worker else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_Worker, rhs: Clarifai_Api_Worker) -> Bool {
    if lhs.worker != rhs.worker {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_App: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".App"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "name"),
    3: .standard(proto: "default_language"),
    4: .standard(proto: "default_workflow_id"),
    23: .standard(proto: "default_workflow"),
    5: .standard(proto: "user_id"),
    6: .standard(proto: "created_at"),
    17: .standard(proto: "modified_at"),
    7: .standard(proto: "legal_consent_status"),
    13: .same(proto: "metadata"),
    14: .same(proto: "description"),
    15: .standard(proto: "sample_ms"),
    16: .same(proto: "visibility"),
    18: .standard(proto: "data_tier_id"),
    19: .standard(proto: "is_starred"),
    20: .standard(proto: "star_count"),
    21: .same(proto: "notes"),
    22: .same(proto: "image"),
    25: .standard(proto: "is_template"),
    24: .standard(proto: "extra_info"),
    26: .standard(proto: "embeddings_storage"),
  ]

  fileprivate class _StorageClass {
    var _id: String = String()
    var _name: String = String()
    var _defaultLanguage: String = String()
    var _defaultWorkflowID: String = String()
    var _defaultWorkflow: Clarifai_Api_Workflow? = nil
    var _userID: String = String()
    var _createdAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _modifiedAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _legalConsentStatus: UInt32 = 0
    var _metadata: SwiftProtobuf.Google_Protobuf_Struct? = nil
    var _description_p: String = String()
    var _sampleMs: UInt32 = 0
    var _visibility: Clarifai_Api_Visibility? = nil
    var _dataTierID: String = String()
    var _isStarred: Bool = false
    var _starCount: Int32 = 0
    var _notes: String = String()
    var _image: Clarifai_Api_Image? = nil
    var _isTemplate: SwiftProtobuf.Google_Protobuf_BoolValue? = nil
    var _extraInfo: Clarifai_Api_AppExtraInfo? = nil
    var _embeddingsStorage: Clarifai_Api_App.EmbeddingsStorage = .embeddingStorageNotSet

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _id = source._id
      _name = source._name
      _defaultLanguage = source._defaultLanguage
      _defaultWorkflowID = source._defaultWorkflowID
      _defaultWorkflow = source._defaultWorkflow
      _userID = source._userID
      _createdAt = source._createdAt
      _modifiedAt = source._modifiedAt
      _legalConsentStatus = source._legalConsentStatus
      _metadata = source._metadata
      _description_p = source._description_p
      _sampleMs = source._sampleMs
      _visibility = source._visibility
      _dataTierID = source._dataTierID
      _isStarred = source._isStarred
      _starCount = source._starCount
      _notes = source._notes
      _image = source._image
      _isTemplate = source._isTemplate
      _extraInfo = source._extraInfo
      _embeddingsStorage = source._embeddingsStorage
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._id) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._name) }()
        case 3: try { try decoder.decodeSingularStringField(value: &_storage._defaultLanguage) }()
        case 4: try { try decoder.decodeSingularStringField(value: &_storage._defaultWorkflowID) }()
        case 5: try { try decoder.decodeSingularStringField(value: &_storage._userID) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._createdAt) }()
        case 7: try { try decoder.decodeSingularUInt32Field(value: &_storage._legalConsentStatus) }()
        case 13: try { try decoder.decodeSingularMessageField(value: &_storage._metadata) }()
        case 14: try { try decoder.decodeSingularStringField(value: &_storage._description_p) }()
        case 15: try { try decoder.decodeSingularUInt32Field(value: &_storage._sampleMs) }()
        case 16: try { try decoder.decodeSingularMessageField(value: &_storage._visibility) }()
        case 17: try { try decoder.decodeSingularMessageField(value: &_storage._modifiedAt) }()
        case 18: try { try decoder.decodeSingularStringField(value: &_storage._dataTierID) }()
        case 19: try { try decoder.decodeSingularBoolField(value: &_storage._isStarred) }()
        case 20: try { try decoder.decodeSingularInt32Field(value: &_storage._starCount) }()
        case 21: try { try decoder.decodeSingularStringField(value: &_storage._notes) }()
        case 22: try { try decoder.decodeSingularMessageField(value: &_storage._image) }()
        case 23: try { try decoder.decodeSingularMessageField(value: &_storage._defaultWorkflow) }()
        case 24: try { try decoder.decodeSingularMessageField(value: &_storage._extraInfo) }()
        case 25: try { try decoder.decodeSingularMessageField(value: &_storage._isTemplate) }()
        case 26: try { try decoder.decodeSingularEnumField(value: &_storage._embeddingsStorage) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._id.isEmpty {
        try visitor.visitSingularStringField(value: _storage._id, fieldNumber: 1)
      }
      if !_storage._name.isEmpty {
        try visitor.visitSingularStringField(value: _storage._name, fieldNumber: 2)
      }
      if !_storage._defaultLanguage.isEmpty {
        try visitor.visitSingularStringField(value: _storage._defaultLanguage, fieldNumber: 3)
      }
      if !_storage._defaultWorkflowID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._defaultWorkflowID, fieldNumber: 4)
      }
      if !_storage._userID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._userID, fieldNumber: 5)
      }
      try { if let v = _storage._createdAt {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
      if _storage._legalConsentStatus != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._legalConsentStatus, fieldNumber: 7)
      }
      try { if let v = _storage._metadata {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
      } }()
      if !_storage._description_p.isEmpty {
        try visitor.visitSingularStringField(value: _storage._description_p, fieldNumber: 14)
      }
      if _storage._sampleMs != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._sampleMs, fieldNumber: 15)
      }
      try { if let v = _storage._visibility {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
      } }()
      try { if let v = _storage._modifiedAt {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 17)
      } }()
      if !_storage._dataTierID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._dataTierID, fieldNumber: 18)
      }
      if _storage._isStarred != false {
        try visitor.visitSingularBoolField(value: _storage._isStarred, fieldNumber: 19)
      }
      if _storage._starCount != 0 {
        try visitor.visitSingularInt32Field(value: _storage._starCount, fieldNumber: 20)
      }
      if !_storage._notes.isEmpty {
        try visitor.visitSingularStringField(value: _storage._notes, fieldNumber: 21)
      }
      try { if let v = _storage._image {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 22)
      } }()
      try { if let v = _storage._defaultWorkflow {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 23)
      } }()
      try { if let v = _storage._extraInfo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 24)
      } }()
      try { if let v = _storage._isTemplate {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 25)
      } }()
      if _storage._embeddingsStorage != .embeddingStorageNotSet {
        try visitor.visitSingularEnumField(value: _storage._embeddingsStorage, fieldNumber: 26)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_App, rhs: Clarifai_Api_App) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._id != rhs_storage._id {return false}
        if _storage._name != rhs_storage._name {return false}
        if _storage._defaultLanguage != rhs_storage._defaultLanguage {return false}
        if _storage._defaultWorkflowID != rhs_storage._defaultWorkflowID {return false}
        if _storage._defaultWorkflow != rhs_storage._defaultWorkflow {return false}
        if _storage._userID != rhs_storage._userID {return false}
        if _storage._createdAt != rhs_storage._createdAt {return false}
        if _storage._modifiedAt != rhs_storage._modifiedAt {return false}
        if _storage._legalConsentStatus != rhs_storage._legalConsentStatus {return false}
        if _storage._metadata != rhs_storage._metadata {return false}
        if _storage._description_p != rhs_storage._description_p {return false}
        if _storage._sampleMs != rhs_storage._sampleMs {return false}
        if _storage._visibility != rhs_storage._visibility {return false}
        if _storage._dataTierID != rhs_storage._dataTierID {return false}
        if _storage._isStarred != rhs_storage._isStarred {return false}
        if _storage._starCount != rhs_storage._starCount {return false}
        if _storage._notes != rhs_storage._notes {return false}
        if _storage._image != rhs_storage._image {return false}
        if _storage._isTemplate != rhs_storage._isTemplate {return false}
        if _storage._extraInfo != rhs_storage._extraInfo {return false}
        if _storage._embeddingsStorage != rhs_storage._embeddingsStorage {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_App.EmbeddingsStorage: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "EMBEDDING_STORAGE_NOT_SET"),
    1: .same(proto: "POSTGRES"),
    2: .same(proto: "QDRANT"),
  ]
}

extension Clarifai_Api_AppExtraInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AppExtraInfo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "search_revision_marker"),
    2: .same(proto: "counts"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.searchRevisionMarker) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._counts) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.searchRevisionMarker.isEmpty {
      try visitor.visitSingularStringField(value: self.searchRevisionMarker, fieldNumber: 1)
    }
    try { if let v = self._counts {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_AppExtraInfo, rhs: Clarifai_Api_AppExtraInfo) -> Bool {
    if lhs.searchRevisionMarker != rhs.searchRevisionMarker {return false}
    if lhs._counts != rhs._counts {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_AppQuery: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AppQuery"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_AppQuery, rhs: Clarifai_Api_AppQuery) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_AppResourceCounts: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AppResourceCounts"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "datasets"),
    2: .same(proto: "models"),
    3: .same(proto: "workflows"),
    4: .same(proto: "modules"),
    5: .same(proto: "inputs"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.datasets) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.models) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.workflows) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.modules) }()
      case 5: try { try decoder.decodeSingularInt64Field(value: &self.inputs) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.datasets != 0 {
      try visitor.visitSingularInt64Field(value: self.datasets, fieldNumber: 1)
    }
    if self.models != 0 {
      try visitor.visitSingularInt64Field(value: self.models, fieldNumber: 2)
    }
    if self.workflows != 0 {
      try visitor.visitSingularInt64Field(value: self.workflows, fieldNumber: 3)
    }
    if self.modules != 0 {
      try visitor.visitSingularInt64Field(value: self.modules, fieldNumber: 4)
    }
    if self.inputs != 0 {
      try visitor.visitSingularInt64Field(value: self.inputs, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_AppResourceCounts, rhs: Clarifai_Api_AppResourceCounts) -> Bool {
    if lhs.datasets != rhs.datasets {return false}
    if lhs.models != rhs.models {return false}
    if lhs.workflows != rhs.workflows {return false}
    if lhs.modules != rhs.modules {return false}
    if lhs.inputs != rhs.inputs {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_Collaborator: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Collaborator"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "app"),
    3: .same(proto: "user"),
    4: .same(proto: "scopes"),
    5: .same(proto: "endpoints"),
    6: .standard(proto: "created_at"),
    7: .standard(proto: "modified_at"),
    8: .standard(proto: "deleted_at"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._app) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._user) }()
      case 4: try { try decoder.decodeRepeatedStringField(value: &self.scopes) }()
      case 5: try { try decoder.decodeRepeatedStringField(value: &self.endpoints) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._createdAt) }()
      case 7: try { try decoder.decodeSingularMessageField(value: &self._modifiedAt) }()
      case 8: try { try decoder.decodeSingularMessageField(value: &self._deletedAt) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    try { if let v = self._app {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._user {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if !self.scopes.isEmpty {
      try visitor.visitRepeatedStringField(value: self.scopes, fieldNumber: 4)
    }
    if !self.endpoints.isEmpty {
      try visitor.visitRepeatedStringField(value: self.endpoints, fieldNumber: 5)
    }
    try { if let v = self._createdAt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    try { if let v = self._modifiedAt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    } }()
    try { if let v = self._deletedAt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_Collaborator, rhs: Clarifai_Api_Collaborator) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs._app != rhs._app {return false}
    if lhs._user != rhs._user {return false}
    if lhs.scopes != rhs.scopes {return false}
    if lhs.endpoints != rhs.endpoints {return false}
    if lhs._createdAt != rhs._createdAt {return false}
    if lhs._modifiedAt != rhs._modifiedAt {return false}
    if lhs._deletedAt != rhs._deletedAt {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_Collaboration: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Collaboration"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "app"),
    2: .standard(proto: "app_owner"),
    3: .same(proto: "scopes"),
    4: .same(proto: "endpoints"),
    5: .standard(proto: "created_at"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._app) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._appOwner) }()
      case 3: try { try decoder.decodeRepeatedStringField(value: &self.scopes) }()
      case 4: try { try decoder.decodeRepeatedStringField(value: &self.endpoints) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._createdAt) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._app {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._appOwner {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.scopes.isEmpty {
      try visitor.visitRepeatedStringField(value: self.scopes, fieldNumber: 3)
    }
    if !self.endpoints.isEmpty {
      try visitor.visitRepeatedStringField(value: self.endpoints, fieldNumber: 4)
    }
    try { if let v = self._createdAt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_Collaboration, rhs: Clarifai_Api_Collaboration) -> Bool {
    if lhs._app != rhs._app {return false}
    if lhs._appOwner != rhs._appOwner {return false}
    if lhs.scopes != rhs.scopes {return false}
    if lhs.endpoints != rhs.endpoints {return false}
    if lhs._createdAt != rhs._createdAt {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_Audio: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Audio"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "url"),
    2: .same(proto: "base64"),
    4: .standard(proto: "allow_duplicate_url"),
    5: .same(proto: "hosted"),
    6: .standard(proto: "audio_info"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.url) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.base64) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.allowDuplicateURL) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._hosted) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._audioInfo) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.url.isEmpty {
      try visitor.visitSingularStringField(value: self.url, fieldNumber: 1)
    }
    if !self.base64.isEmpty {
      try visitor.visitSingularBytesField(value: self.base64, fieldNumber: 2)
    }
    if self.allowDuplicateURL != false {
      try visitor.visitSingularBoolField(value: self.allowDuplicateURL, fieldNumber: 4)
    }
    try { if let v = self._hosted {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._audioInfo {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_Audio, rhs: Clarifai_Api_Audio) -> Bool {
    if lhs.url != rhs.url {return false}
    if lhs.base64 != rhs.base64 {return false}
    if lhs.allowDuplicateURL != rhs.allowDuplicateURL {return false}
    if lhs._hosted != rhs._hosted {return false}
    if lhs._audioInfo != rhs._audioInfo {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_AudioInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AudioInfo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "audio_format"),
    2: .standard(proto: "sample_rate"),
    3: .standard(proto: "duration_seconds"),
    4: .standard(proto: "bit_rate"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.audioFormat) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.sampleRate) }()
      case 3: try { try decoder.decodeSingularFloatField(value: &self.durationSeconds) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.bitRate) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.audioFormat.isEmpty {
      try visitor.visitSingularStringField(value: self.audioFormat, fieldNumber: 1)
    }
    if self.sampleRate != 0 {
      try visitor.visitSingularInt32Field(value: self.sampleRate, fieldNumber: 2)
    }
    if self.durationSeconds != 0 {
      try visitor.visitSingularFloatField(value: self.durationSeconds, fieldNumber: 3)
    }
    if self.bitRate != 0 {
      try visitor.visitSingularInt32Field(value: self.bitRate, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_AudioInfo, rhs: Clarifai_Api_AudioInfo) -> Bool {
    if lhs.audioFormat != rhs.audioFormat {return false}
    if lhs.sampleRate != rhs.sampleRate {return false}
    if lhs.durationSeconds != rhs.durationSeconds {return false}
    if lhs.bitRate != rhs.bitRate {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_Track: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Track"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "data"),
    4: .standard(proto: "time_info"),
    5: .same(proto: "quality"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._data) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._timeInfo) }()
      case 5: try { try decoder.decodeSingularFloatField(value: &self.quality) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    try { if let v = self._data {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._timeInfo {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    if self.quality != 0 {
      try visitor.visitSingularFloatField(value: self.quality, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_Track, rhs: Clarifai_Api_Track) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs._data != rhs._data {return false}
    if lhs._timeInfo != rhs._timeInfo {return false}
    if lhs.quality != rhs.quality {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_Cluster: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Cluster"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "count"),
    3: .same(proto: "score"),
    4: .same(proto: "hits"),
    5: .same(proto: "projection"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.count) }()
      case 3: try { try decoder.decodeSingularFloatField(value: &self.score) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.hits) }()
      case 5: try { try decoder.decodeRepeatedFloatField(value: &self.projection) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if self.count != 0 {
      try visitor.visitSingularUInt32Field(value: self.count, fieldNumber: 2)
    }
    if self.score != 0 {
      try visitor.visitSingularFloatField(value: self.score, fieldNumber: 3)
    }
    if !self.hits.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.hits, fieldNumber: 4)
    }
    if !self.projection.isEmpty {
      try visitor.visitPackedFloatField(value: self.projection, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_Cluster, rhs: Clarifai_Api_Cluster) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.count != rhs.count {return false}
    if lhs.score != rhs.score {return false}
    if lhs.hits != rhs.hits {return false}
    if lhs.projection != rhs.projection {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_Color: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Color"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "raw_hex"),
    2: .same(proto: "w3c"),
    3: .same(proto: "value"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.rawHex) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._w3C) }()
      case 3: try { try decoder.decodeSingularFloatField(value: &self.value) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.rawHex.isEmpty {
      try visitor.visitSingularStringField(value: self.rawHex, fieldNumber: 1)
    }
    try { if let v = self._w3C {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if self.value != 0 {
      try visitor.visitSingularFloatField(value: self.value, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_Color, rhs: Clarifai_Api_Color) -> Bool {
    if lhs.rawHex != rhs.rawHex {return false}
    if lhs._w3C != rhs._w3C {return false}
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_W3C: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".W3C"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "hex"),
    2: .same(proto: "name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.hex) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.name) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.hex.isEmpty {
      try visitor.visitSingularStringField(value: self.hex, fieldNumber: 1)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_W3C, rhs: Clarifai_Api_W3C) -> Bool {
    if lhs.hex != rhs.hex {return false}
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_UserAppIDSet: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UserAppIDSet"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_id"),
    2: .standard(proto: "app_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.userID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.appID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.userID.isEmpty {
      try visitor.visitSingularStringField(value: self.userID, fieldNumber: 1)
    }
    if !self.appID.isEmpty {
      try visitor.visitSingularStringField(value: self.appID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_UserAppIDSet, rhs: Clarifai_Api_UserAppIDSet) -> Bool {
    if lhs.userID != rhs.userID {return false}
    if lhs.appID != rhs.appID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_PatchAction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PatchAction"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "op"),
    2: .standard(proto: "merge_conflict_resolution"),
    3: .same(proto: "path"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.op) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.mergeConflictResolution) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.path) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.op.isEmpty {
      try visitor.visitSingularStringField(value: self.op, fieldNumber: 1)
    }
    if !self.mergeConflictResolution.isEmpty {
      try visitor.visitSingularStringField(value: self.mergeConflictResolution, fieldNumber: 2)
    }
    if !self.path.isEmpty {
      try visitor.visitSingularStringField(value: self.path, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_PatchAction, rhs: Clarifai_Api_PatchAction) -> Bool {
    if lhs.op != rhs.op {return false}
    if lhs.mergeConflictResolution != rhs.mergeConflictResolution {return false}
    if lhs.path != rhs.path {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_Concept: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Concept"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "name"),
    3: .same(proto: "value"),
    4: .standard(proto: "created_at"),
    5: .same(proto: "language"),
    6: .standard(proto: "app_id"),
    7: .same(proto: "definition"),
    8: .standard(proto: "vocab_id"),
    9: .same(proto: "visibility"),
    10: .standard(proto: "user_id"),
    11: .standard(proto: "keypoint_info"),
    12: .standard(proto: "extra_info"),
    13: .same(proto: "metadata"),
    22: .same(proto: "image"),
  ]

  fileprivate class _StorageClass {
    var _id: String = String()
    var _name: String = String()
    var _value: Float = 0
    var _createdAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _language: String = String()
    var _appID: String = String()
    var _definition: String = String()
    var _vocabID: String = String()
    var _visibility: Clarifai_Api_Visibility? = nil
    var _userID: String = String()
    var _keypointInfo: Clarifai_Api_KeypointInfo? = nil
    var _extraInfo: Clarifai_Api_ConceptExtraInfo? = nil
    var _metadata: SwiftProtobuf.Google_Protobuf_Struct? = nil
    var _image: Clarifai_Api_Image? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _id = source._id
      _name = source._name
      _value = source._value
      _createdAt = source._createdAt
      _language = source._language
      _appID = source._appID
      _definition = source._definition
      _vocabID = source._vocabID
      _visibility = source._visibility
      _userID = source._userID
      _keypointInfo = source._keypointInfo
      _extraInfo = source._extraInfo
      _metadata = source._metadata
      _image = source._image
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._id) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._name) }()
        case 3: try { try decoder.decodeSingularFloatField(value: &_storage._value) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._createdAt) }()
        case 5: try { try decoder.decodeSingularStringField(value: &_storage._language) }()
        case 6: try { try decoder.decodeSingularStringField(value: &_storage._appID) }()
        case 7: try { try decoder.decodeSingularStringField(value: &_storage._definition) }()
        case 8: try { try decoder.decodeSingularStringField(value: &_storage._vocabID) }()
        case 9: try { try decoder.decodeSingularMessageField(value: &_storage._visibility) }()
        case 10: try { try decoder.decodeSingularStringField(value: &_storage._userID) }()
        case 11: try { try decoder.decodeSingularMessageField(value: &_storage._keypointInfo) }()
        case 12: try { try decoder.decodeSingularMessageField(value: &_storage._extraInfo) }()
        case 13: try { try decoder.decodeSingularMessageField(value: &_storage._metadata) }()
        case 22: try { try decoder.decodeSingularMessageField(value: &_storage._image) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._id.isEmpty {
        try visitor.visitSingularStringField(value: _storage._id, fieldNumber: 1)
      }
      if !_storage._name.isEmpty {
        try visitor.visitSingularStringField(value: _storage._name, fieldNumber: 2)
      }
      if _storage._value != 0 {
        try visitor.visitSingularFloatField(value: _storage._value, fieldNumber: 3)
      }
      try { if let v = _storage._createdAt {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      if !_storage._language.isEmpty {
        try visitor.visitSingularStringField(value: _storage._language, fieldNumber: 5)
      }
      if !_storage._appID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._appID, fieldNumber: 6)
      }
      if !_storage._definition.isEmpty {
        try visitor.visitSingularStringField(value: _storage._definition, fieldNumber: 7)
      }
      if !_storage._vocabID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._vocabID, fieldNumber: 8)
      }
      try { if let v = _storage._visibility {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      } }()
      if !_storage._userID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._userID, fieldNumber: 10)
      }
      try { if let v = _storage._keypointInfo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      } }()
      try { if let v = _storage._extraInfo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
      } }()
      try { if let v = _storage._metadata {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
      } }()
      try { if let v = _storage._image {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 22)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_Concept, rhs: Clarifai_Api_Concept) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._id != rhs_storage._id {return false}
        if _storage._name != rhs_storage._name {return false}
        if _storage._value != rhs_storage._value {return false}
        if _storage._createdAt != rhs_storage._createdAt {return false}
        if _storage._language != rhs_storage._language {return false}
        if _storage._appID != rhs_storage._appID {return false}
        if _storage._definition != rhs_storage._definition {return false}
        if _storage._vocabID != rhs_storage._vocabID {return false}
        if _storage._visibility != rhs_storage._visibility {return false}
        if _storage._userID != rhs_storage._userID {return false}
        if _storage._keypointInfo != rhs_storage._keypointInfo {return false}
        if _storage._extraInfo != rhs_storage._extraInfo {return false}
        if _storage._metadata != rhs_storage._metadata {return false}
        if _storage._image != rhs_storage._image {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_KeypointInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".KeypointInfo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "keypoint_names"),
    2: .same(proto: "skeleton"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.keypointNames) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.skeleton) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.keypointNames.isEmpty {
      try visitor.visitRepeatedStringField(value: self.keypointNames, fieldNumber: 1)
    }
    if !self.skeleton.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.skeleton, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_KeypointInfo, rhs: Clarifai_Api_KeypointInfo) -> Bool {
    if lhs.keypointNames != rhs.keypointNames {return false}
    if lhs.skeleton != rhs.skeleton {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_KeypointEdge: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".KeypointEdge"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "k1"),
    2: .same(proto: "k2"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.k1) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.k2) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.k1 != 0 {
      try visitor.visitSingularUInt32Field(value: self.k1, fieldNumber: 1)
    }
    if self.k2 != 0 {
      try visitor.visitSingularUInt32Field(value: self.k2, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_KeypointEdge, rhs: Clarifai_Api_KeypointEdge) -> Bool {
    if lhs.k1 != rhs.k1 {return false}
    if lhs.k2 != rhs.k2 {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_ConceptExtraInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ConceptExtraInfo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "is_rankable"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.isRankable) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.isRankable != false {
      try visitor.visitSingularBoolField(value: self.isRankable, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_ConceptExtraInfo, rhs: Clarifai_Api_ConceptExtraInfo) -> Bool {
    if lhs.isRankable != rhs.isRankable {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_ConceptCount: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ConceptCount"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "name"),
    3: .standard(proto: "concept_type_count"),
    4: .standard(proto: "detail_concept_count"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._conceptTypeCount) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._detailConceptCount) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 2)
    }
    try { if let v = self._conceptTypeCount {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._detailConceptCount {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_ConceptCount, rhs: Clarifai_Api_ConceptCount) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.name != rhs.name {return false}
    if lhs._conceptTypeCount != rhs._conceptTypeCount {return false}
    if lhs._detailConceptCount != rhs._detailConceptCount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_ConceptTypeCount: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ConceptTypeCount"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "positive"),
    2: .same(proto: "negative"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.positive) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.negative) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.positive != 0 {
      try visitor.visitSingularUInt32Field(value: self.positive, fieldNumber: 1)
    }
    if self.negative != 0 {
      try visitor.visitSingularUInt32Field(value: self.negative, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_ConceptTypeCount, rhs: Clarifai_Api_ConceptTypeCount) -> Bool {
    if lhs.positive != rhs.positive {return false}
    if lhs.negative != rhs.negative {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_DetailConceptCount: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DetailConceptCount"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "processed"),
    2: .standard(proto: "to_process"),
    3: .same(proto: "errors"),
    4: .same(proto: "processing"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._processed) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._toProcess) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._errors) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._processing) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._processed {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._toProcess {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._errors {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._processing {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_DetailConceptCount, rhs: Clarifai_Api_DetailConceptCount) -> Bool {
    if lhs._processed != rhs._processed {return false}
    if lhs._toProcess != rhs._toProcess {return false}
    if lhs._errors != rhs._errors {return false}
    if lhs._processing != rhs._processing {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_ConceptQuery: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ConceptQuery"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "language"),
    3: .standard(proto: "workflow_id"),
    4: .standard(proto: "use_cases"),
    5: .same(proto: "model"),
    6: .same(proto: "workflow"),
    7: .standard(proto: "ignore_app_concepts"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.language) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.workflowID) }()
      case 4: try { try decoder.decodeRepeatedEnumField(value: &self.useCases) }()
      case 5: try {
        var v: Clarifai_Api_Model?
        var hadOneofValue = false
        if let current = self.source {
          hadOneofValue = true
          if case .model(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.source = .model(v)
        }
      }()
      case 6: try {
        var v: Clarifai_Api_Workflow?
        var hadOneofValue = false
        if let current = self.source {
          hadOneofValue = true
          if case .workflow(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.source = .workflow(v)
        }
      }()
      case 7: try { try decoder.decodeSingularBoolField(value: &self.ignoreAppConcepts) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.language.isEmpty {
      try visitor.visitSingularStringField(value: self.language, fieldNumber: 2)
    }
    if !self.workflowID.isEmpty {
      try visitor.visitSingularStringField(value: self.workflowID, fieldNumber: 3)
    }
    if !self.useCases.isEmpty {
      try visitor.visitPackedEnumField(value: self.useCases, fieldNumber: 4)
    }
    switch self.source {
    case .model?: try {
      guard case .model(let v)? = self.source else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .workflow?: try {
      guard case .workflow(let v)? = self.source else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case nil: break
    }
    if self.ignoreAppConcepts != false {
      try visitor.visitSingularBoolField(value: self.ignoreAppConcepts, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_ConceptQuery, rhs: Clarifai_Api_ConceptQuery) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.language != rhs.language {return false}
    if lhs.workflowID != rhs.workflowID {return false}
    if lhs.useCases != rhs.useCases {return false}
    if lhs.source != rhs.source {return false}
    if lhs.ignoreAppConcepts != rhs.ignoreAppConcepts {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_ConceptRelation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ConceptRelation"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .standard(proto: "subject_concept"),
    3: .standard(proto: "object_concept"),
    4: .same(proto: "predicate"),
    5: .standard(proto: "knowledge_graph_id"),
    6: .same(proto: "visibility"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._subjectConcept) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._objectConcept) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.predicate) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.knowledgeGraphID) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._visibility) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    try { if let v = self._subjectConcept {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._objectConcept {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if !self.predicate.isEmpty {
      try visitor.visitSingularStringField(value: self.predicate, fieldNumber: 4)
    }
    if !self.knowledgeGraphID.isEmpty {
      try visitor.visitSingularStringField(value: self.knowledgeGraphID, fieldNumber: 5)
    }
    try { if let v = self._visibility {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_ConceptRelation, rhs: Clarifai_Api_ConceptRelation) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs._subjectConcept != rhs._subjectConcept {return false}
    if lhs._objectConcept != rhs._objectConcept {return false}
    if lhs.predicate != rhs.predicate {return false}
    if lhs.knowledgeGraphID != rhs.knowledgeGraphID {return false}
    if lhs._visibility != rhs._visibility {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_KnowledgeGraph: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".KnowledgeGraph"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "name"),
    3: .same(proto: "description"),
    4: .standard(proto: "examples_app_id"),
    5: .standard(proto: "sampled_examples_app_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.examplesAppID) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.sampledExamplesAppID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 2)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 3)
    }
    if !self.examplesAppID.isEmpty {
      try visitor.visitSingularStringField(value: self.examplesAppID, fieldNumber: 4)
    }
    if !self.sampledExamplesAppID.isEmpty {
      try visitor.visitSingularStringField(value: self.sampledExamplesAppID, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_KnowledgeGraph, rhs: Clarifai_Api_KnowledgeGraph) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.name != rhs.name {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.examplesAppID != rhs.examplesAppID {return false}
    if lhs.sampledExamplesAppID != rhs.sampledExamplesAppID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_ConceptLanguage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ConceptLanguage"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "name"),
    3: .same(proto: "definition"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.definition) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 2)
    }
    if !self.definition.isEmpty {
      try visitor.visitSingularStringField(value: self.definition, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_ConceptLanguage, rhs: Clarifai_Api_ConceptLanguage) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.name != rhs.name {return false}
    if lhs.definition != rhs.definition {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_Data: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Data"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "image"),
    2: .same(proto: "video"),
    3: .same(proto: "concepts"),
    5: .same(proto: "metadata"),
    6: .same(proto: "geo"),
    7: .same(proto: "colors"),
    8: .same(proto: "clusters"),
    9: .same(proto: "embeddings"),
    11: .same(proto: "regions"),
    12: .same(proto: "frames"),
    13: .same(proto: "text"),
    14: .same(proto: "audio"),
    15: .same(proto: "tracks"),
    16: .standard(proto: "time_segments"),
    17: .same(proto: "hits"),
    18: .same(proto: "heatmaps"),
    19: .same(proto: "parts"),
    20: .same(proto: "ndarray"),
    21: .standard(proto: "int_value"),
    22: .standard(proto: "float_value"),
    23: .standard(proto: "bytes_value"),
    24: .standard(proto: "bool_value"),
    25: .standard(proto: "string_value"),
  ]

  fileprivate class _StorageClass {
    var _image: Clarifai_Api_Image? = nil
    var _video: Clarifai_Api_Video? = nil
    var _concepts: [Clarifai_Api_Concept] = []
    var _metadata: SwiftProtobuf.Google_Protobuf_Struct? = nil
    var _geo: Clarifai_Api_Geo? = nil
    var _colors: [Clarifai_Api_Color] = []
    var _clusters: [Clarifai_Api_Cluster] = []
    var _embeddings: [Clarifai_Api_Embedding] = []
    var _regions: [Clarifai_Api_Region] = []
    var _frames: [Clarifai_Api_Frame] = []
    var _text: Clarifai_Api_Text? = nil
    var _audio: Clarifai_Api_Audio? = nil
    var _tracks: [Clarifai_Api_Track] = []
    var _timeSegments: [Clarifai_Api_TimeSegment] = []
    var _hits: [Clarifai_Api_Hit] = []
    var _heatmaps: [Clarifai_Api_Image] = []
    var _parts: [Clarifai_Api_Part] = []
    var _ndarray: Clarifai_Api_NDArray? = nil
    var _intValue: Int64 = 0
    var _floatValue: Double = 0
    var _bytesValue: Data = Data()
    var _boolValue: Bool = false
    var _stringValue: String = String()

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _image = source._image
      _video = source._video
      _concepts = source._concepts
      _metadata = source._metadata
      _geo = source._geo
      _colors = source._colors
      _clusters = source._clusters
      _embeddings = source._embeddings
      _regions = source._regions
      _frames = source._frames
      _text = source._text
      _audio = source._audio
      _tracks = source._tracks
      _timeSegments = source._timeSegments
      _hits = source._hits
      _heatmaps = source._heatmaps
      _parts = source._parts
      _ndarray = source._ndarray
      _intValue = source._intValue
      _floatValue = source._floatValue
      _bytesValue = source._bytesValue
      _boolValue = source._boolValue
      _stringValue = source._stringValue
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._image) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._video) }()
        case 3: try { try decoder.decodeRepeatedMessageField(value: &_storage._concepts) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._metadata) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._geo) }()
        case 7: try { try decoder.decodeRepeatedMessageField(value: &_storage._colors) }()
        case 8: try { try decoder.decodeRepeatedMessageField(value: &_storage._clusters) }()
        case 9: try { try decoder.decodeRepeatedMessageField(value: &_storage._embeddings) }()
        case 11: try { try decoder.decodeRepeatedMessageField(value: &_storage._regions) }()
        case 12: try { try decoder.decodeRepeatedMessageField(value: &_storage._frames) }()
        case 13: try { try decoder.decodeSingularMessageField(value: &_storage._text) }()
        case 14: try { try decoder.decodeSingularMessageField(value: &_storage._audio) }()
        case 15: try { try decoder.decodeRepeatedMessageField(value: &_storage._tracks) }()
        case 16: try { try decoder.decodeRepeatedMessageField(value: &_storage._timeSegments) }()
        case 17: try { try decoder.decodeRepeatedMessageField(value: &_storage._hits) }()
        case 18: try { try decoder.decodeRepeatedMessageField(value: &_storage._heatmaps) }()
        case 19: try { try decoder.decodeRepeatedMessageField(value: &_storage._parts) }()
        case 20: try { try decoder.decodeSingularMessageField(value: &_storage._ndarray) }()
        case 21: try { try decoder.decodeSingularInt64Field(value: &_storage._intValue) }()
        case 22: try { try decoder.decodeSingularDoubleField(value: &_storage._floatValue) }()
        case 23: try { try decoder.decodeSingularBytesField(value: &_storage._bytesValue) }()
        case 24: try { try decoder.decodeSingularBoolField(value: &_storage._boolValue) }()
        case 25: try { try decoder.decodeSingularStringField(value: &_storage._stringValue) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._image {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._video {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      if !_storage._concepts.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._concepts, fieldNumber: 3)
      }
      try { if let v = _storage._metadata {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._geo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
      if !_storage._colors.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._colors, fieldNumber: 7)
      }
      if !_storage._clusters.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._clusters, fieldNumber: 8)
      }
      if !_storage._embeddings.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._embeddings, fieldNumber: 9)
      }
      if !_storage._regions.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._regions, fieldNumber: 11)
      }
      if !_storage._frames.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._frames, fieldNumber: 12)
      }
      try { if let v = _storage._text {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
      } }()
      try { if let v = _storage._audio {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
      } }()
      if !_storage._tracks.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._tracks, fieldNumber: 15)
      }
      if !_storage._timeSegments.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._timeSegments, fieldNumber: 16)
      }
      if !_storage._hits.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._hits, fieldNumber: 17)
      }
      if !_storage._heatmaps.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._heatmaps, fieldNumber: 18)
      }
      if !_storage._parts.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._parts, fieldNumber: 19)
      }
      try { if let v = _storage._ndarray {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 20)
      } }()
      if _storage._intValue != 0 {
        try visitor.visitSingularInt64Field(value: _storage._intValue, fieldNumber: 21)
      }
      if _storage._floatValue != 0 {
        try visitor.visitSingularDoubleField(value: _storage._floatValue, fieldNumber: 22)
      }
      if !_storage._bytesValue.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._bytesValue, fieldNumber: 23)
      }
      if _storage._boolValue != false {
        try visitor.visitSingularBoolField(value: _storage._boolValue, fieldNumber: 24)
      }
      if !_storage._stringValue.isEmpty {
        try visitor.visitSingularStringField(value: _storage._stringValue, fieldNumber: 25)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_Data, rhs: Clarifai_Api_Data) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._image != rhs_storage._image {return false}
        if _storage._video != rhs_storage._video {return false}
        if _storage._concepts != rhs_storage._concepts {return false}
        if _storage._metadata != rhs_storage._metadata {return false}
        if _storage._geo != rhs_storage._geo {return false}
        if _storage._colors != rhs_storage._colors {return false}
        if _storage._clusters != rhs_storage._clusters {return false}
        if _storage._embeddings != rhs_storage._embeddings {return false}
        if _storage._regions != rhs_storage._regions {return false}
        if _storage._frames != rhs_storage._frames {return false}
        if _storage._text != rhs_storage._text {return false}
        if _storage._audio != rhs_storage._audio {return false}
        if _storage._tracks != rhs_storage._tracks {return false}
        if _storage._timeSegments != rhs_storage._timeSegments {return false}
        if _storage._hits != rhs_storage._hits {return false}
        if _storage._heatmaps != rhs_storage._heatmaps {return false}
        if _storage._parts != rhs_storage._parts {return false}
        if _storage._ndarray != rhs_storage._ndarray {return false}
        if _storage._intValue != rhs_storage._intValue {return false}
        if _storage._floatValue != rhs_storage._floatValue {return false}
        if _storage._bytesValue != rhs_storage._bytesValue {return false}
        if _storage._boolValue != rhs_storage._boolValue {return false}
        if _storage._stringValue != rhs_storage._stringValue {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_Part: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Part"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "data"),
    2: .same(proto: "id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._data) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.id) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._data {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_Part, rhs: Clarifai_Api_Part) -> Bool {
    if lhs._data != rhs._data {return false}
    if lhs.id != rhs.id {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_Region: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Region"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .standard(proto: "region_info"),
    3: .same(proto: "data"),
    4: .same(proto: "value"),
    5: .standard(proto: "track_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._regionInfo) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._data) }()
      case 4: try { try decoder.decodeSingularFloatField(value: &self.value) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.trackID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    try { if let v = self._regionInfo {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._data {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if self.value != 0 {
      try visitor.visitSingularFloatField(value: self.value, fieldNumber: 4)
    }
    if !self.trackID.isEmpty {
      try visitor.visitSingularStringField(value: self.trackID, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_Region, rhs: Clarifai_Api_Region) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs._regionInfo != rhs._regionInfo {return false}
    if lhs._data != rhs._data {return false}
    if lhs.value != rhs.value {return false}
    if lhs.trackID != rhs.trackID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_RegionInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RegionInfo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "bounding_box"),
    4: .same(proto: "mask"),
    5: .same(proto: "polygon"),
    6: .same(proto: "point"),
    7: .same(proto: "span"),
    8: .same(proto: "token"),
    9: .standard(proto: "keypoint_locations"),
  ]

  fileprivate class _StorageClass {
    var _boundingBox: Clarifai_Api_BoundingBox? = nil
    var _mask: Clarifai_Api_Mask? = nil
    var _polygon: Clarifai_Api_Polygon? = nil
    var _point: Clarifai_Api_Point? = nil
    var _span: Clarifai_Api_Span? = nil
    var _token: Clarifai_Api_Token? = nil
    var _keypointLocations: [Clarifai_Api_Point] = []

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _boundingBox = source._boundingBox
      _mask = source._mask
      _polygon = source._polygon
      _point = source._point
      _span = source._span
      _token = source._token
      _keypointLocations = source._keypointLocations
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._boundingBox) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._mask) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._polygon) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._point) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._span) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._token) }()
        case 9: try { try decoder.decodeRepeatedMessageField(value: &_storage._keypointLocations) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._boundingBox {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._mask {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._polygon {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._point {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
      try { if let v = _storage._span {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      } }()
      try { if let v = _storage._token {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      } }()
      if !_storage._keypointLocations.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._keypointLocations, fieldNumber: 9)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_RegionInfo, rhs: Clarifai_Api_RegionInfo) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._boundingBox != rhs_storage._boundingBox {return false}
        if _storage._mask != rhs_storage._mask {return false}
        if _storage._polygon != rhs_storage._polygon {return false}
        if _storage._point != rhs_storage._point {return false}
        if _storage._span != rhs_storage._span {return false}
        if _storage._token != rhs_storage._token {return false}
        if _storage._keypointLocations != rhs_storage._keypointLocations {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_BoundingBox: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".BoundingBox"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "top_row"),
    2: .standard(proto: "left_col"),
    3: .standard(proto: "bottom_row"),
    4: .standard(proto: "right_col"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFloatField(value: &self.topRow) }()
      case 2: try { try decoder.decodeSingularFloatField(value: &self.leftCol) }()
      case 3: try { try decoder.decodeSingularFloatField(value: &self.bottomRow) }()
      case 4: try { try decoder.decodeSingularFloatField(value: &self.rightCol) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.topRow != 0 {
      try visitor.visitSingularFloatField(value: self.topRow, fieldNumber: 1)
    }
    if self.leftCol != 0 {
      try visitor.visitSingularFloatField(value: self.leftCol, fieldNumber: 2)
    }
    if self.bottomRow != 0 {
      try visitor.visitSingularFloatField(value: self.bottomRow, fieldNumber: 3)
    }
    if self.rightCol != 0 {
      try visitor.visitSingularFloatField(value: self.rightCol, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_BoundingBox, rhs: Clarifai_Api_BoundingBox) -> Bool {
    if lhs.topRow != rhs.topRow {return false}
    if lhs.leftCol != rhs.leftCol {return false}
    if lhs.bottomRow != rhs.bottomRow {return false}
    if lhs.rightCol != rhs.rightCol {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_FrameInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".FrameInfo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "index"),
    2: .same(proto: "time"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.index) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.time) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.index != 0 {
      try visitor.visitSingularUInt32Field(value: self.index, fieldNumber: 1)
    }
    if self.time != 0 {
      try visitor.visitSingularUInt32Field(value: self.time, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_FrameInfo, rhs: Clarifai_Api_FrameInfo) -> Bool {
    if lhs.index != rhs.index {return false}
    if lhs.time != rhs.time {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_Frame: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Frame"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "frame_info"),
    2: .same(proto: "data"),
    3: .same(proto: "id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._frameInfo) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._data) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.id) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._frameInfo {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._data {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_Frame, rhs: Clarifai_Api_Frame) -> Bool {
    if lhs._frameInfo != rhs._frameInfo {return false}
    if lhs._data != rhs._data {return false}
    if lhs.id != rhs.id {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_NDArray: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".NDArray"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "buffer"),
    2: .same(proto: "shape"),
    3: .same(proto: "dtype"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.buffer) }()
      case 2: try { try decoder.decodeRepeatedUInt32Field(value: &self.shape) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.dtype) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.buffer.isEmpty {
      try visitor.visitSingularBytesField(value: self.buffer, fieldNumber: 1)
    }
    if !self.shape.isEmpty {
      try visitor.visitPackedUInt32Field(value: self.shape, fieldNumber: 2)
    }
    if !self.dtype.isEmpty {
      try visitor.visitSingularStringField(value: self.dtype, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_NDArray, rhs: Clarifai_Api_NDArray) -> Bool {
    if lhs.buffer != rhs.buffer {return false}
    if lhs.shape != rhs.shape {return false}
    if lhs.dtype != rhs.dtype {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_Mask: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Mask"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .same(proto: "image"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeSingularMessageField(value: &self._image) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._image {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_Mask, rhs: Clarifai_Api_Mask) -> Bool {
    if lhs._image != rhs._image {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_Polygon: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Polygon"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "points"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.points) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.points.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.points, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_Polygon, rhs: Clarifai_Api_Polygon) -> Bool {
    if lhs.points != rhs.points {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_Point: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Point"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "row"),
    2: .same(proto: "col"),
    3: .same(proto: "z"),
    4: .same(proto: "visibility"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFloatField(value: &self.row) }()
      case 2: try { try decoder.decodeSingularFloatField(value: &self.col) }()
      case 3: try { try decoder.decodeSingularFloatField(value: &self.z) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self.visibility) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.row != 0 {
      try visitor.visitSingularFloatField(value: self.row, fieldNumber: 1)
    }
    if self.col != 0 {
      try visitor.visitSingularFloatField(value: self.col, fieldNumber: 2)
    }
    if self.z != 0 {
      try visitor.visitSingularFloatField(value: self.z, fieldNumber: 3)
    }
    if self.visibility != .notSet {
      try visitor.visitSingularEnumField(value: self.visibility, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_Point, rhs: Clarifai_Api_Point) -> Bool {
    if lhs.row != rhs.row {return false}
    if lhs.col != rhs.col {return false}
    if lhs.z != rhs.z {return false}
    if lhs.visibility != rhs.visibility {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_Point.Visibility: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NOT_SET"),
    1: .same(proto: "VISIBLE"),
    2: .same(proto: "NOT_VISIBLE"),
    3: .same(proto: "NOT_PRESENT"),
  ]
}

extension Clarifai_Api_Span: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Span"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "char_start"),
    2: .standard(proto: "char_end"),
    3: .standard(proto: "raw_text"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.charStart) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.charEnd) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.rawText) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.charStart != 0 {
      try visitor.visitSingularUInt32Field(value: self.charStart, fieldNumber: 1)
    }
    if self.charEnd != 0 {
      try visitor.visitSingularUInt32Field(value: self.charEnd, fieldNumber: 2)
    }
    if !self.rawText.isEmpty {
      try visitor.visitSingularStringField(value: self.rawText, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_Span, rhs: Clarifai_Api_Span) -> Bool {
    if lhs.charStart != rhs.charStart {return false}
    if lhs.charEnd != rhs.charEnd {return false}
    if lhs.rawText != rhs.rawText {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_Token: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Token"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "char_start"),
    2: .standard(proto: "char_end"),
    3: .standard(proto: "raw_text"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.charStart) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.charEnd) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.rawText) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.charStart != 0 {
      try visitor.visitSingularUInt32Field(value: self.charStart, fieldNumber: 1)
    }
    if self.charEnd != 0 {
      try visitor.visitSingularUInt32Field(value: self.charEnd, fieldNumber: 2)
    }
    if !self.rawText.isEmpty {
      try visitor.visitSingularStringField(value: self.rawText, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_Token, rhs: Clarifai_Api_Token) -> Bool {
    if lhs.charStart != rhs.charStart {return false}
    if lhs.charEnd != rhs.charEnd {return false}
    if lhs.rawText != rhs.rawText {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_Embedding: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Embedding"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "vector"),
    2: .standard(proto: "num_dimensions"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedFloatField(value: &self.vector) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.numDimensions) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.vector.isEmpty {
      try visitor.visitPackedFloatField(value: self.vector, fieldNumber: 1)
    }
    if self.numDimensions != 0 {
      try visitor.visitSingularUInt32Field(value: self.numDimensions, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_Embedding, rhs: Clarifai_Api_Embedding) -> Bool {
    if lhs.vector != rhs.vector {return false}
    if lhs.numDimensions != rhs.numDimensions {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_GeoPoint: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GeoPoint"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "longitude"),
    2: .same(proto: "latitude"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFloatField(value: &self.longitude) }()
      case 2: try { try decoder.decodeSingularFloatField(value: &self.latitude) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.longitude != 0 {
      try visitor.visitSingularFloatField(value: self.longitude, fieldNumber: 1)
    }
    if self.latitude != 0 {
      try visitor.visitSingularFloatField(value: self.latitude, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_GeoPoint, rhs: Clarifai_Api_GeoPoint) -> Bool {
    if lhs.longitude != rhs.longitude {return false}
    if lhs.latitude != rhs.latitude {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_GeoLimit: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GeoLimit"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .same(proto: "value"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.type) }()
      case 2: try { try decoder.decodeSingularFloatField(value: &self.value) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.type.isEmpty {
      try visitor.visitSingularStringField(value: self.type, fieldNumber: 1)
    }
    if self.value != 0 {
      try visitor.visitSingularFloatField(value: self.value, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_GeoLimit, rhs: Clarifai_Api_GeoLimit) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_GeoBoxedPoint: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GeoBoxedPoint"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "geo_point"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._geoPoint) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._geoPoint {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_GeoBoxedPoint, rhs: Clarifai_Api_GeoBoxedPoint) -> Bool {
    if lhs._geoPoint != rhs._geoPoint {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_Geo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Geo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "geo_point"),
    2: .standard(proto: "geo_limit"),
    3: .standard(proto: "geo_box"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._geoPoint) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._geoLimit) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.geoBox) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._geoPoint {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._geoLimit {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.geoBox.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.geoBox, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_Geo, rhs: Clarifai_Api_Geo) -> Bool {
    if lhs._geoPoint != rhs._geoPoint {return false}
    if lhs._geoLimit != rhs._geoLimit {return false}
    if lhs.geoBox != rhs.geoBox {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_Image: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Image"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "url"),
    2: .same(proto: "base64"),
    4: .standard(proto: "allow_duplicate_url"),
    5: .same(proto: "hosted"),
    6: .standard(proto: "image_info"),
    7: .standard(proto: "hosted_image_info"),
    8: .standard(proto: "decoded_bytes"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.url) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.base64) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.allowDuplicateURL) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._hosted) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._imageInfo) }()
      case 7: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Clarifai_Api_ImageInfo>.self, value: &self.hostedImageInfo) }()
      case 8: try { try decoder.decodeSingularBytesField(value: &self.decodedBytes) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.url.isEmpty {
      try visitor.visitSingularStringField(value: self.url, fieldNumber: 1)
    }
    if !self.base64.isEmpty {
      try visitor.visitSingularBytesField(value: self.base64, fieldNumber: 2)
    }
    if self.allowDuplicateURL != false {
      try visitor.visitSingularBoolField(value: self.allowDuplicateURL, fieldNumber: 4)
    }
    try { if let v = self._hosted {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._imageInfo {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    if !self.hostedImageInfo.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Clarifai_Api_ImageInfo>.self, value: self.hostedImageInfo, fieldNumber: 7)
    }
    if !self.decodedBytes.isEmpty {
      try visitor.visitSingularBytesField(value: self.decodedBytes, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_Image, rhs: Clarifai_Api_Image) -> Bool {
    if lhs.url != rhs.url {return false}
    if lhs.base64 != rhs.base64 {return false}
    if lhs.allowDuplicateURL != rhs.allowDuplicateURL {return false}
    if lhs._hosted != rhs._hosted {return false}
    if lhs._imageInfo != rhs._imageInfo {return false}
    if lhs.hostedImageInfo != rhs.hostedImageInfo {return false}
    if lhs.decodedBytes != rhs.decodedBytes {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_ImageInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ImageInfo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "width"),
    2: .same(proto: "height"),
    3: .same(proto: "format"),
    4: .standard(proto: "color_mode"),
    5: .same(proto: "mode"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.width) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.height) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.format) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.colorMode) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.mode) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.width != 0 {
      try visitor.visitSingularInt32Field(value: self.width, fieldNumber: 1)
    }
    if self.height != 0 {
      try visitor.visitSingularInt32Field(value: self.height, fieldNumber: 2)
    }
    if !self.format.isEmpty {
      try visitor.visitSingularStringField(value: self.format, fieldNumber: 3)
    }
    if !self.colorMode.isEmpty {
      try visitor.visitSingularStringField(value: self.colorMode, fieldNumber: 4)
    }
    if !self.mode.isEmpty {
      try visitor.visitSingularStringField(value: self.mode, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_ImageInfo, rhs: Clarifai_Api_ImageInfo) -> Bool {
    if lhs.width != rhs.width {return false}
    if lhs.height != rhs.height {return false}
    if lhs.format != rhs.format {return false}
    if lhs.colorMode != rhs.colorMode {return false}
    if lhs.mode != rhs.mode {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_HostedURL: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".HostedURL"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "prefix"),
    2: .same(proto: "suffix"),
    3: .same(proto: "sizes"),
    4: .same(proto: "crossorigin"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.prefix) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.suffix) }()
      case 3: try { try decoder.decodeRepeatedStringField(value: &self.sizes) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.crossorigin) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.prefix.isEmpty {
      try visitor.visitSingularStringField(value: self.prefix, fieldNumber: 1)
    }
    if !self.suffix.isEmpty {
      try visitor.visitSingularStringField(value: self.suffix, fieldNumber: 2)
    }
    if !self.sizes.isEmpty {
      try visitor.visitRepeatedStringField(value: self.sizes, fieldNumber: 3)
    }
    if !self.crossorigin.isEmpty {
      try visitor.visitSingularStringField(value: self.crossorigin, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_HostedURL, rhs: Clarifai_Api_HostedURL) -> Bool {
    if lhs.prefix != rhs.prefix {return false}
    if lhs.suffix != rhs.suffix {return false}
    if lhs.sizes != rhs.sizes {return false}
    if lhs.crossorigin != rhs.crossorigin {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_Input: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Input"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "data"),
    4: .standard(proto: "created_at"),
    5: .standard(proto: "modified_at"),
    6: .same(proto: "status"),
    7: .standard(proto: "dataset_ids"),
  ]

  fileprivate class _StorageClass {
    var _id: String = String()
    var _data: Clarifai_Api_Data? = nil
    var _createdAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _modifiedAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _status: Clarifai_Api_Status_Status? = nil
    var _datasetIds: [String] = []

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _id = source._id
      _data = source._data
      _createdAt = source._createdAt
      _modifiedAt = source._modifiedAt
      _status = source._status
      _datasetIds = source._datasetIds
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._id) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._data) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._createdAt) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._modifiedAt) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._status) }()
        case 7: try { try decoder.decodeRepeatedStringField(value: &_storage._datasetIds) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._id.isEmpty {
        try visitor.visitSingularStringField(value: _storage._id, fieldNumber: 1)
      }
      try { if let v = _storage._data {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._createdAt {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._modifiedAt {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._status {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
      if !_storage._datasetIds.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._datasetIds, fieldNumber: 7)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_Input, rhs: Clarifai_Api_Input) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._id != rhs_storage._id {return false}
        if _storage._data != rhs_storage._data {return false}
        if _storage._createdAt != rhs_storage._createdAt {return false}
        if _storage._modifiedAt != rhs_storage._modifiedAt {return false}
        if _storage._status != rhs_storage._status {return false}
        if _storage._datasetIds != rhs_storage._datasetIds {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_InputBatch: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".InputBatch"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "inputs"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.inputs) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.inputs.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.inputs, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_InputBatch, rhs: Clarifai_Api_InputBatch) -> Bool {
    if lhs.inputs != rhs.inputs {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_InputCount: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".InputCount"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "processed"),
    2: .standard(proto: "to_process"),
    3: .same(proto: "errors"),
    4: .same(proto: "processing"),
    5: .same(proto: "reindexed"),
    6: .standard(proto: "to_reindex"),
    7: .standard(proto: "reindex_errors"),
    8: .same(proto: "reindexing"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.processed) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.toProcess) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.errors) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self.processing) }()
      case 5: try { try decoder.decodeSingularUInt32Field(value: &self.reindexed) }()
      case 6: try { try decoder.decodeSingularUInt32Field(value: &self.toReindex) }()
      case 7: try { try decoder.decodeSingularUInt32Field(value: &self.reindexErrors) }()
      case 8: try { try decoder.decodeSingularUInt32Field(value: &self.reindexing) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.processed != 0 {
      try visitor.visitSingularUInt32Field(value: self.processed, fieldNumber: 1)
    }
    if self.toProcess != 0 {
      try visitor.visitSingularUInt32Field(value: self.toProcess, fieldNumber: 2)
    }
    if self.errors != 0 {
      try visitor.visitSingularUInt32Field(value: self.errors, fieldNumber: 3)
    }
    if self.processing != 0 {
      try visitor.visitSingularUInt32Field(value: self.processing, fieldNumber: 4)
    }
    if self.reindexed != 0 {
      try visitor.visitSingularUInt32Field(value: self.reindexed, fieldNumber: 5)
    }
    if self.toReindex != 0 {
      try visitor.visitSingularUInt32Field(value: self.toReindex, fieldNumber: 6)
    }
    if self.reindexErrors != 0 {
      try visitor.visitSingularUInt32Field(value: self.reindexErrors, fieldNumber: 7)
    }
    if self.reindexing != 0 {
      try visitor.visitSingularUInt32Field(value: self.reindexing, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_InputCount, rhs: Clarifai_Api_InputCount) -> Bool {
    if lhs.processed != rhs.processed {return false}
    if lhs.toProcess != rhs.toProcess {return false}
    if lhs.errors != rhs.errors {return false}
    if lhs.processing != rhs.processing {return false}
    if lhs.reindexed != rhs.reindexed {return false}
    if lhs.toReindex != rhs.toReindex {return false}
    if lhs.reindexErrors != rhs.reindexErrors {return false}
    if lhs.reindexing != rhs.reindexing {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_Dataset: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Dataset"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .standard(proto: "created_at"),
    3: .standard(proto: "modified_at"),
    4: .standard(proto: "app_id"),
    5: .standard(proto: "user_id"),
    7: .same(proto: "description"),
    8: .same(proto: "metadata"),
    9: .same(proto: "visibility"),
    12: .standard(proto: "default_annotation_filter"),
    16: .standard(proto: "default_processing_info"),
    11: .same(proto: "notes"),
    13: .same(proto: "version"),
    14: .standard(proto: "is_starred"),
    15: .standard(proto: "star_count"),
    17: .standard(proto: "bookmark_origin"),
    18: .same(proto: "image"),
  ]

  fileprivate class _StorageClass {
    var _id: String = String()
    var _createdAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _modifiedAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _appID: String = String()
    var _userID: String = String()
    var _description_p: String = String()
    var _metadata: SwiftProtobuf.Google_Protobuf_Struct? = nil
    var _visibility: Clarifai_Api_Visibility? = nil
    var _defaultAnnotationFilter: Clarifai_Api_AnnotationFilter? = nil
    var _defaultProcessingInfo: Clarifai_Api_DatasetVersionProcessingInfo? = nil
    var _notes: String = String()
    var _version: Clarifai_Api_DatasetVersion? = nil
    var _isStarred: Bool = false
    var _starCount: Int32 = 0
    var _bookmarkOrigin: Clarifai_Api_BookmarkOrigin? = nil
    var _image: Clarifai_Api_Image? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _id = source._id
      _createdAt = source._createdAt
      _modifiedAt = source._modifiedAt
      _appID = source._appID
      _userID = source._userID
      _description_p = source._description_p
      _metadata = source._metadata
      _visibility = source._visibility
      _defaultAnnotationFilter = source._defaultAnnotationFilter
      _defaultProcessingInfo = source._defaultProcessingInfo
      _notes = source._notes
      _version = source._version
      _isStarred = source._isStarred
      _starCount = source._starCount
      _bookmarkOrigin = source._bookmarkOrigin
      _image = source._image
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._id) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._createdAt) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._modifiedAt) }()
        case 4: try { try decoder.decodeSingularStringField(value: &_storage._appID) }()
        case 5: try { try decoder.decodeSingularStringField(value: &_storage._userID) }()
        case 7: try { try decoder.decodeSingularStringField(value: &_storage._description_p) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._metadata) }()
        case 9: try { try decoder.decodeSingularMessageField(value: &_storage._visibility) }()
        case 11: try { try decoder.decodeSingularStringField(value: &_storage._notes) }()
        case 12: try { try decoder.decodeSingularMessageField(value: &_storage._defaultAnnotationFilter) }()
        case 13: try { try decoder.decodeSingularMessageField(value: &_storage._version) }()
        case 14: try { try decoder.decodeSingularBoolField(value: &_storage._isStarred) }()
        case 15: try { try decoder.decodeSingularInt32Field(value: &_storage._starCount) }()
        case 16: try { try decoder.decodeSingularMessageField(value: &_storage._defaultProcessingInfo) }()
        case 17: try { try decoder.decodeSingularMessageField(value: &_storage._bookmarkOrigin) }()
        case 18: try { try decoder.decodeSingularMessageField(value: &_storage._image) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._id.isEmpty {
        try visitor.visitSingularStringField(value: _storage._id, fieldNumber: 1)
      }
      try { if let v = _storage._createdAt {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._modifiedAt {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      if !_storage._appID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._appID, fieldNumber: 4)
      }
      if !_storage._userID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._userID, fieldNumber: 5)
      }
      if !_storage._description_p.isEmpty {
        try visitor.visitSingularStringField(value: _storage._description_p, fieldNumber: 7)
      }
      try { if let v = _storage._metadata {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      } }()
      try { if let v = _storage._visibility {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      } }()
      if !_storage._notes.isEmpty {
        try visitor.visitSingularStringField(value: _storage._notes, fieldNumber: 11)
      }
      try { if let v = _storage._defaultAnnotationFilter {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
      } }()
      try { if let v = _storage._version {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
      } }()
      if _storage._isStarred != false {
        try visitor.visitSingularBoolField(value: _storage._isStarred, fieldNumber: 14)
      }
      if _storage._starCount != 0 {
        try visitor.visitSingularInt32Field(value: _storage._starCount, fieldNumber: 15)
      }
      try { if let v = _storage._defaultProcessingInfo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
      } }()
      try { if let v = _storage._bookmarkOrigin {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 17)
      } }()
      try { if let v = _storage._image {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 18)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_Dataset, rhs: Clarifai_Api_Dataset) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._id != rhs_storage._id {return false}
        if _storage._createdAt != rhs_storage._createdAt {return false}
        if _storage._modifiedAt != rhs_storage._modifiedAt {return false}
        if _storage._appID != rhs_storage._appID {return false}
        if _storage._userID != rhs_storage._userID {return false}
        if _storage._description_p != rhs_storage._description_p {return false}
        if _storage._metadata != rhs_storage._metadata {return false}
        if _storage._visibility != rhs_storage._visibility {return false}
        if _storage._defaultAnnotationFilter != rhs_storage._defaultAnnotationFilter {return false}
        if _storage._defaultProcessingInfo != rhs_storage._defaultProcessingInfo {return false}
        if _storage._notes != rhs_storage._notes {return false}
        if _storage._version != rhs_storage._version {return false}
        if _storage._isStarred != rhs_storage._isStarred {return false}
        if _storage._starCount != rhs_storage._starCount {return false}
        if _storage._bookmarkOrigin != rhs_storage._bookmarkOrigin {return false}
        if _storage._image != rhs_storage._image {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_AnnotationFilter: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AnnotationFilter"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .standard(proto: "created_at"),
    3: .standard(proto: "modified_at"),
    4: .standard(proto: "user_id"),
    5: .standard(proto: "app_id"),
    9: .same(proto: "search"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._createdAt) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._modifiedAt) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.userID) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.appID) }()
      case 9: try { try decoder.decodeSingularMessageField(value: &self._search) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    try { if let v = self._createdAt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._modifiedAt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if !self.userID.isEmpty {
      try visitor.visitSingularStringField(value: self.userID, fieldNumber: 4)
    }
    if !self.appID.isEmpty {
      try visitor.visitSingularStringField(value: self.appID, fieldNumber: 5)
    }
    try { if let v = self._search {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_AnnotationFilter, rhs: Clarifai_Api_AnnotationFilter) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs._createdAt != rhs._createdAt {return false}
    if lhs._modifiedAt != rhs._modifiedAt {return false}
    if lhs.userID != rhs.userID {return false}
    if lhs.appID != rhs.appID {return false}
    if lhs._search != rhs._search {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_DatasetInput: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DatasetInput"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "created_at"),
    2: .same(proto: "input"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._createdAt) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._input) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._createdAt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._input {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_DatasetInput, rhs: Clarifai_Api_DatasetInput) -> Bool {
    if lhs._createdAt != rhs._createdAt {return false}
    if lhs._input != rhs._input {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_DatasetVersion: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DatasetVersion"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .standard(proto: "created_at"),
    3: .standard(proto: "modified_at"),
    4: .standard(proto: "app_id"),
    5: .standard(proto: "user_id"),
    6: .standard(proto: "dataset_id"),
    15: .standard(proto: "annotation_filter_config"),
    18: .standard(proto: "model_predict_config"),
    8: .same(proto: "status"),
    10: .same(proto: "description"),
    19: .standard(proto: "processing_info"),
    16: .same(proto: "metrics"),
    17: .standard(proto: "export_info"),
    12: .same(proto: "metadata"),
    13: .same(proto: "visibility"),
    14: .standard(proto: "embed_model_version_ids"),
    20: .standard(proto: "request_origin"),
  ]

  fileprivate class _StorageClass {
    var _id: String = String()
    var _createdAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _modifiedAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _appID: String = String()
    var _userID: String = String()
    var _datasetID: String = String()
    var _dataConfig: Clarifai_Api_DatasetVersion.OneOf_DataConfig?
    var _status: Clarifai_Api_Status_Status? = nil
    var _description_p: String = String()
    var _processingInfo: Clarifai_Api_DatasetVersionProcessingInfo? = nil
    var _metrics: Dictionary<String,Clarifai_Api_DatasetVersionMetrics> = [:]
    var _exportInfo: Clarifai_Api_DatasetVersionExportInfo? = nil
    var _metadata: SwiftProtobuf.Google_Protobuf_Struct? = nil
    var _visibility: Clarifai_Api_Visibility? = nil
    var _embedModelVersionIds: [String] = []
    var _requestOrigin: Clarifai_Api_DatasetVersionRequestOrigin = .notSet

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _id = source._id
      _createdAt = source._createdAt
      _modifiedAt = source._modifiedAt
      _appID = source._appID
      _userID = source._userID
      _datasetID = source._datasetID
      _dataConfig = source._dataConfig
      _status = source._status
      _description_p = source._description_p
      _processingInfo = source._processingInfo
      _metrics = source._metrics
      _exportInfo = source._exportInfo
      _metadata = source._metadata
      _visibility = source._visibility
      _embedModelVersionIds = source._embedModelVersionIds
      _requestOrigin = source._requestOrigin
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._id) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._createdAt) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._modifiedAt) }()
        case 4: try { try decoder.decodeSingularStringField(value: &_storage._appID) }()
        case 5: try { try decoder.decodeSingularStringField(value: &_storage._userID) }()
        case 6: try { try decoder.decodeSingularStringField(value: &_storage._datasetID) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._status) }()
        case 10: try { try decoder.decodeSingularStringField(value: &_storage._description_p) }()
        case 12: try { try decoder.decodeSingularMessageField(value: &_storage._metadata) }()
        case 13: try { try decoder.decodeSingularMessageField(value: &_storage._visibility) }()
        case 14: try { try decoder.decodeRepeatedStringField(value: &_storage._embedModelVersionIds) }()
        case 15: try {
          var v: Clarifai_Api_AnnotationFilterConfig?
          var hadOneofValue = false
          if let current = _storage._dataConfig {
            hadOneofValue = true
            if case .annotationFilterConfig(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._dataConfig = .annotationFilterConfig(v)
          }
        }()
        case 16: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Clarifai_Api_DatasetVersionMetrics>.self, value: &_storage._metrics) }()
        case 17: try { try decoder.decodeSingularMessageField(value: &_storage._exportInfo) }()
        case 18: try {
          var v: Clarifai_Api_ModelPredictConfig?
          var hadOneofValue = false
          if let current = _storage._dataConfig {
            hadOneofValue = true
            if case .modelPredictConfig(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._dataConfig = .modelPredictConfig(v)
          }
        }()
        case 19: try { try decoder.decodeSingularMessageField(value: &_storage._processingInfo) }()
        case 20: try { try decoder.decodeSingularEnumField(value: &_storage._requestOrigin) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._id.isEmpty {
        try visitor.visitSingularStringField(value: _storage._id, fieldNumber: 1)
      }
      try { if let v = _storage._createdAt {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._modifiedAt {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      if !_storage._appID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._appID, fieldNumber: 4)
      }
      if !_storage._userID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._userID, fieldNumber: 5)
      }
      if !_storage._datasetID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._datasetID, fieldNumber: 6)
      }
      try { if let v = _storage._status {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      } }()
      if !_storage._description_p.isEmpty {
        try visitor.visitSingularStringField(value: _storage._description_p, fieldNumber: 10)
      }
      try { if let v = _storage._metadata {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
      } }()
      try { if let v = _storage._visibility {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
      } }()
      if !_storage._embedModelVersionIds.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._embedModelVersionIds, fieldNumber: 14)
      }
      try { if case .annotationFilterConfig(let v)? = _storage._dataConfig {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
      } }()
      if !_storage._metrics.isEmpty {
        try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Clarifai_Api_DatasetVersionMetrics>.self, value: _storage._metrics, fieldNumber: 16)
      }
      try { if let v = _storage._exportInfo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 17)
      } }()
      try { if case .modelPredictConfig(let v)? = _storage._dataConfig {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 18)
      } }()
      try { if let v = _storage._processingInfo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 19)
      } }()
      if _storage._requestOrigin != .notSet {
        try visitor.visitSingularEnumField(value: _storage._requestOrigin, fieldNumber: 20)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_DatasetVersion, rhs: Clarifai_Api_DatasetVersion) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._id != rhs_storage._id {return false}
        if _storage._createdAt != rhs_storage._createdAt {return false}
        if _storage._modifiedAt != rhs_storage._modifiedAt {return false}
        if _storage._appID != rhs_storage._appID {return false}
        if _storage._userID != rhs_storage._userID {return false}
        if _storage._datasetID != rhs_storage._datasetID {return false}
        if _storage._dataConfig != rhs_storage._dataConfig {return false}
        if _storage._status != rhs_storage._status {return false}
        if _storage._description_p != rhs_storage._description_p {return false}
        if _storage._processingInfo != rhs_storage._processingInfo {return false}
        if _storage._metrics != rhs_storage._metrics {return false}
        if _storage._exportInfo != rhs_storage._exportInfo {return false}
        if _storage._metadata != rhs_storage._metadata {return false}
        if _storage._visibility != rhs_storage._visibility {return false}
        if _storage._embedModelVersionIds != rhs_storage._embedModelVersionIds {return false}
        if _storage._requestOrigin != rhs_storage._requestOrigin {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_AnnotationFilterConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AnnotationFilterConfig"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "annotation_filter"),
    2: .standard(proto: "ignore_empty_inputs"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._annotationFilter) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.ignoreEmptyInputs) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._annotationFilter {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.ignoreEmptyInputs != false {
      try visitor.visitSingularBoolField(value: self.ignoreEmptyInputs, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_AnnotationFilterConfig, rhs: Clarifai_Api_AnnotationFilterConfig) -> Bool {
    if lhs._annotationFilter != rhs._annotationFilter {return false}
    if lhs.ignoreEmptyInputs != rhs.ignoreEmptyInputs {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_ModelPredictConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ModelPredictConfig"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "model"),
  ]

  fileprivate class _StorageClass {
    var _model: Clarifai_Api_Model? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _model = source._model
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._model) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._model {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_ModelPredictConfig, rhs: Clarifai_Api_ModelPredictConfig) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._model != rhs_storage._model {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_DatasetVersionMetrics: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DatasetVersionMetrics"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "inputs_count"),
    6: .standard(proto: "unlabeled_inputs_count"),
    8: .standard(proto: "inputs_with_metadata_count"),
    9: .standard(proto: "inputs_with_geo_count"),
    20: .standard(proto: "regions_count"),
    21: .standard(proto: "region_location_matrix"),
    22: .standard(proto: "bounding_boxes_count"),
    23: .standard(proto: "polygons_count"),
    24: .standard(proto: "points_count"),
    25: .standard(proto: "masks_count"),
    60: .standard(proto: "region_inputs_count"),
    61: .standard(proto: "region_frames_count"),
    30: .standard(proto: "frames_count"),
    70: .standard(proto: "frame_inputs_count"),
    40: .standard(proto: "embeddings_count"),
    50: .standard(proto: "positive_input_tags_count"),
    51: .standard(proto: "positive_region_tags_count"),
    52: .standard(proto: "positive_frame_tags_count"),
  ]

  fileprivate class _StorageClass {
    var _inputsCount: SwiftProtobuf.Google_Protobuf_UInt64Value? = nil
    var _unlabeledInputsCount: SwiftProtobuf.Google_Protobuf_UInt64Value? = nil
    var _inputsWithMetadataCount: SwiftProtobuf.Google_Protobuf_UInt64Value? = nil
    var _inputsWithGeoCount: SwiftProtobuf.Google_Protobuf_UInt64Value? = nil
    var _regionsCount: SwiftProtobuf.Google_Protobuf_UInt64Value? = nil
    var _regionLocationMatrix: MatrixUint64? = nil
    var _boundingBoxesCount: SwiftProtobuf.Google_Protobuf_UInt64Value? = nil
    var _polygonsCount: SwiftProtobuf.Google_Protobuf_UInt64Value? = nil
    var _pointsCount: SwiftProtobuf.Google_Protobuf_UInt64Value? = nil
    var _masksCount: SwiftProtobuf.Google_Protobuf_UInt64Value? = nil
    var _regionInputsCount: SwiftProtobuf.Google_Protobuf_UInt64Value? = nil
    var _regionFramesCount: SwiftProtobuf.Google_Protobuf_UInt64Value? = nil
    var _framesCount: SwiftProtobuf.Google_Protobuf_UInt64Value? = nil
    var _frameInputsCount: SwiftProtobuf.Google_Protobuf_UInt64Value? = nil
    var _embeddingsCount: SwiftProtobuf.Google_Protobuf_UInt64Value? = nil
    var _positiveInputTagsCount: SwiftProtobuf.Google_Protobuf_UInt64Value? = nil
    var _positiveRegionTagsCount: SwiftProtobuf.Google_Protobuf_UInt64Value? = nil
    var _positiveFrameTagsCount: SwiftProtobuf.Google_Protobuf_UInt64Value? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _inputsCount = source._inputsCount
      _unlabeledInputsCount = source._unlabeledInputsCount
      _inputsWithMetadataCount = source._inputsWithMetadataCount
      _inputsWithGeoCount = source._inputsWithGeoCount
      _regionsCount = source._regionsCount
      _regionLocationMatrix = source._regionLocationMatrix
      _boundingBoxesCount = source._boundingBoxesCount
      _polygonsCount = source._polygonsCount
      _pointsCount = source._pointsCount
      _masksCount = source._masksCount
      _regionInputsCount = source._regionInputsCount
      _regionFramesCount = source._regionFramesCount
      _framesCount = source._framesCount
      _frameInputsCount = source._frameInputsCount
      _embeddingsCount = source._embeddingsCount
      _positiveInputTagsCount = source._positiveInputTagsCount
      _positiveRegionTagsCount = source._positiveRegionTagsCount
      _positiveFrameTagsCount = source._positiveFrameTagsCount
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._inputsCount) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._unlabeledInputsCount) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._inputsWithMetadataCount) }()
        case 9: try { try decoder.decodeSingularMessageField(value: &_storage._inputsWithGeoCount) }()
        case 20: try { try decoder.decodeSingularMessageField(value: &_storage._regionsCount) }()
        case 21: try { try decoder.decodeSingularMessageField(value: &_storage._regionLocationMatrix) }()
        case 22: try { try decoder.decodeSingularMessageField(value: &_storage._boundingBoxesCount) }()
        case 23: try { try decoder.decodeSingularMessageField(value: &_storage._polygonsCount) }()
        case 24: try { try decoder.decodeSingularMessageField(value: &_storage._pointsCount) }()
        case 25: try { try decoder.decodeSingularMessageField(value: &_storage._masksCount) }()
        case 30: try { try decoder.decodeSingularMessageField(value: &_storage._framesCount) }()
        case 40: try { try decoder.decodeSingularMessageField(value: &_storage._embeddingsCount) }()
        case 50: try { try decoder.decodeSingularMessageField(value: &_storage._positiveInputTagsCount) }()
        case 51: try { try decoder.decodeSingularMessageField(value: &_storage._positiveRegionTagsCount) }()
        case 52: try { try decoder.decodeSingularMessageField(value: &_storage._positiveFrameTagsCount) }()
        case 60: try { try decoder.decodeSingularMessageField(value: &_storage._regionInputsCount) }()
        case 61: try { try decoder.decodeSingularMessageField(value: &_storage._regionFramesCount) }()
        case 70: try { try decoder.decodeSingularMessageField(value: &_storage._frameInputsCount) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._inputsCount {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._unlabeledInputsCount {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
      try { if let v = _storage._inputsWithMetadataCount {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      } }()
      try { if let v = _storage._inputsWithGeoCount {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      } }()
      try { if let v = _storage._regionsCount {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 20)
      } }()
      try { if let v = _storage._regionLocationMatrix {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 21)
      } }()
      try { if let v = _storage._boundingBoxesCount {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 22)
      } }()
      try { if let v = _storage._polygonsCount {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 23)
      } }()
      try { if let v = _storage._pointsCount {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 24)
      } }()
      try { if let v = _storage._masksCount {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 25)
      } }()
      try { if let v = _storage._framesCount {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 30)
      } }()
      try { if let v = _storage._embeddingsCount {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 40)
      } }()
      try { if let v = _storage._positiveInputTagsCount {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 50)
      } }()
      try { if let v = _storage._positiveRegionTagsCount {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 51)
      } }()
      try { if let v = _storage._positiveFrameTagsCount {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 52)
      } }()
      try { if let v = _storage._regionInputsCount {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 60)
      } }()
      try { if let v = _storage._regionFramesCount {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 61)
      } }()
      try { if let v = _storage._frameInputsCount {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 70)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_DatasetVersionMetrics, rhs: Clarifai_Api_DatasetVersionMetrics) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._inputsCount != rhs_storage._inputsCount {return false}
        if _storage._unlabeledInputsCount != rhs_storage._unlabeledInputsCount {return false}
        if _storage._inputsWithMetadataCount != rhs_storage._inputsWithMetadataCount {return false}
        if _storage._inputsWithGeoCount != rhs_storage._inputsWithGeoCount {return false}
        if _storage._regionsCount != rhs_storage._regionsCount {return false}
        if _storage._regionLocationMatrix != rhs_storage._regionLocationMatrix {return false}
        if _storage._boundingBoxesCount != rhs_storage._boundingBoxesCount {return false}
        if _storage._polygonsCount != rhs_storage._polygonsCount {return false}
        if _storage._pointsCount != rhs_storage._pointsCount {return false}
        if _storage._masksCount != rhs_storage._masksCount {return false}
        if _storage._regionInputsCount != rhs_storage._regionInputsCount {return false}
        if _storage._regionFramesCount != rhs_storage._regionFramesCount {return false}
        if _storage._framesCount != rhs_storage._framesCount {return false}
        if _storage._frameInputsCount != rhs_storage._frameInputsCount {return false}
        if _storage._embeddingsCount != rhs_storage._embeddingsCount {return false}
        if _storage._positiveInputTagsCount != rhs_storage._positiveInputTagsCount {return false}
        if _storage._positiveRegionTagsCount != rhs_storage._positiveRegionTagsCount {return false}
        if _storage._positiveFrameTagsCount != rhs_storage._positiveFrameTagsCount {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_DatasetVersionMetricsGroup: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DatasetVersionMetricsGroup"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "parent_path"),
    2: .same(proto: "type"),
    3: .same(proto: "value"),
    4: .same(proto: "metrics"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.parentPath) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.type) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._value) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._metrics) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.parentPath.isEmpty {
      try visitor.visitSingularStringField(value: self.parentPath, fieldNumber: 1)
    }
    if self.type != .notSet {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 2)
    }
    try { if let v = self._value {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._metrics {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_DatasetVersionMetricsGroup, rhs: Clarifai_Api_DatasetVersionMetricsGroup) -> Bool {
    if lhs.parentPath != rhs.parentPath {return false}
    if lhs.type != rhs.type {return false}
    if lhs._value != rhs._value {return false}
    if lhs._metrics != rhs._metrics {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_DatasetVersionExportInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DatasetVersionExportInfo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "clarifai_data_protobuf"),
    3: .standard(proto: "clarifai_data_json"),
    2: .same(proto: "coco"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._clarifaiDataProtobuf) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._coco) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._clarifaiDataJson) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._clarifaiDataProtobuf {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._coco {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._clarifaiDataJson {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_DatasetVersionExportInfo, rhs: Clarifai_Api_DatasetVersionExportInfo) -> Bool {
    if lhs._clarifaiDataProtobuf != rhs._clarifaiDataProtobuf {return false}
    if lhs._clarifaiDataJson != rhs._clarifaiDataJson {return false}
    if lhs._coco != rhs._coco {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_DatasetVersionExport: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DatasetVersionExport"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "format"),
    2: .same(proto: "status"),
    3: .same(proto: "url"),
    4: .same(proto: "size"),
    5: .standard(proto: "include_embeddings"),
  ]

  fileprivate class _StorageClass {
    var _format: Clarifai_Api_DatasetVersionExportFormat = .notSet
    var _status: Clarifai_Api_Status_Status? = nil
    var _url: String = String()
    var _size: UInt64 = 0
    var _includeEmbeddings: Bool = false

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _format = source._format
      _status = source._status
      _url = source._url
      _size = source._size
      _includeEmbeddings = source._includeEmbeddings
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularEnumField(value: &_storage._format) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._status) }()
        case 3: try { try decoder.decodeSingularStringField(value: &_storage._url) }()
        case 4: try { try decoder.decodeSingularUInt64Field(value: &_storage._size) }()
        case 5: try { try decoder.decodeSingularBoolField(value: &_storage._includeEmbeddings) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if _storage._format != .notSet {
        try visitor.visitSingularEnumField(value: _storage._format, fieldNumber: 1)
      }
      try { if let v = _storage._status {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      if !_storage._url.isEmpty {
        try visitor.visitSingularStringField(value: _storage._url, fieldNumber: 3)
      }
      if _storage._size != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._size, fieldNumber: 4)
      }
      if _storage._includeEmbeddings != false {
        try visitor.visitSingularBoolField(value: _storage._includeEmbeddings, fieldNumber: 5)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_DatasetVersionExport, rhs: Clarifai_Api_DatasetVersionExport) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._format != rhs_storage._format {return false}
        if _storage._status != rhs_storage._status {return false}
        if _storage._url != rhs_storage._url {return false}
        if _storage._size != rhs_storage._size {return false}
        if _storage._includeEmbeddings != rhs_storage._includeEmbeddings {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_DatasetVersionProcessingInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DatasetVersionProcessingInfo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "frame_interpolation_info"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._frameInterpolationInfo) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._frameInterpolationInfo {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_DatasetVersionProcessingInfo, rhs: Clarifai_Api_DatasetVersionProcessingInfo) -> Bool {
    if lhs._frameInterpolationInfo != rhs._frameInterpolationInfo {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_FrameInterpolationInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".FrameInterpolationInfo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "sample_ms"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.sampleMs) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.sampleMs != 0 {
      try visitor.visitSingularUInt32Field(value: self.sampleMs, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_FrameInterpolationInfo, rhs: Clarifai_Api_FrameInterpolationInfo) -> Bool {
    if lhs.sampleMs != rhs.sampleMs {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_Key: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Key"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    8: .same(proto: "type"),
    2: .same(proto: "description"),
    3: .same(proto: "scopes"),
    7: .same(proto: "endpoints"),
    4: .same(proto: "apps"),
    5: .standard(proto: "created_at"),
    6: .standard(proto: "expires_at"),
    9: .standard(proto: "authorized_idp_ids"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      case 3: try { try decoder.decodeRepeatedStringField(value: &self.scopes) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.apps) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._createdAt) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._expiresAt) }()
      case 7: try { try decoder.decodeRepeatedStringField(value: &self.endpoints) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self.type) }()
      case 9: try { try decoder.decodeRepeatedStringField(value: &self.authorizedIdpIds) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 2)
    }
    if !self.scopes.isEmpty {
      try visitor.visitRepeatedStringField(value: self.scopes, fieldNumber: 3)
    }
    if !self.apps.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.apps, fieldNumber: 4)
    }
    try { if let v = self._createdAt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._expiresAt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    if !self.endpoints.isEmpty {
      try visitor.visitRepeatedStringField(value: self.endpoints, fieldNumber: 7)
    }
    if !self.type.isEmpty {
      try visitor.visitSingularStringField(value: self.type, fieldNumber: 8)
    }
    if !self.authorizedIdpIds.isEmpty {
      try visitor.visitRepeatedStringField(value: self.authorizedIdpIds, fieldNumber: 9)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_Key, rhs: Clarifai_Api_Key) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.type != rhs.type {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.scopes != rhs.scopes {return false}
    if lhs.endpoints != rhs.endpoints {return false}
    if lhs.apps != rhs.apps {return false}
    if lhs._createdAt != rhs._createdAt {return false}
    if lhs._expiresAt != rhs._expiresAt {return false}
    if lhs.authorizedIdpIds != rhs.authorizedIdpIds {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_Model: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Model"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "name"),
    3: .standard(proto: "created_at"),
    19: .standard(proto: "modified_at"),
    4: .standard(proto: "app_id"),
    5: .standard(proto: "output_info"),
    6: .standard(proto: "model_version"),
    7: .standard(proto: "display_name"),
    9: .standard(proto: "user_id"),
    30: .standard(proto: "default_eval_info"),
    14: .standard(proto: "model_type_id"),
    26: .same(proto: "task"),
    15: .same(proto: "visibility"),
    16: .same(proto: "description"),
    17: .same(proto: "metadata"),
    27: .same(proto: "presets"),
    18: .same(proto: "notes"),
    20: .same(proto: "toolkits"),
    21: .standard(proto: "use_cases"),
    25: .same(proto: "languages"),
    31: .standard(proto: "languages_full"),
    32: .standard(proto: "check_consents"),
    22: .standard(proto: "is_starred"),
    23: .standard(proto: "star_count"),
    29: .standard(proto: "workflow_recommended"),
    33: .standard(proto: "bookmark_origin"),
    34: .same(proto: "image"),
    35: .standard(proto: "license_type"),
    36: .same(proto: "source"),
    37: .same(proto: "creator"),
    38: .standard(proto: "version_count"),
    40: .standard(proto: "billing_type"),
    41: .standard(proto: "featured_order"),
  ]

  fileprivate class _StorageClass {
    var _id: String = String()
    var _name: String = String()
    var _createdAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _modifiedAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _appID: String = String()
    var _outputInfo: Clarifai_Api_OutputInfo? = nil
    var _modelVersion: Clarifai_Api_ModelVersion? = nil
    var _displayName: String = String()
    var _userID: String = String()
    var _defaultEvalInfo: Clarifai_Api_EvalInfo? = nil
    var _modelTypeID: String = String()
    var _task: String = String()
    var _visibility: Clarifai_Api_Visibility? = nil
    var _description_p: String = String()
    var _metadata: SwiftProtobuf.Google_Protobuf_Struct? = nil
    var _presets: SwiftProtobuf.Google_Protobuf_Struct? = nil
    var _notes: String = String()
    var _toolkits: [String] = []
    var _useCases: [String] = []
    var _languages: [String] = []
    var _languagesFull: [Clarifai_Api_FullTag] = []
    var _checkConsents: [String] = []
    var _isStarred: Bool = false
    var _starCount: Int32 = 0
    var _workflowRecommended: SwiftProtobuf.Google_Protobuf_BoolValue? = nil
    var _bookmarkOrigin: Clarifai_Api_BookmarkOrigin? = nil
    var _image: Clarifai_Api_Image? = nil
    var _licenseType: Clarifai_Api_LicenseType = .unknownLicenseType
    var _source: Clarifai_Api_Model.Source = .unknownSource
    var _creator: String = String()
    var _versionCount: Int32 = 0
    var _billingType: Clarifai_Api_Model.BillingType = .unknown
    var _featuredOrder: SwiftProtobuf.Google_Protobuf_Int32Value? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _id = source._id
      _name = source._name
      _createdAt = source._createdAt
      _modifiedAt = source._modifiedAt
      _appID = source._appID
      _outputInfo = source._outputInfo
      _modelVersion = source._modelVersion
      _displayName = source._displayName
      _userID = source._userID
      _defaultEvalInfo = source._defaultEvalInfo
      _modelTypeID = source._modelTypeID
      _task = source._task
      _visibility = source._visibility
      _description_p = source._description_p
      _metadata = source._metadata
      _presets = source._presets
      _notes = source._notes
      _toolkits = source._toolkits
      _useCases = source._useCases
      _languages = source._languages
      _languagesFull = source._languagesFull
      _checkConsents = source._checkConsents
      _isStarred = source._isStarred
      _starCount = source._starCount
      _workflowRecommended = source._workflowRecommended
      _bookmarkOrigin = source._bookmarkOrigin
      _image = source._image
      _licenseType = source._licenseType
      _source = source._source
      _creator = source._creator
      _versionCount = source._versionCount
      _billingType = source._billingType
      _featuredOrder = source._featuredOrder
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._id) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._name) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._createdAt) }()
        case 4: try { try decoder.decodeSingularStringField(value: &_storage._appID) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._outputInfo) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._modelVersion) }()
        case 7: try { try decoder.decodeSingularStringField(value: &_storage._displayName) }()
        case 9: try { try decoder.decodeSingularStringField(value: &_storage._userID) }()
        case 14: try { try decoder.decodeSingularStringField(value: &_storage._modelTypeID) }()
        case 15: try { try decoder.decodeSingularMessageField(value: &_storage._visibility) }()
        case 16: try { try decoder.decodeSingularStringField(value: &_storage._description_p) }()
        case 17: try { try decoder.decodeSingularMessageField(value: &_storage._metadata) }()
        case 18: try { try decoder.decodeSingularStringField(value: &_storage._notes) }()
        case 19: try { try decoder.decodeSingularMessageField(value: &_storage._modifiedAt) }()
        case 20: try { try decoder.decodeRepeatedStringField(value: &_storage._toolkits) }()
        case 21: try { try decoder.decodeRepeatedStringField(value: &_storage._useCases) }()
        case 22: try { try decoder.decodeSingularBoolField(value: &_storage._isStarred) }()
        case 23: try { try decoder.decodeSingularInt32Field(value: &_storage._starCount) }()
        case 25: try { try decoder.decodeRepeatedStringField(value: &_storage._languages) }()
        case 26: try { try decoder.decodeSingularStringField(value: &_storage._task) }()
        case 27: try { try decoder.decodeSingularMessageField(value: &_storage._presets) }()
        case 29: try { try decoder.decodeSingularMessageField(value: &_storage._workflowRecommended) }()
        case 30: try { try decoder.decodeSingularMessageField(value: &_storage._defaultEvalInfo) }()
        case 31: try { try decoder.decodeRepeatedMessageField(value: &_storage._languagesFull) }()
        case 32: try { try decoder.decodeRepeatedStringField(value: &_storage._checkConsents) }()
        case 33: try { try decoder.decodeSingularMessageField(value: &_storage._bookmarkOrigin) }()
        case 34: try { try decoder.decodeSingularMessageField(value: &_storage._image) }()
        case 35: try { try decoder.decodeSingularEnumField(value: &_storage._licenseType) }()
        case 36: try { try decoder.decodeSingularEnumField(value: &_storage._source) }()
        case 37: try { try decoder.decodeSingularStringField(value: &_storage._creator) }()
        case 38: try { try decoder.decodeSingularInt32Field(value: &_storage._versionCount) }()
        case 40: try { try decoder.decodeSingularEnumField(value: &_storage._billingType) }()
        case 41: try { try decoder.decodeSingularMessageField(value: &_storage._featuredOrder) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._id.isEmpty {
        try visitor.visitSingularStringField(value: _storage._id, fieldNumber: 1)
      }
      if !_storage._name.isEmpty {
        try visitor.visitSingularStringField(value: _storage._name, fieldNumber: 2)
      }
      try { if let v = _storage._createdAt {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      if !_storage._appID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._appID, fieldNumber: 4)
      }
      try { if let v = _storage._outputInfo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._modelVersion {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
      if !_storage._displayName.isEmpty {
        try visitor.visitSingularStringField(value: _storage._displayName, fieldNumber: 7)
      }
      if !_storage._userID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._userID, fieldNumber: 9)
      }
      if !_storage._modelTypeID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._modelTypeID, fieldNumber: 14)
      }
      try { if let v = _storage._visibility {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
      } }()
      if !_storage._description_p.isEmpty {
        try visitor.visitSingularStringField(value: _storage._description_p, fieldNumber: 16)
      }
      try { if let v = _storage._metadata {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 17)
      } }()
      if !_storage._notes.isEmpty {
        try visitor.visitSingularStringField(value: _storage._notes, fieldNumber: 18)
      }
      try { if let v = _storage._modifiedAt {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 19)
      } }()
      if !_storage._toolkits.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._toolkits, fieldNumber: 20)
      }
      if !_storage._useCases.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._useCases, fieldNumber: 21)
      }
      if _storage._isStarred != false {
        try visitor.visitSingularBoolField(value: _storage._isStarred, fieldNumber: 22)
      }
      if _storage._starCount != 0 {
        try visitor.visitSingularInt32Field(value: _storage._starCount, fieldNumber: 23)
      }
      if !_storage._languages.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._languages, fieldNumber: 25)
      }
      if !_storage._task.isEmpty {
        try visitor.visitSingularStringField(value: _storage._task, fieldNumber: 26)
      }
      try { if let v = _storage._presets {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 27)
      } }()
      try { if let v = _storage._workflowRecommended {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 29)
      } }()
      try { if let v = _storage._defaultEvalInfo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 30)
      } }()
      if !_storage._languagesFull.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._languagesFull, fieldNumber: 31)
      }
      if !_storage._checkConsents.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._checkConsents, fieldNumber: 32)
      }
      try { if let v = _storage._bookmarkOrigin {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 33)
      } }()
      try { if let v = _storage._image {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 34)
      } }()
      if _storage._licenseType != .unknownLicenseType {
        try visitor.visitSingularEnumField(value: _storage._licenseType, fieldNumber: 35)
      }
      if _storage._source != .unknownSource {
        try visitor.visitSingularEnumField(value: _storage._source, fieldNumber: 36)
      }
      if !_storage._creator.isEmpty {
        try visitor.visitSingularStringField(value: _storage._creator, fieldNumber: 37)
      }
      if _storage._versionCount != 0 {
        try visitor.visitSingularInt32Field(value: _storage._versionCount, fieldNumber: 38)
      }
      if _storage._billingType != .unknown {
        try visitor.visitSingularEnumField(value: _storage._billingType, fieldNumber: 40)
      }
      try { if let v = _storage._featuredOrder {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 41)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_Model, rhs: Clarifai_Api_Model) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._id != rhs_storage._id {return false}
        if _storage._name != rhs_storage._name {return false}
        if _storage._createdAt != rhs_storage._createdAt {return false}
        if _storage._modifiedAt != rhs_storage._modifiedAt {return false}
        if _storage._appID != rhs_storage._appID {return false}
        if _storage._outputInfo != rhs_storage._outputInfo {return false}
        if _storage._modelVersion != rhs_storage._modelVersion {return false}
        if _storage._displayName != rhs_storage._displayName {return false}
        if _storage._userID != rhs_storage._userID {return false}
        if _storage._defaultEvalInfo != rhs_storage._defaultEvalInfo {return false}
        if _storage._modelTypeID != rhs_storage._modelTypeID {return false}
        if _storage._task != rhs_storage._task {return false}
        if _storage._visibility != rhs_storage._visibility {return false}
        if _storage._description_p != rhs_storage._description_p {return false}
        if _storage._metadata != rhs_storage._metadata {return false}
        if _storage._presets != rhs_storage._presets {return false}
        if _storage._notes != rhs_storage._notes {return false}
        if _storage._toolkits != rhs_storage._toolkits {return false}
        if _storage._useCases != rhs_storage._useCases {return false}
        if _storage._languages != rhs_storage._languages {return false}
        if _storage._languagesFull != rhs_storage._languagesFull {return false}
        if _storage._checkConsents != rhs_storage._checkConsents {return false}
        if _storage._isStarred != rhs_storage._isStarred {return false}
        if _storage._starCount != rhs_storage._starCount {return false}
        if _storage._workflowRecommended != rhs_storage._workflowRecommended {return false}
        if _storage._bookmarkOrigin != rhs_storage._bookmarkOrigin {return false}
        if _storage._image != rhs_storage._image {return false}
        if _storage._licenseType != rhs_storage._licenseType {return false}
        if _storage._source != rhs_storage._source {return false}
        if _storage._creator != rhs_storage._creator {return false}
        if _storage._versionCount != rhs_storage._versionCount {return false}
        if _storage._billingType != rhs_storage._billingType {return false}
        if _storage._featuredOrder != rhs_storage._featuredOrder {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_Model.Source: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN_SOURCE"),
    1: .same(proto: "HOSTED"),
    2: .same(proto: "WRAPPED"),
  ]
}

extension Clarifai_Api_Model.BillingType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "Unknown"),
    1: .same(proto: "Tokens"),
    2: .same(proto: "Ops"),
  ]
}

extension Clarifai_Api_ModelReference: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ModelReference"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .standard(proto: "model_id"),
    3: .same(proto: "url"),
    4: .same(proto: "name"),
    5: .same(proto: "metadata"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.modelID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.url) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._metadata) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if !self.modelID.isEmpty {
      try visitor.visitSingularStringField(value: self.modelID, fieldNumber: 2)
    }
    if !self.url.isEmpty {
      try visitor.visitSingularStringField(value: self.url, fieldNumber: 3)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 4)
    }
    try { if let v = self._metadata {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_ModelReference, rhs: Clarifai_Api_ModelReference) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.modelID != rhs.modelID {return false}
    if lhs.url != rhs.url {return false}
    if lhs.name != rhs.name {return false}
    if lhs._metadata != rhs._metadata {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_ModelVersionInputExample: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ModelVersionInputExample"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .standard(proto: "model_id"),
    3: .standard(proto: "model_version_id"),
    4: .same(proto: "data"),
    5: .same(proto: "name"),
    6: .same(proto: "description"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.modelID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.modelVersionID) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._data) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if !self.modelID.isEmpty {
      try visitor.visitSingularStringField(value: self.modelID, fieldNumber: 2)
    }
    if !self.modelVersionID.isEmpty {
      try visitor.visitSingularStringField(value: self.modelVersionID, fieldNumber: 3)
    }
    try { if let v = self._data {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 5)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_ModelVersionInputExample, rhs: Clarifai_Api_ModelVersionInputExample) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.modelID != rhs.modelID {return false}
    if lhs.modelVersionID != rhs.modelVersionID {return false}
    if lhs._data != rhs._data {return false}
    if lhs.name != rhs.name {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_OutputInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".OutputInfo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "data"),
    2: .standard(proto: "output_config"),
    3: .same(proto: "message"),
    6: .standard(proto: "fields_map"),
    7: .same(proto: "params"),
    8: .standard(proto: "params_specs"),
  ]

  fileprivate class _StorageClass {
    var _data: Clarifai_Api_Data? = nil
    var _outputConfig: Clarifai_Api_OutputConfig? = nil
    var _message: String = String()
    var _fieldsMap: SwiftProtobuf.Google_Protobuf_Struct? = nil
    var _params: SwiftProtobuf.Google_Protobuf_Struct? = nil
    var _paramsSpecs: [Clarifai_Api_ModelTypeField] = []

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _data = source._data
      _outputConfig = source._outputConfig
      _message = source._message
      _fieldsMap = source._fieldsMap
      _params = source._params
      _paramsSpecs = source._paramsSpecs
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._data) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._outputConfig) }()
        case 3: try { try decoder.decodeSingularStringField(value: &_storage._message) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._fieldsMap) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._params) }()
        case 8: try { try decoder.decodeRepeatedMessageField(value: &_storage._paramsSpecs) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._data {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._outputConfig {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      if !_storage._message.isEmpty {
        try visitor.visitSingularStringField(value: _storage._message, fieldNumber: 3)
      }
      try { if let v = _storage._fieldsMap {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
      try { if let v = _storage._params {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      } }()
      if !_storage._paramsSpecs.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._paramsSpecs, fieldNumber: 8)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_OutputInfo, rhs: Clarifai_Api_OutputInfo) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._data != rhs_storage._data {return false}
        if _storage._outputConfig != rhs_storage._outputConfig {return false}
        if _storage._message != rhs_storage._message {return false}
        if _storage._fieldsMap != rhs_storage._fieldsMap {return false}
        if _storage._params != rhs_storage._params {return false}
        if _storage._paramsSpecs != rhs_storage._paramsSpecs {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_InputInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".InputInfo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "fields_map"),
    2: .same(proto: "params"),
    3: .standard(proto: "base_embed_model"),
  ]

  fileprivate class _StorageClass {
    var _fieldsMap: SwiftProtobuf.Google_Protobuf_Struct? = nil
    var _params: SwiftProtobuf.Google_Protobuf_Struct? = nil
    var _baseEmbedModel: Clarifai_Api_Model? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _fieldsMap = source._fieldsMap
      _params = source._params
      _baseEmbedModel = source._baseEmbedModel
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._fieldsMap) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._params) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._baseEmbedModel) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._fieldsMap {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._params {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._baseEmbedModel {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_InputInfo, rhs: Clarifai_Api_InputInfo) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._fieldsMap != rhs_storage._fieldsMap {return false}
        if _storage._params != rhs_storage._params {return false}
        if _storage._baseEmbedModel != rhs_storage._baseEmbedModel {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_TrainInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TrainInfo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "params"),
    2: .same(proto: "dataset"),
    3: .standard(proto: "resume_from_model"),
  ]

  fileprivate class _StorageClass {
    var _params: SwiftProtobuf.Google_Protobuf_Struct? = nil
    var _dataset: Clarifai_Api_Dataset? = nil
    var _resumeFromModel: Clarifai_Api_Model? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _params = source._params
      _dataset = source._dataset
      _resumeFromModel = source._resumeFromModel
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._params) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._dataset) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._resumeFromModel) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._params {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._dataset {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._resumeFromModel {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_TrainInfo, rhs: Clarifai_Api_TrainInfo) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._params != rhs_storage._params {return false}
        if _storage._dataset != rhs_storage._dataset {return false}
        if _storage._resumeFromModel != rhs_storage._resumeFromModel {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_EvalInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".EvalInfo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "params"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._params) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._params {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_EvalInfo, rhs: Clarifai_Api_EvalInfo) -> Bool {
    if lhs._params != rhs._params {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_ImportInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ImportInfo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "params"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._params) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._params {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_ImportInfo, rhs: Clarifai_Api_ImportInfo) -> Bool {
    if lhs._params != rhs._params {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_OutputConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".OutputConfig"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "concepts_mutually_exclusive"),
    3: .standard(proto: "existing_model_id"),
    4: .same(proto: "language"),
    5: .standard(proto: "hyper_parameters"),
    6: .standard(proto: "max_concepts"),
    7: .standard(proto: "min_value"),
    8: .standard(proto: "select_concepts"),
    9: .standard(proto: "training_timeout"),
    10: .standard(proto: "sample_ms"),
    13: .standard(proto: "hyper_params"),
    14: .standard(proto: "embed_model_version_id"),
    15: .standard(proto: "fail_on_missing_positive_examples"),
    17: .standard(proto: "model_metadata"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.conceptsMutuallyExclusive) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.existingModelID) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.language) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.hyperParameters) }()
      case 6: try { try decoder.decodeSingularUInt32Field(value: &self.maxConcepts) }()
      case 7: try { try decoder.decodeSingularFloatField(value: &self.minValue) }()
      case 8: try { try decoder.decodeRepeatedMessageField(value: &self.selectConcepts) }()
      case 9: try { try decoder.decodeSingularUInt32Field(value: &self.trainingTimeout) }()
      case 10: try { try decoder.decodeSingularUInt32Field(value: &self.sampleMs) }()
      case 13: try { try decoder.decodeSingularMessageField(value: &self._hyperParams) }()
      case 14: try { try decoder.decodeSingularStringField(value: &self.embedModelVersionID) }()
      case 15: try { try decoder.decodeSingularBoolField(value: &self.failOnMissingPositiveExamples) }()
      case 17: try { try decoder.decodeSingularMessageField(value: &self._modelMetadata) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.conceptsMutuallyExclusive != false {
      try visitor.visitSingularBoolField(value: self.conceptsMutuallyExclusive, fieldNumber: 1)
    }
    if !self.existingModelID.isEmpty {
      try visitor.visitSingularStringField(value: self.existingModelID, fieldNumber: 3)
    }
    if !self.language.isEmpty {
      try visitor.visitSingularStringField(value: self.language, fieldNumber: 4)
    }
    if !self.hyperParameters.isEmpty {
      try visitor.visitSingularStringField(value: self.hyperParameters, fieldNumber: 5)
    }
    if self.maxConcepts != 0 {
      try visitor.visitSingularUInt32Field(value: self.maxConcepts, fieldNumber: 6)
    }
    if self.minValue != 0 {
      try visitor.visitSingularFloatField(value: self.minValue, fieldNumber: 7)
    }
    if !self.selectConcepts.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.selectConcepts, fieldNumber: 8)
    }
    if self.trainingTimeout != 0 {
      try visitor.visitSingularUInt32Field(value: self.trainingTimeout, fieldNumber: 9)
    }
    if self.sampleMs != 0 {
      try visitor.visitSingularUInt32Field(value: self.sampleMs, fieldNumber: 10)
    }
    try { if let v = self._hyperParams {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
    } }()
    if !self.embedModelVersionID.isEmpty {
      try visitor.visitSingularStringField(value: self.embedModelVersionID, fieldNumber: 14)
    }
    if self.failOnMissingPositiveExamples != false {
      try visitor.visitSingularBoolField(value: self.failOnMissingPositiveExamples, fieldNumber: 15)
    }
    try { if let v = self._modelMetadata {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 17)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_OutputConfig, rhs: Clarifai_Api_OutputConfig) -> Bool {
    if lhs.conceptsMutuallyExclusive != rhs.conceptsMutuallyExclusive {return false}
    if lhs.existingModelID != rhs.existingModelID {return false}
    if lhs.language != rhs.language {return false}
    if lhs.hyperParameters != rhs.hyperParameters {return false}
    if lhs.maxConcepts != rhs.maxConcepts {return false}
    if lhs.minValue != rhs.minValue {return false}
    if lhs.selectConcepts != rhs.selectConcepts {return false}
    if lhs.trainingTimeout != rhs.trainingTimeout {return false}
    if lhs.sampleMs != rhs.sampleMs {return false}
    if lhs._hyperParams != rhs._hyperParams {return false}
    if lhs.embedModelVersionID != rhs.embedModelVersionID {return false}
    if lhs.failOnMissingPositiveExamples != rhs.failOnMissingPositiveExamples {return false}
    if lhs._modelMetadata != rhs._modelMetadata {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_ModelType: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ModelType"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "title"),
    3: .same(proto: "description"),
    5: .standard(proto: "input_fields"),
    6: .standard(proto: "output_fields"),
    8: .same(proto: "trainable"),
    9: .same(proto: "creatable"),
    10: .standard(proto: "internal_only"),
    11: .standard(proto: "model_type_fields"),
    12: .standard(proto: "requires_sequential_frames"),
    16: .standard(proto: "expected_input_layers"),
    17: .standard(proto: "expected_output_layers"),
    18: .standard(proto: "evaluation_type"),
    19: .standard(proto: "method_signatures"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.title) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      case 5: try { try decoder.decodeRepeatedStringField(value: &self.inputFields) }()
      case 6: try { try decoder.decodeRepeatedStringField(value: &self.outputFields) }()
      case 8: try { try decoder.decodeSingularBoolField(value: &self.trainable) }()
      case 9: try { try decoder.decodeSingularBoolField(value: &self.creatable) }()
      case 10: try { try decoder.decodeSingularBoolField(value: &self.internalOnly) }()
      case 11: try { try decoder.decodeRepeatedMessageField(value: &self.modelTypeFields) }()
      case 12: try { try decoder.decodeSingularBoolField(value: &self.requiresSequentialFrames) }()
      case 16: try { try decoder.decodeRepeatedMessageField(value: &self.expectedInputLayers) }()
      case 17: try { try decoder.decodeRepeatedMessageField(value: &self.expectedOutputLayers) }()
      case 18: try { try decoder.decodeSingularEnumField(value: &self.evaluationType) }()
      case 19: try { try decoder.decodeRepeatedMessageField(value: &self.methodSignatures) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if !self.title.isEmpty {
      try visitor.visitSingularStringField(value: self.title, fieldNumber: 2)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 3)
    }
    if !self.inputFields.isEmpty {
      try visitor.visitRepeatedStringField(value: self.inputFields, fieldNumber: 5)
    }
    if !self.outputFields.isEmpty {
      try visitor.visitRepeatedStringField(value: self.outputFields, fieldNumber: 6)
    }
    if self.trainable != false {
      try visitor.visitSingularBoolField(value: self.trainable, fieldNumber: 8)
    }
    if self.creatable != false {
      try visitor.visitSingularBoolField(value: self.creatable, fieldNumber: 9)
    }
    if self.internalOnly != false {
      try visitor.visitSingularBoolField(value: self.internalOnly, fieldNumber: 10)
    }
    if !self.modelTypeFields.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.modelTypeFields, fieldNumber: 11)
    }
    if self.requiresSequentialFrames != false {
      try visitor.visitSingularBoolField(value: self.requiresSequentialFrames, fieldNumber: 12)
    }
    if !self.expectedInputLayers.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.expectedInputLayers, fieldNumber: 16)
    }
    if !self.expectedOutputLayers.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.expectedOutputLayers, fieldNumber: 17)
    }
    if self.evaluationType != .undefined {
      try visitor.visitSingularEnumField(value: self.evaluationType, fieldNumber: 18)
    }
    if !self.methodSignatures.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.methodSignatures, fieldNumber: 19)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_ModelType, rhs: Clarifai_Api_ModelType) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.title != rhs.title {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.inputFields != rhs.inputFields {return false}
    if lhs.outputFields != rhs.outputFields {return false}
    if lhs.trainable != rhs.trainable {return false}
    if lhs.creatable != rhs.creatable {return false}
    if lhs.internalOnly != rhs.internalOnly {return false}
    if lhs.modelTypeFields != rhs.modelTypeFields {return false}
    if lhs.requiresSequentialFrames != rhs.requiresSequentialFrames {return false}
    if lhs.expectedInputLayers != rhs.expectedInputLayers {return false}
    if lhs.expectedOutputLayers != rhs.expectedOutputLayers {return false}
    if lhs.evaluationType != rhs.evaluationType {return false}
    if lhs.methodSignatures != rhs.methodSignatures {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_ModelLayerInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ModelLayerInfo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "data_field_name"),
    2: .same(proto: "shapes"),
    3: .same(proto: "description"),
    4: .standard(proto: "requires_label_filename"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.dataFieldName) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.shapes) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.requiresLabelFilename) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.dataFieldName.isEmpty {
      try visitor.visitSingularStringField(value: self.dataFieldName, fieldNumber: 1)
    }
    if !self.shapes.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.shapes, fieldNumber: 2)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 3)
    }
    if self.requiresLabelFilename != false {
      try visitor.visitSingularBoolField(value: self.requiresLabelFilename, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_ModelLayerInfo, rhs: Clarifai_Api_ModelLayerInfo) -> Bool {
    if lhs.dataFieldName != rhs.dataFieldName {return false}
    if lhs.shapes != rhs.shapes {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.requiresLabelFilename != rhs.requiresLabelFilename {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_TritonCondaEnvInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TritonCondaEnvInfo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "conda_pack_url"),
    2: .standard(proto: "conda_yaml_url"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.condaPackURL) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.condaYamlURL) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.condaPackURL.isEmpty {
      try visitor.visitSingularStringField(value: self.condaPackURL, fieldNumber: 1)
    }
    if !self.condaYamlURL.isEmpty {
      try visitor.visitSingularStringField(value: self.condaYamlURL, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_TritonCondaEnvInfo, rhs: Clarifai_Api_TritonCondaEnvInfo) -> Bool {
    if lhs.condaPackURL != rhs.condaPackURL {return false}
    if lhs.condaYamlURL != rhs.condaYamlURL {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_LayerShape: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LayerShape"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "dims"),
    2: .standard(proto: "max_dims"),
    3: .standard(proto: "data_type"),
    4: .same(proto: "description"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedInt32Field(value: &self.dims) }()
      case 2: try { try decoder.decodeRepeatedInt32Field(value: &self.maxDims) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.dataType) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.dims.isEmpty {
      try visitor.visitPackedInt32Field(value: self.dims, fieldNumber: 1)
    }
    if !self.maxDims.isEmpty {
      try visitor.visitPackedInt32Field(value: self.maxDims, fieldNumber: 2)
    }
    if self.dataType != .undefined {
      try visitor.visitSingularEnumField(value: self.dataType, fieldNumber: 3)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_LayerShape, rhs: Clarifai_Api_LayerShape) -> Bool {
    if lhs.dims != rhs.dims {return false}
    if lhs.maxDims != rhs.maxDims {return false}
    if lhs.dataType != rhs.dataType {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_ModelTypeField: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ModelTypeField"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "path"),
    2: .standard(proto: "field_type"),
    3: .standard(proto: "default_value"),
    4: .same(proto: "description"),
    5: .same(proto: "placeholder"),
    6: .standard(proto: "model_type_enum_options"),
    7: .standard(proto: "internal_only"),
    8: .same(proto: "required"),
    9: .standard(proto: "model_type_range_info"),
    10: .same(proto: "name"),
    11: .same(proto: "type"),
    12: .standard(proto: "type_args"),
    13: .same(proto: "iterator"),
    14: .same(proto: "default"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.path) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.fieldType) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._defaultValue) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.placeholder) }()
      case 6: try { try decoder.decodeRepeatedMessageField(value: &self.modelTypeEnumOptions) }()
      case 7: try { try decoder.decodeSingularBoolField(value: &self.internalOnly) }()
      case 8: try { try decoder.decodeSingularBoolField(value: &self.required) }()
      case 9: try { try decoder.decodeSingularMessageField(value: &self._modelTypeRangeInfo) }()
      case 10: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 11: try { try decoder.decodeSingularEnumField(value: &self.type) }()
      case 12: try { try decoder.decodeRepeatedMessageField(value: &self.typeArgs) }()
      case 13: try { try decoder.decodeSingularBoolField(value: &self.iterator) }()
      case 14: try { try decoder.decodeSingularStringField(value: &self.`default`) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.path.isEmpty {
      try visitor.visitSingularStringField(value: self.path, fieldNumber: 1)
    }
    if self.fieldType != .invalidModelTypeFieldType {
      try visitor.visitSingularEnumField(value: self.fieldType, fieldNumber: 2)
    }
    try { if let v = self._defaultValue {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 4)
    }
    if !self.placeholder.isEmpty {
      try visitor.visitSingularStringField(value: self.placeholder, fieldNumber: 5)
    }
    if !self.modelTypeEnumOptions.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.modelTypeEnumOptions, fieldNumber: 6)
    }
    if self.internalOnly != false {
      try visitor.visitSingularBoolField(value: self.internalOnly, fieldNumber: 7)
    }
    if self.required != false {
      try visitor.visitSingularBoolField(value: self.required, fieldNumber: 8)
    }
    try { if let v = self._modelTypeRangeInfo {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    } }()
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 10)
    }
    if self.type != .notSet {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 11)
    }
    if !self.typeArgs.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.typeArgs, fieldNumber: 12)
    }
    if self.iterator != false {
      try visitor.visitSingularBoolField(value: self.iterator, fieldNumber: 13)
    }
    if !self.`default`.isEmpty {
      try visitor.visitSingularStringField(value: self.`default`, fieldNumber: 14)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_ModelTypeField, rhs: Clarifai_Api_ModelTypeField) -> Bool {
    if lhs.path != rhs.path {return false}
    if lhs.fieldType != rhs.fieldType {return false}
    if lhs._defaultValue != rhs._defaultValue {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.placeholder != rhs.placeholder {return false}
    if lhs.modelTypeEnumOptions != rhs.modelTypeEnumOptions {return false}
    if lhs.internalOnly != rhs.internalOnly {return false}
    if lhs.required != rhs.required {return false}
    if lhs._modelTypeRangeInfo != rhs._modelTypeRangeInfo {return false}
    if lhs.name != rhs.name {return false}
    if lhs.type != rhs.type {return false}
    if lhs.typeArgs != rhs.typeArgs {return false}
    if lhs.iterator != rhs.iterator {return false}
    if lhs.`default` != rhs.`default` {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_ModelTypeField.ModelTypeFieldType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "INVALID_MODEL_TYPE_FIELD_TYPE"),
    1: .same(proto: "BOOLEAN"),
    2: .same(proto: "STRING"),
    3: .same(proto: "NUMBER"),
    4: .same(proto: "ARRAY_OF_CONCEPTS"),
    5: .same(proto: "ARRAY_OF_CONCEPTS_WITH_THRESHOLD"),
    7: .same(proto: "RANGE"),
    8: .same(proto: "ENUM"),
    9: .same(proto: "COLLABORATORS"),
    10: .same(proto: "JSON"),
    11: .same(proto: "ARRAY_OF_NUMBERS"),
    12: .same(proto: "WORKFLOW_EMBED_MODELS"),
    13: .same(proto: "ARRAY_OF_STRINGS"),
    14: .same(proto: "RECURSIVE_ENUM"),
    15: .same(proto: "PYTHON_CODE"),
    16: .same(proto: "DATASET_ID"),
    17: .same(proto: "DATASET_VERSION_ID"),
    18: .same(proto: "ARRAY_OF_MODEL_CONCEPTS"),
    19: .same(proto: "DATASET"),
    20: .same(proto: "DATASET_VERSION"),
    21: .same(proto: "ENCRYPTED_STRING"),
    22: .same(proto: "CHECKPOINT_MODEL"),
  ]
}

extension Clarifai_Api_ModelTypeField.DataType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NOT_SET"),
    1: .same(proto: "STR"),
    2: .same(proto: "BYTES"),
    3: .same(proto: "INT"),
    4: .same(proto: "FLOAT"),
    5: .same(proto: "BOOL"),
    6: .same(proto: "NDARRAY"),
    7: .same(proto: "JSON_DATA"),
    8: .same(proto: "TEXT"),
    9: .same(proto: "IMAGE"),
    10: .same(proto: "CONCEPT"),
    11: .same(proto: "REGION"),
    12: .same(proto: "FRAME"),
    13: .same(proto: "AUDIO"),
    14: .same(proto: "VIDEO"),
    20: .same(proto: "NAMED_FIELDS"),
    21: .same(proto: "TUPLE"),
    22: .same(proto: "LIST"),
  ]
}

extension Clarifai_Api_ModelTypeRangeInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ModelTypeRangeInfo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "min"),
    2: .same(proto: "max"),
    3: .same(proto: "step"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFloatField(value: &self.min) }()
      case 2: try { try decoder.decodeSingularFloatField(value: &self.max) }()
      case 3: try { try decoder.decodeSingularFloatField(value: &self.step) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.min != 0 {
      try visitor.visitSingularFloatField(value: self.min, fieldNumber: 1)
    }
    if self.max != 0 {
      try visitor.visitSingularFloatField(value: self.max, fieldNumber: 2)
    }
    if self.step != 0 {
      try visitor.visitSingularFloatField(value: self.step, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_ModelTypeRangeInfo, rhs: Clarifai_Api_ModelTypeRangeInfo) -> Bool {
    if lhs.min != rhs.min {return false}
    if lhs.max != rhs.max {return false}
    if lhs.step != rhs.step {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_ModelTypeEnumOption: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ModelTypeEnumOption"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    5: .same(proto: "aliases"),
    2: .same(proto: "description"),
    3: .standard(proto: "model_type_fields"),
    4: .standard(proto: "internal_only"),
    6: .same(proto: "recommended"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.modelTypeFields) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.internalOnly) }()
      case 5: try { try decoder.decodeRepeatedMessageField(value: &self.aliases) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self.recommended) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 2)
    }
    if !self.modelTypeFields.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.modelTypeFields, fieldNumber: 3)
    }
    if self.internalOnly != false {
      try visitor.visitSingularBoolField(value: self.internalOnly, fieldNumber: 4)
    }
    if !self.aliases.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.aliases, fieldNumber: 5)
    }
    if self.recommended != false {
      try visitor.visitSingularBoolField(value: self.recommended, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_ModelTypeEnumOption, rhs: Clarifai_Api_ModelTypeEnumOption) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.aliases != rhs.aliases {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.modelTypeFields != rhs.modelTypeFields {return false}
    if lhs.internalOnly != rhs.internalOnly {return false}
    if lhs.recommended != rhs.recommended {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_ModelTypeEnumOptionAlias: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ModelTypeEnumOptionAlias"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "id_int"),
    2: .standard(proto: "wildcard_string"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.idInt) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.wildcardString) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.idInt != 0 {
      try visitor.visitSingularInt64Field(value: self.idInt, fieldNumber: 1)
    }
    if !self.wildcardString.isEmpty {
      try visitor.visitSingularStringField(value: self.wildcardString, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_ModelTypeEnumOptionAlias, rhs: Clarifai_Api_ModelTypeEnumOptionAlias) -> Bool {
    if lhs.idInt != rhs.idInt {return false}
    if lhs.wildcardString != rhs.wildcardString {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_ModelQuery: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ModelQuery"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    3: .standard(proto: "model_type_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.modelTypeID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.modelTypeID.isEmpty {
      try visitor.visitSingularStringField(value: self.modelTypeID, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_ModelQuery, rhs: Clarifai_Api_ModelQuery) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.modelTypeID != rhs.modelTypeID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_ModelVersion: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ModelVersion"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .standard(proto: "created_at"),
    3: .same(proto: "status"),
    4: .standard(proto: "active_concept_count"),
    5: .same(proto: "metrics"),
    6: .standard(proto: "total_input_count"),
    7: .standard(proto: "pretrained_model_config"),
    10: .standard(proto: "completed_at"),
    11: .same(proto: "description"),
    12: .same(proto: "visibility"),
    13: .standard(proto: "app_id"),
    14: .standard(proto: "user_id"),
    15: .standard(proto: "modified_at"),
    16: .same(proto: "metadata"),
    17: .same(proto: "license"),
    19: .standard(proto: "output_info"),
    20: .standard(proto: "input_info"),
    21: .standard(proto: "train_info"),
    22: .standard(proto: "import_info"),
    23: .standard(proto: "train_log"),
    24: .standard(proto: "inference_compute_info"),
    25: .standard(proto: "build_info"),
    26: .standard(proto: "method_signatures"),
  ]

  fileprivate class _StorageClass {
    var _id: String = String()
    var _createdAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _status: Clarifai_Api_Status_Status? = nil
    var _activeConceptCount: UInt32 = 0
    var _metrics: Clarifai_Api_EvalMetrics? = nil
    var _totalInputCount: UInt32 = 0
    var _pretrainedModelConfig: Clarifai_Api_PretrainedModelConfig? = nil
    var _completedAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _description_p: String = String()
    var _visibility: Clarifai_Api_Visibility? = nil
    var _appID: String = String()
    var _userID: String = String()
    var _modifiedAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _metadata: SwiftProtobuf.Google_Protobuf_Struct? = nil
    var _license: String = String()
    var _outputInfo: Clarifai_Api_OutputInfo? = nil
    var _inputInfo: Clarifai_Api_InputInfo? = nil
    var _trainInfo: Clarifai_Api_TrainInfo? = nil
    var _importInfo: Clarifai_Api_ImportInfo? = nil
    var _trainLog: String = String()
    var _inferenceComputeInfo: Clarifai_Api_ComputeInfo? = nil
    var _buildInfo: Clarifai_Api_BuildInfo? = nil
    var _methodSignatures: [Clarifai_Api_MethodSignature] = []

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _id = source._id
      _createdAt = source._createdAt
      _status = source._status
      _activeConceptCount = source._activeConceptCount
      _metrics = source._metrics
      _totalInputCount = source._totalInputCount
      _pretrainedModelConfig = source._pretrainedModelConfig
      _completedAt = source._completedAt
      _description_p = source._description_p
      _visibility = source._visibility
      _appID = source._appID
      _userID = source._userID
      _modifiedAt = source._modifiedAt
      _metadata = source._metadata
      _license = source._license
      _outputInfo = source._outputInfo
      _inputInfo = source._inputInfo
      _trainInfo = source._trainInfo
      _importInfo = source._importInfo
      _trainLog = source._trainLog
      _inferenceComputeInfo = source._inferenceComputeInfo
      _buildInfo = source._buildInfo
      _methodSignatures = source._methodSignatures
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._id) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._createdAt) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._status) }()
        case 4: try { try decoder.decodeSingularUInt32Field(value: &_storage._activeConceptCount) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._metrics) }()
        case 6: try { try decoder.decodeSingularUInt32Field(value: &_storage._totalInputCount) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._pretrainedModelConfig) }()
        case 10: try { try decoder.decodeSingularMessageField(value: &_storage._completedAt) }()
        case 11: try { try decoder.decodeSingularStringField(value: &_storage._description_p) }()
        case 12: try { try decoder.decodeSingularMessageField(value: &_storage._visibility) }()
        case 13: try { try decoder.decodeSingularStringField(value: &_storage._appID) }()
        case 14: try { try decoder.decodeSingularStringField(value: &_storage._userID) }()
        case 15: try { try decoder.decodeSingularMessageField(value: &_storage._modifiedAt) }()
        case 16: try { try decoder.decodeSingularMessageField(value: &_storage._metadata) }()
        case 17: try { try decoder.decodeSingularStringField(value: &_storage._license) }()
        case 19: try { try decoder.decodeSingularMessageField(value: &_storage._outputInfo) }()
        case 20: try { try decoder.decodeSingularMessageField(value: &_storage._inputInfo) }()
        case 21: try { try decoder.decodeSingularMessageField(value: &_storage._trainInfo) }()
        case 22: try { try decoder.decodeSingularMessageField(value: &_storage._importInfo) }()
        case 23: try { try decoder.decodeSingularStringField(value: &_storage._trainLog) }()
        case 24: try { try decoder.decodeSingularMessageField(value: &_storage._inferenceComputeInfo) }()
        case 25: try { try decoder.decodeSingularMessageField(value: &_storage._buildInfo) }()
        case 26: try { try decoder.decodeRepeatedMessageField(value: &_storage._methodSignatures) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._id.isEmpty {
        try visitor.visitSingularStringField(value: _storage._id, fieldNumber: 1)
      }
      try { if let v = _storage._createdAt {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._status {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      if _storage._activeConceptCount != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._activeConceptCount, fieldNumber: 4)
      }
      try { if let v = _storage._metrics {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      if _storage._totalInputCount != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._totalInputCount, fieldNumber: 6)
      }
      try { if let v = _storage._pretrainedModelConfig {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      } }()
      try { if let v = _storage._completedAt {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      } }()
      if !_storage._description_p.isEmpty {
        try visitor.visitSingularStringField(value: _storage._description_p, fieldNumber: 11)
      }
      try { if let v = _storage._visibility {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
      } }()
      if !_storage._appID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._appID, fieldNumber: 13)
      }
      if !_storage._userID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._userID, fieldNumber: 14)
      }
      try { if let v = _storage._modifiedAt {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
      } }()
      try { if let v = _storage._metadata {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
      } }()
      if !_storage._license.isEmpty {
        try visitor.visitSingularStringField(value: _storage._license, fieldNumber: 17)
      }
      try { if let v = _storage._outputInfo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 19)
      } }()
      try { if let v = _storage._inputInfo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 20)
      } }()
      try { if let v = _storage._trainInfo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 21)
      } }()
      try { if let v = _storage._importInfo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 22)
      } }()
      if !_storage._trainLog.isEmpty {
        try visitor.visitSingularStringField(value: _storage._trainLog, fieldNumber: 23)
      }
      try { if let v = _storage._inferenceComputeInfo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 24)
      } }()
      try { if let v = _storage._buildInfo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 25)
      } }()
      if !_storage._methodSignatures.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._methodSignatures, fieldNumber: 26)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_ModelVersion, rhs: Clarifai_Api_ModelVersion) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._id != rhs_storage._id {return false}
        if _storage._createdAt != rhs_storage._createdAt {return false}
        if _storage._status != rhs_storage._status {return false}
        if _storage._activeConceptCount != rhs_storage._activeConceptCount {return false}
        if _storage._metrics != rhs_storage._metrics {return false}
        if _storage._totalInputCount != rhs_storage._totalInputCount {return false}
        if _storage._pretrainedModelConfig != rhs_storage._pretrainedModelConfig {return false}
        if _storage._completedAt != rhs_storage._completedAt {return false}
        if _storage._description_p != rhs_storage._description_p {return false}
        if _storage._visibility != rhs_storage._visibility {return false}
        if _storage._appID != rhs_storage._appID {return false}
        if _storage._userID != rhs_storage._userID {return false}
        if _storage._modifiedAt != rhs_storage._modifiedAt {return false}
        if _storage._metadata != rhs_storage._metadata {return false}
        if _storage._license != rhs_storage._license {return false}
        if _storage._outputInfo != rhs_storage._outputInfo {return false}
        if _storage._inputInfo != rhs_storage._inputInfo {return false}
        if _storage._trainInfo != rhs_storage._trainInfo {return false}
        if _storage._importInfo != rhs_storage._importInfo {return false}
        if _storage._trainLog != rhs_storage._trainLog {return false}
        if _storage._inferenceComputeInfo != rhs_storage._inferenceComputeInfo {return false}
        if _storage._buildInfo != rhs_storage._buildInfo {return false}
        if _storage._methodSignatures != rhs_storage._methodSignatures {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_MethodSignature: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MethodSignature"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .standard(proto: "method_type"),
    3: .same(proto: "description"),
    4: .standard(proto: "input_fields"),
    5: .standard(proto: "output_fields"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.methodType) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.inputFields) }()
      case 5: try { try decoder.decodeRepeatedMessageField(value: &self.outputFields) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if self.methodType != .unknown {
      try visitor.visitSingularEnumField(value: self.methodType, fieldNumber: 2)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 3)
    }
    if !self.inputFields.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.inputFields, fieldNumber: 4)
    }
    if !self.outputFields.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.outputFields, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_MethodSignature, rhs: Clarifai_Api_MethodSignature) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.methodType != rhs.methodType {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.inputFields != rhs.inputFields {return false}
    if lhs.outputFields != rhs.outputFields {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_BuildInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".BuildInfo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "docker_image_name"),
    2: .standard(proto: "docker_image_tag"),
    3: .standard(proto: "docker_image_digest"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.dockerImageName) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.dockerImageTag) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.dockerImageDigest) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.dockerImageName.isEmpty {
      try visitor.visitSingularStringField(value: self.dockerImageName, fieldNumber: 1)
    }
    if !self.dockerImageTag.isEmpty {
      try visitor.visitSingularStringField(value: self.dockerImageTag, fieldNumber: 2)
    }
    if !self.dockerImageDigest.isEmpty {
      try visitor.visitSingularStringField(value: self.dockerImageDigest, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_BuildInfo, rhs: Clarifai_Api_BuildInfo) -> Bool {
    if lhs.dockerImageName != rhs.dockerImageName {return false}
    if lhs.dockerImageTag != rhs.dockerImageTag {return false}
    if lhs.dockerImageDigest != rhs.dockerImageDigest {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_ModelVersionExport: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ModelVersionExport"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
    2: .same(proto: "url"),
    3: .same(proto: "size"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._status) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.url) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.size) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._status {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.url.isEmpty {
      try visitor.visitSingularStringField(value: self.url, fieldNumber: 2)
    }
    if self.size != 0 {
      try visitor.visitSingularInt64Field(value: self.size, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_ModelVersionExport, rhs: Clarifai_Api_ModelVersionExport) -> Bool {
    if lhs._status != rhs._status {return false}
    if lhs.url != rhs.url {return false}
    if lhs.size != rhs.size {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_PretrainedModelConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PretrainedModelConfig"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    3: .standard(proto: "input_fields_map"),
    4: .standard(proto: "output_fields_map"),
    6: .standard(proto: "model_zip_url"),
    8: .standard(proto: "local_dev"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 3: try { try decoder.decodeSingularMessageField(value: &self._inputFieldsMap) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._outputFieldsMap) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.modelZipURL) }()
      case 8: try { try decoder.decodeSingularBoolField(value: &self.localDev) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._inputFieldsMap {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._outputFieldsMap {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    if !self.modelZipURL.isEmpty {
      try visitor.visitSingularStringField(value: self.modelZipURL, fieldNumber: 6)
    }
    if self.localDev != false {
      try visitor.visitSingularBoolField(value: self.localDev, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_PretrainedModelConfig, rhs: Clarifai_Api_PretrainedModelConfig) -> Bool {
    if lhs._inputFieldsMap != rhs._inputFieldsMap {return false}
    if lhs._outputFieldsMap != rhs._outputFieldsMap {return false}
    if lhs.modelZipURL != rhs.modelZipURL {return false}
    if lhs.localDev != rhs.localDev {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_TrainStats: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TrainStats"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "loss_curve"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.lossCurve) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.lossCurve.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.lossCurve, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_TrainStats, rhs: Clarifai_Api_TrainStats) -> Bool {
    if lhs.lossCurve != rhs.lossCurve {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_LossCurveEntry: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LossCurveEntry"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "epoch"),
    2: .standard(proto: "global_step"),
    3: .same(proto: "cost"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.epoch) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.globalStep) }()
      case 3: try { try decoder.decodeSingularFloatField(value: &self.cost) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.epoch != 0 {
      try visitor.visitSingularUInt32Field(value: self.epoch, fieldNumber: 1)
    }
    if self.globalStep != 0 {
      try visitor.visitSingularUInt32Field(value: self.globalStep, fieldNumber: 2)
    }
    if self.cost != 0 {
      try visitor.visitSingularFloatField(value: self.cost, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_LossCurveEntry, rhs: Clarifai_Api_LossCurveEntry) -> Bool {
    if lhs.epoch != rhs.epoch {return false}
    if lhs.globalStep != rhs.globalStep {return false}
    if lhs.cost != rhs.cost {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_LabelCount: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LabelCount"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "concept_name"),
    2: .same(proto: "count"),
    3: .same(proto: "concept"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.conceptName) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.count) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._concept) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.conceptName.isEmpty {
      try visitor.visitSingularStringField(value: self.conceptName, fieldNumber: 1)
    }
    if self.count != 0 {
      try visitor.visitSingularUInt32Field(value: self.count, fieldNumber: 2)
    }
    try { if let v = self._concept {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_LabelCount, rhs: Clarifai_Api_LabelCount) -> Bool {
    if lhs.conceptName != rhs.conceptName {return false}
    if lhs.count != rhs.count {return false}
    if lhs._concept != rhs._concept {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_LabelDistribution: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LabelDistribution"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "positive_label_counts"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.positiveLabelCounts) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.positiveLabelCounts.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.positiveLabelCounts, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_LabelDistribution, rhs: Clarifai_Api_LabelDistribution) -> Bool {
    if lhs.positiveLabelCounts != rhs.positiveLabelCounts {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_CooccurrenceMatrixEntry: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CooccurrenceMatrixEntry"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "row"),
    2: .same(proto: "col"),
    3: .same(proto: "count"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.row) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.col) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.count) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.row.isEmpty {
      try visitor.visitSingularStringField(value: self.row, fieldNumber: 1)
    }
    if !self.col.isEmpty {
      try visitor.visitSingularStringField(value: self.col, fieldNumber: 2)
    }
    if self.count != 0 {
      try visitor.visitSingularUInt32Field(value: self.count, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_CooccurrenceMatrixEntry, rhs: Clarifai_Api_CooccurrenceMatrixEntry) -> Bool {
    if lhs.row != rhs.row {return false}
    if lhs.col != rhs.col {return false}
    if lhs.count != rhs.count {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_CooccurrenceMatrix: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CooccurrenceMatrix"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "matrix"),
    2: .standard(proto: "concept_ids"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.matrix) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.conceptIds) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.matrix.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.matrix, fieldNumber: 1)
    }
    if !self.conceptIds.isEmpty {
      try visitor.visitRepeatedStringField(value: self.conceptIds, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_CooccurrenceMatrix, rhs: Clarifai_Api_CooccurrenceMatrix) -> Bool {
    if lhs.matrix != rhs.matrix {return false}
    if lhs.conceptIds != rhs.conceptIds {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_ConfusionMatrixEntry: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ConfusionMatrixEntry"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "predicted"),
    2: .same(proto: "actual"),
    4: .same(proto: "value"),
    5: .standard(proto: "predicted_concept"),
    6: .standard(proto: "actual_concept"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.predicted) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.actual) }()
      case 4: try { try decoder.decodeSingularFloatField(value: &self.value) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._predictedConcept) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._actualConcept) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.predicted.isEmpty {
      try visitor.visitSingularStringField(value: self.predicted, fieldNumber: 1)
    }
    if !self.actual.isEmpty {
      try visitor.visitSingularStringField(value: self.actual, fieldNumber: 2)
    }
    if self.value != 0 {
      try visitor.visitSingularFloatField(value: self.value, fieldNumber: 4)
    }
    try { if let v = self._predictedConcept {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._actualConcept {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_ConfusionMatrixEntry, rhs: Clarifai_Api_ConfusionMatrixEntry) -> Bool {
    if lhs.predicted != rhs.predicted {return false}
    if lhs.actual != rhs.actual {return false}
    if lhs.value != rhs.value {return false}
    if lhs._predictedConcept != rhs._predictedConcept {return false}
    if lhs._actualConcept != rhs._actualConcept {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_ConfusionMatrix: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ConfusionMatrix"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "matrix"),
    2: .standard(proto: "concept_ids"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.matrix) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.conceptIds) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.matrix.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.matrix, fieldNumber: 1)
    }
    if !self.conceptIds.isEmpty {
      try visitor.visitRepeatedStringField(value: self.conceptIds, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_ConfusionMatrix, rhs: Clarifai_Api_ConfusionMatrix) -> Bool {
    if lhs.matrix != rhs.matrix {return false}
    if lhs.conceptIds != rhs.conceptIds {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_ROC: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ROC"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "fpr"),
    2: .same(proto: "tpr"),
    3: .same(proto: "thresholds"),
    4: .standard(proto: "fpr_per_image"),
    5: .standard(proto: "fpr_per_object"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedFloatField(value: &self.fpr) }()
      case 2: try { try decoder.decodeRepeatedFloatField(value: &self.tpr) }()
      case 3: try { try decoder.decodeRepeatedFloatField(value: &self.thresholds) }()
      case 4: try { try decoder.decodeRepeatedFloatField(value: &self.fprPerImage) }()
      case 5: try { try decoder.decodeRepeatedFloatField(value: &self.fprPerObject) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.fpr.isEmpty {
      try visitor.visitPackedFloatField(value: self.fpr, fieldNumber: 1)
    }
    if !self.tpr.isEmpty {
      try visitor.visitPackedFloatField(value: self.tpr, fieldNumber: 2)
    }
    if !self.thresholds.isEmpty {
      try visitor.visitPackedFloatField(value: self.thresholds, fieldNumber: 3)
    }
    if !self.fprPerImage.isEmpty {
      try visitor.visitPackedFloatField(value: self.fprPerImage, fieldNumber: 4)
    }
    if !self.fprPerObject.isEmpty {
      try visitor.visitPackedFloatField(value: self.fprPerObject, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_ROC, rhs: Clarifai_Api_ROC) -> Bool {
    if lhs.fpr != rhs.fpr {return false}
    if lhs.tpr != rhs.tpr {return false}
    if lhs.thresholds != rhs.thresholds {return false}
    if lhs.fprPerImage != rhs.fprPerImage {return false}
    if lhs.fprPerObject != rhs.fprPerObject {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_PrecisionRecallCurve: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PrecisionRecallCurve"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "recall"),
    2: .same(proto: "precision"),
    3: .same(proto: "thresholds"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedFloatField(value: &self.recall) }()
      case 2: try { try decoder.decodeRepeatedFloatField(value: &self.precision) }()
      case 3: try { try decoder.decodeRepeatedFloatField(value: &self.thresholds) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.recall.isEmpty {
      try visitor.visitPackedFloatField(value: self.recall, fieldNumber: 1)
    }
    if !self.precision.isEmpty {
      try visitor.visitPackedFloatField(value: self.precision, fieldNumber: 2)
    }
    if !self.thresholds.isEmpty {
      try visitor.visitPackedFloatField(value: self.thresholds, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_PrecisionRecallCurve, rhs: Clarifai_Api_PrecisionRecallCurve) -> Bool {
    if lhs.recall != rhs.recall {return false}
    if lhs.precision != rhs.precision {return false}
    if lhs.thresholds != rhs.thresholds {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_BinaryMetrics: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".BinaryMetrics"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "num_pos"),
    2: .standard(proto: "num_neg"),
    3: .standard(proto: "num_tot"),
    4: .standard(proto: "roc_auc"),
    5: .same(proto: "f1"),
    6: .same(proto: "concept"),
    7: .standard(proto: "roc_curve"),
    8: .standard(proto: "precision_recall_curve"),
    9: .standard(proto: "avg_precision"),
    10: .standard(proto: "area_name"),
    11: .standard(proto: "area_min"),
    12: .standard(proto: "area_max"),
    13: .same(proto: "iou"),
  ]

  fileprivate class _StorageClass {
    var _numPos: UInt32 = 0
    var _numNeg: UInt32 = 0
    var _numTot: UInt32 = 0
    var _rocAuc: Float = 0
    var _f1: Float = 0
    var _concept: Clarifai_Api_Concept? = nil
    var _rocCurve: Clarifai_Api_ROC? = nil
    var _precisionRecallCurve: Clarifai_Api_PrecisionRecallCurve? = nil
    var _avgPrecision: Float = 0
    var _areaName: String = String()
    var _areaMin: Double = 0
    var _areaMax: Double = 0
    var _iou: Float = 0

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _numPos = source._numPos
      _numNeg = source._numNeg
      _numTot = source._numTot
      _rocAuc = source._rocAuc
      _f1 = source._f1
      _concept = source._concept
      _rocCurve = source._rocCurve
      _precisionRecallCurve = source._precisionRecallCurve
      _avgPrecision = source._avgPrecision
      _areaName = source._areaName
      _areaMin = source._areaMin
      _areaMax = source._areaMax
      _iou = source._iou
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularUInt32Field(value: &_storage._numPos) }()
        case 2: try { try decoder.decodeSingularUInt32Field(value: &_storage._numNeg) }()
        case 3: try { try decoder.decodeSingularUInt32Field(value: &_storage._numTot) }()
        case 4: try { try decoder.decodeSingularFloatField(value: &_storage._rocAuc) }()
        case 5: try { try decoder.decodeSingularFloatField(value: &_storage._f1) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._concept) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._rocCurve) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._precisionRecallCurve) }()
        case 9: try { try decoder.decodeSingularFloatField(value: &_storage._avgPrecision) }()
        case 10: try { try decoder.decodeSingularStringField(value: &_storage._areaName) }()
        case 11: try { try decoder.decodeSingularDoubleField(value: &_storage._areaMin) }()
        case 12: try { try decoder.decodeSingularDoubleField(value: &_storage._areaMax) }()
        case 13: try { try decoder.decodeSingularFloatField(value: &_storage._iou) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if _storage._numPos != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._numPos, fieldNumber: 1)
      }
      if _storage._numNeg != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._numNeg, fieldNumber: 2)
      }
      if _storage._numTot != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._numTot, fieldNumber: 3)
      }
      if _storage._rocAuc != 0 {
        try visitor.visitSingularFloatField(value: _storage._rocAuc, fieldNumber: 4)
      }
      if _storage._f1 != 0 {
        try visitor.visitSingularFloatField(value: _storage._f1, fieldNumber: 5)
      }
      try { if let v = _storage._concept {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
      try { if let v = _storage._rocCurve {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      } }()
      try { if let v = _storage._precisionRecallCurve {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      } }()
      if _storage._avgPrecision != 0 {
        try visitor.visitSingularFloatField(value: _storage._avgPrecision, fieldNumber: 9)
      }
      if !_storage._areaName.isEmpty {
        try visitor.visitSingularStringField(value: _storage._areaName, fieldNumber: 10)
      }
      if _storage._areaMin != 0 {
        try visitor.visitSingularDoubleField(value: _storage._areaMin, fieldNumber: 11)
      }
      if _storage._areaMax != 0 {
        try visitor.visitSingularDoubleField(value: _storage._areaMax, fieldNumber: 12)
      }
      if _storage._iou != 0 {
        try visitor.visitSingularFloatField(value: _storage._iou, fieldNumber: 13)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_BinaryMetrics, rhs: Clarifai_Api_BinaryMetrics) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._numPos != rhs_storage._numPos {return false}
        if _storage._numNeg != rhs_storage._numNeg {return false}
        if _storage._numTot != rhs_storage._numTot {return false}
        if _storage._rocAuc != rhs_storage._rocAuc {return false}
        if _storage._f1 != rhs_storage._f1 {return false}
        if _storage._concept != rhs_storage._concept {return false}
        if _storage._rocCurve != rhs_storage._rocCurve {return false}
        if _storage._precisionRecallCurve != rhs_storage._precisionRecallCurve {return false}
        if _storage._avgPrecision != rhs_storage._avgPrecision {return false}
        if _storage._areaName != rhs_storage._areaName {return false}
        if _storage._areaMin != rhs_storage._areaMin {return false}
        if _storage._areaMax != rhs_storage._areaMax {return false}
        if _storage._iou != rhs_storage._iou {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_TrackerMetrics: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TrackerMetrics"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "mot_mota"),
    2: .standard(proto: "mot_num_switches"),
    3: .standard(proto: "morse_frag"),
    4: .standard(proto: "avg_precision"),
    5: .same(proto: "aiid"),
    6: .standard(proto: "unique_switch_rate"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFloatField(value: &self.motMota) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.motNumSwitches) }()
      case 3: try { try decoder.decodeSingularFloatField(value: &self.morseFrag) }()
      case 4: try { try decoder.decodeSingularFloatField(value: &self.avgPrecision) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.aiid) }()
      case 6: try { try decoder.decodeSingularFloatField(value: &self.uniqueSwitchRate) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.motMota != 0 {
      try visitor.visitSingularFloatField(value: self.motMota, fieldNumber: 1)
    }
    if self.motNumSwitches != 0 {
      try visitor.visitSingularInt32Field(value: self.motNumSwitches, fieldNumber: 2)
    }
    if self.morseFrag != 0 {
      try visitor.visitSingularFloatField(value: self.morseFrag, fieldNumber: 3)
    }
    if self.avgPrecision != 0 {
      try visitor.visitSingularFloatField(value: self.avgPrecision, fieldNumber: 4)
    }
    if !self.aiid.isEmpty {
      try visitor.visitSingularStringField(value: self.aiid, fieldNumber: 5)
    }
    if self.uniqueSwitchRate != 0 {
      try visitor.visitSingularFloatField(value: self.uniqueSwitchRate, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_TrackerMetrics, rhs: Clarifai_Api_TrackerMetrics) -> Bool {
    if lhs.motMota != rhs.motMota {return false}
    if lhs.motNumSwitches != rhs.motNumSwitches {return false}
    if lhs.morseFrag != rhs.morseFrag {return false}
    if lhs.avgPrecision != rhs.avgPrecision {return false}
    if lhs.aiid != rhs.aiid {return false}
    if lhs.uniqueSwitchRate != rhs.uniqueSwitchRate {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_EvalTestSetEntry: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".EvalTestSetEntry"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    6: .same(proto: "input"),
    3: .standard(proto: "predicted_concepts"),
    4: .standard(proto: "ground_truth_concepts"),
    5: .same(proto: "annotation"),
    7: .standard(proto: "predicted_annotation"),
    8: .standard(proto: "ground_truth_annotation"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.predictedConcepts) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.groundTruthConcepts) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._annotation) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._input) }()
      case 7: try { try decoder.decodeSingularMessageField(value: &self._predictedAnnotation) }()
      case 8: try { try decoder.decodeSingularMessageField(value: &self._groundTruthAnnotation) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.predictedConcepts.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.predictedConcepts, fieldNumber: 3)
    }
    if !self.groundTruthConcepts.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.groundTruthConcepts, fieldNumber: 4)
    }
    try { if let v = self._annotation {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._input {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    try { if let v = self._predictedAnnotation {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    } }()
    try { if let v = self._groundTruthAnnotation {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_EvalTestSetEntry, rhs: Clarifai_Api_EvalTestSetEntry) -> Bool {
    if lhs._input != rhs._input {return false}
    if lhs.predictedConcepts != rhs.predictedConcepts {return false}
    if lhs.groundTruthConcepts != rhs.groundTruthConcepts {return false}
    if lhs._annotation != rhs._annotation {return false}
    if lhs._predictedAnnotation != rhs._predictedAnnotation {return false}
    if lhs._groundTruthAnnotation != rhs._groundTruthAnnotation {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_LOPQEvalResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LOPQEvalResult"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "k"),
    2: .standard(proto: "recall_vs_brute_force"),
    3: .standard(proto: "kendall_tau_vs_brute_force"),
    4: .standard(proto: "most_frequent_code_percent"),
    5: .standard(proto: "lopq_ndcg"),
    6: .standard(proto: "brute_force_ndcg"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.k) }()
      case 2: try { try decoder.decodeSingularFloatField(value: &self.recallVsBruteForce) }()
      case 3: try { try decoder.decodeSingularFloatField(value: &self.kendallTauVsBruteForce) }()
      case 4: try { try decoder.decodeSingularFloatField(value: &self.mostFrequentCodePercent) }()
      case 5: try { try decoder.decodeSingularFloatField(value: &self.lopqNdcg) }()
      case 6: try { try decoder.decodeSingularFloatField(value: &self.bruteForceNdcg) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.k != 0 {
      try visitor.visitSingularInt32Field(value: self.k, fieldNumber: 1)
    }
    if self.recallVsBruteForce != 0 {
      try visitor.visitSingularFloatField(value: self.recallVsBruteForce, fieldNumber: 2)
    }
    if self.kendallTauVsBruteForce != 0 {
      try visitor.visitSingularFloatField(value: self.kendallTauVsBruteForce, fieldNumber: 3)
    }
    if self.mostFrequentCodePercent != 0 {
      try visitor.visitSingularFloatField(value: self.mostFrequentCodePercent, fieldNumber: 4)
    }
    if self.lopqNdcg != 0 {
      try visitor.visitSingularFloatField(value: self.lopqNdcg, fieldNumber: 5)
    }
    if self.bruteForceNdcg != 0 {
      try visitor.visitSingularFloatField(value: self.bruteForceNdcg, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_LOPQEvalResult, rhs: Clarifai_Api_LOPQEvalResult) -> Bool {
    if lhs.k != rhs.k {return false}
    if lhs.recallVsBruteForce != rhs.recallVsBruteForce {return false}
    if lhs.kendallTauVsBruteForce != rhs.kendallTauVsBruteForce {return false}
    if lhs.mostFrequentCodePercent != rhs.mostFrequentCodePercent {return false}
    if lhs.lopqNdcg != rhs.lopqNdcg {return false}
    if lhs.bruteForceNdcg != rhs.bruteForceNdcg {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_MetricsSummary: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MetricsSummary"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "top1_accuracy"),
    2: .standard(proto: "top5_accuracy"),
    3: .standard(proto: "macro_avg_roc_auc"),
    4: .standard(proto: "macro_std_roc_auc"),
    5: .standard(proto: "macro_avg_f1_score"),
    6: .standard(proto: "macro_std_f1_score"),
    7: .standard(proto: "macro_avg_precision"),
    8: .standard(proto: "macro_avg_recall"),
    10: .standard(proto: "mean_avg_precision_iou_50"),
    11: .standard(proto: "mean_avg_precision_iou_range"),
    9: .standard(proto: "lopq_metrics"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFloatField(value: &self.top1Accuracy) }()
      case 2: try { try decoder.decodeSingularFloatField(value: &self.top5Accuracy) }()
      case 3: try { try decoder.decodeSingularFloatField(value: &self.macroAvgRocAuc) }()
      case 4: try { try decoder.decodeSingularFloatField(value: &self.macroStdRocAuc) }()
      case 5: try { try decoder.decodeSingularFloatField(value: &self.macroAvgF1Score) }()
      case 6: try { try decoder.decodeSingularFloatField(value: &self.macroStdF1Score) }()
      case 7: try { try decoder.decodeSingularFloatField(value: &self.macroAvgPrecision) }()
      case 8: try { try decoder.decodeSingularFloatField(value: &self.macroAvgRecall) }()
      case 9: try { try decoder.decodeRepeatedMessageField(value: &self.lopqMetrics) }()
      case 10: try { try decoder.decodeSingularFloatField(value: &self.meanAvgPrecisionIou50) }()
      case 11: try { try decoder.decodeSingularFloatField(value: &self.meanAvgPrecisionIouRange) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.top1Accuracy != 0 {
      try visitor.visitSingularFloatField(value: self.top1Accuracy, fieldNumber: 1)
    }
    if self.top5Accuracy != 0 {
      try visitor.visitSingularFloatField(value: self.top5Accuracy, fieldNumber: 2)
    }
    if self.macroAvgRocAuc != 0 {
      try visitor.visitSingularFloatField(value: self.macroAvgRocAuc, fieldNumber: 3)
    }
    if self.macroStdRocAuc != 0 {
      try visitor.visitSingularFloatField(value: self.macroStdRocAuc, fieldNumber: 4)
    }
    if self.macroAvgF1Score != 0 {
      try visitor.visitSingularFloatField(value: self.macroAvgF1Score, fieldNumber: 5)
    }
    if self.macroStdF1Score != 0 {
      try visitor.visitSingularFloatField(value: self.macroStdF1Score, fieldNumber: 6)
    }
    if self.macroAvgPrecision != 0 {
      try visitor.visitSingularFloatField(value: self.macroAvgPrecision, fieldNumber: 7)
    }
    if self.macroAvgRecall != 0 {
      try visitor.visitSingularFloatField(value: self.macroAvgRecall, fieldNumber: 8)
    }
    if !self.lopqMetrics.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.lopqMetrics, fieldNumber: 9)
    }
    if self.meanAvgPrecisionIou50 != 0 {
      try visitor.visitSingularFloatField(value: self.meanAvgPrecisionIou50, fieldNumber: 10)
    }
    if self.meanAvgPrecisionIouRange != 0 {
      try visitor.visitSingularFloatField(value: self.meanAvgPrecisionIouRange, fieldNumber: 11)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_MetricsSummary, rhs: Clarifai_Api_MetricsSummary) -> Bool {
    if lhs.top1Accuracy != rhs.top1Accuracy {return false}
    if lhs.top5Accuracy != rhs.top5Accuracy {return false}
    if lhs.macroAvgRocAuc != rhs.macroAvgRocAuc {return false}
    if lhs.macroStdRocAuc != rhs.macroStdRocAuc {return false}
    if lhs.macroAvgF1Score != rhs.macroAvgF1Score {return false}
    if lhs.macroStdF1Score != rhs.macroStdF1Score {return false}
    if lhs.macroAvgPrecision != rhs.macroAvgPrecision {return false}
    if lhs.macroAvgRecall != rhs.macroAvgRecall {return false}
    if lhs.meanAvgPrecisionIou50 != rhs.meanAvgPrecisionIou50 {return false}
    if lhs.meanAvgPrecisionIouRange != rhs.meanAvgPrecisionIouRange {return false}
    if lhs.lopqMetrics != rhs.lopqMetrics {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_EvalMetrics: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".EvalMetrics"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
    15: .standard(proto: "user_id"),
    16: .standard(proto: "app_id"),
    10: .same(proto: "id"),
    13: .same(proto: "model"),
    14: .standard(proto: "ground_truth_dataset"),
    18: .standard(proto: "predictions_dataset"),
    2: .same(proto: "summary"),
    3: .standard(proto: "confusion_matrix"),
    4: .standard(proto: "cooccurrence_matrix"),
    5: .standard(proto: "label_counts"),
    6: .standard(proto: "binary_metrics"),
    7: .standard(proto: "test_set"),
    8: .standard(proto: "metrics_by_area"),
    9: .standard(proto: "metrics_by_class"),
    11: .standard(proto: "tracker_metrics"),
    12: .standard(proto: "eval_info"),
    17: .standard(proto: "extended_metrics"),
  ]

  fileprivate class _StorageClass {
    var _status: Clarifai_Api_Status_Status? = nil
    var _userID: String = String()
    var _appID: String = String()
    var _id: String = String()
    var _model: Clarifai_Api_Model? = nil
    var _groundTruthDataset: Clarifai_Api_Dataset? = nil
    var _predictionsDataset: Clarifai_Api_Dataset? = nil
    var _summary: Clarifai_Api_MetricsSummary? = nil
    var _confusionMatrix: Clarifai_Api_ConfusionMatrix? = nil
    var _cooccurrenceMatrix: Clarifai_Api_CooccurrenceMatrix? = nil
    var _labelCounts: Clarifai_Api_LabelDistribution? = nil
    var _binaryMetrics: [Clarifai_Api_BinaryMetrics] = []
    var _testSet: [Clarifai_Api_EvalTestSetEntry] = []
    var _metricsByArea: [Clarifai_Api_BinaryMetrics] = []
    var _metricsByClass: [Clarifai_Api_BinaryMetrics] = []
    var _trackerMetrics: [Clarifai_Api_TrackerMetrics] = []
    var _evalInfo: Clarifai_Api_EvalInfo? = nil
    var _extendedMetrics: Clarifai_Api_ExtendedMetrics? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _status = source._status
      _userID = source._userID
      _appID = source._appID
      _id = source._id
      _model = source._model
      _groundTruthDataset = source._groundTruthDataset
      _predictionsDataset = source._predictionsDataset
      _summary = source._summary
      _confusionMatrix = source._confusionMatrix
      _cooccurrenceMatrix = source._cooccurrenceMatrix
      _labelCounts = source._labelCounts
      _binaryMetrics = source._binaryMetrics
      _testSet = source._testSet
      _metricsByArea = source._metricsByArea
      _metricsByClass = source._metricsByClass
      _trackerMetrics = source._trackerMetrics
      _evalInfo = source._evalInfo
      _extendedMetrics = source._extendedMetrics
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._status) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._summary) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._confusionMatrix) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._cooccurrenceMatrix) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._labelCounts) }()
        case 6: try { try decoder.decodeRepeatedMessageField(value: &_storage._binaryMetrics) }()
        case 7: try { try decoder.decodeRepeatedMessageField(value: &_storage._testSet) }()
        case 8: try { try decoder.decodeRepeatedMessageField(value: &_storage._metricsByArea) }()
        case 9: try { try decoder.decodeRepeatedMessageField(value: &_storage._metricsByClass) }()
        case 10: try { try decoder.decodeSingularStringField(value: &_storage._id) }()
        case 11: try { try decoder.decodeRepeatedMessageField(value: &_storage._trackerMetrics) }()
        case 12: try { try decoder.decodeSingularMessageField(value: &_storage._evalInfo) }()
        case 13: try { try decoder.decodeSingularMessageField(value: &_storage._model) }()
        case 14: try { try decoder.decodeSingularMessageField(value: &_storage._groundTruthDataset) }()
        case 15: try { try decoder.decodeSingularStringField(value: &_storage._userID) }()
        case 16: try { try decoder.decodeSingularStringField(value: &_storage._appID) }()
        case 17: try { try decoder.decodeSingularMessageField(value: &_storage._extendedMetrics) }()
        case 18: try { try decoder.decodeSingularMessageField(value: &_storage._predictionsDataset) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._status {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._summary {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._confusionMatrix {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._cooccurrenceMatrix {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._labelCounts {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      if !_storage._binaryMetrics.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._binaryMetrics, fieldNumber: 6)
      }
      if !_storage._testSet.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._testSet, fieldNumber: 7)
      }
      if !_storage._metricsByArea.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._metricsByArea, fieldNumber: 8)
      }
      if !_storage._metricsByClass.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._metricsByClass, fieldNumber: 9)
      }
      if !_storage._id.isEmpty {
        try visitor.visitSingularStringField(value: _storage._id, fieldNumber: 10)
      }
      if !_storage._trackerMetrics.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._trackerMetrics, fieldNumber: 11)
      }
      try { if let v = _storage._evalInfo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
      } }()
      try { if let v = _storage._model {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
      } }()
      try { if let v = _storage._groundTruthDataset {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
      } }()
      if !_storage._userID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._userID, fieldNumber: 15)
      }
      if !_storage._appID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._appID, fieldNumber: 16)
      }
      try { if let v = _storage._extendedMetrics {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 17)
      } }()
      try { if let v = _storage._predictionsDataset {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 18)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_EvalMetrics, rhs: Clarifai_Api_EvalMetrics) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._status != rhs_storage._status {return false}
        if _storage._userID != rhs_storage._userID {return false}
        if _storage._appID != rhs_storage._appID {return false}
        if _storage._id != rhs_storage._id {return false}
        if _storage._model != rhs_storage._model {return false}
        if _storage._groundTruthDataset != rhs_storage._groundTruthDataset {return false}
        if _storage._predictionsDataset != rhs_storage._predictionsDataset {return false}
        if _storage._summary != rhs_storage._summary {return false}
        if _storage._confusionMatrix != rhs_storage._confusionMatrix {return false}
        if _storage._cooccurrenceMatrix != rhs_storage._cooccurrenceMatrix {return false}
        if _storage._labelCounts != rhs_storage._labelCounts {return false}
        if _storage._binaryMetrics != rhs_storage._binaryMetrics {return false}
        if _storage._testSet != rhs_storage._testSet {return false}
        if _storage._metricsByArea != rhs_storage._metricsByArea {return false}
        if _storage._metricsByClass != rhs_storage._metricsByClass {return false}
        if _storage._trackerMetrics != rhs_storage._trackerMetrics {return false}
        if _storage._evalInfo != rhs_storage._evalInfo {return false}
        if _storage._extendedMetrics != rhs_storage._extendedMetrics {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_ExtendedMetrics: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ExtendedMetrics"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_metrics"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._userMetrics) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._userMetrics {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_ExtendedMetrics, rhs: Clarifai_Api_ExtendedMetrics) -> Bool {
    if lhs._userMetrics != rhs._userMetrics {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_FieldsValue: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".FieldsValue"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "confusion_matrix"),
    2: .standard(proto: "cooccurrence_matrix"),
    3: .standard(proto: "label_counts"),
    4: .standard(proto: "binary_metrics"),
    5: .standard(proto: "test_set"),
    6: .standard(proto: "metrics_by_area"),
    7: .standard(proto: "metrics_by_class"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.confusionMatrix) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.cooccurrenceMatrix) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.labelCounts) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.binaryMetrics) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.testSet) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self.metricsByArea) }()
      case 7: try { try decoder.decodeSingularBoolField(value: &self.metricsByClass) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.confusionMatrix != false {
      try visitor.visitSingularBoolField(value: self.confusionMatrix, fieldNumber: 1)
    }
    if self.cooccurrenceMatrix != false {
      try visitor.visitSingularBoolField(value: self.cooccurrenceMatrix, fieldNumber: 2)
    }
    if self.labelCounts != false {
      try visitor.visitSingularBoolField(value: self.labelCounts, fieldNumber: 3)
    }
    if self.binaryMetrics != false {
      try visitor.visitSingularBoolField(value: self.binaryMetrics, fieldNumber: 4)
    }
    if self.testSet != false {
      try visitor.visitSingularBoolField(value: self.testSet, fieldNumber: 5)
    }
    if self.metricsByArea != false {
      try visitor.visitSingularBoolField(value: self.metricsByArea, fieldNumber: 6)
    }
    if self.metricsByClass != false {
      try visitor.visitSingularBoolField(value: self.metricsByClass, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_FieldsValue, rhs: Clarifai_Api_FieldsValue) -> Bool {
    if lhs.confusionMatrix != rhs.confusionMatrix {return false}
    if lhs.cooccurrenceMatrix != rhs.cooccurrenceMatrix {return false}
    if lhs.labelCounts != rhs.labelCounts {return false}
    if lhs.binaryMetrics != rhs.binaryMetrics {return false}
    if lhs.testSet != rhs.testSet {return false}
    if lhs.metricsByArea != rhs.metricsByArea {return false}
    if lhs.metricsByClass != rhs.metricsByClass {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_Output: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Output"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "status"),
    3: .standard(proto: "created_at"),
    4: .same(proto: "model"),
    5: .same(proto: "input"),
    6: .same(proto: "data"),
    7: .standard(proto: "prompt_tokens"),
    8: .standard(proto: "completion_tokens"),
  ]

  fileprivate class _StorageClass {
    var _id: String = String()
    var _status: Clarifai_Api_Status_Status? = nil
    var _createdAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _model: Clarifai_Api_Model? = nil
    var _input: Clarifai_Api_Input? = nil
    var _data: Clarifai_Api_Data? = nil
    var _promptTokens: UInt32 = 0
    var _completionTokens: UInt32 = 0

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _id = source._id
      _status = source._status
      _createdAt = source._createdAt
      _model = source._model
      _input = source._input
      _data = source._data
      _promptTokens = source._promptTokens
      _completionTokens = source._completionTokens
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._id) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._status) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._createdAt) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._model) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._input) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._data) }()
        case 7: try { try decoder.decodeSingularUInt32Field(value: &_storage._promptTokens) }()
        case 8: try { try decoder.decodeSingularUInt32Field(value: &_storage._completionTokens) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._id.isEmpty {
        try visitor.visitSingularStringField(value: _storage._id, fieldNumber: 1)
      }
      try { if let v = _storage._status {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._createdAt {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._model {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._input {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._data {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
      if _storage._promptTokens != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._promptTokens, fieldNumber: 7)
      }
      if _storage._completionTokens != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._completionTokens, fieldNumber: 8)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_Output, rhs: Clarifai_Api_Output) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._id != rhs_storage._id {return false}
        if _storage._status != rhs_storage._status {return false}
        if _storage._createdAt != rhs_storage._createdAt {return false}
        if _storage._model != rhs_storage._model {return false}
        if _storage._input != rhs_storage._input {return false}
        if _storage._data != rhs_storage._data {return false}
        if _storage._promptTokens != rhs_storage._promptTokens {return false}
        if _storage._completionTokens != rhs_storage._completionTokens {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_ScopeDeps: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ScopeDeps"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "scope"),
    2: .standard(proto: "depending_scopes"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.scope) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.dependingScopes) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.scope.isEmpty {
      try visitor.visitSingularStringField(value: self.scope, fieldNumber: 1)
    }
    if !self.dependingScopes.isEmpty {
      try visitor.visitRepeatedStringField(value: self.dependingScopes, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_ScopeDeps, rhs: Clarifai_Api_ScopeDeps) -> Bool {
    if lhs.scope != rhs.scope {return false}
    if lhs.dependingScopes != rhs.dependingScopes {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_EndpointDeps: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".EndpointDeps"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "endpoint"),
    2: .standard(proto: "depending_scopes"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.endpoint) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.dependingScopes) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.endpoint.isEmpty {
      try visitor.visitSingularStringField(value: self.endpoint, fieldNumber: 1)
    }
    if !self.dependingScopes.isEmpty {
      try visitor.visitRepeatedStringField(value: self.dependingScopes, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_EndpointDeps, rhs: Clarifai_Api_EndpointDeps) -> Bool {
    if lhs.endpoint != rhs.endpoint {return false}
    if lhs.dependingScopes != rhs.dependingScopes {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_Hit: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Hit"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "score"),
    2: .same(proto: "input"),
    3: .same(proto: "annotation"),
    4: .standard(proto: "user_id"),
    5: .standard(proto: "app_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFloatField(value: &self.score) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._input) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._annotation) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.userID) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.appID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.score != 0 {
      try visitor.visitSingularFloatField(value: self.score, fieldNumber: 1)
    }
    try { if let v = self._input {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._annotation {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if !self.userID.isEmpty {
      try visitor.visitSingularStringField(value: self.userID, fieldNumber: 4)
    }
    if !self.appID.isEmpty {
      try visitor.visitSingularStringField(value: self.appID, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_Hit, rhs: Clarifai_Api_Hit) -> Bool {
    if lhs.score != rhs.score {return false}
    if lhs._input != rhs._input {return false}
    if lhs._annotation != rhs._annotation {return false}
    if lhs.userID != rhs.userID {return false}
    if lhs.appID != rhs.appID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_HitCount: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".HitCount"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "estimated_total"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.estimatedTotal) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.estimatedTotal != 0 {
      try visitor.visitSingularUInt64Field(value: self.estimatedTotal, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_HitCount, rhs: Clarifai_Api_HitCount) -> Bool {
    if lhs.estimatedTotal != rhs.estimatedTotal {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_And: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".And"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "input"),
    2: .same(proto: "output"),
    3: .same(proto: "negate"),
    4: .same(proto: "annotation"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._input) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._output) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.negate) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._annotation) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._input {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._output {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if self.negate != false {
      try visitor.visitSingularBoolField(value: self.negate, fieldNumber: 3)
    }
    try { if let v = self._annotation {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_And, rhs: Clarifai_Api_And) -> Bool {
    if lhs._input != rhs._input {return false}
    if lhs._output != rhs._output {return false}
    if lhs.negate != rhs.negate {return false}
    if lhs._annotation != rhs._annotation {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_Query: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Query"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ands"),
    2: .same(proto: "language"),
    3: .same(proto: "filters"),
    4: .same(proto: "ranks"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.ands) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.language) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.filters) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.ranks) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.ands.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.ands, fieldNumber: 1)
    }
    if !self.language.isEmpty {
      try visitor.visitSingularStringField(value: self.language, fieldNumber: 2)
    }
    if !self.filters.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.filters, fieldNumber: 3)
    }
    if !self.ranks.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.ranks, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_Query, rhs: Clarifai_Api_Query) -> Bool {
    if lhs.ands != rhs.ands {return false}
    if lhs.language != rhs.language {return false}
    if lhs.filters != rhs.filters {return false}
    if lhs.ranks != rhs.ranks {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_Search: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Search"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "query"),
    2: .same(proto: "id"),
    3: .standard(proto: "application_id"),
    4: .same(proto: "name"),
    5: .standard(proto: "as_of"),
    6: .standard(proto: "git_hash"),
    7: .standard(proto: "created_at"),
    8: .standard(proto: "modified_at"),
    9: .same(proto: "algorithm"),
    10: .same(proto: "save"),
    11: .standard(proto: "min_value"),
    12: .same(proto: "visibility"),
    13: .same(proto: "metric"),
  ]

  fileprivate class _StorageClass {
    var _query: Clarifai_Api_Query? = nil
    var _id: String = String()
    var _applicationID: String = String()
    var _name: String = String()
    var _asOf: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _gitHash: String = String()
    var _createdAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _modifiedAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _algorithm: String = String()
    var _save: Bool = false
    var _minValue: Float = 0
    var _visibility: Clarifai_Api_Visibility? = nil
    var _metric: Clarifai_Api_Search.Metric = .notSet

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _query = source._query
      _id = source._id
      _applicationID = source._applicationID
      _name = source._name
      _asOf = source._asOf
      _gitHash = source._gitHash
      _createdAt = source._createdAt
      _modifiedAt = source._modifiedAt
      _algorithm = source._algorithm
      _save = source._save
      _minValue = source._minValue
      _visibility = source._visibility
      _metric = source._metric
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._query) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._id) }()
        case 3: try { try decoder.decodeSingularStringField(value: &_storage._applicationID) }()
        case 4: try { try decoder.decodeSingularStringField(value: &_storage._name) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._asOf) }()
        case 6: try { try decoder.decodeSingularStringField(value: &_storage._gitHash) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._createdAt) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._modifiedAt) }()
        case 9: try { try decoder.decodeSingularStringField(value: &_storage._algorithm) }()
        case 10: try { try decoder.decodeSingularBoolField(value: &_storage._save) }()
        case 11: try { try decoder.decodeSingularFloatField(value: &_storage._minValue) }()
        case 12: try { try decoder.decodeSingularMessageField(value: &_storage._visibility) }()
        case 13: try { try decoder.decodeSingularEnumField(value: &_storage._metric) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._query {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      if !_storage._id.isEmpty {
        try visitor.visitSingularStringField(value: _storage._id, fieldNumber: 2)
      }
      if !_storage._applicationID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._applicationID, fieldNumber: 3)
      }
      if !_storage._name.isEmpty {
        try visitor.visitSingularStringField(value: _storage._name, fieldNumber: 4)
      }
      try { if let v = _storage._asOf {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      if !_storage._gitHash.isEmpty {
        try visitor.visitSingularStringField(value: _storage._gitHash, fieldNumber: 6)
      }
      try { if let v = _storage._createdAt {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      } }()
      try { if let v = _storage._modifiedAt {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      } }()
      if !_storage._algorithm.isEmpty {
        try visitor.visitSingularStringField(value: _storage._algorithm, fieldNumber: 9)
      }
      if _storage._save != false {
        try visitor.visitSingularBoolField(value: _storage._save, fieldNumber: 10)
      }
      if _storage._minValue != 0 {
        try visitor.visitSingularFloatField(value: _storage._minValue, fieldNumber: 11)
      }
      try { if let v = _storage._visibility {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
      } }()
      if _storage._metric != .notSet {
        try visitor.visitSingularEnumField(value: _storage._metric, fieldNumber: 13)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_Search, rhs: Clarifai_Api_Search) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._query != rhs_storage._query {return false}
        if _storage._id != rhs_storage._id {return false}
        if _storage._applicationID != rhs_storage._applicationID {return false}
        if _storage._name != rhs_storage._name {return false}
        if _storage._asOf != rhs_storage._asOf {return false}
        if _storage._gitHash != rhs_storage._gitHash {return false}
        if _storage._createdAt != rhs_storage._createdAt {return false}
        if _storage._modifiedAt != rhs_storage._modifiedAt {return false}
        if _storage._algorithm != rhs_storage._algorithm {return false}
        if _storage._save != rhs_storage._save {return false}
        if _storage._minValue != rhs_storage._minValue {return false}
        if _storage._visibility != rhs_storage._visibility {return false}
        if _storage._metric != rhs_storage._metric {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_Search.Metric: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "METRIC_NOT_SET"),
    1: .same(proto: "EUCLIDEAN_DISTANCE"),
    2: .same(proto: "COSINE_DISTANCE"),
  ]
}

extension Clarifai_Api_Filter: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Filter"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    3: .same(proto: "negate"),
    4: .same(proto: "annotation"),
    5: .same(proto: "input"),
    6: .standard(proto: "last_updated_time_range"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 3: try { try decoder.decodeSingularBoolField(value: &self.negate) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._annotation) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._input) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._lastUpdatedTimeRange) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.negate != false {
      try visitor.visitSingularBoolField(value: self.negate, fieldNumber: 3)
    }
    try { if let v = self._annotation {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._input {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._lastUpdatedTimeRange {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_Filter, rhs: Clarifai_Api_Filter) -> Bool {
    if lhs.negate != rhs.negate {return false}
    if lhs._annotation != rhs._annotation {return false}
    if lhs._input != rhs._input {return false}
    if lhs._lastUpdatedTimeRange != rhs._lastUpdatedTimeRange {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_TimeRange: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TimeRange"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "start_time"),
    2: .standard(proto: "end_time"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._startTime) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._endTime) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._startTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._endTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_TimeRange, rhs: Clarifai_Api_TimeRange) -> Bool {
    if lhs._startTime != rhs._startTime {return false}
    if lhs._endTime != rhs._endTime {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_Rank: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Rank"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    3: .same(proto: "negate"),
    4: .same(proto: "annotation"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 3: try { try decoder.decodeSingularBoolField(value: &self.negate) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._annotation) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.negate != false {
      try visitor.visitSingularBoolField(value: self.negate, fieldNumber: 3)
    }
    try { if let v = self._annotation {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_Rank, rhs: Clarifai_Api_Rank) -> Bool {
    if lhs.negate != rhs.negate {return false}
    if lhs._annotation != rhs._annotation {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_AnnotationSearchMetrics: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AnnotationSearchMetrics"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "ground_truth"),
    2: .standard(proto: "search_to_eval"),
    3: .same(proto: "metrics"),
    4: .same(proto: "data"),
    5: .standard(proto: "active_concept_count"),
    6: .same(proto: "visibility"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._groundTruth) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._searchToEval) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._metrics) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._data) }()
      case 5: try { try decoder.decodeSingularUInt32Field(value: &self.activeConceptCount) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._visibility) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._groundTruth {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._searchToEval {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._metrics {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._data {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    if self.activeConceptCount != 0 {
      try visitor.visitSingularUInt32Field(value: self.activeConceptCount, fieldNumber: 5)
    }
    try { if let v = self._visibility {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_AnnotationSearchMetrics, rhs: Clarifai_Api_AnnotationSearchMetrics) -> Bool {
    if lhs._groundTruth != rhs._groundTruth {return false}
    if lhs._searchToEval != rhs._searchToEval {return false}
    if lhs._metrics != rhs._metrics {return false}
    if lhs._data != rhs._data {return false}
    if lhs.activeConceptCount != rhs.activeConceptCount {return false}
    if lhs._visibility != rhs._visibility {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_Text: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Text"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "raw"),
    2: .same(proto: "url"),
    3: .standard(proto: "allow_duplicate_url"),
    4: .same(proto: "hosted"),
    5: .standard(proto: "text_info"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.raw) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.url) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.allowDuplicateURL) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._hosted) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._textInfo) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.raw.isEmpty {
      try visitor.visitSingularStringField(value: self.raw, fieldNumber: 1)
    }
    if !self.url.isEmpty {
      try visitor.visitSingularStringField(value: self.url, fieldNumber: 2)
    }
    if self.allowDuplicateURL != false {
      try visitor.visitSingularBoolField(value: self.allowDuplicateURL, fieldNumber: 3)
    }
    try { if let v = self._hosted {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._textInfo {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_Text, rhs: Clarifai_Api_Text) -> Bool {
    if lhs.raw != rhs.raw {return false}
    if lhs.url != rhs.url {return false}
    if lhs.allowDuplicateURL != rhs.allowDuplicateURL {return false}
    if lhs._hosted != rhs._hosted {return false}
    if lhs._textInfo != rhs._textInfo {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_TextInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TextInfo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "char_count"),
    2: .same(proto: "encoding"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.charCount) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.encoding) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.charCount != 0 {
      try visitor.visitSingularInt32Field(value: self.charCount, fieldNumber: 1)
    }
    if !self.encoding.isEmpty {
      try visitor.visitSingularStringField(value: self.encoding, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_TextInfo, rhs: Clarifai_Api_TextInfo) -> Bool {
    if lhs.charCount != rhs.charCount {return false}
    if lhs.encoding != rhs.encoding {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_User: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".User"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .standard(proto: "primary_email"),
    3: .standard(proto: "first_name"),
    4: .standard(proto: "last_name"),
    5: .standard(proto: "company_name"),
    19: .standard(proto: "job_title"),
    20: .standard(proto: "job_role"),
    24: .same(proto: "intention"),
    25: .standard(proto: "referral_source"),
    7: .standard(proto: "bill_type"),
    6: .standard(proto: "created_at"),
    8: .standard(proto: "date_gdpr_consent"),
    9: .standard(proto: "date_tos_consent"),
    10: .standard(proto: "date_marketing_consent"),
    23: .standard(proto: "date_pii_consent"),
    11: .same(proto: "metadata"),
    12: .standard(proto: "email_addresses"),
    15: .standard(proto: "two_factor_auth_enabled"),
    16: .standard(proto: "teams_count"),
    21: .standard(proto: "is_starred"),
    22: .standard(proto: "star_count"),
    17: .same(proto: "visibility"),
    18: .standard(proto: "user_detail"),
    26: .same(proto: "image"),
  ]

  fileprivate class _StorageClass {
    var _id: String = String()
    var _primaryEmail: String = String()
    var _firstName: String = String()
    var _lastName: String = String()
    var _companyName: String = String()
    var _jobTitle: String = String()
    var _jobRole: String = String()
    var _intention: String = String()
    var _referralSource: String = String()
    var _billType: String = String()
    var _createdAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _dateGdprConsent: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _dateTosConsent: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _dateMarketingConsent: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _datePiiConsent: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _metadata: SwiftProtobuf.Google_Protobuf_Struct? = nil
    var _emailAddresses: [Clarifai_Api_EmailAddress] = []
    var _twoFactorAuthEnabled: Bool = false
    var _teamsCount: UInt32 = 0
    var _isStarred: Bool = false
    var _starCount: Int32 = 0
    var _visibility: Clarifai_Api_Visibility? = nil
    var _userDetail: Clarifai_Api_UserDetail? = nil
    var _image: Clarifai_Api_Image? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _id = source._id
      _primaryEmail = source._primaryEmail
      _firstName = source._firstName
      _lastName = source._lastName
      _companyName = source._companyName
      _jobTitle = source._jobTitle
      _jobRole = source._jobRole
      _intention = source._intention
      _referralSource = source._referralSource
      _billType = source._billType
      _createdAt = source._createdAt
      _dateGdprConsent = source._dateGdprConsent
      _dateTosConsent = source._dateTosConsent
      _dateMarketingConsent = source._dateMarketingConsent
      _datePiiConsent = source._datePiiConsent
      _metadata = source._metadata
      _emailAddresses = source._emailAddresses
      _twoFactorAuthEnabled = source._twoFactorAuthEnabled
      _teamsCount = source._teamsCount
      _isStarred = source._isStarred
      _starCount = source._starCount
      _visibility = source._visibility
      _userDetail = source._userDetail
      _image = source._image
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._id) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._primaryEmail) }()
        case 3: try { try decoder.decodeSingularStringField(value: &_storage._firstName) }()
        case 4: try { try decoder.decodeSingularStringField(value: &_storage._lastName) }()
        case 5: try { try decoder.decodeSingularStringField(value: &_storage._companyName) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._createdAt) }()
        case 7: try { try decoder.decodeSingularStringField(value: &_storage._billType) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._dateGdprConsent) }()
        case 9: try { try decoder.decodeSingularMessageField(value: &_storage._dateTosConsent) }()
        case 10: try { try decoder.decodeSingularMessageField(value: &_storage._dateMarketingConsent) }()
        case 11: try { try decoder.decodeSingularMessageField(value: &_storage._metadata) }()
        case 12: try { try decoder.decodeRepeatedMessageField(value: &_storage._emailAddresses) }()
        case 15: try { try decoder.decodeSingularBoolField(value: &_storage._twoFactorAuthEnabled) }()
        case 16: try { try decoder.decodeSingularUInt32Field(value: &_storage._teamsCount) }()
        case 17: try { try decoder.decodeSingularMessageField(value: &_storage._visibility) }()
        case 18: try { try decoder.decodeSingularMessageField(value: &_storage._userDetail) }()
        case 19: try { try decoder.decodeSingularStringField(value: &_storage._jobTitle) }()
        case 20: try { try decoder.decodeSingularStringField(value: &_storage._jobRole) }()
        case 21: try { try decoder.decodeSingularBoolField(value: &_storage._isStarred) }()
        case 22: try { try decoder.decodeSingularInt32Field(value: &_storage._starCount) }()
        case 23: try { try decoder.decodeSingularMessageField(value: &_storage._datePiiConsent) }()
        case 24: try { try decoder.decodeSingularStringField(value: &_storage._intention) }()
        case 25: try { try decoder.decodeSingularStringField(value: &_storage._referralSource) }()
        case 26: try { try decoder.decodeSingularMessageField(value: &_storage._image) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._id.isEmpty {
        try visitor.visitSingularStringField(value: _storage._id, fieldNumber: 1)
      }
      if !_storage._primaryEmail.isEmpty {
        try visitor.visitSingularStringField(value: _storage._primaryEmail, fieldNumber: 2)
      }
      if !_storage._firstName.isEmpty {
        try visitor.visitSingularStringField(value: _storage._firstName, fieldNumber: 3)
      }
      if !_storage._lastName.isEmpty {
        try visitor.visitSingularStringField(value: _storage._lastName, fieldNumber: 4)
      }
      if !_storage._companyName.isEmpty {
        try visitor.visitSingularStringField(value: _storage._companyName, fieldNumber: 5)
      }
      try { if let v = _storage._createdAt {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
      if !_storage._billType.isEmpty {
        try visitor.visitSingularStringField(value: _storage._billType, fieldNumber: 7)
      }
      try { if let v = _storage._dateGdprConsent {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      } }()
      try { if let v = _storage._dateTosConsent {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      } }()
      try { if let v = _storage._dateMarketingConsent {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      } }()
      try { if let v = _storage._metadata {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      } }()
      if !_storage._emailAddresses.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._emailAddresses, fieldNumber: 12)
      }
      if _storage._twoFactorAuthEnabled != false {
        try visitor.visitSingularBoolField(value: _storage._twoFactorAuthEnabled, fieldNumber: 15)
      }
      if _storage._teamsCount != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._teamsCount, fieldNumber: 16)
      }
      try { if let v = _storage._visibility {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 17)
      } }()
      try { if let v = _storage._userDetail {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 18)
      } }()
      if !_storage._jobTitle.isEmpty {
        try visitor.visitSingularStringField(value: _storage._jobTitle, fieldNumber: 19)
      }
      if !_storage._jobRole.isEmpty {
        try visitor.visitSingularStringField(value: _storage._jobRole, fieldNumber: 20)
      }
      if _storage._isStarred != false {
        try visitor.visitSingularBoolField(value: _storage._isStarred, fieldNumber: 21)
      }
      if _storage._starCount != 0 {
        try visitor.visitSingularInt32Field(value: _storage._starCount, fieldNumber: 22)
      }
      try { if let v = _storage._datePiiConsent {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 23)
      } }()
      if !_storage._intention.isEmpty {
        try visitor.visitSingularStringField(value: _storage._intention, fieldNumber: 24)
      }
      if !_storage._referralSource.isEmpty {
        try visitor.visitSingularStringField(value: _storage._referralSource, fieldNumber: 25)
      }
      try { if let v = _storage._image {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 26)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_User, rhs: Clarifai_Api_User) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._id != rhs_storage._id {return false}
        if _storage._primaryEmail != rhs_storage._primaryEmail {return false}
        if _storage._firstName != rhs_storage._firstName {return false}
        if _storage._lastName != rhs_storage._lastName {return false}
        if _storage._companyName != rhs_storage._companyName {return false}
        if _storage._jobTitle != rhs_storage._jobTitle {return false}
        if _storage._jobRole != rhs_storage._jobRole {return false}
        if _storage._intention != rhs_storage._intention {return false}
        if _storage._referralSource != rhs_storage._referralSource {return false}
        if _storage._billType != rhs_storage._billType {return false}
        if _storage._createdAt != rhs_storage._createdAt {return false}
        if _storage._dateGdprConsent != rhs_storage._dateGdprConsent {return false}
        if _storage._dateTosConsent != rhs_storage._dateTosConsent {return false}
        if _storage._dateMarketingConsent != rhs_storage._dateMarketingConsent {return false}
        if _storage._datePiiConsent != rhs_storage._datePiiConsent {return false}
        if _storage._metadata != rhs_storage._metadata {return false}
        if _storage._emailAddresses != rhs_storage._emailAddresses {return false}
        if _storage._twoFactorAuthEnabled != rhs_storage._twoFactorAuthEnabled {return false}
        if _storage._teamsCount != rhs_storage._teamsCount {return false}
        if _storage._isStarred != rhs_storage._isStarred {return false}
        if _storage._starCount != rhs_storage._starCount {return false}
        if _storage._visibility != rhs_storage._visibility {return false}
        if _storage._userDetail != rhs_storage._userDetail {return false}
        if _storage._image != rhs_storage._image {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_UserDetail: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UserDetail"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "primary_email"),
    2: .standard(proto: "bill_type"),
    3: .standard(proto: "date_gdpr_consent"),
    4: .standard(proto: "date_tos_consent"),
    5: .standard(proto: "date_marketing_consent"),
    13: .standard(proto: "date_pii_consent"),
    6: .same(proto: "metadata"),
    7: .standard(proto: "email_addresses"),
    9: .standard(proto: "two_factor_auth_enabled"),
    10: .standard(proto: "teams_count"),
    11: .same(proto: "country"),
    12: .same(proto: "state"),
    14: .standard(proto: "commitment_value"),
  ]

  fileprivate class _StorageClass {
    var _primaryEmail: String = String()
    var _billType: String = String()
    var _dateGdprConsent: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _dateTosConsent: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _dateMarketingConsent: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _datePiiConsent: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _metadata: SwiftProtobuf.Google_Protobuf_Struct? = nil
    var _emailAddresses: [Clarifai_Api_EmailAddress] = []
    var _twoFactorAuthEnabled: Bool = false
    var _teamsCount: UInt32 = 0
    var _country: String = String()
    var _state: String = String()
    var _commitmentValue: Clarifai_Api_CommitmentValue? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _primaryEmail = source._primaryEmail
      _billType = source._billType
      _dateGdprConsent = source._dateGdprConsent
      _dateTosConsent = source._dateTosConsent
      _dateMarketingConsent = source._dateMarketingConsent
      _datePiiConsent = source._datePiiConsent
      _metadata = source._metadata
      _emailAddresses = source._emailAddresses
      _twoFactorAuthEnabled = source._twoFactorAuthEnabled
      _teamsCount = source._teamsCount
      _country = source._country
      _state = source._state
      _commitmentValue = source._commitmentValue
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._primaryEmail) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._billType) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._dateGdprConsent) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._dateTosConsent) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._dateMarketingConsent) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._metadata) }()
        case 7: try { try decoder.decodeRepeatedMessageField(value: &_storage._emailAddresses) }()
        case 9: try { try decoder.decodeSingularBoolField(value: &_storage._twoFactorAuthEnabled) }()
        case 10: try { try decoder.decodeSingularUInt32Field(value: &_storage._teamsCount) }()
        case 11: try { try decoder.decodeSingularStringField(value: &_storage._country) }()
        case 12: try { try decoder.decodeSingularStringField(value: &_storage._state) }()
        case 13: try { try decoder.decodeSingularMessageField(value: &_storage._datePiiConsent) }()
        case 14: try { try decoder.decodeSingularMessageField(value: &_storage._commitmentValue) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._primaryEmail.isEmpty {
        try visitor.visitSingularStringField(value: _storage._primaryEmail, fieldNumber: 1)
      }
      if !_storage._billType.isEmpty {
        try visitor.visitSingularStringField(value: _storage._billType, fieldNumber: 2)
      }
      try { if let v = _storage._dateGdprConsent {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._dateTosConsent {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._dateMarketingConsent {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._metadata {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
      if !_storage._emailAddresses.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._emailAddresses, fieldNumber: 7)
      }
      if _storage._twoFactorAuthEnabled != false {
        try visitor.visitSingularBoolField(value: _storage._twoFactorAuthEnabled, fieldNumber: 9)
      }
      if _storage._teamsCount != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._teamsCount, fieldNumber: 10)
      }
      if !_storage._country.isEmpty {
        try visitor.visitSingularStringField(value: _storage._country, fieldNumber: 11)
      }
      if !_storage._state.isEmpty {
        try visitor.visitSingularStringField(value: _storage._state, fieldNumber: 12)
      }
      try { if let v = _storage._datePiiConsent {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
      } }()
      try { if let v = _storage._commitmentValue {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_UserDetail, rhs: Clarifai_Api_UserDetail) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._primaryEmail != rhs_storage._primaryEmail {return false}
        if _storage._billType != rhs_storage._billType {return false}
        if _storage._dateGdprConsent != rhs_storage._dateGdprConsent {return false}
        if _storage._dateTosConsent != rhs_storage._dateTosConsent {return false}
        if _storage._dateMarketingConsent != rhs_storage._dateMarketingConsent {return false}
        if _storage._datePiiConsent != rhs_storage._datePiiConsent {return false}
        if _storage._metadata != rhs_storage._metadata {return false}
        if _storage._emailAddresses != rhs_storage._emailAddresses {return false}
        if _storage._twoFactorAuthEnabled != rhs_storage._twoFactorAuthEnabled {return false}
        if _storage._teamsCount != rhs_storage._teamsCount {return false}
        if _storage._country != rhs_storage._country {return false}
        if _storage._state != rhs_storage._state {return false}
        if _storage._commitmentValue != rhs_storage._commitmentValue {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_EmailAddress: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".EmailAddress"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "email"),
    2: .same(proto: "primary"),
    3: .same(proto: "verified"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.email) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.primary) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.verified) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.email.isEmpty {
      try visitor.visitSingularStringField(value: self.email, fieldNumber: 1)
    }
    if self.primary != false {
      try visitor.visitSingularBoolField(value: self.primary, fieldNumber: 2)
    }
    if self.verified != false {
      try visitor.visitSingularBoolField(value: self.verified, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_EmailAddress, rhs: Clarifai_Api_EmailAddress) -> Bool {
    if lhs.email != rhs.email {return false}
    if lhs.primary != rhs.primary {return false}
    if lhs.verified != rhs.verified {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_Password: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Password"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "plaintext"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.plaintext) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.plaintext.isEmpty {
      try visitor.visitSingularStringField(value: self.plaintext, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_Password, rhs: Clarifai_Api_Password) -> Bool {
    if lhs.plaintext != rhs.plaintext {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_PasswordViolations: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PasswordViolations"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "minimum_length"),
    2: .standard(proto: "maximum_length"),
    3: .standard(proto: "upper_case_needed"),
    4: .standard(proto: "lower_case_needed"),
    5: .standard(proto: "numeric_needed"),
    6: .standard(proto: "non_alphanumeric_needed"),
    7: .standard(proto: "password_reuse"),
    8: .standard(proto: "exclude_names"),
    9: .standard(proto: "exclude_email"),
    10: .standard(proto: "no_confusing_letters"),
    11: .standard(proto: "no_simple_passwords"),
    12: .standard(proto: "no_common_vocabs"),
    13: .standard(proto: "no_overlap_with_old"),
    14: .standard(proto: "password_lifespan"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.minimumLength) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.maximumLength) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.upperCaseNeeded) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.lowerCaseNeeded) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.numericNeeded) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self.nonAlphanumericNeeded) }()
      case 7: try { try decoder.decodeSingularBoolField(value: &self.passwordReuse) }()
      case 8: try { try decoder.decodeSingularBoolField(value: &self.excludeNames) }()
      case 9: try { try decoder.decodeSingularBoolField(value: &self.excludeEmail) }()
      case 10: try { try decoder.decodeSingularBoolField(value: &self.noConfusingLetters) }()
      case 11: try { try decoder.decodeSingularBoolField(value: &self.noSimplePasswords) }()
      case 12: try { try decoder.decodeSingularBoolField(value: &self.noCommonVocabs) }()
      case 13: try { try decoder.decodeSingularBoolField(value: &self.noOverlapWithOld) }()
      case 14: try { try decoder.decodeSingularBoolField(value: &self.passwordLifespan) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.minimumLength != false {
      try visitor.visitSingularBoolField(value: self.minimumLength, fieldNumber: 1)
    }
    if self.maximumLength != false {
      try visitor.visitSingularBoolField(value: self.maximumLength, fieldNumber: 2)
    }
    if self.upperCaseNeeded != false {
      try visitor.visitSingularBoolField(value: self.upperCaseNeeded, fieldNumber: 3)
    }
    if self.lowerCaseNeeded != false {
      try visitor.visitSingularBoolField(value: self.lowerCaseNeeded, fieldNumber: 4)
    }
    if self.numericNeeded != false {
      try visitor.visitSingularBoolField(value: self.numericNeeded, fieldNumber: 5)
    }
    if self.nonAlphanumericNeeded != false {
      try visitor.visitSingularBoolField(value: self.nonAlphanumericNeeded, fieldNumber: 6)
    }
    if self.passwordReuse != false {
      try visitor.visitSingularBoolField(value: self.passwordReuse, fieldNumber: 7)
    }
    if self.excludeNames != false {
      try visitor.visitSingularBoolField(value: self.excludeNames, fieldNumber: 8)
    }
    if self.excludeEmail != false {
      try visitor.visitSingularBoolField(value: self.excludeEmail, fieldNumber: 9)
    }
    if self.noConfusingLetters != false {
      try visitor.visitSingularBoolField(value: self.noConfusingLetters, fieldNumber: 10)
    }
    if self.noSimplePasswords != false {
      try visitor.visitSingularBoolField(value: self.noSimplePasswords, fieldNumber: 11)
    }
    if self.noCommonVocabs != false {
      try visitor.visitSingularBoolField(value: self.noCommonVocabs, fieldNumber: 12)
    }
    if self.noOverlapWithOld != false {
      try visitor.visitSingularBoolField(value: self.noOverlapWithOld, fieldNumber: 13)
    }
    if self.passwordLifespan != false {
      try visitor.visitSingularBoolField(value: self.passwordLifespan, fieldNumber: 14)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_PasswordViolations, rhs: Clarifai_Api_PasswordViolations) -> Bool {
    if lhs.minimumLength != rhs.minimumLength {return false}
    if lhs.maximumLength != rhs.maximumLength {return false}
    if lhs.upperCaseNeeded != rhs.upperCaseNeeded {return false}
    if lhs.lowerCaseNeeded != rhs.lowerCaseNeeded {return false}
    if lhs.numericNeeded != rhs.numericNeeded {return false}
    if lhs.nonAlphanumericNeeded != rhs.nonAlphanumericNeeded {return false}
    if lhs.passwordReuse != rhs.passwordReuse {return false}
    if lhs.excludeNames != rhs.excludeNames {return false}
    if lhs.excludeEmail != rhs.excludeEmail {return false}
    if lhs.noConfusingLetters != rhs.noConfusingLetters {return false}
    if lhs.noSimplePasswords != rhs.noSimplePasswords {return false}
    if lhs.noCommonVocabs != rhs.noCommonVocabs {return false}
    if lhs.noOverlapWithOld != rhs.noOverlapWithOld {return false}
    if lhs.passwordLifespan != rhs.passwordLifespan {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_CommitmentValue: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CommitmentValue"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "value"),
    2: .same(proto: "type"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.value) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.type) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.value != 0 {
      try visitor.visitSingularInt32Field(value: self.value, fieldNumber: 1)
    }
    if self.type != .typeNotSet {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_CommitmentValue, rhs: Clarifai_Api_CommitmentValue) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs.type != rhs.type {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_CommitmentValue.CommitmentType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "TYPE_NOT_SET"),
    1: .same(proto: "MONTHLY"),
    2: .same(proto: "ANNUAL"),
  ]
}

extension Clarifai_Api_Video: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Video"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "url"),
    2: .same(proto: "base64"),
    4: .standard(proto: "allow_duplicate_url"),
    5: .standard(proto: "thumbnail_url"),
    6: .same(proto: "hosted"),
    8: .standard(proto: "hosted_thumbnail"),
    7: .standard(proto: "video_info"),
  ]

  fileprivate class _StorageClass {
    var _url: String = String()
    var _base64: Data = Data()
    var _allowDuplicateURL: Bool = false
    var _thumbnailURL: String = String()
    var _hosted: Clarifai_Api_HostedURL? = nil
    var _hostedThumbnail: Clarifai_Api_HostedURL? = nil
    var _videoInfo: Clarifai_Api_VideoInfo? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _url = source._url
      _base64 = source._base64
      _allowDuplicateURL = source._allowDuplicateURL
      _thumbnailURL = source._thumbnailURL
      _hosted = source._hosted
      _hostedThumbnail = source._hostedThumbnail
      _videoInfo = source._videoInfo
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._url) }()
        case 2: try { try decoder.decodeSingularBytesField(value: &_storage._base64) }()
        case 4: try { try decoder.decodeSingularBoolField(value: &_storage._allowDuplicateURL) }()
        case 5: try { try decoder.decodeSingularStringField(value: &_storage._thumbnailURL) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._hosted) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._videoInfo) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._hostedThumbnail) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._url.isEmpty {
        try visitor.visitSingularStringField(value: _storage._url, fieldNumber: 1)
      }
      if !_storage._base64.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._base64, fieldNumber: 2)
      }
      if _storage._allowDuplicateURL != false {
        try visitor.visitSingularBoolField(value: _storage._allowDuplicateURL, fieldNumber: 4)
      }
      if !_storage._thumbnailURL.isEmpty {
        try visitor.visitSingularStringField(value: _storage._thumbnailURL, fieldNumber: 5)
      }
      try { if let v = _storage._hosted {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
      try { if let v = _storage._videoInfo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      } }()
      try { if let v = _storage._hostedThumbnail {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_Video, rhs: Clarifai_Api_Video) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._url != rhs_storage._url {return false}
        if _storage._base64 != rhs_storage._base64 {return false}
        if _storage._allowDuplicateURL != rhs_storage._allowDuplicateURL {return false}
        if _storage._thumbnailURL != rhs_storage._thumbnailURL {return false}
        if _storage._hosted != rhs_storage._hosted {return false}
        if _storage._hostedThumbnail != rhs_storage._hostedThumbnail {return false}
        if _storage._videoInfo != rhs_storage._videoInfo {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_VideoInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".VideoInfo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "width"),
    2: .same(proto: "height"),
    3: .same(proto: "fps"),
    4: .standard(proto: "video_format"),
    5: .standard(proto: "bit_rate"),
    6: .standard(proto: "frame_count"),
    7: .standard(proto: "duration_seconds"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.width) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.height) }()
      case 3: try { try decoder.decodeSingularFloatField(value: &self.fps) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.videoFormat) }()
      case 5: try { try decoder.decodeSingularInt32Field(value: &self.bitRate) }()
      case 6: try { try decoder.decodeSingularInt32Field(value: &self.frameCount) }()
      case 7: try { try decoder.decodeSingularFloatField(value: &self.durationSeconds) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.width != 0 {
      try visitor.visitSingularInt32Field(value: self.width, fieldNumber: 1)
    }
    if self.height != 0 {
      try visitor.visitSingularInt32Field(value: self.height, fieldNumber: 2)
    }
    if self.fps != 0 {
      try visitor.visitSingularFloatField(value: self.fps, fieldNumber: 3)
    }
    if !self.videoFormat.isEmpty {
      try visitor.visitSingularStringField(value: self.videoFormat, fieldNumber: 4)
    }
    if self.bitRate != 0 {
      try visitor.visitSingularInt32Field(value: self.bitRate, fieldNumber: 5)
    }
    if self.frameCount != 0 {
      try visitor.visitSingularInt32Field(value: self.frameCount, fieldNumber: 6)
    }
    if self.durationSeconds != 0 {
      try visitor.visitSingularFloatField(value: self.durationSeconds, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_VideoInfo, rhs: Clarifai_Api_VideoInfo) -> Bool {
    if lhs.width != rhs.width {return false}
    if lhs.height != rhs.height {return false}
    if lhs.fps != rhs.fps {return false}
    if lhs.videoFormat != rhs.videoFormat {return false}
    if lhs.bitRate != rhs.bitRate {return false}
    if lhs.frameCount != rhs.frameCount {return false}
    if lhs.durationSeconds != rhs.durationSeconds {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_Workflow: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Workflow"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .standard(proto: "app_id"),
    3: .standard(proto: "created_at"),
    4: .same(proto: "nodes"),
    5: .same(proto: "metadata"),
    6: .same(proto: "visibility"),
    7: .standard(proto: "user_id"),
    8: .standard(proto: "modified_at"),
    9: .same(proto: "version"),
    10: .standard(proto: "is_starred"),
    11: .standard(proto: "star_count"),
    12: .same(proto: "description"),
    13: .same(proto: "notes"),
    14: .standard(proto: "use_cases"),
    15: .standard(proto: "check_consents"),
    16: .standard(proto: "bookmark_origin"),
    17: .same(proto: "image"),
  ]

  fileprivate class _StorageClass {
    var _id: String = String()
    var _appID: String = String()
    var _createdAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _nodes: [Clarifai_Api_WorkflowNode] = []
    var _metadata: SwiftProtobuf.Google_Protobuf_Struct? = nil
    var _visibility: Clarifai_Api_Visibility? = nil
    var _userID: String = String()
    var _modifiedAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _version: Clarifai_Api_WorkflowVersion? = nil
    var _isStarred: Bool = false
    var _starCount: Int32 = 0
    var _description_p: String = String()
    var _notes: String = String()
    var _useCases: [String] = []
    var _checkConsents: [String] = []
    var _bookmarkOrigin: Clarifai_Api_BookmarkOrigin? = nil
    var _image: Clarifai_Api_Image? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _id = source._id
      _appID = source._appID
      _createdAt = source._createdAt
      _nodes = source._nodes
      _metadata = source._metadata
      _visibility = source._visibility
      _userID = source._userID
      _modifiedAt = source._modifiedAt
      _version = source._version
      _isStarred = source._isStarred
      _starCount = source._starCount
      _description_p = source._description_p
      _notes = source._notes
      _useCases = source._useCases
      _checkConsents = source._checkConsents
      _bookmarkOrigin = source._bookmarkOrigin
      _image = source._image
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._id) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._appID) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._createdAt) }()
        case 4: try { try decoder.decodeRepeatedMessageField(value: &_storage._nodes) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._metadata) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._visibility) }()
        case 7: try { try decoder.decodeSingularStringField(value: &_storage._userID) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._modifiedAt) }()
        case 9: try { try decoder.decodeSingularMessageField(value: &_storage._version) }()
        case 10: try { try decoder.decodeSingularBoolField(value: &_storage._isStarred) }()
        case 11: try { try decoder.decodeSingularInt32Field(value: &_storage._starCount) }()
        case 12: try { try decoder.decodeSingularStringField(value: &_storage._description_p) }()
        case 13: try { try decoder.decodeSingularStringField(value: &_storage._notes) }()
        case 14: try { try decoder.decodeRepeatedStringField(value: &_storage._useCases) }()
        case 15: try { try decoder.decodeRepeatedStringField(value: &_storage._checkConsents) }()
        case 16: try { try decoder.decodeSingularMessageField(value: &_storage._bookmarkOrigin) }()
        case 17: try { try decoder.decodeSingularMessageField(value: &_storage._image) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._id.isEmpty {
        try visitor.visitSingularStringField(value: _storage._id, fieldNumber: 1)
      }
      if !_storage._appID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._appID, fieldNumber: 2)
      }
      try { if let v = _storage._createdAt {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      if !_storage._nodes.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._nodes, fieldNumber: 4)
      }
      try { if let v = _storage._metadata {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._visibility {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
      if !_storage._userID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._userID, fieldNumber: 7)
      }
      try { if let v = _storage._modifiedAt {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      } }()
      try { if let v = _storage._version {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      } }()
      if _storage._isStarred != false {
        try visitor.visitSingularBoolField(value: _storage._isStarred, fieldNumber: 10)
      }
      if _storage._starCount != 0 {
        try visitor.visitSingularInt32Field(value: _storage._starCount, fieldNumber: 11)
      }
      if !_storage._description_p.isEmpty {
        try visitor.visitSingularStringField(value: _storage._description_p, fieldNumber: 12)
      }
      if !_storage._notes.isEmpty {
        try visitor.visitSingularStringField(value: _storage._notes, fieldNumber: 13)
      }
      if !_storage._useCases.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._useCases, fieldNumber: 14)
      }
      if !_storage._checkConsents.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._checkConsents, fieldNumber: 15)
      }
      try { if let v = _storage._bookmarkOrigin {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
      } }()
      try { if let v = _storage._image {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 17)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_Workflow, rhs: Clarifai_Api_Workflow) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._id != rhs_storage._id {return false}
        if _storage._appID != rhs_storage._appID {return false}
        if _storage._createdAt != rhs_storage._createdAt {return false}
        if _storage._nodes != rhs_storage._nodes {return false}
        if _storage._metadata != rhs_storage._metadata {return false}
        if _storage._visibility != rhs_storage._visibility {return false}
        if _storage._userID != rhs_storage._userID {return false}
        if _storage._modifiedAt != rhs_storage._modifiedAt {return false}
        if _storage._version != rhs_storage._version {return false}
        if _storage._isStarred != rhs_storage._isStarred {return false}
        if _storage._starCount != rhs_storage._starCount {return false}
        if _storage._description_p != rhs_storage._description_p {return false}
        if _storage._notes != rhs_storage._notes {return false}
        if _storage._useCases != rhs_storage._useCases {return false}
        if _storage._checkConsents != rhs_storage._checkConsents {return false}
        if _storage._bookmarkOrigin != rhs_storage._bookmarkOrigin {return false}
        if _storage._image != rhs_storage._image {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_WorkflowVersion: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".WorkflowVersion"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .standard(proto: "workflow_id"),
    3: .standard(proto: "created_at"),
    4: .standard(proto: "modified_at"),
    5: .same(proto: "visibility"),
    6: .same(proto: "nodes"),
    7: .same(proto: "metadata"),
    8: .standard(proto: "app_id"),
    9: .standard(proto: "user_id"),
    10: .same(proto: "description"),
    11: .same(proto: "license"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.workflowID) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._createdAt) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._modifiedAt) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._visibility) }()
      case 6: try { try decoder.decodeRepeatedMessageField(value: &self.nodes) }()
      case 7: try { try decoder.decodeSingularMessageField(value: &self._metadata) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self.appID) }()
      case 9: try { try decoder.decodeSingularStringField(value: &self.userID) }()
      case 10: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      case 11: try { try decoder.decodeSingularStringField(value: &self.license) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if !self.workflowID.isEmpty {
      try visitor.visitSingularStringField(value: self.workflowID, fieldNumber: 2)
    }
    try { if let v = self._createdAt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._modifiedAt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._visibility {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    if !self.nodes.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.nodes, fieldNumber: 6)
    }
    try { if let v = self._metadata {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    } }()
    if !self.appID.isEmpty {
      try visitor.visitSingularStringField(value: self.appID, fieldNumber: 8)
    }
    if !self.userID.isEmpty {
      try visitor.visitSingularStringField(value: self.userID, fieldNumber: 9)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 10)
    }
    if !self.license.isEmpty {
      try visitor.visitSingularStringField(value: self.license, fieldNumber: 11)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_WorkflowVersion, rhs: Clarifai_Api_WorkflowVersion) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.workflowID != rhs.workflowID {return false}
    if lhs._createdAt != rhs._createdAt {return false}
    if lhs._modifiedAt != rhs._modifiedAt {return false}
    if lhs._visibility != rhs._visibility {return false}
    if lhs.nodes != rhs.nodes {return false}
    if lhs._metadata != rhs._metadata {return false}
    if lhs.appID != rhs.appID {return false}
    if lhs.userID != rhs.userID {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.license != rhs.license {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_WorkflowNode: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".WorkflowNode"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "model"),
    3: .standard(proto: "node_inputs"),
    4: .standard(proto: "suppress_output"),
    5: .standard(proto: "output_info_override"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._model) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.nodeInputs) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.suppressOutput) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._outputInfoOverride) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    try { if let v = self._model {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.nodeInputs.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.nodeInputs, fieldNumber: 3)
    }
    if self.suppressOutput != false {
      try visitor.visitSingularBoolField(value: self.suppressOutput, fieldNumber: 4)
    }
    try { if let v = self._outputInfoOverride {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_WorkflowNode, rhs: Clarifai_Api_WorkflowNode) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs._model != rhs._model {return false}
    if lhs.nodeInputs != rhs.nodeInputs {return false}
    if lhs.suppressOutput != rhs.suppressOutput {return false}
    if lhs._outputInfoOverride != rhs._outputInfoOverride {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_NodeInput: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".NodeInput"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "node_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.nodeID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.nodeID.isEmpty {
      try visitor.visitSingularStringField(value: self.nodeID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_NodeInput, rhs: Clarifai_Api_NodeInput) -> Bool {
    if lhs.nodeID != rhs.nodeID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_WorkflowResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".WorkflowResult"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "status"),
    3: .standard(proto: "created_at"),
    5: .same(proto: "input"),
    6: .same(proto: "outputs"),
    7: .standard(proto: "suppress_output"),
  ]

  fileprivate class _StorageClass {
    var _id: String = String()
    var _status: Clarifai_Api_Status_Status? = nil
    var _createdAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _input: Clarifai_Api_Input? = nil
    var _outputs: [Clarifai_Api_Output] = []
    var _suppressOutput: Bool = false

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _id = source._id
      _status = source._status
      _createdAt = source._createdAt
      _input = source._input
      _outputs = source._outputs
      _suppressOutput = source._suppressOutput
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._id) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._status) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._createdAt) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._input) }()
        case 6: try { try decoder.decodeRepeatedMessageField(value: &_storage._outputs) }()
        case 7: try { try decoder.decodeSingularBoolField(value: &_storage._suppressOutput) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._id.isEmpty {
        try visitor.visitSingularStringField(value: _storage._id, fieldNumber: 1)
      }
      try { if let v = _storage._status {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._createdAt {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._input {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      if !_storage._outputs.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._outputs, fieldNumber: 6)
      }
      if _storage._suppressOutput != false {
        try visitor.visitSingularBoolField(value: _storage._suppressOutput, fieldNumber: 7)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_WorkflowResult, rhs: Clarifai_Api_WorkflowResult) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._id != rhs_storage._id {return false}
        if _storage._status != rhs_storage._status {return false}
        if _storage._createdAt != rhs_storage._createdAt {return false}
        if _storage._input != rhs_storage._input {return false}
        if _storage._outputs != rhs_storage._outputs {return false}
        if _storage._suppressOutput != rhs_storage._suppressOutput {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_WorkflowState: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".WorkflowState"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_WorkflowState, rhs: Clarifai_Api_WorkflowState) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_AppDuplication: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AppDuplication"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    10: .standard(proto: "destination_app"),
    8: .standard(proto: "existing_app_id"),
    2: .standard(proto: "new_app_id"),
    3: .standard(proto: "new_app_name"),
    4: .same(proto: "status"),
    5: .standard(proto: "created_at"),
    6: .standard(proto: "last_modified_at"),
    7: .same(proto: "filter"),
    9: .same(proto: "progress"),
  ]

  fileprivate class _StorageClass {
    var _id: String = String()
    var _destinationApp: Clarifai_Api_App? = nil
    var _existingAppID: String = String()
    var _newAppID: String = String()
    var _newAppName: String = String()
    var _status: Clarifai_Api_Status_Status? = nil
    var _createdAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _lastModifiedAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _filter: Clarifai_Api_AppDuplicationFilters? = nil
    var _progress: [Clarifai_Api_AppCopyProgress] = []

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _id = source._id
      _destinationApp = source._destinationApp
      _existingAppID = source._existingAppID
      _newAppID = source._newAppID
      _newAppName = source._newAppName
      _status = source._status
      _createdAt = source._createdAt
      _lastModifiedAt = source._lastModifiedAt
      _filter = source._filter
      _progress = source._progress
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._id) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._newAppID) }()
        case 3: try { try decoder.decodeSingularStringField(value: &_storage._newAppName) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._status) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._createdAt) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._lastModifiedAt) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._filter) }()
        case 8: try { try decoder.decodeSingularStringField(value: &_storage._existingAppID) }()
        case 9: try { try decoder.decodeRepeatedMessageField(value: &_storage._progress) }()
        case 10: try { try decoder.decodeSingularMessageField(value: &_storage._destinationApp) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._id.isEmpty {
        try visitor.visitSingularStringField(value: _storage._id, fieldNumber: 1)
      }
      if !_storage._newAppID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._newAppID, fieldNumber: 2)
      }
      if !_storage._newAppName.isEmpty {
        try visitor.visitSingularStringField(value: _storage._newAppName, fieldNumber: 3)
      }
      try { if let v = _storage._status {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._createdAt {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._lastModifiedAt {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
      try { if let v = _storage._filter {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      } }()
      if !_storage._existingAppID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._existingAppID, fieldNumber: 8)
      }
      if !_storage._progress.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._progress, fieldNumber: 9)
      }
      try { if let v = _storage._destinationApp {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_AppDuplication, rhs: Clarifai_Api_AppDuplication) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._id != rhs_storage._id {return false}
        if _storage._destinationApp != rhs_storage._destinationApp {return false}
        if _storage._existingAppID != rhs_storage._existingAppID {return false}
        if _storage._newAppID != rhs_storage._newAppID {return false}
        if _storage._newAppName != rhs_storage._newAppName {return false}
        if _storage._status != rhs_storage._status {return false}
        if _storage._createdAt != rhs_storage._createdAt {return false}
        if _storage._lastModifiedAt != rhs_storage._lastModifiedAt {return false}
        if _storage._filter != rhs_storage._filter {return false}
        if _storage._progress != rhs_storage._progress {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_AppCopyProgress: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AppCopyProgress"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "field"),
    2: .same(proto: "value"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.field) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.value) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.field.isEmpty {
      try visitor.visitSingularStringField(value: self.field, fieldNumber: 1)
    }
    if self.value != 0 {
      try visitor.visitSingularInt32Field(value: self.value, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_AppCopyProgress, rhs: Clarifai_Api_AppCopyProgress) -> Bool {
    if lhs.field != rhs.field {return false}
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_AppDuplicationFilters: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AppDuplicationFilters"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "copy_inputs"),
    2: .standard(proto: "copy_concepts"),
    3: .standard(proto: "copy_annotations"),
    4: .standard(proto: "copy_models"),
    5: .standard(proto: "copy_workflows"),
    6: .standard(proto: "copy_installed_module_versions"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.copyInputs) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.copyConcepts) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.copyAnnotations) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.copyModels) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.copyWorkflows) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self.copyInstalledModuleVersions) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.copyInputs != false {
      try visitor.visitSingularBoolField(value: self.copyInputs, fieldNumber: 1)
    }
    if self.copyConcepts != false {
      try visitor.visitSingularBoolField(value: self.copyConcepts, fieldNumber: 2)
    }
    if self.copyAnnotations != false {
      try visitor.visitSingularBoolField(value: self.copyAnnotations, fieldNumber: 3)
    }
    if self.copyModels != false {
      try visitor.visitSingularBoolField(value: self.copyModels, fieldNumber: 4)
    }
    if self.copyWorkflows != false {
      try visitor.visitSingularBoolField(value: self.copyWorkflows, fieldNumber: 5)
    }
    if self.copyInstalledModuleVersions != false {
      try visitor.visitSingularBoolField(value: self.copyInstalledModuleVersions, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_AppDuplicationFilters, rhs: Clarifai_Api_AppDuplicationFilters) -> Bool {
    if lhs.copyInputs != rhs.copyInputs {return false}
    if lhs.copyConcepts != rhs.copyConcepts {return false}
    if lhs.copyAnnotations != rhs.copyAnnotations {return false}
    if lhs.copyModels != rhs.copyModels {return false}
    if lhs.copyWorkflows != rhs.copyWorkflows {return false}
    if lhs.copyInstalledModuleVersions != rhs.copyInstalledModuleVersions {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_LabelOrder: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LabelOrder"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "name"),
    3: .same(proto: "status"),
    4: .standard(proto: "auto_release"),
    5: .standard(proto: "allow_empty_tag"),
    6: .standard(proto: "desired_fulfill_time"),
    7: .standard(proto: "estimate_fulfill_time"),
    8: .same(proto: "task"),
    9: .standard(proto: "created_at"),
    10: .standard(proto: "modified_at"),
  ]

  fileprivate class _StorageClass {
    var _id: String = String()
    var _name: String = String()
    var _status: Clarifai_Api_Status_Status? = nil
    var _autoRelease: Bool = false
    var _allowEmptyTag: Bool = false
    var _desiredFulfillTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _estimateFulfillTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _task: Clarifai_Api_Task? = nil
    var _createdAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _modifiedAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _id = source._id
      _name = source._name
      _status = source._status
      _autoRelease = source._autoRelease
      _allowEmptyTag = source._allowEmptyTag
      _desiredFulfillTime = source._desiredFulfillTime
      _estimateFulfillTime = source._estimateFulfillTime
      _task = source._task
      _createdAt = source._createdAt
      _modifiedAt = source._modifiedAt
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._id) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._name) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._status) }()
        case 4: try { try decoder.decodeSingularBoolField(value: &_storage._autoRelease) }()
        case 5: try { try decoder.decodeSingularBoolField(value: &_storage._allowEmptyTag) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._desiredFulfillTime) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._estimateFulfillTime) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._task) }()
        case 9: try { try decoder.decodeSingularMessageField(value: &_storage._createdAt) }()
        case 10: try { try decoder.decodeSingularMessageField(value: &_storage._modifiedAt) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._id.isEmpty {
        try visitor.visitSingularStringField(value: _storage._id, fieldNumber: 1)
      }
      if !_storage._name.isEmpty {
        try visitor.visitSingularStringField(value: _storage._name, fieldNumber: 2)
      }
      try { if let v = _storage._status {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      if _storage._autoRelease != false {
        try visitor.visitSingularBoolField(value: _storage._autoRelease, fieldNumber: 4)
      }
      if _storage._allowEmptyTag != false {
        try visitor.visitSingularBoolField(value: _storage._allowEmptyTag, fieldNumber: 5)
      }
      try { if let v = _storage._desiredFulfillTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
      try { if let v = _storage._estimateFulfillTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      } }()
      try { if let v = _storage._task {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      } }()
      try { if let v = _storage._createdAt {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      } }()
      try { if let v = _storage._modifiedAt {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_LabelOrder, rhs: Clarifai_Api_LabelOrder) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._id != rhs_storage._id {return false}
        if _storage._name != rhs_storage._name {return false}
        if _storage._status != rhs_storage._status {return false}
        if _storage._autoRelease != rhs_storage._autoRelease {return false}
        if _storage._allowEmptyTag != rhs_storage._allowEmptyTag {return false}
        if _storage._desiredFulfillTime != rhs_storage._desiredFulfillTime {return false}
        if _storage._estimateFulfillTime != rhs_storage._estimateFulfillTime {return false}
        if _storage._task != rhs_storage._task {return false}
        if _storage._createdAt != rhs_storage._createdAt {return false}
        if _storage._modifiedAt != rhs_storage._modifiedAt {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_Task: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Task"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .standard(proto: "created_at"),
    3: .standard(proto: "modified_at"),
    4: .same(proto: "type"),
    5: .same(proto: "description"),
    6: .same(proto: "worker"),
    7: .standard(proto: "concept_ids"),
    8: .standard(proto: "input_source"),
    9: .standard(proto: "sample_ms"),
    10: .standard(proto: "ai_assistant"),
    11: .same(proto: "review"),
    12: .same(proto: "status"),
    13: .same(proto: "name"),
    14: .standard(proto: "ai_assist_params"),
    15: .same(proto: "visibility"),
    16: .standard(proto: "app_id"),
    17: .standard(proto: "user_id"),
    18: .standard(proto: "label_order_id"),
    19: .same(proto: "concepts"),
    20: .standard(proto: "delete_previous_annotations"),
    21: .same(proto: "metrics"),
    23: .same(proto: "priority"),
    24: .same(proto: "metadata"),
  ]

  fileprivate class _StorageClass {
    var _id: String = String()
    var _createdAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _modifiedAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _type: Clarifai_Api_Task.TaskType = .typeNotSet
    var _description_p: String = String()
    var _worker: Clarifai_Api_TaskWorker? = nil
    var _conceptIds: [String] = []
    var _inputSource: Clarifai_Api_TaskInputSource? = nil
    var _sampleMs: UInt32 = 0
    var _aiAssistant: Clarifai_Api_TaskAIAssistant? = nil
    var _review: Clarifai_Api_TaskReview? = nil
    var _status: Clarifai_Api_Status_Status? = nil
    var _name: String = String()
    var _aiAssistParams: Clarifai_Api_AiAssistParameters? = nil
    var _visibility: Clarifai_Api_Visibility? = nil
    var _appID: String = String()
    var _userID: String = String()
    var _labelOrderID: String = String()
    var _concepts: [Clarifai_Api_TaskConcept] = []
    var _deletePreviousAnnotations: Bool = false
    var _metrics: Clarifai_Api_TaskMetrics? = nil
    var _priority: Clarifai_Api_Task.TaskPriority = .notSet
    var _metadata: SwiftProtobuf.Google_Protobuf_Struct? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _id = source._id
      _createdAt = source._createdAt
      _modifiedAt = source._modifiedAt
      _type = source._type
      _description_p = source._description_p
      _worker = source._worker
      _conceptIds = source._conceptIds
      _inputSource = source._inputSource
      _sampleMs = source._sampleMs
      _aiAssistant = source._aiAssistant
      _review = source._review
      _status = source._status
      _name = source._name
      _aiAssistParams = source._aiAssistParams
      _visibility = source._visibility
      _appID = source._appID
      _userID = source._userID
      _labelOrderID = source._labelOrderID
      _concepts = source._concepts
      _deletePreviousAnnotations = source._deletePreviousAnnotations
      _metrics = source._metrics
      _priority = source._priority
      _metadata = source._metadata
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._id) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._createdAt) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._modifiedAt) }()
        case 4: try { try decoder.decodeSingularEnumField(value: &_storage._type) }()
        case 5: try { try decoder.decodeSingularStringField(value: &_storage._description_p) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._worker) }()
        case 7: try { try decoder.decodeRepeatedStringField(value: &_storage._conceptIds) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._inputSource) }()
        case 9: try { try decoder.decodeSingularUInt32Field(value: &_storage._sampleMs) }()
        case 10: try { try decoder.decodeSingularMessageField(value: &_storage._aiAssistant) }()
        case 11: try { try decoder.decodeSingularMessageField(value: &_storage._review) }()
        case 12: try { try decoder.decodeSingularMessageField(value: &_storage._status) }()
        case 13: try { try decoder.decodeSingularStringField(value: &_storage._name) }()
        case 14: try { try decoder.decodeSingularMessageField(value: &_storage._aiAssistParams) }()
        case 15: try { try decoder.decodeSingularMessageField(value: &_storage._visibility) }()
        case 16: try { try decoder.decodeSingularStringField(value: &_storage._appID) }()
        case 17: try { try decoder.decodeSingularStringField(value: &_storage._userID) }()
        case 18: try { try decoder.decodeSingularStringField(value: &_storage._labelOrderID) }()
        case 19: try { try decoder.decodeRepeatedMessageField(value: &_storage._concepts) }()
        case 20: try { try decoder.decodeSingularBoolField(value: &_storage._deletePreviousAnnotations) }()
        case 21: try { try decoder.decodeSingularMessageField(value: &_storage._metrics) }()
        case 23: try { try decoder.decodeSingularEnumField(value: &_storage._priority) }()
        case 24: try { try decoder.decodeSingularMessageField(value: &_storage._metadata) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._id.isEmpty {
        try visitor.visitSingularStringField(value: _storage._id, fieldNumber: 1)
      }
      try { if let v = _storage._createdAt {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._modifiedAt {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      if _storage._type != .typeNotSet {
        try visitor.visitSingularEnumField(value: _storage._type, fieldNumber: 4)
      }
      if !_storage._description_p.isEmpty {
        try visitor.visitSingularStringField(value: _storage._description_p, fieldNumber: 5)
      }
      try { if let v = _storage._worker {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
      if !_storage._conceptIds.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._conceptIds, fieldNumber: 7)
      }
      try { if let v = _storage._inputSource {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      } }()
      if _storage._sampleMs != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._sampleMs, fieldNumber: 9)
      }
      try { if let v = _storage._aiAssistant {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      } }()
      try { if let v = _storage._review {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      } }()
      try { if let v = _storage._status {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
      } }()
      if !_storage._name.isEmpty {
        try visitor.visitSingularStringField(value: _storage._name, fieldNumber: 13)
      }
      try { if let v = _storage._aiAssistParams {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
      } }()
      try { if let v = _storage._visibility {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
      } }()
      if !_storage._appID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._appID, fieldNumber: 16)
      }
      if !_storage._userID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._userID, fieldNumber: 17)
      }
      if !_storage._labelOrderID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._labelOrderID, fieldNumber: 18)
      }
      if !_storage._concepts.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._concepts, fieldNumber: 19)
      }
      if _storage._deletePreviousAnnotations != false {
        try visitor.visitSingularBoolField(value: _storage._deletePreviousAnnotations, fieldNumber: 20)
      }
      try { if let v = _storage._metrics {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 21)
      } }()
      if _storage._priority != .notSet {
        try visitor.visitSingularEnumField(value: _storage._priority, fieldNumber: 23)
      }
      try { if let v = _storage._metadata {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 24)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_Task, rhs: Clarifai_Api_Task) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._id != rhs_storage._id {return false}
        if _storage._createdAt != rhs_storage._createdAt {return false}
        if _storage._modifiedAt != rhs_storage._modifiedAt {return false}
        if _storage._type != rhs_storage._type {return false}
        if _storage._description_p != rhs_storage._description_p {return false}
        if _storage._worker != rhs_storage._worker {return false}
        if _storage._conceptIds != rhs_storage._conceptIds {return false}
        if _storage._inputSource != rhs_storage._inputSource {return false}
        if _storage._sampleMs != rhs_storage._sampleMs {return false}
        if _storage._aiAssistant != rhs_storage._aiAssistant {return false}
        if _storage._review != rhs_storage._review {return false}
        if _storage._status != rhs_storage._status {return false}
        if _storage._name != rhs_storage._name {return false}
        if _storage._aiAssistParams != rhs_storage._aiAssistParams {return false}
        if _storage._visibility != rhs_storage._visibility {return false}
        if _storage._appID != rhs_storage._appID {return false}
        if _storage._userID != rhs_storage._userID {return false}
        if _storage._labelOrderID != rhs_storage._labelOrderID {return false}
        if _storage._concepts != rhs_storage._concepts {return false}
        if _storage._deletePreviousAnnotations != rhs_storage._deletePreviousAnnotations {return false}
        if _storage._metrics != rhs_storage._metrics {return false}
        if _storage._priority != rhs_storage._priority {return false}
        if _storage._metadata != rhs_storage._metadata {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_Task.TaskType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "TYPE_NOT_SET"),
    1: .same(proto: "CONCEPTS_CLASSIFICATION"),
    2: .same(proto: "BOUNDING_BOX_DETECTION"),
    3: .same(proto: "POLYGON_DETECTION"),
  ]
}

extension Clarifai_Api_Task.TaskPriority: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "TASK_PRIORITY_NOT_SET"),
    1: .same(proto: "LOW"),
    2: .same(proto: "MEDIUM"),
    3: .same(proto: "HIGH"),
  ]
}

extension Clarifai_Api_AiAssistParameters: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AiAssistParameters"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "min_threshold"),
    2: .standard(proto: "max_threshold"),
    3: .standard(proto: "concept_relation_ids"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFloatField(value: &self.minThreshold) }()
      case 2: try { try decoder.decodeSingularFloatField(value: &self.maxThreshold) }()
      case 3: try { try decoder.decodeRepeatedStringField(value: &self.conceptRelationIds) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.minThreshold != 0 {
      try visitor.visitSingularFloatField(value: self.minThreshold, fieldNumber: 1)
    }
    if self.maxThreshold != 0 {
      try visitor.visitSingularFloatField(value: self.maxThreshold, fieldNumber: 2)
    }
    if !self.conceptRelationIds.isEmpty {
      try visitor.visitRepeatedStringField(value: self.conceptRelationIds, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_AiAssistParameters, rhs: Clarifai_Api_AiAssistParameters) -> Bool {
    if lhs.minThreshold != rhs.minThreshold {return false}
    if lhs.maxThreshold != rhs.maxThreshold {return false}
    if lhs.conceptRelationIds != rhs.conceptRelationIds {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_TaskWorker: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TaskWorker"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "strategy"),
    2: .standard(proto: "user_ids"),
    4: .same(proto: "users"),
    3: .standard(proto: "partitioned_strategy_info"),
    7: .same(proto: "workers"),
    8: .same(proto: "type"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.strategy) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.userIds) }()
      case 3: try {
        var v: Clarifai_Api_TaskWorkerPartitionedStrategyInfo?
        var hadOneofValue = false
        if let current = self.strategyInfo {
          hadOneofValue = true
          if case .partitionedStrategyInfo(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.strategyInfo = .partitionedStrategyInfo(v)
        }
      }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.users) }()
      case 7: try { try decoder.decodeRepeatedMessageField(value: &self.workers) }()
      case 8: try { try decoder.decodeSingularEnumField(value: &self.type) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.strategy != .workerStrategyNotSet {
      try visitor.visitSingularEnumField(value: self.strategy, fieldNumber: 1)
    }
    if !self.userIds.isEmpty {
      try visitor.visitRepeatedStringField(value: self.userIds, fieldNumber: 2)
    }
    try { if case .partitionedStrategyInfo(let v)? = self.strategyInfo {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if !self.users.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.users, fieldNumber: 4)
    }
    if !self.workers.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.workers, fieldNumber: 7)
    }
    if self.type != .notSet {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_TaskWorker, rhs: Clarifai_Api_TaskWorker) -> Bool {
    if lhs.strategy != rhs.strategy {return false}
    if lhs.userIds != rhs.userIds {return false}
    if lhs.users != rhs.users {return false}
    if lhs.strategyInfo != rhs.strategyInfo {return false}
    if lhs.workers != rhs.workers {return false}
    if lhs.type != rhs.type {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_TaskWorker.TaskWorkerStrategy: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "WORKER_STRATEGY_NOT_SET"),
    2: .same(proto: "PARTITIONED"),
    3: .same(proto: "FULL"),
    4: .same(proto: "DYNAMIC"),
  ]
}

extension Clarifai_Api_TaskWorker.WorkerType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "WORKER_TYPE_NOT_SET"),
    1: .same(proto: "WORKER_HUMAN"),
    2: .same(proto: "WORKER_AUTO"),
  ]
}

extension Clarifai_Api_TaskWorkerPartitionedStrategyInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TaskWorkerPartitionedStrategyInfo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .standard(proto: "workers_per_input"),
    3: .same(proto: "weights"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.type) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.workersPerInput) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._weights) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.type != .partitionedWorkerStrategyNotSet {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 1)
    }
    if self.workersPerInput != 0 {
      try visitor.visitSingularInt32Field(value: self.workersPerInput, fieldNumber: 2)
    }
    try { if let v = self._weights {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_TaskWorkerPartitionedStrategyInfo, rhs: Clarifai_Api_TaskWorkerPartitionedStrategyInfo) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.workersPerInput != rhs.workersPerInput {return false}
    if lhs._weights != rhs._weights {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_TaskWorkerPartitionedStrategyInfo.TaskWorkerPartitionedStrategy: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "PARTITIONED_WORKER_STRATEGY_NOT_SET"),
    1: .same(proto: "EVENLY"),
    2: .same(proto: "WEIGHTED"),
  ]
}

extension Clarifai_Api_TaskInputSource: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TaskInputSource"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .same(proto: "id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.type) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.id) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.type != .inputSourceTypeNotSet {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 1)
    }
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_TaskInputSource, rhs: Clarifai_Api_TaskInputSource) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.id != rhs.id {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_TaskInputSource.TaskInputSourceType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "INPUT_SOURCE_TYPE_NOT_SET"),
    1: .same(proto: "ALL_INPUTS"),
    2: .same(proto: "SAVED_SEARCH"),
    3: .same(proto: "DATASET"),
  ]
}

extension Clarifai_Api_TaskReview: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TaskReview"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "strategy"),
    2: .standard(proto: "user_ids"),
    5: .same(proto: "users"),
    3: .standard(proto: "manual_strategy_info"),
    4: .standard(proto: "consensus_strategy_info"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.strategy) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.userIds) }()
      case 3: try {
        var v: Clarifai_Api_TaskReviewManualStrategyInfo?
        var hadOneofValue = false
        if let current = self.strategyInfo {
          hadOneofValue = true
          if case .manualStrategyInfo(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.strategyInfo = .manualStrategyInfo(v)
        }
      }()
      case 4: try {
        var v: Clarifai_Api_TaskReviewConsensusStrategyInfo?
        var hadOneofValue = false
        if let current = self.strategyInfo {
          hadOneofValue = true
          if case .consensusStrategyInfo(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.strategyInfo = .consensusStrategyInfo(v)
        }
      }()
      case 5: try { try decoder.decodeRepeatedMessageField(value: &self.users) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.strategy != .notSet {
      try visitor.visitSingularEnumField(value: self.strategy, fieldNumber: 1)
    }
    if !self.userIds.isEmpty {
      try visitor.visitRepeatedStringField(value: self.userIds, fieldNumber: 2)
    }
    switch self.strategyInfo {
    case .manualStrategyInfo?: try {
      guard case .manualStrategyInfo(let v)? = self.strategyInfo else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .consensusStrategyInfo?: try {
      guard case .consensusStrategyInfo(let v)? = self.strategyInfo else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case nil: break
    }
    if !self.users.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.users, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_TaskReview, rhs: Clarifai_Api_TaskReview) -> Bool {
    if lhs.strategy != rhs.strategy {return false}
    if lhs.userIds != rhs.userIds {return false}
    if lhs.users != rhs.users {return false}
    if lhs.strategyInfo != rhs.strategyInfo {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_TaskReview.TaskReviewStrategy: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "TASK_REVIEW_STRATEGY_NOT_SET"),
    1: .same(proto: "NONE"),
    2: .same(proto: "MANUAL"),
    3: .same(proto: "CONSENSUS"),
  ]
}

extension Clarifai_Api_TaskReviewManualStrategyInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TaskReviewManualStrategyInfo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "sample_percentage"),
    2: .standard(proto: "approval_threshold"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFloatField(value: &self.samplePercentage) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.approvalThreshold) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.samplePercentage != 0 {
      try visitor.visitSingularFloatField(value: self.samplePercentage, fieldNumber: 1)
    }
    if self.approvalThreshold != 0 {
      try visitor.visitSingularInt32Field(value: self.approvalThreshold, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_TaskReviewManualStrategyInfo, rhs: Clarifai_Api_TaskReviewManualStrategyInfo) -> Bool {
    if lhs.samplePercentage != rhs.samplePercentage {return false}
    if lhs.approvalThreshold != rhs.approvalThreshold {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_TaskReviewConsensusStrategyInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TaskReviewConsensusStrategyInfo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .standard(proto: "approval_threshold"),
    3: .standard(proto: "approval_threshold_labelers"),
    4: .standard(proto: "approval_threshold_reviewers"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.approvalThreshold) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.approvalThresholdLabelers) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.approvalThresholdReviewers) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.approvalThreshold != 0 {
      try visitor.visitSingularUInt32Field(value: self.approvalThreshold, fieldNumber: 2)
    }
    if self.approvalThresholdLabelers != 0 {
      try visitor.visitSingularUInt32Field(value: self.approvalThresholdLabelers, fieldNumber: 3)
    }
    if self.approvalThresholdReviewers != 0 {
      try visitor.visitSingularInt32Field(value: self.approvalThresholdReviewers, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_TaskReviewConsensusStrategyInfo, rhs: Clarifai_Api_TaskReviewConsensusStrategyInfo) -> Bool {
    if lhs.approvalThreshold != rhs.approvalThreshold {return false}
    if lhs.approvalThresholdLabelers != rhs.approvalThresholdLabelers {return false}
    if lhs.approvalThresholdReviewers != rhs.approvalThresholdReviewers {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_TaskAIAssistant: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TaskAIAssistant"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "workflow_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.workflowID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.workflowID.isEmpty {
      try visitor.visitSingularStringField(value: self.workflowID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_TaskAIAssistant, rhs: Clarifai_Api_TaskAIAssistant) -> Bool {
    if lhs.workflowID != rhs.workflowID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_TaskAssignment: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TaskAssignment"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .standard(proto: "created_at"),
    3: .standard(proto: "modified_at"),
    4: .same(proto: "worker"),
    5: .same(proto: "input"),
    6: .same(proto: "status"),
  ]

  fileprivate class _StorageClass {
    var _id: String = String()
    var _createdAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _modifiedAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _worker: Clarifai_Api_Worker? = nil
    var _input: Clarifai_Api_Input? = nil
    var _status: Clarifai_Api_Status_Status? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _id = source._id
      _createdAt = source._createdAt
      _modifiedAt = source._modifiedAt
      _worker = source._worker
      _input = source._input
      _status = source._status
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._id) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._createdAt) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._modifiedAt) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._worker) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._input) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._status) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._id.isEmpty {
        try visitor.visitSingularStringField(value: _storage._id, fieldNumber: 1)
      }
      try { if let v = _storage._createdAt {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._modifiedAt {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._worker {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._input {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._status {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_TaskAssignment, rhs: Clarifai_Api_TaskAssignment) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._id != rhs_storage._id {return false}
        if _storage._createdAt != rhs_storage._createdAt {return false}
        if _storage._modifiedAt != rhs_storage._modifiedAt {return false}
        if _storage._worker != rhs_storage._worker {return false}
        if _storage._input != rhs_storage._input {return false}
        if _storage._status != rhs_storage._status {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_TaskStatusCountPerUser: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TaskStatusCountPerUser"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_id"),
    2: .same(proto: "pending"),
    3: .standard(proto: "awaiting_review"),
    4: .same(proto: "success"),
    5: .standard(proto: "review_denied"),
    6: .standard(proto: "awaiting_consensus_review"),
    7: .same(proto: "worker"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.userID) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.pending) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.awaitingReview) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self.success) }()
      case 5: try { try decoder.decodeSingularUInt32Field(value: &self.reviewDenied) }()
      case 6: try { try decoder.decodeSingularUInt32Field(value: &self.awaitingConsensusReview) }()
      case 7: try { try decoder.decodeSingularMessageField(value: &self._worker) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.userID.isEmpty {
      try visitor.visitSingularStringField(value: self.userID, fieldNumber: 1)
    }
    if self.pending != 0 {
      try visitor.visitSingularUInt32Field(value: self.pending, fieldNumber: 2)
    }
    if self.awaitingReview != 0 {
      try visitor.visitSingularUInt32Field(value: self.awaitingReview, fieldNumber: 3)
    }
    if self.success != 0 {
      try visitor.visitSingularUInt32Field(value: self.success, fieldNumber: 4)
    }
    if self.reviewDenied != 0 {
      try visitor.visitSingularUInt32Field(value: self.reviewDenied, fieldNumber: 5)
    }
    if self.awaitingConsensusReview != 0 {
      try visitor.visitSingularUInt32Field(value: self.awaitingConsensusReview, fieldNumber: 6)
    }
    try { if let v = self._worker {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_TaskStatusCountPerUser, rhs: Clarifai_Api_TaskStatusCountPerUser) -> Bool {
    if lhs.userID != rhs.userID {return false}
    if lhs.pending != rhs.pending {return false}
    if lhs.awaitingReview != rhs.awaitingReview {return false}
    if lhs.success != rhs.success {return false}
    if lhs.reviewDenied != rhs.reviewDenied {return false}
    if lhs.awaitingConsensusReview != rhs.awaitingConsensusReview {return false}
    if lhs._worker != rhs._worker {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_ThresholdRange: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ThresholdRange"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "is_lower_inclusive"),
    2: .standard(proto: "is_upper_inclusive"),
    3: .same(proto: "lower"),
    4: .same(proto: "upper"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.isLowerInclusive) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.isUpperInclusive) }()
      case 3: try { try decoder.decodeSingularFloatField(value: &self.lower) }()
      case 4: try { try decoder.decodeSingularFloatField(value: &self.upper) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.isLowerInclusive != false {
      try visitor.visitSingularBoolField(value: self.isLowerInclusive, fieldNumber: 1)
    }
    if self.isUpperInclusive != false {
      try visitor.visitSingularBoolField(value: self.isUpperInclusive, fieldNumber: 2)
    }
    if self.lower != 0 {
      try visitor.visitSingularFloatField(value: self.lower, fieldNumber: 3)
    }
    if self.upper != 0 {
      try visitor.visitSingularFloatField(value: self.upper, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_ThresholdRange, rhs: Clarifai_Api_ThresholdRange) -> Bool {
    if lhs.isLowerInclusive != rhs.isLowerInclusive {return false}
    if lhs.isUpperInclusive != rhs.isUpperInclusive {return false}
    if lhs.lower != rhs.lower {return false}
    if lhs.upper != rhs.upper {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_TaskConceptAutoAnnotationConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TaskConceptAutoAnnotationConfig"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "annotation_data_types"),
    2: .standard(proto: "threshold_range"),
    3: .standard(proto: "status_code"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.annotationDataTypes) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._thresholdRange) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.statusCode) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.annotationDataTypes != 0 {
      try visitor.visitSingularUInt32Field(value: self.annotationDataTypes, fieldNumber: 1)
    }
    try { if let v = self._thresholdRange {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if self.statusCode != .zero {
      try visitor.visitSingularEnumField(value: self.statusCode, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_TaskConceptAutoAnnotationConfig, rhs: Clarifai_Api_TaskConceptAutoAnnotationConfig) -> Bool {
    if lhs.annotationDataTypes != rhs.annotationDataTypes {return false}
    if lhs._thresholdRange != rhs._thresholdRange {return false}
    if lhs.statusCode != rhs.statusCode {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_TaskConcept: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TaskConcept"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "concept"),
    2: .standard(proto: "auto_annotation_config"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._concept) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._autoAnnotationConfig) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._concept {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._autoAnnotationConfig {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_TaskConcept, rhs: Clarifai_Api_TaskConcept) -> Bool {
    if lhs._concept != rhs._concept {return false}
    if lhs._autoAnnotationConfig != rhs._autoAnnotationConfig {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_TaskMetrics: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TaskMetrics"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .same(proto: "work"),
    3: .same(proto: "review"),
    4: .standard(proto: "input_source"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeSingularMessageField(value: &self._work) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._review) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._inputSource) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._work {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._review {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._inputSource {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_TaskMetrics, rhs: Clarifai_Api_TaskMetrics) -> Bool {
    if lhs._work != rhs._work {return false}
    if lhs._review != rhs._review {return false}
    if lhs._inputSource != rhs._inputSource {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_TaskWorkMetrics: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TaskWorkMetrics"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "inputs_count_estimated"),
    2: .standard(proto: "inputs_percent_estimated"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.inputsCountEstimated) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.inputsPercentEstimated) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.inputsCountEstimated != 0 {
      try visitor.visitSingularUInt64Field(value: self.inputsCountEstimated, fieldNumber: 1)
    }
    if self.inputsPercentEstimated != 0 {
      try visitor.visitSingularUInt32Field(value: self.inputsPercentEstimated, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_TaskWorkMetrics, rhs: Clarifai_Api_TaskWorkMetrics) -> Bool {
    if lhs.inputsCountEstimated != rhs.inputsCountEstimated {return false}
    if lhs.inputsPercentEstimated != rhs.inputsPercentEstimated {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_TaskReviewMetrics: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TaskReviewMetrics"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "inputs_count_estimated"),
    2: .standard(proto: "inputs_percent_estimated"),
    3: .standard(proto: "inputs_count_estimated_per_reviewer"),
    4: .standard(proto: "inputs_reviewable_count_estimated_per_reviewer"),
    5: .standard(proto: "inputs_percent_estimated_per_reviewer"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.inputsCountEstimated) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.inputsPercentEstimated) }()
      case 3: try { try decoder.decodeRepeatedUInt64Field(value: &self.inputsCountEstimatedPerReviewer) }()
      case 4: try { try decoder.decodeRepeatedUInt64Field(value: &self.inputsReviewableCountEstimatedPerReviewer) }()
      case 5: try { try decoder.decodeRepeatedUInt32Field(value: &self.inputsPercentEstimatedPerReviewer) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.inputsCountEstimated != 0 {
      try visitor.visitSingularUInt64Field(value: self.inputsCountEstimated, fieldNumber: 1)
    }
    if self.inputsPercentEstimated != 0 {
      try visitor.visitSingularUInt32Field(value: self.inputsPercentEstimated, fieldNumber: 2)
    }
    if !self.inputsCountEstimatedPerReviewer.isEmpty {
      try visitor.visitPackedUInt64Field(value: self.inputsCountEstimatedPerReviewer, fieldNumber: 3)
    }
    if !self.inputsReviewableCountEstimatedPerReviewer.isEmpty {
      try visitor.visitPackedUInt64Field(value: self.inputsReviewableCountEstimatedPerReviewer, fieldNumber: 4)
    }
    if !self.inputsPercentEstimatedPerReviewer.isEmpty {
      try visitor.visitPackedUInt32Field(value: self.inputsPercentEstimatedPerReviewer, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_TaskReviewMetrics, rhs: Clarifai_Api_TaskReviewMetrics) -> Bool {
    if lhs.inputsCountEstimated != rhs.inputsCountEstimated {return false}
    if lhs.inputsPercentEstimated != rhs.inputsPercentEstimated {return false}
    if lhs.inputsCountEstimatedPerReviewer != rhs.inputsCountEstimatedPerReviewer {return false}
    if lhs.inputsReviewableCountEstimatedPerReviewer != rhs.inputsReviewableCountEstimatedPerReviewer {return false}
    if lhs.inputsPercentEstimatedPerReviewer != rhs.inputsPercentEstimatedPerReviewer {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_TaskInputSourceMetrics: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TaskInputSourceMetrics"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "inputs_count_estimated"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.inputsCountEstimated) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.inputsCountEstimated != 0 {
      try visitor.visitSingularUInt64Field(value: self.inputsCountEstimated, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_TaskInputSourceMetrics, rhs: Clarifai_Api_TaskInputSourceMetrics) -> Bool {
    if lhs.inputsCountEstimated != rhs.inputsCountEstimated {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_Role: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Role"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .standard(proto: "created_at"),
    3: .standard(proto: "modified_at"),
    4: .same(proto: "name"),
    5: .same(proto: "description"),
    6: .same(proto: "scopes"),
    7: .same(proto: "endpoints"),
    8: .same(proto: "type"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._createdAt) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._modifiedAt) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      case 6: try { try decoder.decodeRepeatedStringField(value: &self.scopes) }()
      case 7: try { try decoder.decodeRepeatedStringField(value: &self.endpoints) }()
      case 8: try { try decoder.decodeSingularEnumField(value: &self.type) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    try { if let v = self._createdAt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._modifiedAt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 4)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 5)
    }
    if !self.scopes.isEmpty {
      try visitor.visitRepeatedStringField(value: self.scopes, fieldNumber: 6)
    }
    if !self.endpoints.isEmpty {
      try visitor.visitRepeatedStringField(value: self.endpoints, fieldNumber: 7)
    }
    if self.type != .team {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_Role, rhs: Clarifai_Api_Role) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs._createdAt != rhs._createdAt {return false}
    if lhs._modifiedAt != rhs._modifiedAt {return false}
    if lhs.name != rhs.name {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.scopes != rhs.scopes {return false}
    if lhs.endpoints != rhs.endpoints {return false}
    if lhs.type != rhs.type {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_Team: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Team"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .standard(proto: "created_at"),
    3: .standard(proto: "modified_at"),
    4: .same(proto: "name"),
    5: .standard(proto: "default_role_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._createdAt) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._modifiedAt) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.defaultRoleID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    try { if let v = self._createdAt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._modifiedAt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 4)
    }
    if !self.defaultRoleID.isEmpty {
      try visitor.visitSingularStringField(value: self.defaultRoleID, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_Team, rhs: Clarifai_Api_Team) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs._createdAt != rhs._createdAt {return false}
    if lhs._modifiedAt != rhs._modifiedAt {return false}
    if lhs.name != rhs.name {return false}
    if lhs.defaultRoleID != rhs.defaultRoleID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_Collector: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Collector"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "description"),
    3: .standard(proto: "created_at"),
    4: .standard(proto: "pre_queue_workflow_id"),
    8: .standard(proto: "pre_queue_random_sample"),
    5: .standard(proto: "post_queue_workflow_id"),
    6: .standard(proto: "collector_source"),
    7: .same(proto: "status"),
    9: .standard(proto: "collect_outputs"),
  ]

  fileprivate class _StorageClass {
    var _id: String = String()
    var _description_p: String = String()
    var _createdAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _preQueueWorkflowID: String = String()
    var _preQueueRandomSample: Float = 0
    var _postQueueWorkflowID: String = String()
    var _collectorSource: Clarifai_Api_CollectorSource? = nil
    var _status: Clarifai_Api_Status_Status? = nil
    var _collectOutputs: Bool = false

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _id = source._id
      _description_p = source._description_p
      _createdAt = source._createdAt
      _preQueueWorkflowID = source._preQueueWorkflowID
      _preQueueRandomSample = source._preQueueRandomSample
      _postQueueWorkflowID = source._postQueueWorkflowID
      _collectorSource = source._collectorSource
      _status = source._status
      _collectOutputs = source._collectOutputs
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._id) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._description_p) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._createdAt) }()
        case 4: try { try decoder.decodeSingularStringField(value: &_storage._preQueueWorkflowID) }()
        case 5: try { try decoder.decodeSingularStringField(value: &_storage._postQueueWorkflowID) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._collectorSource) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._status) }()
        case 8: try { try decoder.decodeSingularFloatField(value: &_storage._preQueueRandomSample) }()
        case 9: try { try decoder.decodeSingularBoolField(value: &_storage._collectOutputs) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._id.isEmpty {
        try visitor.visitSingularStringField(value: _storage._id, fieldNumber: 1)
      }
      if !_storage._description_p.isEmpty {
        try visitor.visitSingularStringField(value: _storage._description_p, fieldNumber: 2)
      }
      try { if let v = _storage._createdAt {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      if !_storage._preQueueWorkflowID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._preQueueWorkflowID, fieldNumber: 4)
      }
      if !_storage._postQueueWorkflowID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._postQueueWorkflowID, fieldNumber: 5)
      }
      try { if let v = _storage._collectorSource {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
      try { if let v = _storage._status {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      } }()
      if _storage._preQueueRandomSample != 0 {
        try visitor.visitSingularFloatField(value: _storage._preQueueRandomSample, fieldNumber: 8)
      }
      if _storage._collectOutputs != false {
        try visitor.visitSingularBoolField(value: _storage._collectOutputs, fieldNumber: 9)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_Collector, rhs: Clarifai_Api_Collector) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._id != rhs_storage._id {return false}
        if _storage._description_p != rhs_storage._description_p {return false}
        if _storage._createdAt != rhs_storage._createdAt {return false}
        if _storage._preQueueWorkflowID != rhs_storage._preQueueWorkflowID {return false}
        if _storage._preQueueRandomSample != rhs_storage._preQueueRandomSample {return false}
        if _storage._postQueueWorkflowID != rhs_storage._postQueueWorkflowID {return false}
        if _storage._collectorSource != rhs_storage._collectorSource {return false}
        if _storage._status != rhs_storage._status {return false}
        if _storage._collectOutputs != rhs_storage._collectOutputs {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_CollectorSource: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CollectorSource"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .standard(proto: "api_post_model_outputs_collector_source"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeSingularMessageField(value: &self._apiPostModelOutputsCollectorSource) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._apiPostModelOutputsCollectorSource {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_CollectorSource, rhs: Clarifai_Api_CollectorSource) -> Bool {
    if lhs._apiPostModelOutputsCollectorSource != rhs._apiPostModelOutputsCollectorSource {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_APIPostModelOutputsCollectorSource: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".APIPostModelOutputsCollectorSource"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "model_user_id"),
    2: .standard(proto: "model_app_id"),
    3: .standard(proto: "model_id"),
    4: .standard(proto: "model_version_id"),
    5: .standard(proto: "post_inputs_key_id"),
    6: .standard(proto: "caller_user_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.modelUserID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.modelAppID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.modelID) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.modelVersionID) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.postInputsKeyID) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.callerUserID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.modelUserID.isEmpty {
      try visitor.visitSingularStringField(value: self.modelUserID, fieldNumber: 1)
    }
    if !self.modelAppID.isEmpty {
      try visitor.visitSingularStringField(value: self.modelAppID, fieldNumber: 2)
    }
    if !self.modelID.isEmpty {
      try visitor.visitSingularStringField(value: self.modelID, fieldNumber: 3)
    }
    if !self.modelVersionID.isEmpty {
      try visitor.visitSingularStringField(value: self.modelVersionID, fieldNumber: 4)
    }
    if !self.postInputsKeyID.isEmpty {
      try visitor.visitSingularStringField(value: self.postInputsKeyID, fieldNumber: 5)
    }
    if !self.callerUserID.isEmpty {
      try visitor.visitSingularStringField(value: self.callerUserID, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_APIPostModelOutputsCollectorSource, rhs: Clarifai_Api_APIPostModelOutputsCollectorSource) -> Bool {
    if lhs.modelUserID != rhs.modelUserID {return false}
    if lhs.modelAppID != rhs.modelAppID {return false}
    if lhs.modelID != rhs.modelID {return false}
    if lhs.modelVersionID != rhs.modelVersionID {return false}
    if lhs.postInputsKeyID != rhs.postInputsKeyID {return false}
    if lhs.callerUserID != rhs.callerUserID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_StatValue: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".StatValue"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "time"),
    2: .same(proto: "value"),
    3: .same(proto: "tags"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._time) }()
      case 2: try { try decoder.decodeSingularFloatField(value: &self.value) }()
      case 3: try { try decoder.decodeRepeatedStringField(value: &self.tags) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._time {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.value != 0 {
      try visitor.visitSingularFloatField(value: self.value, fieldNumber: 2)
    }
    if !self.tags.isEmpty {
      try visitor.visitRepeatedStringField(value: self.tags, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_StatValue, rhs: Clarifai_Api_StatValue) -> Bool {
    if lhs._time != rhs._time {return false}
    if lhs.value != rhs.value {return false}
    if lhs.tags != rhs.tags {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_StatValueAggregateResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".StatValueAggregateResult"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "stat_value_aggregates"),
    2: .standard(proto: "stat_value_aggregate_query"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.statValueAggregates) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._statValueAggregateQuery) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.statValueAggregates.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.statValueAggregates, fieldNumber: 1)
    }
    try { if let v = self._statValueAggregateQuery {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_StatValueAggregateResult, rhs: Clarifai_Api_StatValueAggregateResult) -> Bool {
    if lhs.statValueAggregates != rhs.statValueAggregates {return false}
    if lhs._statValueAggregateQuery != rhs._statValueAggregateQuery {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_StatValueAggregate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".StatValueAggregate"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "time"),
    2: .standard(proto: "aggregate_value"),
    3: .same(proto: "count"),
    4: .same(proto: "tags"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._time) }()
      case 2: try { try decoder.decodeSingularFloatField(value: &self.aggregateValue) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.count) }()
      case 4: try { try decoder.decodeRepeatedStringField(value: &self.tags) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._time {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.aggregateValue != 0 {
      try visitor.visitSingularFloatField(value: self.aggregateValue, fieldNumber: 2)
    }
    if self.count != 0 {
      try visitor.visitSingularUInt64Field(value: self.count, fieldNumber: 3)
    }
    if !self.tags.isEmpty {
      try visitor.visitRepeatedStringField(value: self.tags, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_StatValueAggregate, rhs: Clarifai_Api_StatValueAggregate) -> Bool {
    if lhs._time != rhs._time {return false}
    if lhs.aggregateValue != rhs.aggregateValue {return false}
    if lhs.count != rhs.count {return false}
    if lhs.tags != rhs.tags {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_StatValueAggregateQuery: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".StatValueAggregateQuery"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "tags"),
    2: .standard(proto: "tag_groups"),
    3: .standard(proto: "stat_value_agg_type"),
    4: .standard(proto: "stat_time_agg_type"),
    5: .standard(proto: "start_time"),
    6: .standard(proto: "end_time"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.tags) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.tagGroups) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.statValueAggType) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self.statTimeAggType) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._startTime) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._endTime) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.tags.isEmpty {
      try visitor.visitRepeatedStringField(value: self.tags, fieldNumber: 1)
    }
    if !self.tagGroups.isEmpty {
      try visitor.visitRepeatedStringField(value: self.tagGroups, fieldNumber: 2)
    }
    if self.statValueAggType != .sum {
      try visitor.visitSingularEnumField(value: self.statValueAggType, fieldNumber: 3)
    }
    if self.statTimeAggType != .noTimeAgg {
      try visitor.visitSingularEnumField(value: self.statTimeAggType, fieldNumber: 4)
    }
    try { if let v = self._startTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._endTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_StatValueAggregateQuery, rhs: Clarifai_Api_StatValueAggregateQuery) -> Bool {
    if lhs.tags != rhs.tags {return false}
    if lhs.tagGroups != rhs.tagGroups {return false}
    if lhs.statValueAggType != rhs.statValueAggType {return false}
    if lhs.statTimeAggType != rhs.statTimeAggType {return false}
    if lhs._startTime != rhs._startTime {return false}
    if lhs._endTime != rhs._endTime {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_PCAProjectionComparator: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PCAProjectionComparator"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "distance_threshold"),
    2: .standard(proto: "model_version_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFloatField(value: &self.distanceThreshold) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.modelVersionID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.distanceThreshold != 0 {
      try visitor.visitSingularFloatField(value: self.distanceThreshold, fieldNumber: 1)
    }
    if !self.modelVersionID.isEmpty {
      try visitor.visitSingularStringField(value: self.modelVersionID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_PCAProjectionComparator, rhs: Clarifai_Api_PCAProjectionComparator) -> Bool {
    if lhs.distanceThreshold != rhs.distanceThreshold {return false}
    if lhs.modelVersionID != rhs.modelVersionID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_DuplicateAnnotationsResults: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DuplicateAnnotationsResults"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "duplicate_cfid"),
    2: .standard(proto: "unique_count"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.duplicateCfid) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.uniqueCount) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.duplicateCfid.isEmpty {
      try visitor.visitRepeatedStringField(value: self.duplicateCfid, fieldNumber: 1)
    }
    if self.uniqueCount != 0 {
      try visitor.visitSingularInt32Field(value: self.uniqueCount, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_DuplicateAnnotationsResults, rhs: Clarifai_Api_DuplicateAnnotationsResults) -> Bool {
    if lhs.duplicateCfid != rhs.duplicateCfid {return false}
    if lhs.uniqueCount != rhs.uniqueCount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_Visibility: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Visibility"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "gettable"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.gettable) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.gettable != .unknownVisibility {
      try visitor.visitSingularEnumField(value: self.gettable, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_Visibility, rhs: Clarifai_Api_Visibility) -> Bool {
    if lhs.gettable != rhs.gettable {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_Visibility.Gettable: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN_VISIBILITY"),
    10: .same(proto: "PRIVATE"),
    30: .same(proto: "ORG"),
    50: .same(proto: "PUBLIC"),
  ]
}

extension Clarifai_Api_FullTag: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".FullTag"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.id) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_FullTag, rhs: Clarifai_Api_FullTag) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.id != rhs.id {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_TimeSegment: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TimeSegment"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "data"),
    3: .standard(proto: "time_info"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._data) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._timeInfo) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    try { if let v = self._data {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._timeInfo {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_TimeSegment, rhs: Clarifai_Api_TimeSegment) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs._data != rhs._data {return false}
    if lhs._timeInfo != rhs._timeInfo {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_TimeInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TimeInfo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "num_frames"),
    4: .standard(proto: "begin_time"),
    5: .standard(proto: "end_time"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.numFrames) }()
      case 4: try { try decoder.decodeSingularFloatField(value: &self.beginTime) }()
      case 5: try { try decoder.decodeSingularFloatField(value: &self.endTime) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.numFrames != 0 {
      try visitor.visitSingularUInt32Field(value: self.numFrames, fieldNumber: 1)
    }
    if self.beginTime != 0 {
      try visitor.visitSingularFloatField(value: self.beginTime, fieldNumber: 4)
    }
    if self.endTime != 0 {
      try visitor.visitSingularFloatField(value: self.endTime, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_TimeInfo, rhs: Clarifai_Api_TimeInfo) -> Bool {
    if lhs.numFrames != rhs.numFrames {return false}
    if lhs.beginTime != rhs.beginTime {return false}
    if lhs.endTime != rhs.endTime {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_DatasetStar: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DatasetStar"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "dataset_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.datasetID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.datasetID.isEmpty {
      try visitor.visitSingularStringField(value: self.datasetID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_DatasetStar, rhs: Clarifai_Api_DatasetStar) -> Bool {
    if lhs.datasetID != rhs.datasetID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_ModuleStar: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ModuleStar"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "module_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.moduleID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.moduleID.isEmpty {
      try visitor.visitSingularStringField(value: self.moduleID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_ModuleStar, rhs: Clarifai_Api_ModuleStar) -> Bool {
    if lhs.moduleID != rhs.moduleID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_Module: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Module"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    3: .same(proto: "description"),
    4: .standard(proto: "created_at"),
    5: .standard(proto: "modified_at"),
    7: .same(proto: "visibility"),
    8: .same(proto: "metadata"),
    9: .standard(proto: "user_id"),
    10: .standard(proto: "app_id"),
    11: .standard(proto: "module_version"),
    12: .standard(proto: "is_starred"),
    13: .standard(proto: "star_count"),
    14: .standard(proto: "bookmark_origin"),
    15: .same(proto: "image"),
  ]

  fileprivate class _StorageClass {
    var _id: String = String()
    var _description_p: String = String()
    var _createdAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _modifiedAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _visibility: Clarifai_Api_Visibility? = nil
    var _metadata: SwiftProtobuf.Google_Protobuf_Struct? = nil
    var _userID: String = String()
    var _appID: String = String()
    var _moduleVersion: Clarifai_Api_ModuleVersion? = nil
    var _isStarred: Bool = false
    var _starCount: Int32 = 0
    var _bookmarkOrigin: Clarifai_Api_BookmarkOrigin? = nil
    var _image: Clarifai_Api_Image? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _id = source._id
      _description_p = source._description_p
      _createdAt = source._createdAt
      _modifiedAt = source._modifiedAt
      _visibility = source._visibility
      _metadata = source._metadata
      _userID = source._userID
      _appID = source._appID
      _moduleVersion = source._moduleVersion
      _isStarred = source._isStarred
      _starCount = source._starCount
      _bookmarkOrigin = source._bookmarkOrigin
      _image = source._image
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._id) }()
        case 3: try { try decoder.decodeSingularStringField(value: &_storage._description_p) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._createdAt) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._modifiedAt) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._visibility) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._metadata) }()
        case 9: try { try decoder.decodeSingularStringField(value: &_storage._userID) }()
        case 10: try { try decoder.decodeSingularStringField(value: &_storage._appID) }()
        case 11: try { try decoder.decodeSingularMessageField(value: &_storage._moduleVersion) }()
        case 12: try { try decoder.decodeSingularBoolField(value: &_storage._isStarred) }()
        case 13: try { try decoder.decodeSingularInt32Field(value: &_storage._starCount) }()
        case 14: try { try decoder.decodeSingularMessageField(value: &_storage._bookmarkOrigin) }()
        case 15: try { try decoder.decodeSingularMessageField(value: &_storage._image) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._id.isEmpty {
        try visitor.visitSingularStringField(value: _storage._id, fieldNumber: 1)
      }
      if !_storage._description_p.isEmpty {
        try visitor.visitSingularStringField(value: _storage._description_p, fieldNumber: 3)
      }
      try { if let v = _storage._createdAt {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._modifiedAt {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._visibility {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      } }()
      try { if let v = _storage._metadata {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      } }()
      if !_storage._userID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._userID, fieldNumber: 9)
      }
      if !_storage._appID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._appID, fieldNumber: 10)
      }
      try { if let v = _storage._moduleVersion {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      } }()
      if _storage._isStarred != false {
        try visitor.visitSingularBoolField(value: _storage._isStarred, fieldNumber: 12)
      }
      if _storage._starCount != 0 {
        try visitor.visitSingularInt32Field(value: _storage._starCount, fieldNumber: 13)
      }
      try { if let v = _storage._bookmarkOrigin {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
      } }()
      try { if let v = _storage._image {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_Module, rhs: Clarifai_Api_Module) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._id != rhs_storage._id {return false}
        if _storage._description_p != rhs_storage._description_p {return false}
        if _storage._createdAt != rhs_storage._createdAt {return false}
        if _storage._modifiedAt != rhs_storage._modifiedAt {return false}
        if _storage._visibility != rhs_storage._visibility {return false}
        if _storage._metadata != rhs_storage._metadata {return false}
        if _storage._userID != rhs_storage._userID {return false}
        if _storage._appID != rhs_storage._appID {return false}
        if _storage._moduleVersion != rhs_storage._moduleVersion {return false}
        if _storage._isStarred != rhs_storage._isStarred {return false}
        if _storage._starCount != rhs_storage._starCount {return false}
        if _storage._bookmarkOrigin != rhs_storage._bookmarkOrigin {return false}
        if _storage._image != rhs_storage._image {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_ModuleVersion: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ModuleVersion"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .standard(proto: "module_id"),
    3: .standard(proto: "app_id"),
    4: .standard(proto: "user_id"),
    6: .same(proto: "description"),
    7: .same(proto: "notes"),
    8: .standard(proto: "created_at"),
    9: .standard(proto: "modified_at"),
    10: .standard(proto: "git_commit_url"),
    11: .standard(proto: "module_nav"),
    12: .same(proto: "approved"),
    13: .same(proto: "visibility"),
    14: .same(proto: "metadata"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.moduleID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.appID) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.userID) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.notes) }()
      case 8: try { try decoder.decodeSingularMessageField(value: &self._createdAt) }()
      case 9: try { try decoder.decodeSingularMessageField(value: &self._modifiedAt) }()
      case 10: try { try decoder.decodeSingularStringField(value: &self.gitCommitURL) }()
      case 11: try { try decoder.decodeSingularMessageField(value: &self._moduleNav) }()
      case 12: try { try decoder.decodeSingularBoolField(value: &self.approved) }()
      case 13: try { try decoder.decodeSingularMessageField(value: &self._visibility) }()
      case 14: try { try decoder.decodeSingularMessageField(value: &self._metadata) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if !self.moduleID.isEmpty {
      try visitor.visitSingularStringField(value: self.moduleID, fieldNumber: 2)
    }
    if !self.appID.isEmpty {
      try visitor.visitSingularStringField(value: self.appID, fieldNumber: 3)
    }
    if !self.userID.isEmpty {
      try visitor.visitSingularStringField(value: self.userID, fieldNumber: 4)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 6)
    }
    if !self.notes.isEmpty {
      try visitor.visitSingularStringField(value: self.notes, fieldNumber: 7)
    }
    try { if let v = self._createdAt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    } }()
    try { if let v = self._modifiedAt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    } }()
    if !self.gitCommitURL.isEmpty {
      try visitor.visitSingularStringField(value: self.gitCommitURL, fieldNumber: 10)
    }
    try { if let v = self._moduleNav {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
    } }()
    if self.approved != false {
      try visitor.visitSingularBoolField(value: self.approved, fieldNumber: 12)
    }
    try { if let v = self._visibility {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
    } }()
    try { if let v = self._metadata {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_ModuleVersion, rhs: Clarifai_Api_ModuleVersion) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.moduleID != rhs.moduleID {return false}
    if lhs.appID != rhs.appID {return false}
    if lhs.userID != rhs.userID {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.notes != rhs.notes {return false}
    if lhs._createdAt != rhs._createdAt {return false}
    if lhs._modifiedAt != rhs._modifiedAt {return false}
    if lhs.gitCommitURL != rhs.gitCommitURL {return false}
    if lhs._moduleNav != rhs._moduleNav {return false}
    if lhs.approved != rhs.approved {return false}
    if lhs._visibility != rhs._visibility {return false}
    if lhs._metadata != rhs._metadata {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_ModuleVersion.ModuleSubNav: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Clarifai_Api_ModuleVersion.protoMessageName + ".ModuleSubNav"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "title"),
    2: .standard(proto: "query_key"),
    3: .standard(proto: "query_value"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.title) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.queryKey) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.queryValue) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.title.isEmpty {
      try visitor.visitSingularStringField(value: self.title, fieldNumber: 1)
    }
    if !self.queryKey.isEmpty {
      try visitor.visitSingularStringField(value: self.queryKey, fieldNumber: 2)
    }
    if !self.queryValue.isEmpty {
      try visitor.visitSingularStringField(value: self.queryValue, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_ModuleVersion.ModuleSubNav, rhs: Clarifai_Api_ModuleVersion.ModuleSubNav) -> Bool {
    if lhs.title != rhs.title {return false}
    if lhs.queryKey != rhs.queryKey {return false}
    if lhs.queryValue != rhs.queryValue {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_ModuleVersion.ModuleNav: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Clarifai_Api_ModuleVersion.protoMessageName + ".ModuleNav"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "title"),
    2: .standard(proto: "module_sub_navs"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.title) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.moduleSubNavs) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.title.isEmpty {
      try visitor.visitSingularStringField(value: self.title, fieldNumber: 1)
    }
    if !self.moduleSubNavs.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.moduleSubNavs, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_ModuleVersion.ModuleNav, rhs: Clarifai_Api_ModuleVersion.ModuleNav) -> Bool {
    if lhs.title != rhs.title {return false}
    if lhs.moduleSubNavs != rhs.moduleSubNavs {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_InstalledModuleVersion: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".InstalledModuleVersion"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .standard(proto: "module_version"),
    3: .standard(proto: "app_id"),
    4: .standard(proto: "user_id"),
    5: .standard(proto: "created_at"),
    6: .standard(proto: "modified_at"),
    7: .standard(proto: "deploy_url"),
    8: .same(proto: "visibility"),
    9: .standard(proto: "key_id"),
  ]

  fileprivate class _StorageClass {
    var _id: String = String()
    var _moduleVersion: Clarifai_Api_ModuleVersion? = nil
    var _appID: String = String()
    var _userID: String = String()
    var _createdAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _modifiedAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _deployURL: String = String()
    var _visibility: Clarifai_Api_Visibility? = nil
    var _keyID: String = String()

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _id = source._id
      _moduleVersion = source._moduleVersion
      _appID = source._appID
      _userID = source._userID
      _createdAt = source._createdAt
      _modifiedAt = source._modifiedAt
      _deployURL = source._deployURL
      _visibility = source._visibility
      _keyID = source._keyID
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._id) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._moduleVersion) }()
        case 3: try { try decoder.decodeSingularStringField(value: &_storage._appID) }()
        case 4: try { try decoder.decodeSingularStringField(value: &_storage._userID) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._createdAt) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._modifiedAt) }()
        case 7: try { try decoder.decodeSingularStringField(value: &_storage._deployURL) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._visibility) }()
        case 9: try { try decoder.decodeSingularStringField(value: &_storage._keyID) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._id.isEmpty {
        try visitor.visitSingularStringField(value: _storage._id, fieldNumber: 1)
      }
      try { if let v = _storage._moduleVersion {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      if !_storage._appID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._appID, fieldNumber: 3)
      }
      if !_storage._userID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._userID, fieldNumber: 4)
      }
      try { if let v = _storage._createdAt {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._modifiedAt {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
      if !_storage._deployURL.isEmpty {
        try visitor.visitSingularStringField(value: _storage._deployURL, fieldNumber: 7)
      }
      try { if let v = _storage._visibility {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      } }()
      if !_storage._keyID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._keyID, fieldNumber: 9)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_InstalledModuleVersion, rhs: Clarifai_Api_InstalledModuleVersion) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._id != rhs_storage._id {return false}
        if _storage._moduleVersion != rhs_storage._moduleVersion {return false}
        if _storage._appID != rhs_storage._appID {return false}
        if _storage._userID != rhs_storage._userID {return false}
        if _storage._createdAt != rhs_storage._createdAt {return false}
        if _storage._modifiedAt != rhs_storage._modifiedAt {return false}
        if _storage._deployURL != rhs_storage._deployURL {return false}
        if _storage._visibility != rhs_storage._visibility {return false}
        if _storage._keyID != rhs_storage._keyID {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_BulkOperation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".BulkOperation"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .standard(proto: "input_ids"),
    10: .same(proto: "search"),
    11: .same(proto: "dataset"),
    12: .standard(proto: "annotation_search"),
    3: .same(proto: "operation"),
    4: .standard(proto: "app_id"),
    5: .same(proto: "status"),
    6: .same(proto: "progress"),
    7: .standard(proto: "created_by"),
    8: .standard(proto: "created_at"),
    9: .standard(proto: "last_modified_at"),
  ]

  fileprivate class _StorageClass {
    var _id: String = String()
    var _inputSource: Clarifai_Api_BulkOperation.OneOf_InputSource?
    var _annotationSource: Clarifai_Api_BulkOperation.OneOf_AnnotationSource?
    var _operation: Clarifai_Api_Operation? = nil
    var _appID: String = String()
    var _status: Clarifai_Api_Status_Status? = nil
    var _progress: Clarifai_Api_Progress? = nil
    var _createdBy: String = String()
    var _createdAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _lastModifiedAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _id = source._id
      _inputSource = source._inputSource
      _annotationSource = source._annotationSource
      _operation = source._operation
      _appID = source._appID
      _status = source._status
      _progress = source._progress
      _createdBy = source._createdBy
      _createdAt = source._createdAt
      _lastModifiedAt = source._lastModifiedAt
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._id) }()
        case 2: try {
          var v: Clarifai_Api_InputIDs?
          var hadOneofValue = false
          if let current = _storage._inputSource {
            hadOneofValue = true
            if case .inputIds(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._inputSource = .inputIds(v)
          }
        }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._operation) }()
        case 4: try { try decoder.decodeSingularStringField(value: &_storage._appID) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._status) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._progress) }()
        case 7: try { try decoder.decodeSingularStringField(value: &_storage._createdBy) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._createdAt) }()
        case 9: try { try decoder.decodeSingularMessageField(value: &_storage._lastModifiedAt) }()
        case 10: try {
          var v: Clarifai_Api_Search?
          var hadOneofValue = false
          if let current = _storage._inputSource {
            hadOneofValue = true
            if case .search(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._inputSource = .search(v)
          }
        }()
        case 11: try {
          var v: Clarifai_Api_Dataset?
          var hadOneofValue = false
          if let current = _storage._inputSource {
            hadOneofValue = true
            if case .dataset(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._inputSource = .dataset(v)
          }
        }()
        case 12: try {
          var v: Clarifai_Api_Search?
          var hadOneofValue = false
          if let current = _storage._annotationSource {
            hadOneofValue = true
            if case .annotationSearch(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._annotationSource = .annotationSearch(v)
          }
        }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._id.isEmpty {
        try visitor.visitSingularStringField(value: _storage._id, fieldNumber: 1)
      }
      try { if case .inputIds(let v)? = _storage._inputSource {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._operation {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      if !_storage._appID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._appID, fieldNumber: 4)
      }
      try { if let v = _storage._status {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._progress {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
      if !_storage._createdBy.isEmpty {
        try visitor.visitSingularStringField(value: _storage._createdBy, fieldNumber: 7)
      }
      try { if let v = _storage._createdAt {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      } }()
      try { if let v = _storage._lastModifiedAt {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      } }()
      switch _storage._inputSource {
      case .search?: try {
        guard case .search(let v)? = _storage._inputSource else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      }()
      case .dataset?: try {
        guard case .dataset(let v)? = _storage._inputSource else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      }()
      default: break
      }
      try { if case .annotationSearch(let v)? = _storage._annotationSource {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_BulkOperation, rhs: Clarifai_Api_BulkOperation) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._id != rhs_storage._id {return false}
        if _storage._inputSource != rhs_storage._inputSource {return false}
        if _storage._annotationSource != rhs_storage._annotationSource {return false}
        if _storage._operation != rhs_storage._operation {return false}
        if _storage._appID != rhs_storage._appID {return false}
        if _storage._status != rhs_storage._status {return false}
        if _storage._progress != rhs_storage._progress {return false}
        if _storage._createdBy != rhs_storage._createdBy {return false}
        if _storage._createdAt != rhs_storage._createdAt {return false}
        if _storage._lastModifiedAt != rhs_storage._lastModifiedAt {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_InputIDs: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".InputIDs"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "input_ids"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.inputIds) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.inputIds.isEmpty {
      try visitor.visitRepeatedStringField(value: self.inputIds, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_InputIDs, rhs: Clarifai_Api_InputIDs) -> Bool {
    if lhs.inputIds != rhs.inputIds {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_Progress: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Progress"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "processed"),
    2: .standard(proto: "last_processed_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.processed) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.lastProcessedID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.processed != 0 {
      try visitor.visitSingularUInt32Field(value: self.processed, fieldNumber: 1)
    }
    if !self.lastProcessedID.isEmpty {
      try visitor.visitSingularStringField(value: self.lastProcessedID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_Progress, rhs: Clarifai_Api_Progress) -> Bool {
    if lhs.processed != rhs.processed {return false}
    if lhs.lastProcessedID != rhs.lastProcessedID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_Operation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Operation"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "add_concepts"),
    2: .standard(proto: "delete_concepts"),
    3: .standard(proto: "add_metadata"),
    4: .standard(proto: "delete_metadata"),
    5: .standard(proto: "overwrite_geo"),
    6: .standard(proto: "delete_geo"),
    7: .standard(proto: "delete_from_dataset"),
    8: .standard(proto: "add_to_dataset"),
    9: .standard(proto: "split_into_datasets"),
    10: .standard(proto: "delete_annotations"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Clarifai_Api_AddConcepts?
        var hadOneofValue = false
        if let current = self.operation {
          hadOneofValue = true
          if case .addConcepts(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.operation = .addConcepts(v)
        }
      }()
      case 2: try {
        var v: Clarifai_Api_DeleteConcepts?
        var hadOneofValue = false
        if let current = self.operation {
          hadOneofValue = true
          if case .deleteConcepts(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.operation = .deleteConcepts(v)
        }
      }()
      case 3: try {
        var v: Clarifai_Api_AddMetadata?
        var hadOneofValue = false
        if let current = self.operation {
          hadOneofValue = true
          if case .addMetadata(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.operation = .addMetadata(v)
        }
      }()
      case 4: try {
        var v: Clarifai_Api_DeleteMetadata?
        var hadOneofValue = false
        if let current = self.operation {
          hadOneofValue = true
          if case .deleteMetadata(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.operation = .deleteMetadata(v)
        }
      }()
      case 5: try {
        var v: Clarifai_Api_OverwriteGeo?
        var hadOneofValue = false
        if let current = self.operation {
          hadOneofValue = true
          if case .overwriteGeo(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.operation = .overwriteGeo(v)
        }
      }()
      case 6: try {
        var v: Clarifai_Api_DeleteGeo?
        var hadOneofValue = false
        if let current = self.operation {
          hadOneofValue = true
          if case .deleteGeo(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.operation = .deleteGeo(v)
        }
      }()
      case 7: try {
        var v: Clarifai_Api_DeleteFromDataset?
        var hadOneofValue = false
        if let current = self.operation {
          hadOneofValue = true
          if case .deleteFromDataset(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.operation = .deleteFromDataset(v)
        }
      }()
      case 8: try {
        var v: Clarifai_Api_AddToDataset?
        var hadOneofValue = false
        if let current = self.operation {
          hadOneofValue = true
          if case .addToDataset(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.operation = .addToDataset(v)
        }
      }()
      case 9: try {
        var v: Clarifai_Api_SplitIntoDatasets?
        var hadOneofValue = false
        if let current = self.operation {
          hadOneofValue = true
          if case .splitIntoDatasets(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.operation = .splitIntoDatasets(v)
        }
      }()
      case 10: try {
        var v: Clarifai_Api_DeleteAnnotations?
        var hadOneofValue = false
        if let current = self.annotationOperation {
          hadOneofValue = true
          if case .deleteAnnotations(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.annotationOperation = .deleteAnnotations(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.operation {
    case .addConcepts?: try {
      guard case .addConcepts(let v)? = self.operation else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .deleteConcepts?: try {
      guard case .deleteConcepts(let v)? = self.operation else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .addMetadata?: try {
      guard case .addMetadata(let v)? = self.operation else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .deleteMetadata?: try {
      guard case .deleteMetadata(let v)? = self.operation else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .overwriteGeo?: try {
      guard case .overwriteGeo(let v)? = self.operation else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .deleteGeo?: try {
      guard case .deleteGeo(let v)? = self.operation else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case .deleteFromDataset?: try {
      guard case .deleteFromDataset(let v)? = self.operation else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }()
    case .addToDataset?: try {
      guard case .addToDataset(let v)? = self.operation else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    }()
    case .splitIntoDatasets?: try {
      guard case .splitIntoDatasets(let v)? = self.operation else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    }()
    case nil: break
    }
    try { if case .deleteAnnotations(let v)? = self.annotationOperation {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_Operation, rhs: Clarifai_Api_Operation) -> Bool {
    if lhs.operation != rhs.operation {return false}
    if lhs.annotationOperation != rhs.annotationOperation {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_AddConcepts: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AddConcepts"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "concepts"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.concepts) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.concepts.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.concepts, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_AddConcepts, rhs: Clarifai_Api_AddConcepts) -> Bool {
    if lhs.concepts != rhs.concepts {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_DeleteConcepts: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DeleteConcepts"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "concepts"),
    2: .standard(proto: "user_ids"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.concepts) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.userIds) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.concepts.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.concepts, fieldNumber: 1)
    }
    if !self.userIds.isEmpty {
      try visitor.visitRepeatedStringField(value: self.userIds, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_DeleteConcepts, rhs: Clarifai_Api_DeleteConcepts) -> Bool {
    if lhs.concepts != rhs.concepts {return false}
    if lhs.userIds != rhs.userIds {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_AddMetadata: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AddMetadata"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "metadata"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._metadata) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._metadata {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_AddMetadata, rhs: Clarifai_Api_AddMetadata) -> Bool {
    if lhs._metadata != rhs._metadata {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_DeleteMetadata: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DeleteMetadata"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "metadata"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._metadata) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._metadata {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_DeleteMetadata, rhs: Clarifai_Api_DeleteMetadata) -> Bool {
    if lhs._metadata != rhs._metadata {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_OverwriteGeo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".OverwriteGeo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "geo"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._geo) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._geo {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_OverwriteGeo, rhs: Clarifai_Api_OverwriteGeo) -> Bool {
    if lhs._geo != rhs._geo {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_DeleteGeo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DeleteGeo"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_DeleteGeo, rhs: Clarifai_Api_DeleteGeo) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_AddToDataset: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AddToDataset"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "dataset_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.datasetID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.datasetID.isEmpty {
      try visitor.visitSingularStringField(value: self.datasetID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_AddToDataset, rhs: Clarifai_Api_AddToDataset) -> Bool {
    if lhs.datasetID != rhs.datasetID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_DeleteFromDataset: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DeleteFromDataset"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "dataset_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.datasetID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.datasetID.isEmpty {
      try visitor.visitSingularStringField(value: self.datasetID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_DeleteFromDataset, rhs: Clarifai_Api_DeleteFromDataset) -> Bool {
    if lhs.datasetID != rhs.datasetID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_SplitIntoDatasets: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SplitIntoDatasets"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "dataset_splits"),
    2: .same(proto: "method"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.datasetSplits) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.method) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.datasetSplits.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.datasetSplits, fieldNumber: 1)
    }
    if self.method != .notSet {
      try visitor.visitSingularEnumField(value: self.method, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_SplitIntoDatasets, rhs: Clarifai_Api_SplitIntoDatasets) -> Bool {
    if lhs.datasetSplits != rhs.datasetSplits {return false}
    if lhs.method != rhs.method {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_SplitIntoDatasets.DatasetSplitMethod: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NOT_SET"),
    1: .same(proto: "RANDOM_PERCENTAGE_SPLIT"),
  ]
}

extension Clarifai_Api_DatasetSplit: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DatasetSplit"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "dataset"),
    2: .same(proto: "percentage"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._dataset) }()
      case 2: try {
        var v: UInt32?
        try decoder.decodeSingularUInt32Field(value: &v)
        if let v = v {
          if self.methodInfo != nil {try decoder.handleConflictingOneOf()}
          self.methodInfo = .percentage(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._dataset {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if case .percentage(let v)? = self.methodInfo {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_DatasetSplit, rhs: Clarifai_Api_DatasetSplit) -> Bool {
    if lhs._dataset != rhs._dataset {return false}
    if lhs.methodInfo != rhs.methodInfo {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_DeleteAnnotations: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DeleteAnnotations"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_DeleteAnnotations, rhs: Clarifai_Api_DeleteAnnotations) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_InputsAddJob: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".InputsAddJob"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    3: .standard(proto: "call_back_url"),
    4: .standard(proto: "app_pat"),
    7: .same(proto: "progress"),
    8: .standard(proto: "created_at"),
    9: .standard(proto: "modified_at"),
    10: .standard(proto: "extraction_jobs"),
    11: .same(proto: "uploads"),
    12: .same(proto: "status"),
  ]

  fileprivate class _StorageClass {
    var _id: String = String()
    var _callBackURL: String = String()
    var _appPat: String = String()
    var _progress: Clarifai_Api_InputsAddJobProgress? = nil
    var _createdAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _modifiedAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _extractionJobs: [Clarifai_Api_InputsExtractionJob] = []
    var _uploads: [Clarifai_Api_Upload] = []
    var _status: Clarifai_Api_Status_Status? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _id = source._id
      _callBackURL = source._callBackURL
      _appPat = source._appPat
      _progress = source._progress
      _createdAt = source._createdAt
      _modifiedAt = source._modifiedAt
      _extractionJobs = source._extractionJobs
      _uploads = source._uploads
      _status = source._status
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._id) }()
        case 3: try { try decoder.decodeSingularStringField(value: &_storage._callBackURL) }()
        case 4: try { try decoder.decodeSingularStringField(value: &_storage._appPat) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._progress) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._createdAt) }()
        case 9: try { try decoder.decodeSingularMessageField(value: &_storage._modifiedAt) }()
        case 10: try { try decoder.decodeRepeatedMessageField(value: &_storage._extractionJobs) }()
        case 11: try { try decoder.decodeRepeatedMessageField(value: &_storage._uploads) }()
        case 12: try { try decoder.decodeSingularMessageField(value: &_storage._status) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._id.isEmpty {
        try visitor.visitSingularStringField(value: _storage._id, fieldNumber: 1)
      }
      if !_storage._callBackURL.isEmpty {
        try visitor.visitSingularStringField(value: _storage._callBackURL, fieldNumber: 3)
      }
      if !_storage._appPat.isEmpty {
        try visitor.visitSingularStringField(value: _storage._appPat, fieldNumber: 4)
      }
      try { if let v = _storage._progress {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      } }()
      try { if let v = _storage._createdAt {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      } }()
      try { if let v = _storage._modifiedAt {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      } }()
      if !_storage._extractionJobs.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._extractionJobs, fieldNumber: 10)
      }
      if !_storage._uploads.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._uploads, fieldNumber: 11)
      }
      try { if let v = _storage._status {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_InputsAddJob, rhs: Clarifai_Api_InputsAddJob) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._id != rhs_storage._id {return false}
        if _storage._callBackURL != rhs_storage._callBackURL {return false}
        if _storage._appPat != rhs_storage._appPat {return false}
        if _storage._progress != rhs_storage._progress {return false}
        if _storage._createdAt != rhs_storage._createdAt {return false}
        if _storage._modifiedAt != rhs_storage._modifiedAt {return false}
        if _storage._extractionJobs != rhs_storage._extractionJobs {return false}
        if _storage._uploads != rhs_storage._uploads {return false}
        if _storage._status != rhs_storage._status {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_InputsAddJobProgress: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".InputsAddJobProgress"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "pending_count"),
    2: .standard(proto: "in_progress_count"),
    3: .standard(proto: "success_count"),
    4: .standard(proto: "failed_count"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.pendingCount) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.inProgressCount) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.successCount) }()
      case 4: try { try decoder.decodeSingularUInt64Field(value: &self.failedCount) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.pendingCount != 0 {
      try visitor.visitSingularUInt64Field(value: self.pendingCount, fieldNumber: 1)
    }
    if self.inProgressCount != 0 {
      try visitor.visitSingularUInt64Field(value: self.inProgressCount, fieldNumber: 2)
    }
    if self.successCount != 0 {
      try visitor.visitSingularUInt64Field(value: self.successCount, fieldNumber: 3)
    }
    if self.failedCount != 0 {
      try visitor.visitSingularUInt64Field(value: self.failedCount, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_InputsAddJobProgress, rhs: Clarifai_Api_InputsAddJobProgress) -> Bool {
    if lhs.pendingCount != rhs.pendingCount {return false}
    if lhs.inProgressCount != rhs.inProgressCount {return false}
    if lhs.successCount != rhs.successCount {return false}
    if lhs.failedCount != rhs.failedCount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_Upload: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Upload"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .standard(proto: "created_at"),
    3: .standard(proto: "modified_at"),
    4: .standard(proto: "expires_at"),
    5: .same(proto: "status"),
    8: .standard(proto: "content_name"),
    6: .standard(proto: "content_length"),
    7: .standard(proto: "content_url"),
  ]

  fileprivate class _StorageClass {
    var _id: String = String()
    var _createdAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _modifiedAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _expiresAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _status: Clarifai_Api_Status_Status? = nil
    var _contentName: String = String()
    var _contentLength: UInt64 = 0
    var _contentURL: String = String()

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _id = source._id
      _createdAt = source._createdAt
      _modifiedAt = source._modifiedAt
      _expiresAt = source._expiresAt
      _status = source._status
      _contentName = source._contentName
      _contentLength = source._contentLength
      _contentURL = source._contentURL
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._id) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._createdAt) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._modifiedAt) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._expiresAt) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._status) }()
        case 6: try { try decoder.decodeSingularUInt64Field(value: &_storage._contentLength) }()
        case 7: try { try decoder.decodeSingularStringField(value: &_storage._contentURL) }()
        case 8: try { try decoder.decodeSingularStringField(value: &_storage._contentName) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._id.isEmpty {
        try visitor.visitSingularStringField(value: _storage._id, fieldNumber: 1)
      }
      try { if let v = _storage._createdAt {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._modifiedAt {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._expiresAt {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._status {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      if _storage._contentLength != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._contentLength, fieldNumber: 6)
      }
      if !_storage._contentURL.isEmpty {
        try visitor.visitSingularStringField(value: _storage._contentURL, fieldNumber: 7)
      }
      if !_storage._contentName.isEmpty {
        try visitor.visitSingularStringField(value: _storage._contentName, fieldNumber: 8)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_Upload, rhs: Clarifai_Api_Upload) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._id != rhs_storage._id {return false}
        if _storage._createdAt != rhs_storage._createdAt {return false}
        if _storage._modifiedAt != rhs_storage._modifiedAt {return false}
        if _storage._expiresAt != rhs_storage._expiresAt {return false}
        if _storage._status != rhs_storage._status {return false}
        if _storage._contentName != rhs_storage._contentName {return false}
        if _storage._contentLength != rhs_storage._contentLength {return false}
        if _storage._contentURL != rhs_storage._contentURL {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_UploadContentPart: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UploadContentPart"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "range_start"),
    2: .standard(proto: "part_number"),
    3: .same(proto: "data"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.rangeStart) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.partNumber) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.data) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.rangeStart != 0 {
      try visitor.visitSingularUInt64Field(value: self.rangeStart, fieldNumber: 1)
    }
    if self.partNumber != 0 {
      try visitor.visitSingularInt64Field(value: self.partNumber, fieldNumber: 2)
    }
    if !self.data.isEmpty {
      try visitor.visitSingularBytesField(value: self.data, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_UploadContentPart, rhs: Clarifai_Api_UploadContentPart) -> Bool {
    if lhs.rangeStart != rhs.rangeStart {return false}
    if lhs.partNumber != rhs.partNumber {return false}
    if lhs.data != rhs.data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_InputsExtractionJob: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".InputsExtractionJob"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
    2: .same(proto: "id"),
    3: .same(proto: "url"),
    4: .same(proto: "progress"),
    5: .standard(proto: "created_at"),
    6: .standard(proto: "modified_at"),
    7: .standard(proto: "input_id_conflict_resolution"),
    8: .standard(proto: "input_template"),
  ]

  fileprivate class _StorageClass {
    var _status: Clarifai_Api_Status_Status? = nil
    var _id: String = String()
    var _url: String = String()
    var _progress: Clarifai_Api_InputsExtractionJobProgress? = nil
    var _createdAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _modifiedAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _inputIDConflictResolution: Clarifai_Api_InputIDConflictResolution = .notSet
    var _inputTemplate: Clarifai_Api_Input? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _status = source._status
      _id = source._id
      _url = source._url
      _progress = source._progress
      _createdAt = source._createdAt
      _modifiedAt = source._modifiedAt
      _inputIDConflictResolution = source._inputIDConflictResolution
      _inputTemplate = source._inputTemplate
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._status) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._id) }()
        case 3: try { try decoder.decodeSingularStringField(value: &_storage._url) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._progress) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._createdAt) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._modifiedAt) }()
        case 7: try { try decoder.decodeSingularEnumField(value: &_storage._inputIDConflictResolution) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._inputTemplate) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._status {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      if !_storage._id.isEmpty {
        try visitor.visitSingularStringField(value: _storage._id, fieldNumber: 2)
      }
      if !_storage._url.isEmpty {
        try visitor.visitSingularStringField(value: _storage._url, fieldNumber: 3)
      }
      try { if let v = _storage._progress {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._createdAt {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._modifiedAt {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
      if _storage._inputIDConflictResolution != .notSet {
        try visitor.visitSingularEnumField(value: _storage._inputIDConflictResolution, fieldNumber: 7)
      }
      try { if let v = _storage._inputTemplate {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_InputsExtractionJob, rhs: Clarifai_Api_InputsExtractionJob) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._status != rhs_storage._status {return false}
        if _storage._id != rhs_storage._id {return false}
        if _storage._url != rhs_storage._url {return false}
        if _storage._progress != rhs_storage._progress {return false}
        if _storage._createdAt != rhs_storage._createdAt {return false}
        if _storage._modifiedAt != rhs_storage._modifiedAt {return false}
        if _storage._inputIDConflictResolution != rhs_storage._inputIDConflictResolution {return false}
        if _storage._inputTemplate != rhs_storage._inputTemplate {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_InputsExtractionJobProgress: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".InputsExtractionJobProgress"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .standard(proto: "audio_inputs_count"),
    3: .standard(proto: "image_inputs_count"),
    4: .standard(proto: "video_inputs_count"),
    5: .standard(proto: "text_inputs_count"),
    6: .standard(proto: "pending_archives_count"),
    7: .standard(proto: "in_progress_archives_count"),
    8: .standard(proto: "completed_archives_count"),
    9: .standard(proto: "failed_archives_count"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.audioInputsCount) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.imageInputsCount) }()
      case 4: try { try decoder.decodeSingularUInt64Field(value: &self.videoInputsCount) }()
      case 5: try { try decoder.decodeSingularUInt64Field(value: &self.textInputsCount) }()
      case 6: try { try decoder.decodeSingularUInt64Field(value: &self.pendingArchivesCount) }()
      case 7: try { try decoder.decodeSingularUInt64Field(value: &self.inProgressArchivesCount) }()
      case 8: try { try decoder.decodeSingularUInt64Field(value: &self.completedArchivesCount) }()
      case 9: try { try decoder.decodeSingularUInt64Field(value: &self.failedArchivesCount) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.audioInputsCount != 0 {
      try visitor.visitSingularUInt64Field(value: self.audioInputsCount, fieldNumber: 2)
    }
    if self.imageInputsCount != 0 {
      try visitor.visitSingularUInt64Field(value: self.imageInputsCount, fieldNumber: 3)
    }
    if self.videoInputsCount != 0 {
      try visitor.visitSingularUInt64Field(value: self.videoInputsCount, fieldNumber: 4)
    }
    if self.textInputsCount != 0 {
      try visitor.visitSingularUInt64Field(value: self.textInputsCount, fieldNumber: 5)
    }
    if self.pendingArchivesCount != 0 {
      try visitor.visitSingularUInt64Field(value: self.pendingArchivesCount, fieldNumber: 6)
    }
    if self.inProgressArchivesCount != 0 {
      try visitor.visitSingularUInt64Field(value: self.inProgressArchivesCount, fieldNumber: 7)
    }
    if self.completedArchivesCount != 0 {
      try visitor.visitSingularUInt64Field(value: self.completedArchivesCount, fieldNumber: 8)
    }
    if self.failedArchivesCount != 0 {
      try visitor.visitSingularUInt64Field(value: self.failedArchivesCount, fieldNumber: 9)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_InputsExtractionJobProgress, rhs: Clarifai_Api_InputsExtractionJobProgress) -> Bool {
    if lhs.audioInputsCount != rhs.audioInputsCount {return false}
    if lhs.imageInputsCount != rhs.imageInputsCount {return false}
    if lhs.videoInputsCount != rhs.videoInputsCount {return false}
    if lhs.textInputsCount != rhs.textInputsCount {return false}
    if lhs.pendingArchivesCount != rhs.pendingArchivesCount {return false}
    if lhs.inProgressArchivesCount != rhs.inProgressArchivesCount {return false}
    if lhs.completedArchivesCount != rhs.completedArchivesCount {return false}
    if lhs.failedArchivesCount != rhs.failedArchivesCount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_InputsDataSource: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".InputsDataSource"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "inputs_add_job_id"),
    2: .same(proto: "url"),
    3: .standard(proto: "input_id_conflict_resolution"),
    4: .standard(proto: "input_template"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.inputsAddJobID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._url) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.inputIDConflictResolution) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._inputTemplate) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.inputsAddJobID.isEmpty {
      try visitor.visitSingularStringField(value: self.inputsAddJobID, fieldNumber: 1)
    }
    try { if let v = self._url {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if self.inputIDConflictResolution != .notSet {
      try visitor.visitSingularEnumField(value: self.inputIDConflictResolution, fieldNumber: 3)
    }
    try { if let v = self._inputTemplate {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_InputsDataSource, rhs: Clarifai_Api_InputsDataSource) -> Bool {
    if lhs.inputsAddJobID != rhs.inputsAddJobID {return false}
    if lhs._url != rhs._url {return false}
    if lhs.inputIDConflictResolution != rhs.inputIDConflictResolution {return false}
    if lhs._inputTemplate != rhs._inputTemplate {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_DataSourceURL: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DataSourceURL"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "url"),
    2: .same(proto: "credentials"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.url) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._credentials) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.url.isEmpty {
      try visitor.visitSingularStringField(value: self.url, fieldNumber: 1)
    }
    try { if let v = self._credentials {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_DataSourceURL, rhs: Clarifai_Api_DataSourceURL) -> Bool {
    if lhs.url != rhs.url {return false}
    if lhs._credentials != rhs._credentials {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_DataSourceCredentials: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DataSourceCredentials"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "s3_creds"),
    2: .standard(proto: "gcp_creds"),
    4: .standard(proto: "azure_blob_creds"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Clarifai_Api_AWSCreds?
        var hadOneofValue = false
        if let current = self.credentials {
          hadOneofValue = true
          if case .s3Creds(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.credentials = .s3Creds(v)
        }
      }()
      case 2: try {
        var v: Data?
        try decoder.decodeSingularBytesField(value: &v)
        if let v = v {
          if self.credentials != nil {try decoder.handleConflictingOneOf()}
          self.credentials = .gcpCreds(v)
        }
      }()
      case 4: try {
        var v: Clarifai_Api_AzureBlobCreds?
        var hadOneofValue = false
        if let current = self.credentials {
          hadOneofValue = true
          if case .azureBlobCreds(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.credentials = .azureBlobCreds(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.credentials {
    case .s3Creds?: try {
      guard case .s3Creds(let v)? = self.credentials else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .gcpCreds?: try {
      guard case .gcpCreds(let v)? = self.credentials else { preconditionFailure() }
      try visitor.visitSingularBytesField(value: v, fieldNumber: 2)
    }()
    case .azureBlobCreds?: try {
      guard case .azureBlobCreds(let v)? = self.credentials else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_DataSourceCredentials, rhs: Clarifai_Api_DataSourceCredentials) -> Bool {
    if lhs.credentials != rhs.credentials {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_AWSCreds: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AWSCreds"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .same(proto: "region"),
    3: .same(proto: "id"),
    4: .same(proto: "secret"),
    5: .same(proto: "token"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeSingularStringField(value: &self.region) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.secret) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.token) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.region.isEmpty {
      try visitor.visitSingularStringField(value: self.region, fieldNumber: 2)
    }
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 3)
    }
    if !self.secret.isEmpty {
      try visitor.visitSingularStringField(value: self.secret, fieldNumber: 4)
    }
    if !self.token.isEmpty {
      try visitor.visitSingularStringField(value: self.token, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_AWSCreds, rhs: Clarifai_Api_AWSCreds) -> Bool {
    if lhs.region != rhs.region {return false}
    if lhs.id != rhs.id {return false}
    if lhs.secret != rhs.secret {return false}
    if lhs.token != rhs.token {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_AzureBlobCreds: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AzureBlobCreds"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "account_name"),
    2: .standard(proto: "account_key"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.accountName) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.accountKey) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.accountName.isEmpty {
      try visitor.visitSingularStringField(value: self.accountName, fieldNumber: 1)
    }
    if !self.accountKey.isEmpty {
      try visitor.visitSingularStringField(value: self.accountKey, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_AzureBlobCreds, rhs: Clarifai_Api_AzureBlobCreds) -> Bool {
    if lhs.accountName != rhs.accountName {return false}
    if lhs.accountKey != rhs.accountKey {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_InputsUpload: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".InputsUpload"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "inputs_add_job_id"),
    2: .standard(proto: "app_pat"),
    3: .same(proto: "upload"),
    4: .standard(proto: "input_id_conflict_resolution"),
    5: .standard(proto: "input_template"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.inputsAddJobID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.appPat) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._upload) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self.inputIDConflictResolution) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._inputTemplate) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.inputsAddJobID.isEmpty {
      try visitor.visitSingularStringField(value: self.inputsAddJobID, fieldNumber: 1)
    }
    if !self.appPat.isEmpty {
      try visitor.visitSingularStringField(value: self.appPat, fieldNumber: 2)
    }
    try { if let v = self._upload {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if self.inputIDConflictResolution != .notSet {
      try visitor.visitSingularEnumField(value: self.inputIDConflictResolution, fieldNumber: 4)
    }
    try { if let v = self._inputTemplate {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_InputsUpload, rhs: Clarifai_Api_InputsUpload) -> Bool {
    if lhs.inputsAddJobID != rhs.inputsAddJobID {return false}
    if lhs.appPat != rhs.appPat {return false}
    if lhs._upload != rhs._upload {return false}
    if lhs.inputIDConflictResolution != rhs.inputIDConflictResolution {return false}
    if lhs._inputTemplate != rhs._inputTemplate {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_BookmarkOrigin: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".BookmarkOrigin"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .standard(proto: "app_id"),
    3: .standard(proto: "user_id"),
    4: .standard(proto: "resource_type"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.appID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.userID) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self.resourceType) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if !self.appID.isEmpty {
      try visitor.visitSingularStringField(value: self.appID, fieldNumber: 2)
    }
    if !self.userID.isEmpty {
      try visitor.visitSingularStringField(value: self.userID, fieldNumber: 3)
    }
    if self.resourceType != .unknown {
      try visitor.visitSingularEnumField(value: self.resourceType, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_BookmarkOrigin, rhs: Clarifai_Api_BookmarkOrigin) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.appID != rhs.appID {return false}
    if lhs.userID != rhs.userID {return false}
    if lhs.resourceType != rhs.resourceType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_BookmarkOrigin.BookmarkType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "unknown"),
    1: .same(proto: "model"),
    2: .same(proto: "workflow"),
    3: .same(proto: "dataset"),
    4: .same(proto: "module"),
  ]
}

extension Clarifai_Api_Runner: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Runner"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "description"),
    3: .standard(proto: "created_at"),
    4: .standard(proto: "modified_at"),
    5: .same(proto: "metadata"),
    7: .same(proto: "labels"),
    8: .same(proto: "worker"),
    9: .same(proto: "nodepool"),
    10: .standard(proto: "compute_info"),
    11: .standard(proto: "num_replicas"),
  ]

  fileprivate class _StorageClass {
    var _id: String = String()
    var _description_p: String = String()
    var _createdAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _modifiedAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _metadata: SwiftProtobuf.Google_Protobuf_Struct? = nil
    var _labels: [String] = []
    var _worker: Clarifai_Api_Worker? = nil
    var _nodepool: Clarifai_Api_Nodepool? = nil
    var _computeInfo: Clarifai_Api_ComputeInfo? = nil
    var _numReplicas: UInt32 = 0

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _id = source._id
      _description_p = source._description_p
      _createdAt = source._createdAt
      _modifiedAt = source._modifiedAt
      _metadata = source._metadata
      _labels = source._labels
      _worker = source._worker
      _nodepool = source._nodepool
      _computeInfo = source._computeInfo
      _numReplicas = source._numReplicas
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._id) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._description_p) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._createdAt) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._modifiedAt) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._metadata) }()
        case 7: try { try decoder.decodeRepeatedStringField(value: &_storage._labels) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._worker) }()
        case 9: try { try decoder.decodeSingularMessageField(value: &_storage._nodepool) }()
        case 10: try { try decoder.decodeSingularMessageField(value: &_storage._computeInfo) }()
        case 11: try { try decoder.decodeSingularUInt32Field(value: &_storage._numReplicas) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._id.isEmpty {
        try visitor.visitSingularStringField(value: _storage._id, fieldNumber: 1)
      }
      if !_storage._description_p.isEmpty {
        try visitor.visitSingularStringField(value: _storage._description_p, fieldNumber: 2)
      }
      try { if let v = _storage._createdAt {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._modifiedAt {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._metadata {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      if !_storage._labels.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._labels, fieldNumber: 7)
      }
      try { if let v = _storage._worker {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      } }()
      try { if let v = _storage._nodepool {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      } }()
      try { if let v = _storage._computeInfo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      } }()
      if _storage._numReplicas != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._numReplicas, fieldNumber: 11)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_Runner, rhs: Clarifai_Api_Runner) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._id != rhs_storage._id {return false}
        if _storage._description_p != rhs_storage._description_p {return false}
        if _storage._createdAt != rhs_storage._createdAt {return false}
        if _storage._modifiedAt != rhs_storage._modifiedAt {return false}
        if _storage._metadata != rhs_storage._metadata {return false}
        if _storage._labels != rhs_storage._labels {return false}
        if _storage._worker != rhs_storage._worker {return false}
        if _storage._nodepool != rhs_storage._nodepool {return false}
        if _storage._computeInfo != rhs_storage._computeInfo {return false}
        if _storage._numReplicas != rhs_storage._numReplicas {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_Nodepool: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Nodepool"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "description"),
    3: .standard(proto: "created_at"),
    4: .standard(proto: "modified_at"),
    6: .standard(proto: "compute_cluster"),
    7: .standard(proto: "node_capacity_type"),
    8: .standard(proto: "instance_types"),
    9: .standard(proto: "min_instances"),
    10: .standard(proto: "max_instances"),
    13: .standard(proto: "enforced_min_instances"),
    14: .standard(proto: "enforced_max_instances"),
    11: .same(proto: "visibility"),
    12: .same(proto: "metadata"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._createdAt) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._modifiedAt) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._computeCluster) }()
      case 7: try { try decoder.decodeSingularMessageField(value: &self._nodeCapacityType) }()
      case 8: try { try decoder.decodeRepeatedMessageField(value: &self.instanceTypes) }()
      case 9: try { try decoder.decodeSingularUInt32Field(value: &self.minInstances) }()
      case 10: try { try decoder.decodeSingularUInt32Field(value: &self.maxInstances) }()
      case 11: try { try decoder.decodeSingularMessageField(value: &self._visibility) }()
      case 12: try { try decoder.decodeSingularMessageField(value: &self._metadata) }()
      case 13: try { try decoder.decodeSingularUInt32Field(value: &self.enforcedMinInstances) }()
      case 14: try { try decoder.decodeSingularUInt32Field(value: &self.enforcedMaxInstances) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 2)
    }
    try { if let v = self._createdAt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._modifiedAt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._computeCluster {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    try { if let v = self._nodeCapacityType {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    } }()
    if !self.instanceTypes.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.instanceTypes, fieldNumber: 8)
    }
    if self.minInstances != 0 {
      try visitor.visitSingularUInt32Field(value: self.minInstances, fieldNumber: 9)
    }
    if self.maxInstances != 0 {
      try visitor.visitSingularUInt32Field(value: self.maxInstances, fieldNumber: 10)
    }
    try { if let v = self._visibility {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
    } }()
    try { if let v = self._metadata {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
    } }()
    if self.enforcedMinInstances != 0 {
      try visitor.visitSingularUInt32Field(value: self.enforcedMinInstances, fieldNumber: 13)
    }
    if self.enforcedMaxInstances != 0 {
      try visitor.visitSingularUInt32Field(value: self.enforcedMaxInstances, fieldNumber: 14)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_Nodepool, rhs: Clarifai_Api_Nodepool) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs._createdAt != rhs._createdAt {return false}
    if lhs._modifiedAt != rhs._modifiedAt {return false}
    if lhs._computeCluster != rhs._computeCluster {return false}
    if lhs._nodeCapacityType != rhs._nodeCapacityType {return false}
    if lhs.instanceTypes != rhs.instanceTypes {return false}
    if lhs.minInstances != rhs.minInstances {return false}
    if lhs.maxInstances != rhs.maxInstances {return false}
    if lhs.enforcedMinInstances != rhs.enforcedMinInstances {return false}
    if lhs.enforcedMaxInstances != rhs.enforcedMaxInstances {return false}
    if lhs._visibility != rhs._visibility {return false}
    if lhs._metadata != rhs._metadata {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_NodeCapacityType: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".NodeCapacityType"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "capacity_types"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedEnumField(value: &self.capacityTypes) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.capacityTypes.isEmpty {
      try visitor.visitPackedEnumField(value: self.capacityTypes, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_NodeCapacityType, rhs: Clarifai_Api_NodeCapacityType) -> Bool {
    if lhs.capacityTypes != rhs.capacityTypes {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_NodeCapacityType.CapacityType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UKNOWN_CAPACITY_TYPE"),
    1: .same(proto: "ON_DEMAND_TYPE"),
    2: .same(proto: "SPOT_TYPE"),
  ]
}

extension Clarifai_Api_InstanceType: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".InstanceType"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "description"),
    3: .standard(proto: "compute_info"),
    4: .same(proto: "price"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._computeInfo) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.price) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 2)
    }
    try { if let v = self._computeInfo {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if !self.price.isEmpty {
      try visitor.visitSingularStringField(value: self.price, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_InstanceType, rhs: Clarifai_Api_InstanceType) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs._computeInfo != rhs._computeInfo {return false}
    if lhs.price != rhs.price {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_CloudProvider: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CloudProvider"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.name) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_CloudProvider, rhs: Clarifai_Api_CloudProvider) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_ComputeCluster: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ComputeCluster"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "description"),
    3: .standard(proto: "cloud_provider"),
    4: .same(proto: "region"),
    5: .standard(proto: "user_id"),
    6: .standard(proto: "created_at"),
    7: .standard(proto: "modified_at"),
    8: .same(proto: "visibility"),
    9: .standard(proto: "cluster_type"),
    10: .standard(proto: "managed_by"),
    11: .same(proto: "key"),
  ]

  fileprivate class _StorageClass {
    var _id: String = String()
    var _description_p: String = String()
    var _cloudProvider: Clarifai_Api_CloudProvider? = nil
    var _region: String = String()
    var _userID: String = String()
    var _createdAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _modifiedAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _visibility: Clarifai_Api_Visibility? = nil
    var _clusterType: String = String()
    var _managedBy: String = String()
    var _key: Clarifai_Api_Key? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _id = source._id
      _description_p = source._description_p
      _cloudProvider = source._cloudProvider
      _region = source._region
      _userID = source._userID
      _createdAt = source._createdAt
      _modifiedAt = source._modifiedAt
      _visibility = source._visibility
      _clusterType = source._clusterType
      _managedBy = source._managedBy
      _key = source._key
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._id) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._description_p) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._cloudProvider) }()
        case 4: try { try decoder.decodeSingularStringField(value: &_storage._region) }()
        case 5: try { try decoder.decodeSingularStringField(value: &_storage._userID) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._createdAt) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._modifiedAt) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._visibility) }()
        case 9: try { try decoder.decodeSingularStringField(value: &_storage._clusterType) }()
        case 10: try { try decoder.decodeSingularStringField(value: &_storage._managedBy) }()
        case 11: try { try decoder.decodeSingularMessageField(value: &_storage._key) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._id.isEmpty {
        try visitor.visitSingularStringField(value: _storage._id, fieldNumber: 1)
      }
      if !_storage._description_p.isEmpty {
        try visitor.visitSingularStringField(value: _storage._description_p, fieldNumber: 2)
      }
      try { if let v = _storage._cloudProvider {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      if !_storage._region.isEmpty {
        try visitor.visitSingularStringField(value: _storage._region, fieldNumber: 4)
      }
      if !_storage._userID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._userID, fieldNumber: 5)
      }
      try { if let v = _storage._createdAt {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
      try { if let v = _storage._modifiedAt {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      } }()
      try { if let v = _storage._visibility {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      } }()
      if !_storage._clusterType.isEmpty {
        try visitor.visitSingularStringField(value: _storage._clusterType, fieldNumber: 9)
      }
      if !_storage._managedBy.isEmpty {
        try visitor.visitSingularStringField(value: _storage._managedBy, fieldNumber: 10)
      }
      try { if let v = _storage._key {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_ComputeCluster, rhs: Clarifai_Api_ComputeCluster) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._id != rhs_storage._id {return false}
        if _storage._description_p != rhs_storage._description_p {return false}
        if _storage._cloudProvider != rhs_storage._cloudProvider {return false}
        if _storage._region != rhs_storage._region {return false}
        if _storage._userID != rhs_storage._userID {return false}
        if _storage._createdAt != rhs_storage._createdAt {return false}
        if _storage._modifiedAt != rhs_storage._modifiedAt {return false}
        if _storage._visibility != rhs_storage._visibility {return false}
        if _storage._clusterType != rhs_storage._clusterType {return false}
        if _storage._managedBy != rhs_storage._managedBy {return false}
        if _storage._key != rhs_storage._key {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_ComputeInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ComputeInfo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    6: .standard(proto: "cpu_limit"),
    2: .standard(proto: "cpu_memory"),
    3: .standard(proto: "num_accelerators"),
    4: .standard(proto: "accelerator_memory"),
    5: .standard(proto: "accelerator_type"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeSingularStringField(value: &self.cpuMemory) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.numAccelerators) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.acceleratorMemory) }()
      case 5: try { try decoder.decodeRepeatedStringField(value: &self.acceleratorType) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.cpuLimit) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.cpuMemory.isEmpty {
      try visitor.visitSingularStringField(value: self.cpuMemory, fieldNumber: 2)
    }
    if self.numAccelerators != 0 {
      try visitor.visitSingularUInt32Field(value: self.numAccelerators, fieldNumber: 3)
    }
    if !self.acceleratorMemory.isEmpty {
      try visitor.visitSingularStringField(value: self.acceleratorMemory, fieldNumber: 4)
    }
    if !self.acceleratorType.isEmpty {
      try visitor.visitRepeatedStringField(value: self.acceleratorType, fieldNumber: 5)
    }
    if !self.cpuLimit.isEmpty {
      try visitor.visitSingularStringField(value: self.cpuLimit, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_ComputeInfo, rhs: Clarifai_Api_ComputeInfo) -> Bool {
    if lhs.cpuLimit != rhs.cpuLimit {return false}
    if lhs.cpuMemory != rhs.cpuMemory {return false}
    if lhs.numAccelerators != rhs.numAccelerators {return false}
    if lhs.acceleratorMemory != rhs.acceleratorMemory {return false}
    if lhs.acceleratorType != rhs.acceleratorType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_AutoscaleConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AutoscaleConfig"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "min_replicas"),
    2: .standard(proto: "max_replicas"),
    3: .standard(proto: "traffic_history_seconds"),
    4: .standard(proto: "scale_down_delay_seconds"),
    5: .standard(proto: "scale_up_delay_seconds"),
    7: .standard(proto: "disable_packing"),
    8: .standard(proto: "scale_to_zero_delay_seconds"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.minReplicas) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.maxReplicas) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.trafficHistorySeconds) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self.scaleDownDelaySeconds) }()
      case 5: try { try decoder.decodeSingularUInt32Field(value: &self.scaleUpDelaySeconds) }()
      case 7: try { try decoder.decodeSingularBoolField(value: &self.disablePacking) }()
      case 8: try { try decoder.decodeSingularUInt32Field(value: &self.scaleToZeroDelaySeconds) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.minReplicas != 0 {
      try visitor.visitSingularUInt32Field(value: self.minReplicas, fieldNumber: 1)
    }
    if self.maxReplicas != 0 {
      try visitor.visitSingularUInt32Field(value: self.maxReplicas, fieldNumber: 2)
    }
    if self.trafficHistorySeconds != 0 {
      try visitor.visitSingularUInt32Field(value: self.trafficHistorySeconds, fieldNumber: 3)
    }
    if self.scaleDownDelaySeconds != 0 {
      try visitor.visitSingularUInt32Field(value: self.scaleDownDelaySeconds, fieldNumber: 4)
    }
    if self.scaleUpDelaySeconds != 0 {
      try visitor.visitSingularUInt32Field(value: self.scaleUpDelaySeconds, fieldNumber: 5)
    }
    if self.disablePacking != false {
      try visitor.visitSingularBoolField(value: self.disablePacking, fieldNumber: 7)
    }
    if self.scaleToZeroDelaySeconds != 0 {
      try visitor.visitSingularUInt32Field(value: self.scaleToZeroDelaySeconds, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_AutoscaleConfig, rhs: Clarifai_Api_AutoscaleConfig) -> Bool {
    if lhs.minReplicas != rhs.minReplicas {return false}
    if lhs.maxReplicas != rhs.maxReplicas {return false}
    if lhs.trafficHistorySeconds != rhs.trafficHistorySeconds {return false}
    if lhs.scaleDownDelaySeconds != rhs.scaleDownDelaySeconds {return false}
    if lhs.scaleUpDelaySeconds != rhs.scaleUpDelaySeconds {return false}
    if lhs.disablePacking != rhs.disablePacking {return false}
    if lhs.scaleToZeroDelaySeconds != rhs.scaleToZeroDelaySeconds {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_Deployment: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Deployment"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .standard(proto: "user_id"),
    3: .standard(proto: "autoscale_config"),
    4: .same(proto: "nodepools"),
    7: .standard(proto: "scheduling_choice"),
    8: .same(proto: "visibility"),
    9: .same(proto: "metadata"),
    10: .same(proto: "description"),
    11: .same(proto: "worker"),
    12: .standard(proto: "created_at"),
    13: .standard(proto: "modified_at"),
  ]

  fileprivate class _StorageClass {
    var _id: String = String()
    var _userID: String = String()
    var _autoscaleConfig: Clarifai_Api_AutoscaleConfig? = nil
    var _nodepools: [Clarifai_Api_Nodepool] = []
    var _schedulingChoice: Clarifai_Api_Deployment.SchedulingChoice = .unknownSchedulingChoice
    var _visibility: Clarifai_Api_Visibility? = nil
    var _metadata: SwiftProtobuf.Google_Protobuf_Struct? = nil
    var _description_p: String = String()
    var _worker: Clarifai_Api_Worker? = nil
    var _createdAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _modifiedAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _id = source._id
      _userID = source._userID
      _autoscaleConfig = source._autoscaleConfig
      _nodepools = source._nodepools
      _schedulingChoice = source._schedulingChoice
      _visibility = source._visibility
      _metadata = source._metadata
      _description_p = source._description_p
      _worker = source._worker
      _createdAt = source._createdAt
      _modifiedAt = source._modifiedAt
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._id) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._userID) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._autoscaleConfig) }()
        case 4: try { try decoder.decodeRepeatedMessageField(value: &_storage._nodepools) }()
        case 7: try { try decoder.decodeSingularEnumField(value: &_storage._schedulingChoice) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._visibility) }()
        case 9: try { try decoder.decodeSingularMessageField(value: &_storage._metadata) }()
        case 10: try { try decoder.decodeSingularStringField(value: &_storage._description_p) }()
        case 11: try { try decoder.decodeSingularMessageField(value: &_storage._worker) }()
        case 12: try { try decoder.decodeSingularMessageField(value: &_storage._createdAt) }()
        case 13: try { try decoder.decodeSingularMessageField(value: &_storage._modifiedAt) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._id.isEmpty {
        try visitor.visitSingularStringField(value: _storage._id, fieldNumber: 1)
      }
      if !_storage._userID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._userID, fieldNumber: 2)
      }
      try { if let v = _storage._autoscaleConfig {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      if !_storage._nodepools.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._nodepools, fieldNumber: 4)
      }
      if _storage._schedulingChoice != .unknownSchedulingChoice {
        try visitor.visitSingularEnumField(value: _storage._schedulingChoice, fieldNumber: 7)
      }
      try { if let v = _storage._visibility {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      } }()
      try { if let v = _storage._metadata {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      } }()
      if !_storage._description_p.isEmpty {
        try visitor.visitSingularStringField(value: _storage._description_p, fieldNumber: 10)
      }
      try { if let v = _storage._worker {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      } }()
      try { if let v = _storage._createdAt {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
      } }()
      try { if let v = _storage._modifiedAt {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_Deployment, rhs: Clarifai_Api_Deployment) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._id != rhs_storage._id {return false}
        if _storage._userID != rhs_storage._userID {return false}
        if _storage._autoscaleConfig != rhs_storage._autoscaleConfig {return false}
        if _storage._nodepools != rhs_storage._nodepools {return false}
        if _storage._schedulingChoice != rhs_storage._schedulingChoice {return false}
        if _storage._visibility != rhs_storage._visibility {return false}
        if _storage._metadata != rhs_storage._metadata {return false}
        if _storage._description_p != rhs_storage._description_p {return false}
        if _storage._worker != rhs_storage._worker {return false}
        if _storage._createdAt != rhs_storage._createdAt {return false}
        if _storage._modifiedAt != rhs_storage._modifiedAt {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_Deployment.SchedulingChoice: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN_SCHEDULING_CHOICE"),
    1: .same(proto: "FAIL"),
    2: .same(proto: "RANDOM"),
    3: .same(proto: "PRICE"),
    4: .same(proto: "PERFORMANCE"),
    5: .same(proto: "NETWORK"),
    6: .same(proto: "UTILIZATION"),
    7: .same(proto: "PREFER_SPOT"),
    8: .same(proto: "PREFER_ONDEMAND"),
  ]
}

extension Clarifai_Api_RunnerSelector: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RunnerSelector"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "nodepool"),
    2: .same(proto: "runner"),
    3: .same(proto: "deployment"),
  ]

  fileprivate class _StorageClass {
    var _nodepool: Clarifai_Api_Nodepool? = nil
    var _runner: Clarifai_Api_Runner? = nil
    var _deployment: Clarifai_Api_Deployment? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _nodepool = source._nodepool
      _runner = source._runner
      _deployment = source._deployment
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._nodepool) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._runner) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._deployment) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._nodepool {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._runner {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._deployment {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_RunnerSelector, rhs: Clarifai_Api_RunnerSelector) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._nodepool != rhs_storage._nodepool {return false}
        if _storage._runner != rhs_storage._runner {return false}
        if _storage._deployment != rhs_storage._deployment {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_ProcessingInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ProcessingInfo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "runner_method_type"),
    2: .same(proto: "status"),
    3: .standard(proto: "processing_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.runnerMethodType) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._status) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.processingID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.runnerMethodType != .unknown {
      try visitor.visitSingularEnumField(value: self.runnerMethodType, fieldNumber: 1)
    }
    try { if let v = self._status {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.processingID.isEmpty {
      try visitor.visitSingularStringField(value: self.processingID, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_ProcessingInfo, rhs: Clarifai_Api_ProcessingInfo) -> Bool {
    if lhs.runnerMethodType != rhs.runnerMethodType {return false}
    if lhs._status != rhs._status {return false}
    if lhs.processingID != rhs.processingID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_AuditLogTarget: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AuditLogTarget"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "user"),
    2: .same(proto: "role"),
    3: .same(proto: "team"),
    4: .same(proto: "app"),
    5: .same(proto: "module"),
    6: .standard(proto: "module_version"),
    7: .same(proto: "workflow"),
    8: .standard(proto: "workflow_version"),
    9: .same(proto: "model"),
    10: .standard(proto: "model_version"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Clarifai_Api_User?
        var hadOneofValue = false
        if let current = self.target {
          hadOneofValue = true
          if case .user(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.target = .user(v)
        }
      }()
      case 2: try {
        var v: Clarifai_Api_Role?
        var hadOneofValue = false
        if let current = self.target {
          hadOneofValue = true
          if case .role(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.target = .role(v)
        }
      }()
      case 3: try {
        var v: Clarifai_Api_Team?
        var hadOneofValue = false
        if let current = self.target {
          hadOneofValue = true
          if case .team(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.target = .team(v)
        }
      }()
      case 4: try {
        var v: Clarifai_Api_App?
        var hadOneofValue = false
        if let current = self.target {
          hadOneofValue = true
          if case .app(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.target = .app(v)
        }
      }()
      case 5: try {
        var v: Clarifai_Api_Module?
        var hadOneofValue = false
        if let current = self.target {
          hadOneofValue = true
          if case .module(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.target = .module(v)
        }
      }()
      case 6: try {
        var v: Clarifai_Api_ModuleVersion?
        var hadOneofValue = false
        if let current = self.target {
          hadOneofValue = true
          if case .moduleVersion(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.target = .moduleVersion(v)
        }
      }()
      case 7: try {
        var v: Clarifai_Api_Workflow?
        var hadOneofValue = false
        if let current = self.target {
          hadOneofValue = true
          if case .workflow(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.target = .workflow(v)
        }
      }()
      case 8: try {
        var v: Clarifai_Api_WorkflowVersion?
        var hadOneofValue = false
        if let current = self.target {
          hadOneofValue = true
          if case .workflowVersion(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.target = .workflowVersion(v)
        }
      }()
      case 9: try {
        var v: Clarifai_Api_Model?
        var hadOneofValue = false
        if let current = self.target {
          hadOneofValue = true
          if case .model(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.target = .model(v)
        }
      }()
      case 10: try {
        var v: Clarifai_Api_ModelVersion?
        var hadOneofValue = false
        if let current = self.target {
          hadOneofValue = true
          if case .modelVersion(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.target = .modelVersion(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.target {
    case .user?: try {
      guard case .user(let v)? = self.target else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .role?: try {
      guard case .role(let v)? = self.target else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .team?: try {
      guard case .team(let v)? = self.target else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .app?: try {
      guard case .app(let v)? = self.target else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .module?: try {
      guard case .module(let v)? = self.target else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .moduleVersion?: try {
      guard case .moduleVersion(let v)? = self.target else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case .workflow?: try {
      guard case .workflow(let v)? = self.target else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }()
    case .workflowVersion?: try {
      guard case .workflowVersion(let v)? = self.target else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    }()
    case .model?: try {
      guard case .model(let v)? = self.target else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    }()
    case .modelVersion?: try {
      guard case .modelVersion(let v)? = self.target else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_AuditLogTarget, rhs: Clarifai_Api_AuditLogTarget) -> Bool {
    if lhs.target != rhs.target {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_AuditLogEntry: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AuditLogEntry"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "timestamp"),
    2: .same(proto: "user"),
    3: .same(proto: "operation"),
    4: .same(proto: "description"),
    5: .same(proto: "targets"),
    6: .same(proto: "details"),
    7: .same(proto: "success"),
    8: .standard(proto: "req_id"),
    9: .standard(proto: "source_ip"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._timestamp) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._user) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.operation) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      case 5: try { try decoder.decodeRepeatedMessageField(value: &self.targets) }()
      case 6: try { try decoder.decodeRepeatedStringField(value: &self.details) }()
      case 7: try { try decoder.decodeSingularBoolField(value: &self.success) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self.reqID) }()
      case 9: try { try decoder.decodeSingularStringField(value: &self.sourceIp) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._timestamp {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._user {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if self.operation != .notSet {
      try visitor.visitSingularEnumField(value: self.operation, fieldNumber: 3)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 4)
    }
    if !self.targets.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.targets, fieldNumber: 5)
    }
    if !self.details.isEmpty {
      try visitor.visitRepeatedStringField(value: self.details, fieldNumber: 6)
    }
    if self.success != false {
      try visitor.visitSingularBoolField(value: self.success, fieldNumber: 7)
    }
    if !self.reqID.isEmpty {
      try visitor.visitSingularStringField(value: self.reqID, fieldNumber: 8)
    }
    if !self.sourceIp.isEmpty {
      try visitor.visitSingularStringField(value: self.sourceIp, fieldNumber: 9)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_AuditLogEntry, rhs: Clarifai_Api_AuditLogEntry) -> Bool {
    if lhs._timestamp != rhs._timestamp {return false}
    if lhs._user != rhs._user {return false}
    if lhs.operation != rhs.operation {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.targets != rhs.targets {return false}
    if lhs.details != rhs.details {return false}
    if lhs.success != rhs.success {return false}
    if lhs.reqID != rhs.reqID {return false}
    if lhs.sourceIp != rhs.sourceIp {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_AuditLogQuery: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AuditLogQuery"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "timestamp_from"),
    2: .standard(proto: "timestamp_to"),
    3: .standard(proto: "user_ids"),
    4: .same(proto: "operations"),
    5: .same(proto: "targets"),
    6: .same(proto: "success"),
    7: .standard(proto: "source_ips"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._timestampFrom) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._timestampTo) }()
      case 3: try { try decoder.decodeRepeatedStringField(value: &self.userIds) }()
      case 4: try { try decoder.decodeRepeatedEnumField(value: &self.operations) }()
      case 5: try { try decoder.decodeRepeatedMessageField(value: &self.targets) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._success) }()
      case 7: try { try decoder.decodeRepeatedStringField(value: &self.sourceIps) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._timestampFrom {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._timestampTo {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.userIds.isEmpty {
      try visitor.visitRepeatedStringField(value: self.userIds, fieldNumber: 3)
    }
    if !self.operations.isEmpty {
      try visitor.visitPackedEnumField(value: self.operations, fieldNumber: 4)
    }
    if !self.targets.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.targets, fieldNumber: 5)
    }
    try { if let v = self._success {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    if !self.sourceIps.isEmpty {
      try visitor.visitRepeatedStringField(value: self.sourceIps, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_AuditLogQuery, rhs: Clarifai_Api_AuditLogQuery) -> Bool {
    if lhs._timestampFrom != rhs._timestampFrom {return false}
    if lhs._timestampTo != rhs._timestampTo {return false}
    if lhs.userIds != rhs.userIds {return false}
    if lhs.operations != rhs.operations {return false}
    if lhs.targets != rhs.targets {return false}
    if lhs._success != rhs._success {return false}
    if lhs.sourceIps != rhs.sourceIps {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_WorkflowVersionEvaluationMetric: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".WorkflowVersionEvaluationMetric"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "summary"),
    3: .same(proto: "description"),
    4: .standard(proto: "data_type"),
    5: .standard(proto: "visualisation_type"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.summary) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self.dataType) }()
      case 5: try { try decoder.decodeSingularEnumField(value: &self.visualisationType) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if !self.summary.isEmpty {
      try visitor.visitSingularStringField(value: self.summary, fieldNumber: 2)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 3)
    }
    if self.dataType != .notSet {
      try visitor.visitSingularEnumField(value: self.dataType, fieldNumber: 4)
    }
    if self.visualisationType != .visualizationTypeNotSet {
      try visitor.visitSingularEnumField(value: self.visualisationType, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_WorkflowVersionEvaluationMetric, rhs: Clarifai_Api_WorkflowVersionEvaluationMetric) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.summary != rhs.summary {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.dataType != rhs.dataType {return false}
    if lhs.visualisationType != rhs.visualisationType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_WorkflowVersionEvaluationMetric.DataType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "DATA_TYPE_NOT_SET"),
    1: .same(proto: "FLOAT"),
  ]
}

extension Clarifai_Api_WorkflowVersionEvaluationMetric.VisualisationType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "VISUALIZATION_TYPE_NOT_SET"),
    1: .same(proto: "CONFUSION_MATRIX"),
    2: .same(proto: "PRECISION_RECALL_CURVE"),
    3: .same(proto: "ROC_AUC_CURVE"),
  ]
}

extension Clarifai_Api_WorkflowVersionEvaluationTemplate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".WorkflowVersionEvaluationTemplate"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "description"),
    3: .standard(proto: "task_types"),
    4: .standard(proto: "workflow_version_evaluation_metrics"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      case 3: try { try decoder.decodeRepeatedEnumField(value: &self.taskTypes) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.workflowVersionEvaluationMetrics) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 2)
    }
    if !self.taskTypes.isEmpty {
      try visitor.visitPackedEnumField(value: self.taskTypes, fieldNumber: 3)
    }
    if !self.workflowVersionEvaluationMetrics.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.workflowVersionEvaluationMetrics, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_WorkflowVersionEvaluationTemplate, rhs: Clarifai_Api_WorkflowVersionEvaluationTemplate) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.taskTypes != rhs.taskTypes {return false}
    if lhs.workflowVersionEvaluationMetrics != rhs.workflowVersionEvaluationMetrics {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_WorkflowVersionEvaluationTemplate.TaskType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "TASK_TYPE_NOT_SET"),
    1: .same(proto: "TEXT_CLASSIFICATION"),
  ]
}

extension Clarifai_Api_ComputePlaneMetrics: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ComputePlaneMetrics"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "meta"),
    2: .same(proto: "cloud"),
    3: .same(proto: "region"),
    4: .standard(proto: "instance_type"),
    5: .standard(proto: "reservation_type"),
    6: .standard(proto: "reservation_price"),
    7: .standard(proto: "runtime_s"),
    8: .same(proto: "timestamp"),
    9: .standard(proto: "event_type"),
    10: .standard(proto: "gpu_metrics"),
    11: .same(proto: "hostname"),
    12: .standard(proto: "cpu_metrics"),
  ]

  fileprivate class _StorageClass {
    var _meta: Clarifai_Api_ComputeSourceMetadata? = nil
    var _cloud: String = String()
    var _region: String = String()
    var _instanceType: String = String()
    var _reservationType: String = String()
    var _reservationPrice: Float = 0
    var _runtimeS: Int32 = 0
    var _timestamp: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _eventType: String = String()
    var _gpuMetrics: [Clarifai_Api_GpuMetrics] = []
    var _hostname: String = String()
    var _cpuMetrics: [Clarifai_Api_CpuMetrics] = []

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _meta = source._meta
      _cloud = source._cloud
      _region = source._region
      _instanceType = source._instanceType
      _reservationType = source._reservationType
      _reservationPrice = source._reservationPrice
      _runtimeS = source._runtimeS
      _timestamp = source._timestamp
      _eventType = source._eventType
      _gpuMetrics = source._gpuMetrics
      _hostname = source._hostname
      _cpuMetrics = source._cpuMetrics
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._meta) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._cloud) }()
        case 3: try { try decoder.decodeSingularStringField(value: &_storage._region) }()
        case 4: try { try decoder.decodeSingularStringField(value: &_storage._instanceType) }()
        case 5: try { try decoder.decodeSingularStringField(value: &_storage._reservationType) }()
        case 6: try { try decoder.decodeSingularFloatField(value: &_storage._reservationPrice) }()
        case 7: try { try decoder.decodeSingularInt32Field(value: &_storage._runtimeS) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._timestamp) }()
        case 9: try { try decoder.decodeSingularStringField(value: &_storage._eventType) }()
        case 10: try { try decoder.decodeRepeatedMessageField(value: &_storage._gpuMetrics) }()
        case 11: try { try decoder.decodeSingularStringField(value: &_storage._hostname) }()
        case 12: try { try decoder.decodeRepeatedMessageField(value: &_storage._cpuMetrics) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._meta {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      if !_storage._cloud.isEmpty {
        try visitor.visitSingularStringField(value: _storage._cloud, fieldNumber: 2)
      }
      if !_storage._region.isEmpty {
        try visitor.visitSingularStringField(value: _storage._region, fieldNumber: 3)
      }
      if !_storage._instanceType.isEmpty {
        try visitor.visitSingularStringField(value: _storage._instanceType, fieldNumber: 4)
      }
      if !_storage._reservationType.isEmpty {
        try visitor.visitSingularStringField(value: _storage._reservationType, fieldNumber: 5)
      }
      if _storage._reservationPrice != 0 {
        try visitor.visitSingularFloatField(value: _storage._reservationPrice, fieldNumber: 6)
      }
      if _storage._runtimeS != 0 {
        try visitor.visitSingularInt32Field(value: _storage._runtimeS, fieldNumber: 7)
      }
      try { if let v = _storage._timestamp {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      } }()
      if !_storage._eventType.isEmpty {
        try visitor.visitSingularStringField(value: _storage._eventType, fieldNumber: 9)
      }
      if !_storage._gpuMetrics.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._gpuMetrics, fieldNumber: 10)
      }
      if !_storage._hostname.isEmpty {
        try visitor.visitSingularStringField(value: _storage._hostname, fieldNumber: 11)
      }
      if !_storage._cpuMetrics.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._cpuMetrics, fieldNumber: 12)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_ComputePlaneMetrics, rhs: Clarifai_Api_ComputePlaneMetrics) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._meta != rhs_storage._meta {return false}
        if _storage._cloud != rhs_storage._cloud {return false}
        if _storage._region != rhs_storage._region {return false}
        if _storage._instanceType != rhs_storage._instanceType {return false}
        if _storage._reservationType != rhs_storage._reservationType {return false}
        if _storage._reservationPrice != rhs_storage._reservationPrice {return false}
        if _storage._runtimeS != rhs_storage._runtimeS {return false}
        if _storage._timestamp != rhs_storage._timestamp {return false}
        if _storage._eventType != rhs_storage._eventType {return false}
        if _storage._gpuMetrics != rhs_storage._gpuMetrics {return false}
        if _storage._hostname != rhs_storage._hostname {return false}
        if _storage._cpuMetrics != rhs_storage._cpuMetrics {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_GpuMetrics: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GpuMetrics"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "uuid"),
    2: .standard(proto: "model_name"),
    3: .standard(proto: "utilization_pct"),
    4: .standard(proto: "tensor_utilization_pct"),
    5: .standard(proto: "memory_utilization_pct"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.uuid) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.modelName) }()
      case 3: try { try decoder.decodeSingularFloatField(value: &self.utilizationPct) }()
      case 4: try { try decoder.decodeSingularFloatField(value: &self.tensorUtilizationPct) }()
      case 5: try { try decoder.decodeSingularFloatField(value: &self.memoryUtilizationPct) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.uuid.isEmpty {
      try visitor.visitSingularStringField(value: self.uuid, fieldNumber: 1)
    }
    if !self.modelName.isEmpty {
      try visitor.visitSingularStringField(value: self.modelName, fieldNumber: 2)
    }
    if self.utilizationPct != 0 {
      try visitor.visitSingularFloatField(value: self.utilizationPct, fieldNumber: 3)
    }
    if self.tensorUtilizationPct != 0 {
      try visitor.visitSingularFloatField(value: self.tensorUtilizationPct, fieldNumber: 4)
    }
    if self.memoryUtilizationPct != 0 {
      try visitor.visitSingularFloatField(value: self.memoryUtilizationPct, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_GpuMetrics, rhs: Clarifai_Api_GpuMetrics) -> Bool {
    if lhs.uuid != rhs.uuid {return false}
    if lhs.modelName != rhs.modelName {return false}
    if lhs.utilizationPct != rhs.utilizationPct {return false}
    if lhs.tensorUtilizationPct != rhs.tensorUtilizationPct {return false}
    if lhs.memoryUtilizationPct != rhs.memoryUtilizationPct {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_CpuMetrics: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CpuMetrics"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "timestamp"),
    2: .standard(proto: "cpu_utilization_pct"),
    3: .standard(proto: "memory_utilization_pct"),
    4: .same(proto: "millicores"),
    5: .standard(proto: "memory_bytes"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._timestamp) }()
      case 2: try { try decoder.decodeSingularFloatField(value: &self.cpuUtilizationPct) }()
      case 3: try { try decoder.decodeSingularFloatField(value: &self.memoryUtilizationPct) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.millicores) }()
      case 5: try { try decoder.decodeSingularInt64Field(value: &self.memoryBytes) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._timestamp {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.cpuUtilizationPct != 0 {
      try visitor.visitSingularFloatField(value: self.cpuUtilizationPct, fieldNumber: 2)
    }
    if self.memoryUtilizationPct != 0 {
      try visitor.visitSingularFloatField(value: self.memoryUtilizationPct, fieldNumber: 3)
    }
    if self.millicores != 0 {
      try visitor.visitSingularInt64Field(value: self.millicores, fieldNumber: 4)
    }
    if self.memoryBytes != 0 {
      try visitor.visitSingularInt64Field(value: self.memoryBytes, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_CpuMetrics, rhs: Clarifai_Api_CpuMetrics) -> Bool {
    if lhs._timestamp != rhs._timestamp {return false}
    if lhs.cpuUtilizationPct != rhs.cpuUtilizationPct {return false}
    if lhs.memoryUtilizationPct != rhs.memoryUtilizationPct {return false}
    if lhs.millicores != rhs.millicores {return false}
    if lhs.memoryBytes != rhs.memoryBytes {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_LogEntry: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LogEntry"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "message"),
    2: .standard(proto: "log_type"),
    3: .same(proto: "url"),
    9: .same(proto: "meta"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.message) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.logType) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.url) }()
      case 9: try { try decoder.decodeSingularMessageField(value: &self._meta) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 1)
    }
    if !self.logType.isEmpty {
      try visitor.visitSingularStringField(value: self.logType, fieldNumber: 2)
    }
    if !self.url.isEmpty {
      try visitor.visitSingularStringField(value: self.url, fieldNumber: 3)
    }
    try { if let v = self._meta {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_LogEntry, rhs: Clarifai_Api_LogEntry) -> Bool {
    if lhs.message != rhs.message {return false}
    if lhs.logType != rhs.logType {return false}
    if lhs.url != rhs.url {return false}
    if lhs._meta != rhs._meta {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_ComputeSourceMetadata: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ComputeSourceMetadata"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_app_id"),
    2: .standard(proto: "model_id"),
    3: .standard(proto: "model_version_id"),
    4: .standard(proto: "workflow_id"),
    6: .standard(proto: "compute_cluster_id"),
    7: .standard(proto: "nodepool_id"),
    8: .standard(proto: "runner_id"),
    9: .standard(proto: "pipeline_id"),
    10: .standard(proto: "pipeline_version_id"),
    11: .standard(proto: "pipeline_version_run_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._userAppID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.modelID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.modelVersionID) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.workflowID) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.computeClusterID) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.nodepoolID) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self.runnerID) }()
      case 9: try { try decoder.decodeSingularStringField(value: &self.pipelineID) }()
      case 10: try { try decoder.decodeSingularStringField(value: &self.pipelineVersionID) }()
      case 11: try { try decoder.decodeSingularStringField(value: &self.pipelineVersionRunID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._userAppID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.modelID.isEmpty {
      try visitor.visitSingularStringField(value: self.modelID, fieldNumber: 2)
    }
    if !self.modelVersionID.isEmpty {
      try visitor.visitSingularStringField(value: self.modelVersionID, fieldNumber: 3)
    }
    if !self.workflowID.isEmpty {
      try visitor.visitSingularStringField(value: self.workflowID, fieldNumber: 4)
    }
    if !self.computeClusterID.isEmpty {
      try visitor.visitSingularStringField(value: self.computeClusterID, fieldNumber: 6)
    }
    if !self.nodepoolID.isEmpty {
      try visitor.visitSingularStringField(value: self.nodepoolID, fieldNumber: 7)
    }
    if !self.runnerID.isEmpty {
      try visitor.visitSingularStringField(value: self.runnerID, fieldNumber: 8)
    }
    if !self.pipelineID.isEmpty {
      try visitor.visitSingularStringField(value: self.pipelineID, fieldNumber: 9)
    }
    if !self.pipelineVersionID.isEmpty {
      try visitor.visitSingularStringField(value: self.pipelineVersionID, fieldNumber: 10)
    }
    if !self.pipelineVersionRunID.isEmpty {
      try visitor.visitSingularStringField(value: self.pipelineVersionRunID, fieldNumber: 11)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_ComputeSourceMetadata, rhs: Clarifai_Api_ComputeSourceMetadata) -> Bool {
    if lhs._userAppID != rhs._userAppID {return false}
    if lhs.modelID != rhs.modelID {return false}
    if lhs.modelVersionID != rhs.modelVersionID {return false}
    if lhs.workflowID != rhs.workflowID {return false}
    if lhs.computeClusterID != rhs.computeClusterID {return false}
    if lhs.nodepoolID != rhs.nodepoolID {return false}
    if lhs.runnerID != rhs.runnerID {return false}
    if lhs.pipelineID != rhs.pipelineID {return false}
    if lhs.pipelineVersionID != rhs.pipelineVersionID {return false}
    if lhs.pipelineVersionRunID != rhs.pipelineVersionRunID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_WorkflowVersionEvaluation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".WorkflowVersionEvaluation"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .standard(proto: "workflow_id"),
    3: .standard(proto: "workflow_version_id"),
    4: .standard(proto: "ground_truth_dataset_id"),
    5: .standard(proto: "ground_truth_dataset_version_id"),
    6: .standard(proto: "predictions_dataset_id"),
    7: .standard(proto: "predictions_dataset_version_id"),
    8: .standard(proto: "evaluation_template_id"),
    9: .standard(proto: "workflow_evaluation_result"),
    10: .same(proto: "status"),
    11: .standard(proto: "created_at"),
    12: .standard(proto: "modified_at"),
    13: .standard(proto: "target_node_id"),
  ]

  fileprivate class _StorageClass {
    var _id: String = String()
    var _workflowID: String = String()
    var _workflowVersionID: String = String()
    var _groundTruthDatasetID: String = String()
    var _groundTruthDatasetVersionID: String = String()
    var _predictionsDatasetID: String = String()
    var _predictionsDatasetVersionID: String = String()
    var _evaluationTemplateID: String = String()
    var _workflowEvaluationResult: Clarifai_Api_WorkflowEvaluationResult? = nil
    var _status: Clarifai_Api_Status_Status? = nil
    var _createdAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _modifiedAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _targetNodeID: String = String()

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _id = source._id
      _workflowID = source._workflowID
      _workflowVersionID = source._workflowVersionID
      _groundTruthDatasetID = source._groundTruthDatasetID
      _groundTruthDatasetVersionID = source._groundTruthDatasetVersionID
      _predictionsDatasetID = source._predictionsDatasetID
      _predictionsDatasetVersionID = source._predictionsDatasetVersionID
      _evaluationTemplateID = source._evaluationTemplateID
      _workflowEvaluationResult = source._workflowEvaluationResult
      _status = source._status
      _createdAt = source._createdAt
      _modifiedAt = source._modifiedAt
      _targetNodeID = source._targetNodeID
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._id) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._workflowID) }()
        case 3: try { try decoder.decodeSingularStringField(value: &_storage._workflowVersionID) }()
        case 4: try { try decoder.decodeSingularStringField(value: &_storage._groundTruthDatasetID) }()
        case 5: try { try decoder.decodeSingularStringField(value: &_storage._groundTruthDatasetVersionID) }()
        case 6: try { try decoder.decodeSingularStringField(value: &_storage._predictionsDatasetID) }()
        case 7: try { try decoder.decodeSingularStringField(value: &_storage._predictionsDatasetVersionID) }()
        case 8: try { try decoder.decodeSingularStringField(value: &_storage._evaluationTemplateID) }()
        case 9: try { try decoder.decodeSingularMessageField(value: &_storage._workflowEvaluationResult) }()
        case 10: try { try decoder.decodeSingularMessageField(value: &_storage._status) }()
        case 11: try { try decoder.decodeSingularMessageField(value: &_storage._createdAt) }()
        case 12: try { try decoder.decodeSingularMessageField(value: &_storage._modifiedAt) }()
        case 13: try { try decoder.decodeSingularStringField(value: &_storage._targetNodeID) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._id.isEmpty {
        try visitor.visitSingularStringField(value: _storage._id, fieldNumber: 1)
      }
      if !_storage._workflowID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._workflowID, fieldNumber: 2)
      }
      if !_storage._workflowVersionID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._workflowVersionID, fieldNumber: 3)
      }
      if !_storage._groundTruthDatasetID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._groundTruthDatasetID, fieldNumber: 4)
      }
      if !_storage._groundTruthDatasetVersionID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._groundTruthDatasetVersionID, fieldNumber: 5)
      }
      if !_storage._predictionsDatasetID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._predictionsDatasetID, fieldNumber: 6)
      }
      if !_storage._predictionsDatasetVersionID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._predictionsDatasetVersionID, fieldNumber: 7)
      }
      if !_storage._evaluationTemplateID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._evaluationTemplateID, fieldNumber: 8)
      }
      try { if let v = _storage._workflowEvaluationResult {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      } }()
      try { if let v = _storage._status {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      } }()
      try { if let v = _storage._createdAt {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      } }()
      try { if let v = _storage._modifiedAt {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
      } }()
      if !_storage._targetNodeID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._targetNodeID, fieldNumber: 13)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_WorkflowVersionEvaluation, rhs: Clarifai_Api_WorkflowVersionEvaluation) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._id != rhs_storage._id {return false}
        if _storage._workflowID != rhs_storage._workflowID {return false}
        if _storage._workflowVersionID != rhs_storage._workflowVersionID {return false}
        if _storage._groundTruthDatasetID != rhs_storage._groundTruthDatasetID {return false}
        if _storage._groundTruthDatasetVersionID != rhs_storage._groundTruthDatasetVersionID {return false}
        if _storage._predictionsDatasetID != rhs_storage._predictionsDatasetID {return false}
        if _storage._predictionsDatasetVersionID != rhs_storage._predictionsDatasetVersionID {return false}
        if _storage._evaluationTemplateID != rhs_storage._evaluationTemplateID {return false}
        if _storage._workflowEvaluationResult != rhs_storage._workflowEvaluationResult {return false}
        if _storage._status != rhs_storage._status {return false}
        if _storage._createdAt != rhs_storage._createdAt {return false}
        if _storage._modifiedAt != rhs_storage._modifiedAt {return false}
        if _storage._targetNodeID != rhs_storage._targetNodeID {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_WorkflowEvaluationResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".WorkflowEvaluationResult"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "summary"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._summary) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._summary {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_WorkflowEvaluationResult, rhs: Clarifai_Api_WorkflowEvaluationResult) -> Bool {
    if lhs._summary != rhs._summary {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_WorkflowEvaluationResultSummary: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".WorkflowEvaluationResultSummary"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .standard(proto: "evaluation_metric_values"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.evaluationMetricValues) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.evaluationMetricValues.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.evaluationMetricValues, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_WorkflowEvaluationResultSummary, rhs: Clarifai_Api_WorkflowEvaluationResultSummary) -> Bool {
    if lhs.evaluationMetricValues != rhs.evaluationMetricValues {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_EvaluationMetricValue: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".EvaluationMetricValue"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "evaluation_metric_id"),
    2: .standard(proto: "metric_value"),
    3: .same(proto: "explanation"),
    4: .standard(proto: "per_concept_values"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.evaluationMetricID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._metricValue) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.explanation) }()
      case 4: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Clarifai_Api_MetricValue>.self, value: &self.perConceptValues) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.evaluationMetricID.isEmpty {
      try visitor.visitSingularStringField(value: self.evaluationMetricID, fieldNumber: 1)
    }
    try { if let v = self._metricValue {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.explanation.isEmpty {
      try visitor.visitSingularStringField(value: self.explanation, fieldNumber: 3)
    }
    if !self.perConceptValues.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Clarifai_Api_MetricValue>.self, value: self.perConceptValues, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_EvaluationMetricValue, rhs: Clarifai_Api_EvaluationMetricValue) -> Bool {
    if lhs.evaluationMetricID != rhs.evaluationMetricID {return false}
    if lhs._metricValue != rhs._metricValue {return false}
    if lhs.explanation != rhs.explanation {return false}
    if lhs.perConceptValues != rhs.perConceptValues {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_MetricValue: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MetricValue"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "string_value"),
    2: .standard(proto: "float_value"),
    3: .standard(proto: "int_value"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.metricValue != nil {try decoder.handleConflictingOneOf()}
          self.metricValue = .stringValue(v)
        }
      }()
      case 2: try {
        var v: Float?
        try decoder.decodeSingularFloatField(value: &v)
        if let v = v {
          if self.metricValue != nil {try decoder.handleConflictingOneOf()}
          self.metricValue = .floatValue(v)
        }
      }()
      case 3: try {
        var v: Int32?
        try decoder.decodeSingularInt32Field(value: &v)
        if let v = v {
          if self.metricValue != nil {try decoder.handleConflictingOneOf()}
          self.metricValue = .intValue(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.metricValue {
    case .stringValue?: try {
      guard case .stringValue(let v)? = self.metricValue else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }()
    case .floatValue?: try {
      guard case .floatValue(let v)? = self.metricValue else { preconditionFailure() }
      try visitor.visitSingularFloatField(value: v, fieldNumber: 2)
    }()
    case .intValue?: try {
      guard case .intValue(let v)? = self.metricValue else { preconditionFailure() }
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_MetricValue, rhs: Clarifai_Api_MetricValue) -> Bool {
    if lhs.metricValue != rhs.metricValue {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_ArgoOrchestrationSpec: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ArgoOrchestrationSpec"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .standard(proto: "api_version"),
    3: .standard(proto: "spec_json"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeSingularStringField(value: &self.apiVersion) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.specJson) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.apiVersion.isEmpty {
      try visitor.visitSingularStringField(value: self.apiVersion, fieldNumber: 2)
    }
    if !self.specJson.isEmpty {
      try visitor.visitSingularStringField(value: self.specJson, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_ArgoOrchestrationSpec, rhs: Clarifai_Api_ArgoOrchestrationSpec) -> Bool {
    if lhs.apiVersion != rhs.apiVersion {return false}
    if lhs.specJson != rhs.specJson {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_OrchestrationSpec: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".OrchestrationSpec"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "argo_orchestration_spec"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Clarifai_Api_ArgoOrchestrationSpec?
        var hadOneofValue = false
        if let current = self.orchestration {
          hadOneofValue = true
          if case .argoOrchestrationSpec(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.orchestration = .argoOrchestrationSpec(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if case .argoOrchestrationSpec(let v)? = self.orchestration {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_OrchestrationSpec, rhs: Clarifai_Api_OrchestrationSpec) -> Bool {
    if lhs.orchestration != rhs.orchestration {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_PipelineVersion: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PipelineVersion"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .standard(proto: "app_id"),
    3: .standard(proto: "user_id"),
    4: .standard(proto: "orchestration_spec"),
    5: .standard(proto: "pipeline_id"),
    6: .same(proto: "description"),
    7: .same(proto: "visibility"),
    8: .same(proto: "metadata"),
    9: .standard(proto: "created_at"),
    10: .standard(proto: "modified_at"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.appID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.userID) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._orchestrationSpec) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.pipelineID) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      case 7: try { try decoder.decodeSingularMessageField(value: &self._visibility) }()
      case 8: try { try decoder.decodeSingularMessageField(value: &self._metadata) }()
      case 9: try { try decoder.decodeSingularMessageField(value: &self._createdAt) }()
      case 10: try { try decoder.decodeSingularMessageField(value: &self._modifiedAt) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if !self.appID.isEmpty {
      try visitor.visitSingularStringField(value: self.appID, fieldNumber: 2)
    }
    if !self.userID.isEmpty {
      try visitor.visitSingularStringField(value: self.userID, fieldNumber: 3)
    }
    try { if let v = self._orchestrationSpec {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    if !self.pipelineID.isEmpty {
      try visitor.visitSingularStringField(value: self.pipelineID, fieldNumber: 5)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 6)
    }
    try { if let v = self._visibility {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    } }()
    try { if let v = self._metadata {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    } }()
    try { if let v = self._createdAt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    } }()
    try { if let v = self._modifiedAt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_PipelineVersion, rhs: Clarifai_Api_PipelineVersion) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.appID != rhs.appID {return false}
    if lhs.userID != rhs.userID {return false}
    if lhs._orchestrationSpec != rhs._orchestrationSpec {return false}
    if lhs.pipelineID != rhs.pipelineID {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs._visibility != rhs._visibility {return false}
    if lhs._metadata != rhs._metadata {return false}
    if lhs._createdAt != rhs._createdAt {return false}
    if lhs._modifiedAt != rhs._modifiedAt {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_OrchestrationStatus: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".OrchestrationStatus"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "argo_status"),
    2: .same(proto: "status"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Clarifai_Api_ArgoOrchestrationStatus?
        var hadOneofValue = false
        if let current = self.statusDetails {
          hadOneofValue = true
          if case .argoStatus(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.statusDetails = .argoStatus(v)
        }
      }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._status) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if case .argoStatus(let v)? = self.statusDetails {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._status {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_OrchestrationStatus, rhs: Clarifai_Api_OrchestrationStatus) -> Bool {
    if lhs.statusDetails != rhs.statusDetails {return false}
    if lhs._status != rhs._status {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_ArgoOrchestrationStatus: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ArgoOrchestrationStatus"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.status) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.status.isEmpty {
      try visitor.visitSingularStringField(value: self.status, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_ArgoOrchestrationStatus, rhs: Clarifai_Api_ArgoOrchestrationStatus) -> Bool {
    if lhs.status != rhs.status {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_PipelineVersionRun: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PipelineVersionRun"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .standard(proto: "pipeline_version"),
    3: .same(proto: "nodepools"),
    4: .standard(proto: "orchestration_status"),
    5: .standard(proto: "user_id"),
    6: .standard(proto: "app_id"),
  ]

  fileprivate class _StorageClass {
    var _id: String = String()
    var _pipelineVersion: Clarifai_Api_PipelineVersion? = nil
    var _nodepools: [Clarifai_Api_Nodepool] = []
    var _orchestrationStatus: Clarifai_Api_OrchestrationStatus? = nil
    var _userID: String = String()
    var _appID: String = String()

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _id = source._id
      _pipelineVersion = source._pipelineVersion
      _nodepools = source._nodepools
      _orchestrationStatus = source._orchestrationStatus
      _userID = source._userID
      _appID = source._appID
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._id) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._pipelineVersion) }()
        case 3: try { try decoder.decodeRepeatedMessageField(value: &_storage._nodepools) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._orchestrationStatus) }()
        case 5: try { try decoder.decodeSingularStringField(value: &_storage._userID) }()
        case 6: try { try decoder.decodeSingularStringField(value: &_storage._appID) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._id.isEmpty {
        try visitor.visitSingularStringField(value: _storage._id, fieldNumber: 1)
      }
      try { if let v = _storage._pipelineVersion {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      if !_storage._nodepools.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._nodepools, fieldNumber: 3)
      }
      try { if let v = _storage._orchestrationStatus {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      if !_storage._userID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._userID, fieldNumber: 5)
      }
      if !_storage._appID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._appID, fieldNumber: 6)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_PipelineVersionRun, rhs: Clarifai_Api_PipelineVersionRun) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._id != rhs_storage._id {return false}
        if _storage._pipelineVersion != rhs_storage._pipelineVersion {return false}
        if _storage._nodepools != rhs_storage._nodepools {return false}
        if _storage._orchestrationStatus != rhs_storage._orchestrationStatus {return false}
        if _storage._userID != rhs_storage._userID {return false}
        if _storage._appID != rhs_storage._appID {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
