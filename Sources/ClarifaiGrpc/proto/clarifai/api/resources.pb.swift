// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: proto/clarifai/api/resources.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

public enum Clarifai_Api_ExpirationAction: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case notSet // = 0

  /// Progressively delay the execution of operations
  case delay // = 1

  /// Cease functioning
  case expiry // = 2
  case UNRECOGNIZED(Int)

  public init() {
    self = .notSet
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .notSet
    case 1: self = .delay
    case 2: self = .expiry
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .notSet: return 0
    case .delay: return 1
    case .expiry: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Clarifai_Api_ExpirationAction: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Clarifai_Api_ExpirationAction] = [
    .notSet,
    .delay,
    .expiry,
  ]
}

#endif  // swift(>=4.2)

public enum Clarifai_Api_LicenseScope: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case notSet // = 0
  case predict // = 1
  case train // = 2
  case search // = 3
  case UNRECOGNIZED(Int)

  public init() {
    self = .notSet
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .notSet
    case 1: self = .predict
    case 2: self = .train
    case 3: self = .search
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .notSet: return 0
    case .predict: return 1
    case .train: return 2
    case .search: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Clarifai_Api_LicenseScope: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Clarifai_Api_LicenseScope] = [
    .notSet,
    .predict,
    .train,
    .search,
  ]
}

#endif  // swift(>=4.2)

public enum Clarifai_Api_ValueComparator: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case conceptThresholdNotSet // = 0

  /// input > value
  case greaterThan // = 1

  /// input >= value
  case greaterThanOrEqual // = 2

  /// input < value
  case lessThan // = 3

  /// input <= value
  case lessThanOrEqual // = 4

  /// input == value
  case equal // = 5
  case UNRECOGNIZED(Int)

  public init() {
    self = .conceptThresholdNotSet
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .conceptThresholdNotSet
    case 1: self = .greaterThan
    case 2: self = .greaterThanOrEqual
    case 3: self = .lessThan
    case 4: self = .lessThanOrEqual
    case 5: self = .equal
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .conceptThresholdNotSet: return 0
    case .greaterThan: return 1
    case .greaterThanOrEqual: return 2
    case .lessThan: return 3
    case .lessThanOrEqual: return 4
    case .equal: return 5
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Clarifai_Api_ValueComparator: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Clarifai_Api_ValueComparator] = [
    .conceptThresholdNotSet,
    .greaterThan,
    .greaterThanOrEqual,
    .lessThan,
    .lessThanOrEqual,
    .equal,
  ]
}

#endif  // swift(>=4.2)

public enum Clarifai_Api_EvaluationType: SwiftProtobuf.Enum {
  public typealias RawValue = Int

  /// default
  case classification // = 0
  case detection // = 1
  case UNRECOGNIZED(Int)

  public init() {
    self = .classification
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .classification
    case 1: self = .detection
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .classification: return 0
    case .detection: return 1
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Clarifai_Api_EvaluationType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Clarifai_Api_EvaluationType] = [
    .classification,
    .detection,
  ]
}

#endif  // swift(>=4.2)

public enum Clarifai_Api_APIEventType: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case notSet // = 0

  /// On Prem event types
  case onPremPredict // = 1
  case onPremTrain // = 2
  case onPremSearch // = 3
  case UNRECOGNIZED(Int)

  public init() {
    self = .notSet
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .notSet
    case 1: self = .onPremPredict
    case 2: self = .onPremTrain
    case 3: self = .onPremSearch
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .notSet: return 0
    case .onPremPredict: return 1
    case .onPremTrain: return 2
    case .onPremSearch: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Clarifai_Api_APIEventType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Clarifai_Api_APIEventType] = [
    .notSet,
    .onPremPredict,
    .onPremTrain,
    .onPremSearch,
  ]
}

#endif  // swift(>=4.2)

public enum Clarifai_Api_UsageIntervalType: SwiftProtobuf.Enum {
  public typealias RawValue = Int

  /// undef UsageIntervalType is so that the interval field can be forced to be included
  case undef // = 0
  case day // = 1
  case month // = 2
  case year // = 3
  case UNRECOGNIZED(Int)

  public init() {
    self = .undef
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .undef
    case 1: self = .day
    case 2: self = .month
    case 3: self = .year
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .undef: return 0
    case .day: return 1
    case .month: return 2
    case .year: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Clarifai_Api_UsageIntervalType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Clarifai_Api_UsageIntervalType] = [
    .undef,
    .day,
    .month,
    .year,
  ]
}

#endif  // swift(>=4.2)

public enum Clarifai_Api_StatValueAggType: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case sum // = 0
  case avg // = 1
  case UNRECOGNIZED(Int)

  public init() {
    self = .sum
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .sum
    case 1: self = .avg
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .sum: return 0
    case .avg: return 1
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Clarifai_Api_StatValueAggType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Clarifai_Api_StatValueAggType] = [
    .sum,
    .avg,
  ]
}

#endif  // swift(>=4.2)

public enum Clarifai_Api_StatTimeAggType: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case noTimeAgg // = 0
  case year // = 1
  case month // = 2
  case week // = 3
  case day // = 4
  case hour // = 5
  case minute // = 6
  case UNRECOGNIZED(Int)

  public init() {
    self = .noTimeAgg
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .noTimeAgg
    case 1: self = .year
    case 2: self = .month
    case 3: self = .week
    case 4: self = .day
    case 5: self = .hour
    case 6: self = .minute
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .noTimeAgg: return 0
    case .year: return 1
    case .month: return 2
    case .week: return 3
    case .day: return 4
    case .hour: return 5
    case .minute: return 6
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Clarifai_Api_StatTimeAggType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Clarifai_Api_StatTimeAggType] = [
    .noTimeAgg,
    .year,
    .month,
    .week,
    .day,
    .hour,
    .minute,
  ]
}

#endif  // swift(>=4.2)

/////////////////////////////////////////////////////////////////////////////////
/// Messages from /proto/clarifai/api/annotation.proto
/////////////////////////////////////////////////////////////////////////////////
public struct Clarifai_Api_Annotation {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The ID for the annotation
  public var id: String = String()

  /// ID of the input this annotation is tied to
  public var inputID: String = String()

  /// The data passed along in this annotation.
  public var data: Clarifai_Api_Data {
    get {return _data ?? Clarifai_Api_Data()}
    set {_data = newValue}
  }
  /// Returns true if `data` has been explicitly set.
  public var hasData: Bool {return self._data != nil}
  /// Clears the value of `data`. Subsequent reads from it will return its default value.
  public mutating func clearData() {self._data = nil}

  public var annotationInfo: SwiftProtobuf.Google_Protobuf_Struct {
    get {return _annotationInfo ?? SwiftProtobuf.Google_Protobuf_Struct()}
    set {_annotationInfo = newValue}
  }
  /// Returns true if `annotationInfo` has been explicitly set.
  public var hasAnnotationInfo: Bool {return self._annotationInfo != nil}
  /// Clears the value of `annotationInfo`. Subsequent reads from it will return its default value.
  public mutating func clearAnnotationInfo() {self._annotationInfo = nil}

  /// ID of the user this annotation is created by
  public var userID: String = String()

  /// ID of the model version this annotation is created by
  public var modelVersionID: String = String()

  /// The embedding model version used make this annotation available for search and training
  /// Note that an annotation always have an 'embed_model_version_id' even if it is For human
  /// produced annotations i.e. if its worker is of type 'human' or 'app_owner'.
  public var embedModelVersionID: String = String()

  /// Annotation Status
  public var status: Clarifai_Api_Status_Status {
    get {return _status ?? Clarifai_Api_Status_Status()}
    set {_status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  public var hasStatus: Bool {return self._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  public mutating func clearStatus() {self._status = nil}

  /// When the annotation was created. We follow the XXXX timestamp
  /// format. We use https://www.ietf.org/rfc/rfc3339.txt format:
  /// "2006-01-02T15:04:05.999999Z" so you can expect results like
  /// the following from the API:
  /// "2017-04-11T21:50:50.223962Z"
  public var createdAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _createdAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_createdAt = newValue}
  }
  /// Returns true if `createdAt` has been explicitly set.
  public var hasCreatedAt: Bool {return self._createdAt != nil}
  /// Clears the value of `createdAt`. Subsequent reads from it will return its default value.
  public mutating func clearCreatedAt() {self._createdAt = nil}

  /// When the annotation was modified.
  public var modifiedAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _modifiedAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_modifiedAt = newValue}
  }
  /// Returns true if `modifiedAt` has been explicitly set.
  public var hasModifiedAt: Bool {return self._modifiedAt != nil}
  /// Clears the value of `modifiedAt`. Subsequent reads from it will return its default value.
  public mutating func clearModifiedAt() {self._modifiedAt = nil}

  /// Whether or not this annotation is trusted
  /// Will be deprecated
  public var trusted: Bool = false

  /// Is this the input level annotation.
  public var inputLevel: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _data: Clarifai_Api_Data? = nil
  fileprivate var _annotationInfo: SwiftProtobuf.Google_Protobuf_Struct? = nil
  fileprivate var _status: Clarifai_Api_Status_Status? = nil
  fileprivate var _createdAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _modifiedAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

/////////////////////////////////////////////////////////////////////////////////
/// Messages from /proto/clarifai/api/app.proto
/////////////////////////////////////////////////////////////////////////////////
public struct Clarifai_Api_App {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: String = String()

  public var name: String = String()

  public var defaultLanguage: String = String()

  public var defaultWorkflowID: String = String()

  public var userID: String = String()

  /// When the app was created. We follow the XXXX timestamp
  /// format. We use https://www.ietf.org/rfc/rfc3339.txt format:
  /// "2006-01-02T15:04:05.999999Z" so you can expect results like
  /// the following from the API:
  /// "2017-04-11T21:50:50.223962Z"
  public var createdAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _createdAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_createdAt = newValue}
  }
  /// Returns true if `createdAt` has been explicitly set.
  public var hasCreatedAt: Bool {return self._createdAt != nil}
  /// Clears the value of `createdAt`. Subsequent reads from it will return its default value.
  public mutating func clearCreatedAt() {self._createdAt = nil}

  /// if user accept legal consent for face recognition
  public var legalConsentStatus: UInt32 = 0

  /// To handle arbitrary json metadata you can use a struct field:
  /// https://github.com/google/protobuf/blob/master/src/google/protobuf/struct.proto
  public var metadata: SwiftProtobuf.Google_Protobuf_Struct {
    get {return _metadata ?? SwiftProtobuf.Google_Protobuf_Struct()}
    set {_metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  public var hasMetadata: Bool {return self._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  public mutating func clearMetadata() {self._metadata = nil}

  /// short description about the app.
  public var description_p: String = String()

  /// Default value for model predictions on video: Sample delay for video predicting (1 frame per N milliseconds)
  public var sampleMs: UInt32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _createdAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _metadata: SwiftProtobuf.Google_Protobuf_Struct? = nil
}

public struct Clarifai_Api_AppQuery {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The name of the field. This supports wildcard queries like "gen*" to match "general" as an example.
  public var name: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/////////////////////////////////////////////////////////////////////////////////
/// Messages from /proto/clarifai/api/app_sharing.proto
/////////////////////////////////////////////////////////////////////////////////
public struct Clarifai_Api_Collaborator {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///id of this collaborator
  public var id: String = String()

  ///the app this collaborator has access to
  public var app: Clarifai_Api_App {
    get {return _app ?? Clarifai_Api_App()}
    set {_app = newValue}
  }
  /// Returns true if `app` has been explicitly set.
  public var hasApp: Bool {return self._app != nil}
  /// Clears the value of `app`. Subsequent reads from it will return its default value.
  public mutating func clearApp() {self._app = nil}

  ///who is this collaborator
  public var user: Clarifai_Api_User {
    get {return _user ?? Clarifai_Api_User()}
    set {_user = newValue}
  }
  /// Returns true if `user` has been explicitly set.
  public var hasUser: Bool {return self._user != nil}
  /// Clears the value of `user`. Subsequent reads from it will return its default value.
  public mutating func clearUser() {self._user = nil}

  ///the permission this collaborator
  public var scopes: [String] = []

  public var endpoints: [String] = []

  /// When the app was shared with. We follow the XXXX timestamp
  /// format. We use https://www.ietf.org/rfc/rfc3339.txt format:
  /// "2006-01-02T15:04:05.999999Z" so you can expect results like
  /// the following from the API:
  /// "2017-04-11T21:50:50.223962Z"
  public var createdAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _createdAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_createdAt = newValue}
  }
  /// Returns true if `createdAt` has been explicitly set.
  public var hasCreatedAt: Bool {return self._createdAt != nil}
  /// Clears the value of `createdAt`. Subsequent reads from it will return its default value.
  public mutating func clearCreatedAt() {self._createdAt = nil}

  /// When the collaborator was updated.
  public var modifiedAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _modifiedAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_modifiedAt = newValue}
  }
  /// Returns true if `modifiedAt` has been explicitly set.
  public var hasModifiedAt: Bool {return self._modifiedAt != nil}
  /// Clears the value of `modifiedAt`. Subsequent reads from it will return its default value.
  public mutating func clearModifiedAt() {self._modifiedAt = nil}

  /// When the collaborator was removed from app.
  public var deletedAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _deletedAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_deletedAt = newValue}
  }
  /// Returns true if `deletedAt` has been explicitly set.
  public var hasDeletedAt: Bool {return self._deletedAt != nil}
  /// Clears the value of `deletedAt`. Subsequent reads from it will return its default value.
  public mutating func clearDeletedAt() {self._deletedAt = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _app: Clarifai_Api_App? = nil
  fileprivate var _user: Clarifai_Api_User? = nil
  fileprivate var _createdAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _modifiedAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _deletedAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

///collaboration includes an app you're invited to work on.
public struct Clarifai_Api_Collaboration {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///the application
  public var app: Clarifai_Api_App {
    get {return _app ?? Clarifai_Api_App()}
    set {_app = newValue}
  }
  /// Returns true if `app` has been explicitly set.
  public var hasApp: Bool {return self._app != nil}
  /// Clears the value of `app`. Subsequent reads from it will return its default value.
  public mutating func clearApp() {self._app = nil}

  ///the app owner's info(including user_unique_id, first_name, last_name, primary_email)
  public var appOwner: Clarifai_Api_User {
    get {return _appOwner ?? Clarifai_Api_User()}
    set {_appOwner = newValue}
  }
  /// Returns true if `appOwner` has been explicitly set.
  public var hasAppOwner: Bool {return self._appOwner != nil}
  /// Clears the value of `appOwner`. Subsequent reads from it will return its default value.
  public mutating func clearAppOwner() {self._appOwner = nil}

  ///the low-level scope users are shared with for this collaboration
  public var scopes: [String] = []

  ///the endpoint-level scopes users are shared with for this collaboration
  public var endpoints: [String] = []

  ///when is the collaboration created
  public var createdAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _createdAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_createdAt = newValue}
  }
  /// Returns true if `createdAt` has been explicitly set.
  public var hasCreatedAt: Bool {return self._createdAt != nil}
  /// Clears the value of `createdAt`. Subsequent reads from it will return its default value.
  public mutating func clearCreatedAt() {self._createdAt = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _app: Clarifai_Api_App? = nil
  fileprivate var _appOwner: Clarifai_Api_User? = nil
  fileprivate var _createdAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

/////////////////////////////////////////////////////////////////////////////////
/// Messages from /proto/clarifai/api/audio.proto
/////////////////////////////////////////////////////////////////////////////////
public struct Clarifai_Api_Audio {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// This is a URL to a publicly accessible image file. The platform will download this file server
  /// side and then process.
  public var url: String = String()

  /// The base64 field is using image file bytes directly in the request.
  /// NOTE: if you're sending a json request, then this MUST be base64 encoded before sending (hence
  /// the name here).
  /// When using our grpc clients, you DO NOT need to base64 encode
  /// it yourself since the clients know how to do this for you automatically and will avoid the
  /// base64 encoding if they send a binary request.
  public var base64: Data = SwiftProtobuf.Internal.emptyData

  /// If True then you will be allowed to have multiple urls.
  public var allowDuplicateURL: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/////////////////////////////////////////////////////////////////////////////////
/// Messages from /proto/clarifai/api/cluster.proto
/////////////////////////////////////////////////////////////////////////////////
public struct Clarifai_Api_Cluster {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: String = String()

  /// Number of annotations tied to the cluster in the app
  public var count: UInt32 = 0

  /// The score assigned to this cluster
  public var score: Float = 0

  /// Representative hits for cluster (for now we only return 1)
  public var hits: [Clarifai_Api_Hit] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/////////////////////////////////////////////////////////////////////////////////
/// Messages from /proto/clarifai/api/color.proto
/////////////////////////////////////////////////////////////////////////////////
public struct Clarifai_Api_Color {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var rawHex: String = String()

  public var w3C: Clarifai_Api_W3C {
    get {return _w3C ?? Clarifai_Api_W3C()}
    set {_w3C = newValue}
  }
  /// Returns true if `w3C` has been explicitly set.
  public var hasW3C: Bool {return self._w3C != nil}
  /// Clears the value of `w3C`. Subsequent reads from it will return its default value.
  public mutating func clearW3C() {self._w3C = nil}

  public var value: Float = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _w3C: Clarifai_Api_W3C? = nil
}

public struct Clarifai_Api_W3C {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var hex: String = String()

  public var name: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/////////////////////////////////////////////////////////////////////////////////
/// Messages from /proto/clarifai/api/common.proto
/////////////////////////////////////////////////////////////////////////////////
/// Common message to identify the app in a url endpoint.
public struct Clarifai_Api_UserAppIDSet {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Note user_id 'me' is reserved - it is the alias for the id of authorized user
  public var userID: String = String()

  public var appID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Clarifai_Api_PatchAction {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The operation to perform on the patched metadata given a path
  /// For now only operations 'overwrite', 'delete, and 'merge' is supported
  public var op: String = String()

  /// If the action is 'merge' and there is a conflict, how to resolve it.
  /// The options are
  /// 'overwrite_by_id', 'remove_by_id', 'merge_by_id','overwrite', 'append' and 'do_nothing'
  /// Note that for conflict resolutions '*_by_id' to work on a list, the list should contain
  /// objects with an 'id' field which will be used to uniquely identify each field. For example
  /// Patching existing json
  /// {
  ///   "tag": [
  ///     {
  ///       "id": "1",
  ///       "data": 1
  ///     },
  ///     {
  ///       "id": "2",
  ///       "data": 2
  ///     }
  ///   ]
  /// }
  /// with op 'merge' and merge_conflict_resolution 'overwrite_by_id'
  /// {
  ///   "tag": [
  ///     {
  ///       "id": "2",
  ///       "data": 3
  ///     }
  ///   ]
  /// }
  /// would produce
  /// {
  ///   "tag": [
  ///     {
  ///       "id": "1",
  ///       "data": 1
  ///     },
  ///     {
  ///       "id": "2",
  ///       "data": 3
  ///     }
  ///   ]
  /// }
  /// while with merge_conflict_resolution 'remove_by_id' it would produce
  /// {
  ///   "tag": [
  ///     {
  ///       "id": "1",
  ///       "data": 1
  ///     }
  ///   ]
  /// }
  ///
  /// Option 'append' will simply create a list on conflicts. For example in above example
  /// the final result would be
  /// {
  ///   "tag": [
  ///     {
  ///       "id": "1",
  ///       "data": 1
  ///     },
  ///     {
  ///       "id": "2",
  ///       "data": [2, 3]
  ///     }
  ///   ]
  /// }
  public var mergeConflictResolution: String = String()

  /// Path for the change. For example 'tag[1].data' is a valid path in above example.
  /// Default path is root level i.e. ''.
  public var path: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/////////////////////////////////////////////////////////////////////////////////
/// Messages from /proto/clarifai/api/concept.proto
/////////////////////////////////////////////////////////////////////////////////
public struct Clarifai_Api_Concept {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The concept's unique id.
  public var id: String = String()

  /// The name of the concept in the given language.
  public var name: String = String()

  /// Used to indicate presence (1.0) or not (0.0) of this concept when making a request.
  /// This is also the prediction probability when returning predictions from our API.
  /// For convenience we use the default of 1.0 when making requests so the concept you provide is
  /// is treated as a positive (1.0) and not a negative (which would be value == 0.0).
  public var value: Float = 0

  /// When the concept was created. The format is https://www.ietf.org/rfc/rfc3339.txt .
  /// Example: "2006-01-02T15:04:05.999999Z". This field is used only in a response.
  public var createdAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _createdAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_createdAt = newValue}
  }
  /// Returns true if `createdAt` has been explicitly set.
  public var hasCreatedAt: Bool {return self._createdAt != nil}
  /// Clears the value of `createdAt`. Subsequent reads from it will return its default value.
  public mutating func clearCreatedAt() {self._createdAt = nil}

  /// The language in which the concept name is in. This is *ONLY* used in the response and setting
  /// it in a request is ignored since the default language of your app is used when creating
  /// or patching a Concept. To set other languages for your concept use the ConceptLanguage object
  /// and its corresponding endpoints.
  public var language: String = String()

  /// The application id that this concept is within. This can be ignored by most users.
  public var appID: String = String()

  /// The definition for the concept. Similar to name. This can be ignored by most users.
  public var definition: String = String()

  /// The vocabulary that this concept belongs to. This is useful if you have different unique sets
  /// of concepts that you can separate out based on this field. For example "age_appearance" vs
  /// "gender_appearance" in a list of concept returned from the demographics model.
  public var vocabID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _createdAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

public struct Clarifai_Api_ConceptCount {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The concept's unique id.
  public var id: String = String()

  /// The name of the concept.
  public var name: String = String()

  /// The total count for concepts labeled for all asset statues (processing, to_process, processed, error)
  public var conceptTypeCount: Clarifai_Api_ConceptTypeCount {
    get {return _conceptTypeCount ?? Clarifai_Api_ConceptTypeCount()}
    set {_conceptTypeCount = newValue}
  }
  /// Returns true if `conceptTypeCount` has been explicitly set.
  public var hasConceptTypeCount: Bool {return self._conceptTypeCount != nil}
  /// Clears the value of `conceptTypeCount`. Subsequent reads from it will return its default value.
  public mutating func clearConceptTypeCount() {self._conceptTypeCount = nil}

  /// The detail count for different assets status
  public var detailConceptCount: Clarifai_Api_DetailConceptCount {
    get {return _detailConceptCount ?? Clarifai_Api_DetailConceptCount()}
    set {_detailConceptCount = newValue}
  }
  /// Returns true if `detailConceptCount` has been explicitly set.
  public var hasDetailConceptCount: Bool {return self._detailConceptCount != nil}
  /// Clears the value of `detailConceptCount`. Subsequent reads from it will return its default value.
  public mutating func clearDetailConceptCount() {self._detailConceptCount = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _conceptTypeCount: Clarifai_Api_ConceptTypeCount? = nil
  fileprivate var _detailConceptCount: Clarifai_Api_DetailConceptCount? = nil
}

public struct Clarifai_Api_ConceptTypeCount {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The number of inputs that have a concept with a value of 1.0 (indicating presence of the
  /// concept in an input).
  public var positive: UInt32 = 0

  /// The number of inputs that have a concept with a value of 0.0 (indicating absence of the
  /// concept in an input).
  public var negative: UInt32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Clarifai_Api_DetailConceptCount {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The concept count for processed assets
  public var processed: Clarifai_Api_ConceptTypeCount {
    get {return _processed ?? Clarifai_Api_ConceptTypeCount()}
    set {_processed = newValue}
  }
  /// Returns true if `processed` has been explicitly set.
  public var hasProcessed: Bool {return self._processed != nil}
  /// Clears the value of `processed`. Subsequent reads from it will return its default value.
  public mutating func clearProcessed() {self._processed = nil}

  /// The concept count for to process assets
  public var toProcess: Clarifai_Api_ConceptTypeCount {
    get {return _toProcess ?? Clarifai_Api_ConceptTypeCount()}
    set {_toProcess = newValue}
  }
  /// Returns true if `toProcess` has been explicitly set.
  public var hasToProcess: Bool {return self._toProcess != nil}
  /// Clears the value of `toProcess`. Subsequent reads from it will return its default value.
  public mutating func clearToProcess() {self._toProcess = nil}

  /// The concept count for assets with status error
  public var errors: Clarifai_Api_ConceptTypeCount {
    get {return _errors ?? Clarifai_Api_ConceptTypeCount()}
    set {_errors = newValue}
  }
  /// Returns true if `errors` has been explicitly set.
  public var hasErrors: Bool {return self._errors != nil}
  /// Clears the value of `errors`. Subsequent reads from it will return its default value.
  public mutating func clearErrors() {self._errors = nil}

  /// The concept count for processing assets
  public var processing: Clarifai_Api_ConceptTypeCount {
    get {return _processing ?? Clarifai_Api_ConceptTypeCount()}
    set {_processing = newValue}
  }
  /// Returns true if `processing` has been explicitly set.
  public var hasProcessing: Bool {return self._processing != nil}
  /// Clears the value of `processing`. Subsequent reads from it will return its default value.
  public mutating func clearProcessing() {self._processing = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _processed: Clarifai_Api_ConceptTypeCount? = nil
  fileprivate var _toProcess: Clarifai_Api_ConceptTypeCount? = nil
  fileprivate var _errors: Clarifai_Api_ConceptTypeCount? = nil
  fileprivate var _processing: Clarifai_Api_ConceptTypeCount? = nil
}

public struct Clarifai_Api_ConceptQuery {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The name of the concept to search.
  public var name: String = String()

  /// (optional) The language of the concept name in a search. Defaults to English.
  public var language: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/////////////////////////////////////////////////////////////////////////////////
/// Messages from /proto/clarifai/api/concept_graph.proto
/////////////////////////////////////////////////////////////////////////////////
/// This represents a relation (i.e. edge) between the subject concept and the object concept
public struct Clarifai_Api_ConceptRelation {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// ID of the concept relation
  public var id: String = String()

  /// The subject concept (i.e. source) of the concept relation
  public var subjectConcept: Clarifai_Api_Concept {
    get {return _subjectConcept ?? Clarifai_Api_Concept()}
    set {_subjectConcept = newValue}
  }
  /// Returns true if `subjectConcept` has been explicitly set.
  public var hasSubjectConcept: Bool {return self._subjectConcept != nil}
  /// Clears the value of `subjectConcept`. Subsequent reads from it will return its default value.
  public mutating func clearSubjectConcept() {self._subjectConcept = nil}

  /// The subject concept (i.e. destination) of the concept relation
  public var objectConcept: Clarifai_Api_Concept {
    get {return _objectConcept ?? Clarifai_Api_Concept()}
    set {_objectConcept = newValue}
  }
  /// Returns true if `objectConcept` has been explicitly set.
  public var hasObjectConcept: Bool {return self._objectConcept != nil}
  /// Clears the value of `objectConcept`. Subsequent reads from it will return its default value.
  public mutating func clearObjectConcept() {self._objectConcept = nil}

  /// The predicate (i.e. edge) linking the subject and the object
  /// Both subject_concept and object_concept are concepts.
  /// The predicate is the type of relationship.
  /// That predicate acts on the subject.
  ///
  /// There are three current types of predicates:
  /// 1) "hyponym"
  /// 2) "hypernym"
  /// 3) "synonym"
  ///
  /// 1) For example, 'hyponym' is a type of predicate which represents 'is_a_kind_of' relation so
  /// the following relationship:
  /// 'honey' (subject), 'hyponym' (predicate), 'food' (object)
  /// Can more easily be read as:
  /// 'honey' 'is a kind of' 'food'
  ///
  ///
  /// 2) The 'hypernym' relation is the opposite of 'hyponym' and when you add one of the
  /// relationships the opposite will automatically appear for you in queries.
  ///
  /// The 'hypernym' can be read as 'is a parent of' so:
  /// 'food' (subject), 'hypernym' (predicate), 'honey' (object)
  /// Can more easily be read as:
  /// 'food' is a parent of 'honey'
  ///
  /// 3) The 'synonym' relation defines two concepts that essential mean the same thing. This
  /// is more like a "is" relationship. So for example a 'synonym' relationship could be:
  /// "puppy" is "pup"
  /// The reverse is also true once the former is added so:
  /// "pup" is "puppy"
  /// will appear in queries as well.
  public var predicate: String = String()

  /// The knowledge graph id that this edge belongs to
  public var knowledgeGraphID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _subjectConcept: Clarifai_Api_Concept? = nil
  fileprivate var _objectConcept: Clarifai_Api_Concept? = nil
}

/// A Knowledge Graph is a logical subsets of edges in the overall Concept Graph
public struct Clarifai_Api_KnowledgeGraph {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// ID of the knowledge graph
  public var id: String = String()

  /// Name of the knowledge graph
  public var name: String = String()

  /// Human readable description of the knowledge graph
  public var description_p: String = String()

  /// The app that contains the images that correspond to the concepts in the knowledge graph
  public var examplesAppID: String = String()

  /// The app that contains the sample images that we want to show the customer for the concepts in the knowledge graph
  public var sampledExamplesAppID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Clarifai_Api_ConceptMappingJob {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The id of the knowledge graph being used for this concept mapping job
  public var knowledgeGraphID: String = String()

  /// The ids of the concepts being mapped
  public var conceptIds: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/////////////////////////////////////////////////////////////////////////////////
/// Messages from /proto/clarifai/api/concept_language.proto
/////////////////////////////////////////////////////////////////////////////////
/// This represents a link to an outside source for the given concept.
/// The values from here are sticked into Concept message into the name and definition fields when
/// returning from the API in your default language. The "id" field here becomes the "language"
/// field of the Concept message which is a little weird.
public struct Clarifai_Api_ConceptLanguage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// This is the language code for the language such as "en".
  public var id: String = String()

  /// The type of the outside source.
  public var name: String = String()

  /// The ID that is referenced in the source.
  public var definition: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/////////////////////////////////////////////////////////////////////////////////
/// Messages from /proto/clarifai/api/data.proto
/////////////////////////////////////////////////////////////////////////////////
public struct Clarifai_Api_Data {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Input and output images.
  public var image: Clarifai_Api_Image {
    get {return _image ?? Clarifai_Api_Image()}
    set {_image = newValue}
  }
  /// Returns true if `image` has been explicitly set.
  public var hasImage: Bool {return self._image != nil}
  /// Clears the value of `image`. Subsequent reads from it will return its default value.
  public mutating func clearImage() {self._image = nil}

  /// Input and output videos.
  public var video: Clarifai_Api_Video {
    get {return _video ?? Clarifai_Api_Video()}
    set {_video = newValue}
  }
  /// Returns true if `video` has been explicitly set.
  public var hasVideo: Bool {return self._video != nil}
  /// Clears the value of `video`. Subsequent reads from it will return its default value.
  public mutating func clearVideo() {self._video = nil}

  /// A list of concepts.
  public var concepts: [Clarifai_Api_Concept] = []

  /// To handle arbitrary json metadata you can use a struct field:
  /// https://github.com/google/protobuf/blob/master/src/google/protobuf/struct.proto
  public var metadata: SwiftProtobuf.Google_Protobuf_Struct {
    get {return _metadata ?? SwiftProtobuf.Google_Protobuf_Struct()}
    set {_metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  public var hasMetadata: Bool {return self._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  public mutating func clearMetadata() {self._metadata = nil}

  /// Geography information.
  public var geo: Clarifai_Api_Geo {
    get {return _geo ?? Clarifai_Api_Geo()}
    set {_geo = newValue}
  }
  /// Returns true if `geo` has been explicitly set.
  public var hasGeo: Bool {return self._geo != nil}
  /// Clears the value of `geo`. Subsequent reads from it will return its default value.
  public mutating func clearGeo() {self._geo = nil}

  /// The dominant colors within an image.
  public var colors: [Clarifai_Api_Color] = []

  /// Clustering centroids for inputs.
  public var clusters: [Clarifai_Api_Cluster] = []

  /// Embedding vectors representing each input.
  public var embeddings: [Clarifai_Api_Embedding] = []

  /// For recursing into localized regions of an input.
  public var regions: [Clarifai_Api_Region] = []

  /// For temporal content like video.
  public var frames: [Clarifai_Api_Frame] = []

  /// Input and output text.
  public var text: Clarifai_Api_Text {
    get {return _text ?? Clarifai_Api_Text()}
    set {_text = newValue}
  }
  /// Returns true if `text` has been explicitly set.
  public var hasText: Bool {return self._text != nil}
  /// Clears the value of `text`. Subsequent reads from it will return its default value.
  public mutating func clearText() {self._text = nil}

  /// Input and output audio.
  public var audio: Clarifai_Api_Audio {
    get {return _audio ?? Clarifai_Api_Audio()}
    set {_audio = newValue}
  }
  /// Returns true if `audio` has been explicitly set.
  public var hasAudio: Bool {return self._audio != nil}
  /// Clears the value of `audio`. Subsequent reads from it will return its default value.
  public mutating func clearAudio() {self._audio = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _image: Clarifai_Api_Image? = nil
  fileprivate var _video: Clarifai_Api_Video? = nil
  fileprivate var _metadata: SwiftProtobuf.Google_Protobuf_Struct? = nil
  fileprivate var _geo: Clarifai_Api_Geo? = nil
  fileprivate var _text: Clarifai_Api_Text? = nil
  fileprivate var _audio: Clarifai_Api_Audio? = nil
}

/// A region within the data.
public struct Clarifai_Api_Region {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// A unique id for the region.
  public var id: String = String()

  /// The details about the location of the region.
  public var regionInfo: Clarifai_Api_RegionInfo {
    get {return _regionInfo ?? Clarifai_Api_RegionInfo()}
    set {_regionInfo = newValue}
  }
  /// Returns true if `regionInfo` has been explicitly set.
  public var hasRegionInfo: Bool {return self._regionInfo != nil}
  /// Clears the value of `regionInfo`. Subsequent reads from it will return its default value.
  public mutating func clearRegionInfo() {self._regionInfo = nil}

  /// A recursive definition of the data within the Region. For example, this will contain
  /// data.concepts if the region also has annotations or predictions of concepts within it.
  public var data: Clarifai_Api_Data {
    get {return _data ?? Clarifai_Api_Data()}
    set {_data = newValue}
  }
  /// Returns true if `data` has been explicitly set.
  public var hasData: Bool {return self._data != nil}
  /// Clears the value of `data`. Subsequent reads from it will return its default value.
  public mutating func clearData() {self._data = nil}

  /// This is the confidence score of the overall Region.
  public var value: Float = 0

  /// For tracking algorithsm and annotations we tie regions together with this track id.
  public var trackID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _regionInfo: Clarifai_Api_RegionInfo? = nil
  fileprivate var _data: Clarifai_Api_Data? = nil
}

/// The information of the location of the Region.
public struct Clarifai_Api_RegionInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Details of the region's rectangular bounding box.
  public var boundingBox: Clarifai_Api_BoundingBox {
    get {return _boundingBox ?? Clarifai_Api_BoundingBox()}
    set {_boundingBox = newValue}
  }
  /// Returns true if `boundingBox` has been explicitly set.
  public var hasBoundingBox: Bool {return self._boundingBox != nil}
  /// Clears the value of `boundingBox`. Subsequent reads from it will return its default value.
  public mutating func clearBoundingBox() {self._boundingBox = nil}

  /// Details of the region's segmentation mask.
  public var mask: Clarifai_Api_Mask {
    get {return _mask ?? Clarifai_Api_Mask()}
    set {_mask = newValue}
  }
  /// Returns true if `mask` has been explicitly set.
  public var hasMask: Bool {return self._mask != nil}
  /// Clears the value of `mask`. Subsequent reads from it will return its default value.
  public mutating func clearMask() {self._mask = nil}

  /// A polygon of points.
  public var polygon: Clarifai_Api_Polygon {
    get {return _polygon ?? Clarifai_Api_Polygon()}
    set {_polygon = newValue}
  }
  /// Returns true if `polygon` has been explicitly set.
  public var hasPolygon: Bool {return self._polygon != nil}
  /// Clears the value of `polygon`. Subsequent reads from it will return its default value.
  public mutating func clearPolygon() {self._polygon = nil}

  /// A landmark point location.
  public var point: Clarifai_Api_Point {
    get {return _point ?? Clarifai_Api_Point()}
    set {_point = newValue}
  }
  /// Returns true if `point` has been explicitly set.
  public var hasPoint: Bool {return self._point != nil}
  /// Clears the value of `point`. Subsequent reads from it will return its default value.
  public mutating func clearPoint() {self._point = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _boundingBox: Clarifai_Api_BoundingBox? = nil
  fileprivate var _mask: Clarifai_Api_Mask? = nil
  fileprivate var _polygon: Clarifai_Api_Polygon? = nil
  fileprivate var _point: Clarifai_Api_Point? = nil
}

/// Rectangular bounding box for a region.
public struct Clarifai_Api_BoundingBox {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The top left of the bounding box normalized to the data dimension to be within [0-1.0]
  public var topRow: Float = 0

  /// The left column of the bounding box normalized to the data dimension to be within [0-1.0]
  public var leftCol: Float = 0

  /// The bottom row of the bounding box normalized to the data dimension to be within [0-1.0]
  public var bottomRow: Float = 0

  /// The right col of the bounding box normalized to the data dimension to be within [0-1.0]
  public var rightCol: Float = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// The information of the location of the Frame.
public struct Clarifai_Api_FrameInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The index of the frame. Keep in mind that this depends on the sampling rate used during
  /// processing.
  public var index: UInt32 = 0

  /// time in the video in milliseconds. This is independent of the sampling rates used during
  /// processing.
  public var time: UInt32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// A Frame of time-series Data such as a Video.
public struct Clarifai_Api_Frame {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Information aboue frame such as number and time.
  public var frameInfo: Clarifai_Api_FrameInfo {
    get {return _frameInfo ?? Clarifai_Api_FrameInfo()}
    set {_frameInfo = newValue}
  }
  /// Returns true if `frameInfo` has been explicitly set.
  public var hasFrameInfo: Bool {return self._frameInfo != nil}
  /// Clears the value of `frameInfo`. Subsequent reads from it will return its default value.
  public mutating func clearFrameInfo() {self._frameInfo = nil}

  /// A recursive definition of the data within the Frame. For example, this will contain
  /// data.concepts if the Frame also has annotations or predictions of concepts within it.
  /// This can also have data.regions for annotation or predictions of detection regions, which can
  /// then recursively have their data field filled in as well.
  public var data: Clarifai_Api_Data {
    get {return _data ?? Clarifai_Api_Data()}
    set {_data = newValue}
  }
  /// Returns true if `data` has been explicitly set.
  public var hasData: Bool {return self._data != nil}
  /// Clears the value of `data`. Subsequent reads from it will return its default value.
  public mutating func clearData() {self._data = nil}

  /// An ID for the frame.
  public var id: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _frameInfo: Clarifai_Api_FrameInfo? = nil
  fileprivate var _data: Clarifai_Api_Data? = nil
}

/// Segmentation mask.
public struct Clarifai_Api_Mask {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The color of the segmentation mask that was created. This is used in visualizing masks next to
  /// each other.
  public var color: Clarifai_Api_Color {
    get {return _color ?? Clarifai_Api_Color()}
    set {_color = newValue}
  }
  /// Returns true if `color` has been explicitly set.
  public var hasColor: Bool {return self._color != nil}
  /// Clears the value of `color`. Subsequent reads from it will return its default value.
  public mutating func clearColor() {self._color = nil}

  /// The image of the mask in a non-raster format.
  public var image: Clarifai_Api_Image {
    get {return _image ?? Clarifai_Api_Image()}
    set {_image = newValue}
  }
  /// Returns true if `image` has been explicitly set.
  public var hasImage: Bool {return self._image != nil}
  /// Clears the value of `image`. Subsequent reads from it will return its default value.
  public mutating func clearImage() {self._image = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _color: Clarifai_Api_Color? = nil
  fileprivate var _image: Clarifai_Api_Image? = nil
}

public struct Clarifai_Api_Polygon {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// A list of points connected together to form the polygon.
  public var points: [Clarifai_Api_Point] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Clarifai_Api_Point {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The row location of the point. This has a [0.0-1.0] range with 0.0 being top row and 1.0
  /// being the bottom row.
  public var row: Float = 0

  /// The column location of the point. This has a [0.0-1.0] range with 0.0 being left col and 1.0
  /// being the right col.
  public var col: Float = 0

  /// Depth if applicable for the point.
  public var z: Float = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/////////////////////////////////////////////////////////////////////////////////
/// Messages from /proto/clarifai/api/embedding.proto
/////////////////////////////////////////////////////////////////////////////////
public struct Clarifai_Api_Embedding {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var vector: [Float] = []

  public var numDimensions: UInt32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/////////////////////////////////////////////////////////////////////////////////
/// Messages from /proto/clarifai/api/geo.proto
/////////////////////////////////////////////////////////////////////////////////
public struct Clarifai_Api_GeoPoint {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var longitude: Float = 0

  public var latitude: Float = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Clarifai_Api_GeoLimit {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var type: String = String()

  public var value: Float = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Clarifai_Api_GeoBoxedPoint {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var geoPoint: Clarifai_Api_GeoPoint {
    get {return _geoPoint ?? Clarifai_Api_GeoPoint()}
    set {_geoPoint = newValue}
  }
  /// Returns true if `geoPoint` has been explicitly set.
  public var hasGeoPoint: Bool {return self._geoPoint != nil}
  /// Clears the value of `geoPoint`. Subsequent reads from it will return its default value.
  public mutating func clearGeoPoint() {self._geoPoint = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _geoPoint: Clarifai_Api_GeoPoint? = nil
}

public struct Clarifai_Api_Geo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var geoPoint: Clarifai_Api_GeoPoint {
    get {return _geoPoint ?? Clarifai_Api_GeoPoint()}
    set {_geoPoint = newValue}
  }
  /// Returns true if `geoPoint` has been explicitly set.
  public var hasGeoPoint: Bool {return self._geoPoint != nil}
  /// Clears the value of `geoPoint`. Subsequent reads from it will return its default value.
  public mutating func clearGeoPoint() {self._geoPoint = nil}

  public var geoLimit: Clarifai_Api_GeoLimit {
    get {return _geoLimit ?? Clarifai_Api_GeoLimit()}
    set {_geoLimit = newValue}
  }
  /// Returns true if `geoLimit` has been explicitly set.
  public var hasGeoLimit: Bool {return self._geoLimit != nil}
  /// Clears the value of `geoLimit`. Subsequent reads from it will return its default value.
  public mutating func clearGeoLimit() {self._geoLimit = nil}

  /// NOTE: inconsistency: should have been geo_boxed_points
  public var geoBox: [Clarifai_Api_GeoBoxedPoint] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _geoPoint: Clarifai_Api_GeoPoint? = nil
  fileprivate var _geoLimit: Clarifai_Api_GeoLimit? = nil
}

/////////////////////////////////////////////////////////////////////////////////
/// Messages from /proto/clarifai/api/image.proto
/////////////////////////////////////////////////////////////////////////////////
public struct Clarifai_Api_Image {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// This is a URL to a publicly accessible image file. The platform will download this file server
  /// side and then process.
  public var url: String = String()

  /// The base64 field is using image file bytes directly in the request.
  /// NOTE: if you're sending a json request, then this MUST be base64 encoded before sending (hence
  /// the name here).
  /// When using our grpc clients, you DO NOT need to base64 encode
  /// it yourself since the clients know how to do this for you automatically and will avoid the
  /// base64 encoding if they send a binary request.
  public var base64: Data = SwiftProtobuf.Internal.emptyData

  public var allowDuplicateURL: Bool = false

  /// The hosted field lists images in different sizes hosted in Clarifai storage.
  public var hosted: Clarifai_Api_HostedURL {
    get {return _hosted ?? Clarifai_Api_HostedURL()}
    set {_hosted = newValue}
  }
  /// Returns true if `hosted` has been explicitly set.
  public var hasHosted: Bool {return self._hosted != nil}
  /// Clears the value of `hosted`. Subsequent reads from it will return its default value.
  public mutating func clearHosted() {self._hosted = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _hosted: Clarifai_Api_HostedURL? = nil
}

public struct Clarifai_Api_HostedURL {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Prefix of the URL of every hosted image.
  public var prefix: String = String()

  /// Suffix of an image stored in different sizes.
  public var suffix: String = String()

  /// The sizes field lists which images of the different sizes are hosted in our storage. The URL
  /// of each hosted image can be obtained by joining the prefix, one of the sizes and suffix.
  public var sizes: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/////////////////////////////////////////////////////////////////////////////////
/// Messages from /proto/clarifai/api/input.proto
/////////////////////////////////////////////////////////////////////////////////
public struct Clarifai_Api_Input {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The ID for the input
  public var id: String = String()

  /// The data passed along in this input.
  public var data: Clarifai_Api_Data {
    get {return _data ?? Clarifai_Api_Data()}
    set {_data = newValue}
  }
  /// Returns true if `data` has been explicitly set.
  public var hasData: Bool {return self._data != nil}
  /// Clears the value of `data`. Subsequent reads from it will return its default value.
  public mutating func clearData() {self._data = nil}

  /// When the input was created. We follow the XXXX timestamp
  /// format. We use https://www.ietf.org/rfc/rfc3339.txt format:
  /// "2006-01-02T15:04:05.999999Z" so you can expect results like
  /// the following from the API:
  /// "2017-04-11T21:50:50.223962Z"
  public var createdAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _createdAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_createdAt = newValue}
  }
  /// Returns true if `createdAt` has been explicitly set.
  public var hasCreatedAt: Bool {return self._createdAt != nil}
  /// Clears the value of `createdAt`. Subsequent reads from it will return its default value.
  public mutating func clearCreatedAt() {self._createdAt = nil}

  /// When the input was modified.
  public var modifiedAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _modifiedAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_modifiedAt = newValue}
  }
  /// Returns true if `modifiedAt` has been explicitly set.
  public var hasModifiedAt: Bool {return self._modifiedAt != nil}
  /// Clears the value of `modifiedAt`. Subsequent reads from it will return its default value.
  public mutating func clearModifiedAt() {self._modifiedAt = nil}

  /// This is the status at a per Input level which allows for
  /// partial failures.
  public var status: Clarifai_Api_Status_Status {
    get {return _status ?? Clarifai_Api_Status_Status()}
    set {_status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  public var hasStatus: Bool {return self._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  public mutating func clearStatus() {self._status = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _data: Clarifai_Api_Data? = nil
  fileprivate var _createdAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _modifiedAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _status: Clarifai_Api_Status_Status? = nil
}

/// NOTE: inconsistency: this is weird mix of plural and singular words.
public struct Clarifai_Api_InputCount {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var processed: UInt32 = 0

  public var toProcess: UInt32 = 0

  public var errors: UInt32 = 0

  public var processing: UInt32 = 0

  public var reindexed: UInt32 = 0

  public var toReindex: UInt32 = 0

  public var reindexErrors: UInt32 = 0

  public var reindexing: UInt32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Clarifai_Api_WorkflowResultsSimilarity {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The input with the specific data compare against all pool results
  public var probeInput: Clarifai_Api_Input {
    get {return _probeInput ?? Clarifai_Api_Input()}
    set {_probeInput = newValue}
  }
  /// Returns true if `probeInput` has been explicitly set.
  public var hasProbeInput: Bool {return self._probeInput != nil}
  /// Clears the value of `probeInput`. Subsequent reads from it will return its default value.
  public mutating func clearProbeInput() {self._probeInput = nil}

  public var poolResults: [Clarifai_Api_Hit] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _probeInput: Clarifai_Api_Input? = nil
}

/////////////////////////////////////////////////////////////////////////////////
/// Messages from /proto/clarifai/api/key.proto
/////////////////////////////////////////////////////////////////////////////////
public struct Clarifai_Api_Key {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The id of this key, it is used for authorization.
  public var id: String = String()

  /// The type of key, it can be api_key or personal_access_token, the default value is api_key
  public var type: String = String()

  /// The description
  public var description_p: String = String()

  /// The low-level scopes this key has
  public var scopes: [String] = []

  /// The endpoint-level scopes this key has
  public var endpoints: [String] = []

  /// The apps that this key give you access to, it is empty if this key is personal_access_token
  /// API key can only give you access to a single app.
  public var apps: [Clarifai_Api_App] = []

  /// When the key was created. We follow the XXXX timestamp
  /// format. We use https://www.ietf.org/rfc/rfc3339.txt format:
  /// "2006-01-02T15:04:05.999999Z" so you can expect results like
  /// the following from the API:
  /// "2017-04-11T21:50:50.223962Z"
  public var createdAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _createdAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_createdAt = newValue}
  }
  /// Returns true if `createdAt` has been explicitly set.
  public var hasCreatedAt: Bool {return self._createdAt != nil}
  /// Clears the value of `createdAt`. Subsequent reads from it will return its default value.
  public mutating func clearCreatedAt() {self._createdAt = nil}

  /// When does the key expires, the key won't expire if this is empty
  public var expiresAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _expiresAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_expiresAt = newValue}
  }
  /// Returns true if `expiresAt` has been explicitly set.
  public var hasExpiresAt: Bool {return self._expiresAt != nil}
  /// Clears the value of `expiresAt`. Subsequent reads from it will return its default value.
  public mutating func clearExpiresAt() {self._expiresAt = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _createdAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _expiresAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

/////////////////////////////////////////////////////////////////////////////////
/// Messages from /proto/clarifai/api/model.proto
/////////////////////////////////////////////////////////////////////////////////
/// This is the Model object which represents a created model in the platform.
/// Each model has a particular type denoted by the model_type_id.
/// When creating a Model with PostModels the following happens:
///  - if the ModelType is trainable, then a new ModelVersion is created that is
///    - UNTRAINED status by default
///    - TRAINED status if a ModelVersion was included with PretrainedModelConfig in PostModels
///  - if the ModelType is not trainable, then a new ModelVersion is created with TRAINED status.
/// To modify config settings like OutputInfo for the Model you an use PatchModels. This will
/// also create a new ModelVersion, potentially UNTRAINED following the same rules as above.
/// The fields that are patchable include Model.name, Model.display_name and Model.output_info
/// (except the Model.output_info.type and Model.output_info.type_ext).
public struct Clarifai_Api_Model {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The model's ID. Must be unique within a particular app and URL-friendly.
  public var id: String = String()

  /// A nicer-to-read name for the model. Can have spaces and special characters.
  public var name: String = String()

  /// When the model was created.
  public var createdAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _createdAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_createdAt = newValue}
  }
  /// Returns true if `createdAt` has been explicitly set.
  public var hasCreatedAt: Bool {return self._createdAt != nil}
  /// Clears the value of `createdAt`. Subsequent reads from it will return its default value.
  public mutating func clearCreatedAt() {self._createdAt = nil}

  /// The app the model belongs to.
  public var appID: String = String()

  /// Info about the model's output and configuration.
  public var outputInfo: Clarifai_Api_OutputInfo {
    get {return _outputInfo ?? Clarifai_Api_OutputInfo()}
    set {_outputInfo = newValue}
  }
  /// Returns true if `outputInfo` has been explicitly set.
  public var hasOutputInfo: Bool {return self._outputInfo != nil}
  /// Clears the value of `outputInfo`. Subsequent reads from it will return its default value.
  public mutating func clearOutputInfo() {self._outputInfo = nil}

  /// A particular version of the model, e.g., to specify the version when creating a workflow.
  public var modelVersion: Clarifai_Api_ModelVersion {
    get {return _modelVersion ?? Clarifai_Api_ModelVersion()}
    set {_modelVersion = newValue}
  }
  /// Returns true if `modelVersion` has been explicitly set.
  public var hasModelVersion: Bool {return self._modelVersion != nil}
  /// Clears the value of `modelVersion`. Subsequent reads from it will return its default value.
  public mutating func clearModelVersion() {self._modelVersion = nil}

  /// An even nicer-to-read name for public Clarifai models where we're not happy with the name but
  /// need a temporary workaround while we check what depends on these names.
  public var displayName: String = String()

  /// The user id that the model belongs to.
  public var userID: String = String()

  /// Info about the models' input and configuration of them.
  public var inputInfo: Clarifai_Api_InputInfo {
    get {return _inputInfo ?? Clarifai_Api_InputInfo()}
    set {_inputInfo = newValue}
  }
  /// Returns true if `inputInfo` has been explicitly set.
  public var hasInputInfo: Bool {return self._inputInfo != nil}
  /// Clears the value of `inputInfo`. Subsequent reads from it will return its default value.
  public mutating func clearInputInfo() {self._inputInfo = nil}

  /// Configuration for the training process of this model.
  public var trainInfo: Clarifai_Api_TrainInfo {
    get {return _trainInfo ?? Clarifai_Api_TrainInfo()}
    set {_trainInfo = newValue}
  }
  /// Returns true if `trainInfo` has been explicitly set.
  public var hasTrainInfo: Bool {return self._trainInfo != nil}
  /// Clears the value of `trainInfo`. Subsequent reads from it will return its default value.
  public mutating func clearTrainInfo() {self._trainInfo = nil}

  /// The ModelType.Id that is used for this model. This is used for all versions and you cannot
  /// change model_type_id between versions of the same model.
  public var modelTypeID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _createdAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _outputInfo: Clarifai_Api_OutputInfo? = nil
  fileprivate var _modelVersion: Clarifai_Api_ModelVersion? = nil
  fileprivate var _inputInfo: Clarifai_Api_InputInfo? = nil
  fileprivate var _trainInfo: Clarifai_Api_TrainInfo? = nil
}

/// OutputInfo defines some of the settings for each model version that PatchModels can effect. These
/// parameters control some of the training or inference operations that this model can do.
/// As the number of parameters continued to grow when we launched more ModelTypes we decided to move
/// to using the OutputInfo.params field which is a Struct (or JSON object if you're using
/// our JSON REST APIs). This allows each ModelType to define the set of fields, their default values
/// and description of each field so that we can display those in Portal and make the creation of
/// Model's very extensible. The OutputConfig object will eventually go away in favor of
/// infer_params struct.
public struct Clarifai_Api_OutputInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// List of concepts or other output related data for the model.
  public var data: Clarifai_Api_Data {
    get {return _data ?? Clarifai_Api_Data()}
    set {_data = newValue}
  }
  /// Returns true if `data` has been explicitly set.
  public var hasData: Bool {return self._data != nil}
  /// Clears the value of `data`. Subsequent reads from it will return its default value.
  public mutating func clearData() {self._data = nil}

  /// Model configuration...going away in favor of infer_params and train_params over time.
  /// TO BE DEPRECATED
  public var outputConfig: Clarifai_Api_OutputConfig {
    get {return _outputConfig ?? Clarifai_Api_OutputConfig()}
    set {_outputConfig = newValue}
  }
  /// Returns true if `outputConfig` has been explicitly set.
  public var hasOutputConfig: Bool {return self._outputConfig != nil}
  /// Clears the value of `outputConfig`. Subsequent reads from it will return its default value.
  public mutating func clearOutputConfig() {self._outputConfig = nil}

  /// For returning where to look for the Output info if not returning it.
  public var message: String = String()

  /// To help clients know what type of Data to expect out of the model.
  /// TO BE DEPRECATED
  public var type: String = String()

  /// Extra metadata about the Type data.
  /// TO BE DEPRECATED
  public var typeExt: String = String()

  /// Map from the api.Data field names to the underlying model graph's outputs. When using a
  /// PretrainedModelConfig the values in this map need to match the Triton config.pbtxt output names.
  public var fieldsMap: SwiftProtobuf.Google_Protobuf_Struct {
    get {return _fieldsMap ?? SwiftProtobuf.Google_Protobuf_Struct()}
    set {_fieldsMap = newValue}
  }
  /// Returns true if `fieldsMap` has been explicitly set.
  public var hasFieldsMap: Bool {return self._fieldsMap != nil}
  /// Clears the value of `fieldsMap`. Subsequent reads from it will return its default value.
  public mutating func clearFieldsMap() {self._fieldsMap = nil}

  /// For predicting with the various ModelType's we accept a Struct (JSON object) worth of args
  /// that the ModelTypeField defines. During inference, the settings contained within are sent
  /// to the model predictor to alter predictions from this Model.
  public var params: SwiftProtobuf.Google_Protobuf_Struct {
    get {return _params ?? SwiftProtobuf.Google_Protobuf_Struct()}
    set {_params = newValue}
  }
  /// Returns true if `params` has been explicitly set.
  public var hasParams: Bool {return self._params != nil}
  /// Clears the value of `params`. Subsequent reads from it will return its default value.
  public mutating func clearParams() {self._params = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _data: Clarifai_Api_Data? = nil
  fileprivate var _outputConfig: Clarifai_Api_OutputConfig? = nil
  fileprivate var _fieldsMap: SwiftProtobuf.Google_Protobuf_Struct? = nil
  fileprivate var _params: SwiftProtobuf.Google_Protobuf_Struct? = nil
}

public struct Clarifai_Api_InputInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Map from the api.Data field names to the underlying model graph's inputs. When using a
  /// PretrainedModelConfig the values in this map need to match the Triton config.pbtxt input names.
  public var fieldsMap: SwiftProtobuf.Google_Protobuf_Struct {
    get {return _fieldsMap ?? SwiftProtobuf.Google_Protobuf_Struct()}
    set {_fieldsMap = newValue}
  }
  /// Returns true if `fieldsMap` has been explicitly set.
  public var hasFieldsMap: Bool {return self._fieldsMap != nil}
  /// Clears the value of `fieldsMap`. Subsequent reads from it will return its default value.
  public mutating func clearFieldsMap() {self._fieldsMap = nil}

  /// To control the inputs to the given model we allow a list of parameters
  /// defined for each ModelType as a Struct (JSON object) here. During training or inference, the
  /// settings contained within are sent to the training processor to alter the training process.
  public var params: SwiftProtobuf.Google_Protobuf_Struct {
    get {return _params ?? SwiftProtobuf.Google_Protobuf_Struct()}
    set {_params = newValue}
  }
  /// Returns true if `params` has been explicitly set.
  public var hasParams: Bool {return self._params != nil}
  /// Clears the value of `params`. Subsequent reads from it will return its default value.
  public mutating func clearParams() {self._params = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _fieldsMap: SwiftProtobuf.Google_Protobuf_Struct? = nil
  fileprivate var _params: SwiftProtobuf.Google_Protobuf_Struct? = nil
}

public struct Clarifai_Api_TrainInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// To control the training process when PostModelVersions is used we allow a list of parameters
  /// defined for each ModelType as a Struct (JSON object) here. During training, the settings
  /// contained within are sent to the training processor to alter the training process.
  public var params: SwiftProtobuf.Google_Protobuf_Struct {
    get {return _params ?? SwiftProtobuf.Google_Protobuf_Struct()}
    set {_params = newValue}
  }
  /// Returns true if `params` has been explicitly set.
  public var hasParams: Bool {return self._params != nil}
  /// Clears the value of `params`. Subsequent reads from it will return its default value.
  public mutating func clearParams() {self._params = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _params: SwiftProtobuf.Google_Protobuf_Struct? = nil
}

/// OutputConfig is a collection of parameters controlling either inference or training settings for
/// the given Model. This message will be deprecated over time in favor or infer_params and
/// train_params in OutputInfo which are cleaner and more extensible for many ModelTypes.
public struct Clarifai_Api_OutputConfig {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// For custom concept model training: whether the concept predictions must sum to 1.
  public var conceptsMutuallyExclusive: Bool = false

  /// For custom concept model training: Whether negatives should only be sampled from within the app during
  /// training, for custom models.
  public var closedEnvironment: Bool = false

  /// DEPRECATED: For custom models, this is the base model to use for image embeddings.
  /// Default is general model.
  public var existingModelID: String = String()

  /// For concept model predictions: Overrides the default_language for the app in a predict call.
  public var language: String = String()

  /// DEPRECATED: Hyper-parameters for custom training.
  /// Use new hyper_params field instead.
  public var hyperParameters: String = String()

  /// For concept model predictions:  Maximum number of concepts in result. Defaults to 0 which under
  /// the hood will return default of 20. We do a server side default in order to control this
  /// feature in the future.
  public var maxConcepts: UInt32 = 0

  /// For concept model predictions: Minimum value of concept's probability score in result.
  /// Defaults to 0.0 which means we won't do any thresholding as all probabilities will
  /// likely be > 0.0.
  public var minValue: Float = 0

  /// For concept model predictions: Select concepts in result by name or by id
  public var selectConcepts: [Clarifai_Api_Concept] = []

  /// For custom concept model training: Training timeout of the model (in seconds)
  public var trainingTimeout: UInt32 = 0

  /// For model predictions on video: Sample delay for video predicting (1 frame per N milliseconds)
  public var sampleMs: UInt32 = 0

  /// For custom model training: Hyperparameters for custom training
  public var hyperParams: SwiftProtobuf.Google_Protobuf_Struct {
    get {return _hyperParams ?? SwiftProtobuf.Google_Protobuf_Struct()}
    set {_hyperParams = newValue}
  }
  /// Returns true if `hyperParams` has been explicitly set.
  public var hasHyperParams: Bool {return self._hyperParams != nil}
  /// Clears the value of `hyperParams`. Subsequent reads from it will return its default value.
  public mutating func clearHyperParams() {self._hyperParams = nil}

  /// For custom model training: this is the base model version to use for image embeddings.
  /// This has to be one of the embed models in the app workflow.
  public var embedModelVersionID: String = String()

  /// For custom model training: Use this flag to fail on missing positive examples
  /// By default we fill in the missing with random examples
  public var failOnMissingPositiveExamples: Bool = false

  /// For custom model training: This is any additional metadata as a JSON object that we want
  /// want to persist in the model's output config. This is a useful quick way to set fields for
  /// introducing fields for new model types so we don't have to add a new proto field and DB field
  /// each time. Please refer to the documentation or model implementation internally for more
  /// details on what fields are supported for which models.
  /// TODO(zeiler): remove this field after Portal is updated.
  public var modelMetadata: SwiftProtobuf.Google_Protobuf_Struct {
    get {return _modelMetadata ?? SwiftProtobuf.Google_Protobuf_Struct()}
    set {_modelMetadata = newValue}
  }
  /// Returns true if `modelMetadata` has been explicitly set.
  public var hasModelMetadata: Bool {return self._modelMetadata != nil}
  /// Clears the value of `modelMetadata`. Subsequent reads from it will return its default value.
  public mutating func clearModelMetadata() {self._modelMetadata = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _hyperParams: SwiftProtobuf.Google_Protobuf_Struct? = nil
  fileprivate var _modelMetadata: SwiftProtobuf.Google_Protobuf_Struct? = nil
}

/// ModelSpec is a definition of a Model type. This is used in model mode of portal
/// to list out the possible models that can be created and can be used to understand more about
/// the possible models in our platform.
public struct Clarifai_Api_ModelType {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// A unique identifies for this model type. This is differnt than the 'type' field below because
  /// the 'type' can be re-used for differnet input and output combinations whereas 'id' is always
  /// unique.
  public var id: String = String()

  /// title for this model in model gallery
  public var title: String = String()

  /// Description of this model type.
  public var description_p: String = String()

  /// The type of the model to create. This is currently stored in output_info.type.
  public var type: String = String()

  /// The list of input fields that this model accepts. These are the keys of the Model's
  /// InputInfo.fields_map
  public var inputFields: [String] = []

  /// The list of output fields that this model accepts. These are the keys of the Model's
  /// OutputInfo.fields_map
  public var outputFields: [String] = []

  /// Is this model trainable in our platform.
  public var trainable: Bool = false

  /// Is this model creatable. We have some pre-trained model types that users cannot create yet in
  /// model mode.
  public var creatable: Bool = false

  /// Is this model type only for internal users at this time.
  public var internalOnly: Bool = false

  /// The remaining fields are definitions of the configurable fields that exist.
  /// Each field has path into the Model object such as "name" as a top level or "output_info.data"
  /// if it's the Data obejct within the OutputInfo object. We deciddd to not break these up
  /// into input_info, train_info and output_info related parameters and instead use the path
  /// so that they are most flexible.
  public var modelTypeFields: [Clarifai_Api_ModelTypeField] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// For each field in ModelType.model_type_fields we defined them with ModelTypeField
public struct Clarifai_Api_ModelTypeField {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The path to the field within the Model proto.
  /// Example:
  /// "output_info.data" would be the Data message in the OutputInfo message.
  /// "output_info.output_config.language" is in the OutputConfig message within OutputInfo
  /// "input_info.params" is in the params struct within InputInfo.
  /// "output_info.params" is in the params struct within OutputInfo.
  /// "train_info.params" is in the params struct within TrainInfo.
  /// and so on.
  public var path: String = String()

  /// The field for this field.
  public var fieldType: Clarifai_Api_ModelTypeField.ModelTypeFieldType = .invalidModelTypeFieldType

  /// A default value. We use the Value field because we want to have structured data (just like
  /// google.protobuf.Struct but this is just a single value).
  public var defaultValue: SwiftProtobuf.Google_Protobuf_Value {
    get {return _defaultValue ?? SwiftProtobuf.Google_Protobuf_Value()}
    set {_defaultValue = newValue}
  }
  /// Returns true if `defaultValue` has been explicitly set.
  public var hasDefaultValue: Bool {return self._defaultValue != nil}
  /// Clears the value of `defaultValue`. Subsequent reads from it will return its default value.
  public mutating func clearDefaultValue() {self._defaultValue = nil}

  /// Description for this field.
  public var description_p: String = String()

  /// Placeholder text for the UI element.
  public var placeholder: String = String()

  /// List of options of the ENUM type and potentially additional fields they bring with them.
  public var modelTypeEnumOptions: [Clarifai_Api_ModelTypeEnumOption] = []

  /// If this field should appear for internal users only.
  public var internalOnly: Bool = false

  /// If this field is a required field. If True then during validation you won't be able to create
  /// a model of this type with providing a value for this field. When False, the ModelType's
  /// default_value will be used for this field.
  public var required: Bool = false

  /// If the field_type is RANGE, this must be filled in.
  public var modelTypeRangeInfo: Clarifai_Api_ModelTypeRangeInfo {
    get {return _modelTypeRangeInfo ?? Clarifai_Api_ModelTypeRangeInfo()}
    set {_modelTypeRangeInfo = newValue}
  }
  /// Returns true if `modelTypeRangeInfo` has been explicitly set.
  public var hasModelTypeRangeInfo: Bool {return self._modelTypeRangeInfo != nil}
  /// Clears the value of `modelTypeRangeInfo`. Subsequent reads from it will return its default value.
  public mutating func clearModelTypeRangeInfo() {self._modelTypeRangeInfo = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// These are various types of fields that we have UIs for.
  public enum ModelTypeFieldType: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case invalidModelTypeFieldType // = 0
    case boolean // = 1
    case string // = 2
    case number // = 3

    /// For auto-completting to concepts in the app. This goes into an data.concepts field.
    case arrayOfConcepts // = 4

    /// For auto-completting to concepts in the app. This goes into an data.concepts field.
    case arrayOfConceptsWithThreshold // = 5

    /// A range for a float value.
    case range // = 7

    /// If ENUM is used then the "enum_options" field should also be filled in which allows for
    /// additional ModelTypeFields too depending on the enum choice.
    case `enum` // = 8

    /// For listing collaborators of the app. The field is a string of the collaborator's user_id.
    case collaborators // = 9

    /// For arbitrary json object: "{...}"
    case json // = 10

    /// Such as [1.0, 2.0, 3.5]
    case arrayOfNumbers // = 11

    /// For selecting the embed_model_version_id for context based models.
    /// This is a string type in the API request.
    case workflowEmbedModels // = 12
    case UNRECOGNIZED(Int)

    public init() {
      self = .invalidModelTypeFieldType
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .invalidModelTypeFieldType
      case 1: self = .boolean
      case 2: self = .string
      case 3: self = .number
      case 4: self = .arrayOfConcepts
      case 5: self = .arrayOfConceptsWithThreshold
      case 7: self = .range
      case 8: self = .enum
      case 9: self = .collaborators
      case 10: self = .json
      case 11: self = .arrayOfNumbers
      case 12: self = .workflowEmbedModels
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .invalidModelTypeFieldType: return 0
      case .boolean: return 1
      case .string: return 2
      case .number: return 3
      case .arrayOfConcepts: return 4
      case .arrayOfConceptsWithThreshold: return 5
      case .range: return 7
      case .enum: return 8
      case .collaborators: return 9
      case .json: return 10
      case .arrayOfNumbers: return 11
      case .workflowEmbedModels: return 12
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}

  fileprivate var _defaultValue: SwiftProtobuf.Google_Protobuf_Value? = nil
  fileprivate var _modelTypeRangeInfo: Clarifai_Api_ModelTypeRangeInfo? = nil
}

#if swift(>=4.2)

extension Clarifai_Api_ModelTypeField.ModelTypeFieldType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Clarifai_Api_ModelTypeField.ModelTypeFieldType] = [
    .invalidModelTypeFieldType,
    .boolean,
    .string,
    .number,
    .arrayOfConcepts,
    .arrayOfConceptsWithThreshold,
    .range,
    .enum,
    .collaborators,
    .json,
    .arrayOfNumbers,
    .workflowEmbedModels,
  ]
}

#endif  // swift(>=4.2)

public struct Clarifai_Api_ModelTypeRangeInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The start of the range as a float.
  public var min: Float = 0

  /// The end of the range as a float.
  public var max: Float = 0

  /// An optional step size for the range. If provided then only values at that step size will be
  /// rounded to. For example if step is 0.02 then 0.0245 will round to 0.02.
  public var step: Float = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Clarifai_Api_ModelTypeEnumOption {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The unique value of the enum option.
  public var id: String = String()

  /// Optional description for this enum option.
  public var description_p: String = String()

  /// These are additional fields that are specific to this enum choice. This allows
  /// us to use enums to control configuration settings as well.
  public var modelTypeFields: [Clarifai_Api_ModelTypeField] = []

  /// If this enum option should be internal only.
  public var internalOnly: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Clarifai_Api_ModelQuery {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The name ofthe field. This supports wilcard queries like "gen*" to match "general" as an example.
  public var name: String = String()

  /// This is the legacy model type. Do not use, only kept for support in old API clients.
  public var type: String = String()

  /// Filter models by the specific model_type_id. See ListModelTypes for the list of ModelType.Id's
  /// supported.
  public var modelTypeID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/////////////////////////////////////////////////////////////////////////////////
/// Messages from /proto/clarifai/api/model_version.proto
/////////////////////////////////////////////////////////////////////////////////
public struct Clarifai_Api_ModelVersion {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: String = String()

  /// When the version was created.
  public var createdAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _createdAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_createdAt = newValue}
  }
  /// Returns true if `createdAt` has been explicitly set.
  public var hasCreatedAt: Bool {return self._createdAt != nil}
  /// Clears the value of `createdAt`. Subsequent reads from it will return its default value.
  public mutating func clearCreatedAt() {self._createdAt = nil}

  /// The status of the version (whether it's untrained, training, trained, etc.).
  public var status: Clarifai_Api_Status_Status {
    get {return _status ?? Clarifai_Api_Status_Status()}
    set {_status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  public var hasStatus: Bool {return self._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  public mutating func clearStatus() {self._status = nil}

  public var activeConceptCount: UInt32 = 0

  public var metrics: Clarifai_Api_EvalMetrics {
    get {return _metrics ?? Clarifai_Api_EvalMetrics()}
    set {_metrics = newValue}
  }
  /// Returns true if `metrics` has been explicitly set.
  public var hasMetrics: Bool {return self._metrics != nil}
  /// Clears the value of `metrics`. Subsequent reads from it will return its default value.
  public mutating func clearMetrics() {self._metrics = nil}

  /// number of inputs in the model version
  public var totalInputCount: UInt32 = 0

  /// When training of this version was completed.
  public var completedAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _completedAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_completedAt = newValue}
  }
  /// Returns true if `completedAt` has been explicitly set.
  public var hasCompletedAt: Bool {return self._completedAt != nil}
  /// Clears the value of `completedAt`. Subsequent reads from it will return its default value.
  public mutating func clearCompletedAt() {self._completedAt = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _createdAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _status: Clarifai_Api_Status_Status? = nil
  fileprivate var _metrics: Clarifai_Api_EvalMetrics? = nil
  fileprivate var _completedAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

public struct Clarifai_Api_PretrainedModelConfig {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// This is the internal id of the pretrained model.
  public var id: String = String()

  /// This is the internal type of the pretrained model.
  public var type: String = String()

  /// Map from the api.Data field names to the Triton config.pbtxt input.
  public var inputFieldsMap: SwiftProtobuf.Google_Protobuf_Struct {
    get {return _inputFieldsMap ?? SwiftProtobuf.Google_Protobuf_Struct()}
    set {_inputFieldsMap = newValue}
  }
  /// Returns true if `inputFieldsMap` has been explicitly set.
  public var hasInputFieldsMap: Bool {return self._inputFieldsMap != nil}
  /// Clears the value of `inputFieldsMap`. Subsequent reads from it will return its default value.
  public mutating func clearInputFieldsMap() {self._inputFieldsMap = nil}

  /// Map from the api.Data field names to the Triton config.pbtxt output.
  public var outputFieldsMap: SwiftProtobuf.Google_Protobuf_Struct {
    get {return _outputFieldsMap ?? SwiftProtobuf.Google_Protobuf_Struct()}
    set {_outputFieldsMap = newValue}
  }
  /// Returns true if `outputFieldsMap` has been explicitly set.
  public var hasOutputFieldsMap: Bool {return self._outputFieldsMap != nil}
  /// Clears the value of `outputFieldsMap`. Subsequent reads from it will return its default value.
  public mutating func clearOutputFieldsMap() {self._outputFieldsMap = nil}

  /// Preprocessing steps for the model as a json string
  public var dataProviderParams: String = String()

  /// Url to a zipped up model in triton format with only version 1
  public var modelZipURL: String = String()

  /// Whether to overwrite the model for the existing internal id
  public var overwrite: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _inputFieldsMap: SwiftProtobuf.Google_Protobuf_Struct? = nil
  fileprivate var _outputFieldsMap: SwiftProtobuf.Google_Protobuf_Struct? = nil
}

public struct Clarifai_Api_TrainStats {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var lossCurve: [Clarifai_Api_LossCurveEntry] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Clarifai_Api_LossCurveEntry {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// current epoch
  public var epoch: UInt32 = 0

  /// current global step
  public var globalStep: UInt32 = 0

  /// current cost
  /// FIXME(rigel): this should be loss instead of cost.
  public var cost: Float = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Clarifai_Api_LabelCount {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// FIXME: should move to Concept object and return the whole thing (including name and id)
  /// otherwise if two concepts have same name then you won't tell them apart in confusion matrix.
  public var conceptName: String = String()

  public var count: UInt32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Clarifai_Api_LabelDistribution {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var positiveLabelCounts: [Clarifai_Api_LabelCount] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// NOTE: this is inefficient, should just have the order of the rows/cols
public struct Clarifai_Api_CooccurrenceMatrixEntry {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// concept_id for the row
  public var row: String = String()

  /// concept_id for the col
  public var col: String = String()

  public var count: UInt32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Clarifai_Api_CooccurrenceMatrix {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var matrix: [Clarifai_Api_CooccurrenceMatrixEntry] = []

  /// These concept_ids are ordered by the strength of the diagonal in the ConfusionMatrix.
  public var conceptIds: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Clarifai_Api_ConfusionMatrixEntry {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var predicted: String = String()

  public var actual: String = String()

  public var value: Float = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Clarifai_Api_ConfusionMatrix {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var matrix: [Clarifai_Api_ConfusionMatrixEntry] = []

  /// These concept_ids are ordered by the strength of the diagonal in the ConfusionMatrix.
  public var conceptIds: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Clarifai_Api_ROC {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var fpr: [Float] = []

  public var tpr: [Float] = []

  public var thresholds: [Float] = []

  public var fprPerImage: [Float] = []

  public var fprPerObject: [Float] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Clarifai_Api_PrecisionRecallCurve {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var recall: [Float] = []

  public var precision: [Float] = []

  public var thresholds: [Float] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Clarifai_Api_BinaryMetrics {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var numPos: UInt32 = 0

  public var numNeg: UInt32 = 0

  public var numTot: UInt32 = 0

  public var rocAuc: Float = 0

  public var f1: Float = 0

  public var concept: Clarifai_Api_Concept {
    get {return _concept ?? Clarifai_Api_Concept()}
    set {_concept = newValue}
  }
  /// Returns true if `concept` has been explicitly set.
  public var hasConcept: Bool {return self._concept != nil}
  /// Clears the value of `concept`. Subsequent reads from it will return its default value.
  public mutating func clearConcept() {self._concept = nil}

  public var rocCurve: Clarifai_Api_ROC {
    get {return _rocCurve ?? Clarifai_Api_ROC()}
    set {_rocCurve = newValue}
  }
  /// Returns true if `rocCurve` has been explicitly set.
  public var hasRocCurve: Bool {return self._rocCurve != nil}
  /// Clears the value of `rocCurve`. Subsequent reads from it will return its default value.
  public mutating func clearRocCurve() {self._rocCurve = nil}

  public var precisionRecallCurve: Clarifai_Api_PrecisionRecallCurve {
    get {return _precisionRecallCurve ?? Clarifai_Api_PrecisionRecallCurve()}
    set {_precisionRecallCurve = newValue}
  }
  /// Returns true if `precisionRecallCurve` has been explicitly set.
  public var hasPrecisionRecallCurve: Bool {return self._precisionRecallCurve != nil}
  /// Clears the value of `precisionRecallCurve`. Subsequent reads from it will return its default value.
  public mutating func clearPrecisionRecallCurve() {self._precisionRecallCurve = nil}

  public var avgPrecision: Float = 0

  public var areaName: String = String()

  public var areaMin: Double = 0

  public var areaMax: Double = 0

  public var iou: Float = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _concept: Clarifai_Api_Concept? = nil
  fileprivate var _rocCurve: Clarifai_Api_ROC? = nil
  fileprivate var _precisionRecallCurve: Clarifai_Api_PrecisionRecallCurve? = nil
}

public struct Clarifai_Api_EvalTestSetEntry {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Input CFID
  public var id: String = String()

  public var url: String = String()

  public var predictedConcepts: [Clarifai_Api_Concept] = []

  /// All the ground truth concepts will be show on the top level
  public var groundTruthConcepts: [Clarifai_Api_Concept] = []

  /// Only region-based/frame-based app contains this annotation
  /// Each annotation only contains one region
  /// And the concepts is in ground_truth_concepts instead of this annotation
  public var annotation: Clarifai_Api_Annotation {
    get {return _annotation ?? Clarifai_Api_Annotation()}
    set {_annotation = newValue}
  }
  /// Returns true if `annotation` has been explicitly set.
  public var hasAnnotation: Bool {return self._annotation != nil}
  /// Clears the value of `annotation`. Subsequent reads from it will return its default value.
  public mutating func clearAnnotation() {self._annotation = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _annotation: Clarifai_Api_Annotation? = nil
}

/// NOTE(Janvier): We copy this from proto/utils/lopq_service.proto instead of importing it because
/// we should not import internal protos in public protos.
public struct Clarifai_Api_LOPQEvalResult {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Rank k for which all metrics are reported.
  public var k: Int32 = 0

  /// Recall @ k assuming the brute force search is the ground truth.
  public var recallVsBruteForce: Float = 0

  /// Kendall's tau correlation @ k assuming the brute force search is the ground truth.
  public var kendallTauVsBruteForce: Float = 0

  /// The percentage of the most frequent code in the indexed part of evaluation data.
  public var mostFrequentCodePercent: Float = 0

  /// Normalized Discounted Cumulative Gain (NDCG) @ k with a ground truth inferred from annotations
  /// and/or prediction for this evaluation LOPQ model.
  /// NDCG uses individual relevance scores of each returned image to evaluate the usefulness, or
  /// gain, of a document based on its position in the result list. The premise of DCG is that
  /// highly relevant documents appearing lower in a search result list should be penalized as the
  /// graded relevance value is reduced logarithmically proportional to the position of the result.
  /// See: https://en.wikipedia.org/wiki/Information_retrieval#Discounted_cumulative_gain
  ///
  /// To compute the relevance score between two images we consider two cases:
  /// 1) Only one label for each image
  /// An image is relevant to an image query iff they are labeled the same (score 1), and
  /// not relevant otherwise (score 0)
  /// 2) Multiple labels for each image
  /// Here an image relevancy with respect to a single image query is measured by f-beta score
  /// assuming the query image list of labels as ground truth and comparing them with that of
  /// the search result. These labels can come from image annotations or if substitute_annotation_misses
  /// is set, predictions of base classifier where any prediction with prob < prob_threshold are
  /// discarded. To quantify the relevancy score of a single search result we opt to compute precision
  /// and recall @ k for simplicity, and combine them with f-beta score to obtain a single number.
  public var lopqNdcg: Float = 0

  /// Brute force NDCG which gives a baseline to compare to and is a measure of how good
  /// the embeddings are.
  public var bruteForceNdcg: Float = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// FIXME: copy this into an internal proto since it is stored in DB and field names can't change.
public struct Clarifai_Api_MetricsSummary {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var top1Accuracy: Float = 0

  public var top5Accuracy: Float = 0

  public var macroAvgRocAuc: Float = 0

  public var macroStdRocAuc: Float = 0

  public var macroAvgF1Score: Float = 0

  public var macroStdF1Score: Float = 0

  public var macroAvgPrecision: Float = 0

  public var macroAvgRecall: Float = 0

  public var meanAvgPrecisionIou50: Float = 0

  public var meanAvgPrecisionIouRange: Float = 0

  public var lopqMetrics: [Clarifai_Api_LOPQEvalResult] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Clarifai_Api_EvalMetrics {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var status: Clarifai_Api_Status_Status {
    get {return _status ?? Clarifai_Api_Status_Status()}
    set {_status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  public var hasStatus: Bool {return self._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  public mutating func clearStatus() {self._status = nil}

  public var id: String = String()

  public var summary: Clarifai_Api_MetricsSummary {
    get {return _summary ?? Clarifai_Api_MetricsSummary()}
    set {_summary = newValue}
  }
  /// Returns true if `summary` has been explicitly set.
  public var hasSummary: Bool {return self._summary != nil}
  /// Clears the value of `summary`. Subsequent reads from it will return its default value.
  public mutating func clearSummary() {self._summary = nil}

  public var confusionMatrix: Clarifai_Api_ConfusionMatrix {
    get {return _confusionMatrix ?? Clarifai_Api_ConfusionMatrix()}
    set {_confusionMatrix = newValue}
  }
  /// Returns true if `confusionMatrix` has been explicitly set.
  public var hasConfusionMatrix: Bool {return self._confusionMatrix != nil}
  /// Clears the value of `confusionMatrix`. Subsequent reads from it will return its default value.
  public mutating func clearConfusionMatrix() {self._confusionMatrix = nil}

  public var cooccurrenceMatrix: Clarifai_Api_CooccurrenceMatrix {
    get {return _cooccurrenceMatrix ?? Clarifai_Api_CooccurrenceMatrix()}
    set {_cooccurrenceMatrix = newValue}
  }
  /// Returns true if `cooccurrenceMatrix` has been explicitly set.
  public var hasCooccurrenceMatrix: Bool {return self._cooccurrenceMatrix != nil}
  /// Clears the value of `cooccurrenceMatrix`. Subsequent reads from it will return its default value.
  public mutating func clearCooccurrenceMatrix() {self._cooccurrenceMatrix = nil}

  public var labelCounts: Clarifai_Api_LabelDistribution {
    get {return _labelCounts ?? Clarifai_Api_LabelDistribution()}
    set {_labelCounts = newValue}
  }
  /// Returns true if `labelCounts` has been explicitly set.
  public var hasLabelCounts: Bool {return self._labelCounts != nil}
  /// Clears the value of `labelCounts`. Subsequent reads from it will return its default value.
  public mutating func clearLabelCounts() {self._labelCounts = nil}

  public var binaryMetrics: [Clarifai_Api_BinaryMetrics] = []

  public var testSet: [Clarifai_Api_EvalTestSetEntry] = []

  public var metricsByArea: [Clarifai_Api_BinaryMetrics] = []

  public var metricsByClass: [Clarifai_Api_BinaryMetrics] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _status: Clarifai_Api_Status_Status? = nil
  fileprivate var _summary: Clarifai_Api_MetricsSummary? = nil
  fileprivate var _confusionMatrix: Clarifai_Api_ConfusionMatrix? = nil
  fileprivate var _cooccurrenceMatrix: Clarifai_Api_CooccurrenceMatrix? = nil
  fileprivate var _labelCounts: Clarifai_Api_LabelDistribution? = nil
}

public struct Clarifai_Api_FieldsValue {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var confusionMatrix: Bool = false

  public var cooccurrenceMatrix: Bool = false

  public var labelCounts: Bool = false

  public var binaryMetrics: Bool = false

  public var testSet: Bool = false

  public var metricsByArea: Bool = false

  public var metricsByClass: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/////////////////////////////////////////////////////////////////////////////////
/// Messages from /proto/clarifai/api/output.proto
/////////////////////////////////////////////////////////////////////////////////
public struct Clarifai_Api_Output {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// One of these outputs per Input
  public var id: String = String()

  public var status: Clarifai_Api_Status_Status {
    get {return _status ?? Clarifai_Api_Status_Status()}
    set {_status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  public var hasStatus: Bool {return self._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  public mutating func clearStatus() {self._status = nil}

  /// When the object was created. We follow the XXXX timestamp
  /// format. We use https://www.ietf.org/rfc/rfc3339.txt format:
  /// "2006-01-02T15:04:05.999999Z" so you can expect results like
  /// the following from the API:
  /// "2017-04-11T21:50:50.223962Z"
  public var createdAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _createdAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_createdAt = newValue}
  }
  /// Returns true if `createdAt` has been explicitly set.
  public var hasCreatedAt: Bool {return self._createdAt != nil}
  /// Clears the value of `createdAt`. Subsequent reads from it will return its default value.
  public mutating func clearCreatedAt() {self._createdAt = nil}

  /// The model that created this Output.
  public var model: Clarifai_Api_Model {
    get {return _model ?? Clarifai_Api_Model()}
    set {_model = newValue}
  }
  /// Returns true if `model` has been explicitly set.
  public var hasModel: Bool {return self._model != nil}
  /// Clears the value of `model`. Subsequent reads from it will return its default value.
  public mutating func clearModel() {self._model = nil}

  /// The input that was passed to the model to create this Output. For example if we have an image
  /// model then it will take as input here an Input object with Image filled in.
  public var input: Clarifai_Api_Input {
    get {return _input ?? Clarifai_Api_Input()}
    set {_input = newValue}
  }
  /// Returns true if `input` has been explicitly set.
  public var hasInput: Bool {return self._input != nil}
  /// Clears the value of `input`. Subsequent reads from it will return its default value.
  public mutating func clearInput() {self._input = nil}

  /// The output data for this Output. For example if we have a concept model then the predicted
  /// concepts will appear here.
  public var data: Clarifai_Api_Data {
    get {return _data ?? Clarifai_Api_Data()}
    set {_data = newValue}
  }
  /// Returns true if `data` has been explicitly set.
  public var hasData: Bool {return self._data != nil}
  /// Clears the value of `data`. Subsequent reads from it will return its default value.
  public mutating func clearData() {self._data = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _status: Clarifai_Api_Status_Status? = nil
  fileprivate var _createdAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _model: Clarifai_Api_Model? = nil
  fileprivate var _input: Clarifai_Api_Input? = nil
  fileprivate var _data: Clarifai_Api_Data? = nil
}

/////////////////////////////////////////////////////////////////////////////////
/// Messages from /proto/clarifai/api/scope.proto
/////////////////////////////////////////////////////////////////////////////////
public struct Clarifai_Api_ScopeDeps {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The scope
  public var scope: String = String()

  /// Other scopes that are required.
  public var dependingScopes: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Clarifai_Api_EndpointDeps {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The fully qualified endpoint to
  public var endpoint: String = String()

  /// Other scopes that are required.
  public var dependingScopes: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/////////////////////////////////////////////////////////////////////////////////
/// Messages from /proto/clarifai/api/search.proto
/////////////////////////////////////////////////////////////////////////////////
public struct Clarifai_Api_Hit {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// This is the score for the ranked Hit results of the search query. This score is a number
  /// between 0.0 and 1.0 as it represents a confidence in the search Hit. For example, if you search
  /// for "car" and get a close matching Hit, the score should be close to 1.0. If you get a score
  /// of close to 0.0 that means it's very disimilar to your query, in this case NOT a "car". There
  /// is a special intermediate score of 0.5 that means that the Hit is not really correlated with
  /// your search query (ie. not similar or dissimlar to the query) which is a common occurrence
  /// when using negate queries.
  /// Note: some queries that are just filtering down your app of inputs may just return a score of
  /// 1.0 for all Hits.
  public var score: Float = 0

  /// This is the matched input returned from the search query. This will contain information about
  /// the Input such as the url, created_at time and trusted annotation information (for backwards
  /// compatibility with apps that existed before Annotations were introduced.
  public var input: Clarifai_Api_Input {
    get {return _input ?? Clarifai_Api_Input()}
    set {_input = newValue}
  }
  /// Returns true if `input` has been explicitly set.
  public var hasInput: Bool {return self._input != nil}
  /// Clears the value of `input`. Subsequent reads from it will return its default value.
  public mutating func clearInput() {self._input = nil}

  /// We also provide back the specific matched annotation for the above input. We do this in order
  /// to support more complex Annotation queries in the And message below. For example if we match
  /// the search results to a region in your input, or a frame in a video input, this annotation
  /// field will be that matched annotation info and the input will be the image/video that the user
  /// originally added which contains those regions / frames.
  public var annotation: Clarifai_Api_Annotation {
    get {return _annotation ?? Clarifai_Api_Annotation()}
    set {_annotation = newValue}
  }
  /// Returns true if `annotation` has been explicitly set.
  public var hasAnnotation: Bool {return self._annotation != nil}
  /// Clears the value of `annotation`. Subsequent reads from it will return its default value.
  public mutating func clearAnnotation() {self._annotation = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _input: Clarifai_Api_Input? = nil
  fileprivate var _annotation: Clarifai_Api_Annotation? = nil
}

/// This is the common building block of a query which is a sequence of And messages ANDed together.
/// Note that some fields are used too RANK results (affect the scores) and some are used to FILTER
/// results (unordered subset of your app's contents). In general, FILTER operations are more
/// efficient queries at scale and when combined with RANK operations can speed up search performance
/// as you effectively operate on a smaller sub-set of your entire app.
public struct Clarifai_Api_And {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// FILTER by input.data... information.
  /// This can include human provided concepts, geo location info, metadata, etc.
  /// This is effectively searching over only the trusted annotation attached to an input in your
  /// app. To search by more specific annotation fields use the Annotation object here.
  public var input: Clarifai_Api_Input {
    get {return _input ?? Clarifai_Api_Input()}
    set {_input = newValue}
  }
  /// Returns true if `input` has been explicitly set.
  public var hasInput: Bool {return self._input != nil}
  /// Clears the value of `input`. Subsequent reads from it will return its default value.
  public mutating func clearInput() {self._input = nil}

  /// RANK based predicted outputs from models such as custom trained models, pre-trained models,
  /// etc. This is also where you enter the image url for a visual search because what we're asking
  /// the system to do is find output embedding most visually similar to the provided input (that
  /// input being in And.output.input.data.image.url for example). This will return the Hits
  /// sorted by visual similarity (1.0 being very similar or exact match and 0.0 being very
  /// dissimlar). For a search by Output concept, this means we're asking the system to rank
  /// the Hits by confidence of our model's predicted Outputs. So for example if the model
  /// predicts an image is 0.95 likely there is a "dog" present, that should related directly
  /// to the score returned if you search for Output concept "dog" in your query. This provides
  /// a natural ranking to search results based on confidence of predictions from the models and
  /// is used when ANDing multiple of these types of RANK by Output queries together as well.
  public var output: Clarifai_Api_Output {
    get {return _output ?? Clarifai_Api_Output()}
    set {_output = newValue}
  }
  /// Returns true if `output` has been explicitly set.
  public var hasOutput: Bool {return self._output != nil}
  /// Clears the value of `output`. Subsequent reads from it will return its default value.
  public mutating func clearOutput() {self._output = nil}

  /// If True then this will flip the meaning of this part of the
  /// query. This allow for queries such as dog AND ! metadata=={"blah":"value"}
  public var negate: Bool = false

  /// FILTER by annotation information. This is more flexible than just filtering by
  /// Input information because in the general case each input can have several annotations.
  /// Some example use cases for filtering by annotations:
  /// 1) find all the inputs annotated "dog" by worker_id = "XYZ"
  /// 2) find all the annotations associated with embed_model_version_id = "123"
  /// 3) find all the annotations that are trusted, etc.
  ///
  /// Since all the annotations under the hood are joined to the embedding model's annotation
  /// using worker_id's of other models like cluster models or concept models should be
  /// combinable with queries like visual search (a query with Output filled in).
  public var annotation: Clarifai_Api_Annotation {
    get {return _annotation ?? Clarifai_Api_Annotation()}
    set {_annotation = newValue}
  }
  /// Returns true if `annotation` has been explicitly set.
  public var hasAnnotation: Bool {return self._annotation != nil}
  /// Clears the value of `annotation`. Subsequent reads from it will return its default value.
  public mutating func clearAnnotation() {self._annotation = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _input: Clarifai_Api_Input? = nil
  fileprivate var _output: Clarifai_Api_Output? = nil
  fileprivate var _annotation: Clarifai_Api_Annotation? = nil
}

/// This is the search query used in /searches, model training requests, bulk data exports, etc.
public struct Clarifai_Api_Query {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The query syntax is simply a list of And operatiosn that will be ANDed together to fetch
  /// results which are returned to the user as Hit messages.
  public var ands: [Clarifai_Api_And] = []

  /// This allows the query to override any default language the app was setup in when doing Concept
  /// based searches. This currently only affects public Models Output searches when those public
  /// Models have translations for their Concepts.
  public var language: String = String()

  /// filters in this query
  /// e.q. only fetch annotations that have certain metadata
  public var filters: [Clarifai_Api_Filter] = []

  /// rankings in this query
  /// e.g. visual search by a url
  public var ranks: [Clarifai_Api_Rank] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// This is the new Search object used in saved searches.
public struct Clarifai_Api_Search {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Search query.
  public var query: Clarifai_Api_Query {
    get {return _query ?? Clarifai_Api_Query()}
    set {_query = newValue}
  }
  /// Returns true if `query` has been explicitly set.
  public var hasQuery: Bool {return self._query != nil}
  /// Clears the value of `query`. Subsequent reads from it will return its default value.
  public mutating func clearQuery() {self._query = nil}

  /// Customer facing, external ID for search to be saved. Provided by the user, e.g. "saved-search-1.
  /// It is unique per application.
  public var id: String = String()

  /// Application that owns this saved search.
  public var applicationID: String = String()

  /// Human readable display name of the saved search.
  public var name: String = String()

  /// "As of" timestamp, indicating a time in the past as of which we want to
  /// retrieve the annotations satisfying the query.
  public var asOf: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _asOf ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_asOf = newValue}
  }
  /// Returns true if `asOf` has been explicitly set.
  public var hasAsOf: Bool {return self._asOf != nil}
  /// Clears the value of `asOf`. Subsequent reads from it will return its default value.
  public mutating func clearAsOf() {self._asOf = nil}

  /// Git hash of the code that ran the filter.
  public var gitHash: String = String()

  /// When the saved search was created.
  public var createdAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _createdAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_createdAt = newValue}
  }
  /// Returns true if `createdAt` has been explicitly set.
  public var hasCreatedAt: Bool {return self._createdAt != nil}
  /// Clears the value of `createdAt`. Subsequent reads from it will return its default value.
  public mutating func clearCreatedAt() {self._createdAt = nil}

  /// When the saved search was updated.
  public var modifiedAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _modifiedAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_modifiedAt = newValue}
  }
  /// Returns true if `modifiedAt` has been explicitly set.
  public var hasModifiedAt: Bool {return self._modifiedAt != nil}
  /// Clears the value of `modifiedAt`. Subsequent reads from it will return its default value.
  public mutating func clearModifiedAt() {self._modifiedAt = nil}

  /// The search algorithm to be used.
  /// Options are are 'nearest_neighbor', 'brute_force', and 'avg_concept_brute_force'
  /// The last two perform a brute force search visual search instead of a more scalable distributed
  /// nearest neighbor search and should be used by advanced users only.
  /// If not specified we default to nearest neighbor
  public var algorithm: String = String()

  /// If true, save this search, and exit without executing the search.
  /// If false execute the query
  public var save: Bool = false

  /// Minimum value of confidence threshold score in result.
  /// Defaults to 0.0 which means we won't do any thresholding as all probabilities will
  /// likely be > 0.0.
  public var minValue: Float = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _query: Clarifai_Api_Query? = nil
  fileprivate var _asOf: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _createdAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _modifiedAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

public struct Clarifai_Api_Filter {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// If True then this will flip the meaning of this part of the
  /// query. This allow for queries such as dog AND ! metadata=={"blah":"value"}
  public var negate: Bool = false

  /// FILTER by annotation information.
  public var annotation: Clarifai_Api_Annotation {
    get {return _annotation ?? Clarifai_Api_Annotation()}
    set {_annotation = newValue}
  }
  /// Returns true if `annotation` has been explicitly set.
  public var hasAnnotation: Bool {return self._annotation != nil}
  /// Clears the value of `annotation`. Subsequent reads from it will return its default value.
  public mutating func clearAnnotation() {self._annotation = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _annotation: Clarifai_Api_Annotation? = nil
}

public struct Clarifai_Api_Rank {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// If True then this will flip the meaning of this part of the
  /// query. This allow for queries such as !dog
  public var negate: Bool = false

  /// RANK by annotation information.
  public var annotation: Clarifai_Api_Annotation {
    get {return _annotation ?? Clarifai_Api_Annotation()}
    set {_annotation = newValue}
  }
  /// Returns true if `annotation` has been explicitly set.
  public var hasAnnotation: Bool {return self._annotation != nil}
  /// Clears the value of `annotation`. Subsequent reads from it will return its default value.
  public mutating func clearAnnotation() {self._annotation = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _annotation: Clarifai_Api_Annotation? = nil
}

public struct Clarifai_Api_AnnotationSearchMetrics {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The ground truth we are evaluating against
  public var groundTruth: Clarifai_Api_Search {
    get {return _groundTruth ?? Clarifai_Api_Search()}
    set {_groundTruth = newValue}
  }
  /// Returns true if `groundTruth` has been explicitly set.
  public var hasGroundTruth: Bool {return self._groundTruth != nil}
  /// Clears the value of `groundTruth`. Subsequent reads from it will return its default value.
  public mutating func clearGroundTruth() {self._groundTruth = nil}

  /// The set we are evaluating
  public var searchToEval: Clarifai_Api_Search {
    get {return _searchToEval ?? Clarifai_Api_Search()}
    set {_searchToEval = newValue}
  }
  /// Returns true if `searchToEval` has been explicitly set.
  public var hasSearchToEval: Bool {return self._searchToEval != nil}
  /// Clears the value of `searchToEval`. Subsequent reads from it will return its default value.
  public mutating func clearSearchToEval() {self._searchToEval = nil}

  /// The metric result
  public var metrics: Clarifai_Api_EvalMetrics {
    get {return _metrics ?? Clarifai_Api_EvalMetrics()}
    set {_metrics = newValue}
  }
  /// Returns true if `metrics` has been explicitly set.
  public var hasMetrics: Bool {return self._metrics != nil}
  /// Clears the value of `metrics`. Subsequent reads from it will return its default value.
  public mutating func clearMetrics() {self._metrics = nil}

  /// data is filled out with the concepts used for this evaluation
  public var data: Clarifai_Api_Data {
    get {return _data ?? Clarifai_Api_Data()}
    set {_data = newValue}
  }
  /// Returns true if `data` has been explicitly set.
  public var hasData: Bool {return self._data != nil}
  /// Clears the value of `data`. Subsequent reads from it will return its default value.
  public mutating func clearData() {self._data = nil}

  /// active_concept_count is the number of concepts for this evaluation
  public var activeConceptCount: UInt32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _groundTruth: Clarifai_Api_Search? = nil
  fileprivate var _searchToEval: Clarifai_Api_Search? = nil
  fileprivate var _metrics: Clarifai_Api_EvalMetrics? = nil
  fileprivate var _data: Clarifai_Api_Data? = nil
}

/////////////////////////////////////////////////////////////////////////////////
/// Messages from /proto/clarifai/api/text.proto
/////////////////////////////////////////////////////////////////////////////////
public struct Clarifai_Api_Text {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// This is a raw text string.
  public var raw: String = String()

  /// Url to a text file
  public var url: String = String()

  public var allowDuplicateURL: Bool = false

  /// The hosted field lists original text hosted in Clarifai storage. This field is currently used
  /// only in response..
  public var hosted: Clarifai_Api_HostedURL {
    get {return _hosted ?? Clarifai_Api_HostedURL()}
    set {_hosted = newValue}
  }
  /// Returns true if `hosted` has been explicitly set.
  public var hasHosted: Bool {return self._hosted != nil}
  /// Clears the value of `hosted`. Subsequent reads from it will return its default value.
  public mutating func clearHosted() {self._hosted = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _hosted: Clarifai_Api_HostedURL? = nil
}

/////////////////////////////////////////////////////////////////////////////////
/// Messages from /proto/clarifai/api/user.proto
/////////////////////////////////////////////////////////////////////////////////
public struct Clarifai_Api_User {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: String = String()

  public var primaryEmail: String = String()

  public var firstName: String = String()

  public var lastName: String = String()

  public var companyName: String = String()

  public var billType: String = String()

  /// When the user was created. We follow the XXXX timestamp
  /// format. We use https://www.ietf.org/rfc/rfc3339.txt format:
  /// "2006-01-02T15:04:05.999999Z" so you can expect results like
  /// the following from the API:
  /// "2017-04-11T21:50:50.223962Z"
  public var createdAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _createdAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_createdAt = newValue}
  }
  /// Returns true if `createdAt` has been explicitly set.
  public var hasCreatedAt: Bool {return self._createdAt != nil}
  /// Clears the value of `createdAt`. Subsequent reads from it will return its default value.
  public mutating func clearCreatedAt() {self._createdAt = nil}

  public var dateGdprConsent: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _dateGdprConsent ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_dateGdprConsent = newValue}
  }
  /// Returns true if `dateGdprConsent` has been explicitly set.
  public var hasDateGdprConsent: Bool {return self._dateGdprConsent != nil}
  /// Clears the value of `dateGdprConsent`. Subsequent reads from it will return its default value.
  public mutating func clearDateGdprConsent() {self._dateGdprConsent = nil}

  public var dateTosConsent: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _dateTosConsent ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_dateTosConsent = newValue}
  }
  /// Returns true if `dateTosConsent` has been explicitly set.
  public var hasDateTosConsent: Bool {return self._dateTosConsent != nil}
  /// Clears the value of `dateTosConsent`. Subsequent reads from it will return its default value.
  public mutating func clearDateTosConsent() {self._dateTosConsent = nil}

  public var dateMarketingConsent: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _dateMarketingConsent ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_dateMarketingConsent = newValue}
  }
  /// Returns true if `dateMarketingConsent` has been explicitly set.
  public var hasDateMarketingConsent: Bool {return self._dateMarketingConsent != nil}
  /// Clears the value of `dateMarketingConsent`. Subsequent reads from it will return its default value.
  public mutating func clearDateMarketingConsent() {self._dateMarketingConsent = nil}

  /// To handle arbitrary json metadata you can use a struct field:
  /// https://github.com/google/protobuf/blob/master/src/google/protobuf/struct.proto
  public var metadata: SwiftProtobuf.Google_Protobuf_Struct {
    get {return _metadata ?? SwiftProtobuf.Google_Protobuf_Struct()}
    set {_metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  public var hasMetadata: Bool {return self._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  public mutating func clearMetadata() {self._metadata = nil}

  public var emailAddresses: [Clarifai_Api_EmailAddress] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _createdAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _dateGdprConsent: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _dateTosConsent: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _dateMarketingConsent: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _metadata: SwiftProtobuf.Google_Protobuf_Struct? = nil
}

public struct Clarifai_Api_EmailAddress {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var email: String = String()

  public var primary: Bool = false

  public var verified: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Clarifai_Api_Password {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// TODO(lawrence): merge this with message UserPassword above
  /// unencrypted password string
  public var plaintext: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Clarifai_Api_PasswordViolations {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// when new password length is shorter than minimum length set
  public var minimumLength: Bool = false

  /// when new password length is longer than maximum length set
  public var maximumLength: Bool = false

  /// there is no upper case letter in the new password when there should be at least one
  public var upperCaseNeeded: Bool = false

  /// there is no lower case letter in the new password when there should be at least one
  public var lowerCaseNeeded: Bool = false

  /// there is no numerics in the new password when there should be at least one
  public var numericNeeded: Bool = false

  /// there is no special character in the new password when there should be at least one
  public var nonAlphanumericNeeded: Bool = false

  /// when one of the N most recent old password is reused, N is specified by password_reuse_epoch in db.password_policies
  public var passwordReuse: Bool = false

  /// when either user's first, middle or last name is used in the new password
  public var excludeNames: Bool = false

  /// when first part of user's email (exact string or after removing special characters) is used in the new password
  public var excludeEmail: Bool = false

  /// when there are confusing letters in the new password, such as o (first character of 'omega') vs 0 (zero)
  public var noConfusingLetters: Bool = false

  /// when there are simple password patterns used, such as 12345678 or aaaaaaa1
  public var noSimplePasswords: Bool = false

  /// when there are common vocabs from the common vocab list used
  public var noCommonVocabs: Bool = false

  /// when the current password is contained in the new password or vice versa
  public var noOverlapWithOld: Bool = false

  /// when password has to be changed becauase it's too old
  public var passwordLifespan: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/////////////////////////////////////////////////////////////////////////////////
/// Messages from /proto/clarifai/api/video.proto
/////////////////////////////////////////////////////////////////////////////////
public struct Clarifai_Api_Video {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// This is a URL to a publicly accessible video file. The platform will download this file server
  /// side and then process.
  public var url: String = String()

  /// The base64 field is using video file bytes directly in the request.
  /// NOTE: if you're sending a json request, then this MUST be base64 encoded before sending (hence
  /// the name here).
  /// When using our grpc clients, you DO NOT need to base64 encode
  /// it yourself since the clients know how to do this for you automatically and will avoid the
  /// base64 encoding if they send a binary request.
  public var base64: Data = SwiftProtobuf.Internal.emptyData

  public var allowDuplicateURL: Bool = false

  /// URL of thumbnail image, which is currently frame at position of 1s. This field is currently
  /// used only in response.
  public var thumbnailURL: String = String()

  /// The hosted field lists original video hosted in Clarifai storage. This field is currently used
  /// only in response.
  public var hosted: Clarifai_Api_HostedURL {
    get {return _hosted ?? Clarifai_Api_HostedURL()}
    set {_hosted = newValue}
  }
  /// Returns true if `hosted` has been explicitly set.
  public var hasHosted: Bool {return self._hosted != nil}
  /// Clears the value of `hosted`. Subsequent reads from it will return its default value.
  public mutating func clearHosted() {self._hosted = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _hosted: Clarifai_Api_HostedURL? = nil
}

/////////////////////////////////////////////////////////////////////////////////
/// Messages from /proto/clarifai/api/workflow.proto
/////////////////////////////////////////////////////////////////////////////////
public struct Clarifai_Api_Workflow {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The concept's unique id.
  public var id: String = String()

  /// The name of the concept in the given language.
  public var appID: String = String()

  /// When the workflow was created. We follow the XXXX timestamp
  /// format. We use https://www.ietf.org/rfc/rfc3339.txt format:
  /// "2006-01-02T15:04:05.999999Z" so you can expect results like
  /// the following from the API:
  /// "2017-04-11T21:50:50.223962Z"
  public var createdAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _createdAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_createdAt = newValue}
  }
  /// Returns true if `createdAt` has been explicitly set.
  public var hasCreatedAt: Bool {return self._createdAt != nil}
  /// Clears the value of `createdAt`. Subsequent reads from it will return its default value.
  public mutating func clearCreatedAt() {self._createdAt = nil}

  public var nodes: [Clarifai_Api_WorkflowNode] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _createdAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

public struct Clarifai_Api_WorkflowNode {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// An identifier for this node in the graph. This is used when connecting NodeInputs
  /// together.
  public var id: String = String()

  /// The model that will do the processing at this node. We only vlidate the model.id and
  /// model.model_version.id fields.
  public var model: Clarifai_Api_Model {
    get {return _model ?? Clarifai_Api_Model()}
    set {_model = newValue}
  }
  /// Returns true if `model` has been explicitly set.
  public var hasModel: Bool {return self._model != nil}
  /// Clears the value of `model`. Subsequent reads from it will return its default value.
  public mutating func clearModel() {self._model = nil}

  /// Each WorkflowNode can connect to multiple input nodes so that we can handle multi-model data
  /// and more complex workflow operations.
  public var nodeInputs: [Clarifai_Api_NodeInput] = []

  /// suppress the output for workflow prediction
  public var suppressOutput: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _model: Clarifai_Api_Model? = nil
}

/// NodeInput represents inputs to a node of the graph.
public struct Clarifai_Api_NodeInput {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The id to a connected WorkflowNode which will be used as an input for current WorkflowNode.
  public var nodeID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Clarifai_Api_WorkflowResult {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: String = String()

  public var status: Clarifai_Api_Status_Status {
    get {return _status ?? Clarifai_Api_Status_Status()}
    set {_status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  public var hasStatus: Bool {return self._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  public mutating func clearStatus() {self._status = nil}

  /// When the object was created. We follow the XXXX timestamp
  /// format. We use https://www.ietf.org/rfc/rfc3339.txt format:
  /// "2006-01-02T15:04:05.999999Z" so you can expect results like
  /// the following from the API:
  /// "2017-04-11T21:50:50.223962Z"
  public var createdAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _createdAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_createdAt = newValue}
  }
  /// Returns true if `createdAt` has been explicitly set.
  public var hasCreatedAt: Bool {return self._createdAt != nil}
  /// Clears the value of `createdAt`. Subsequent reads from it will return its default value.
  public mutating func clearCreatedAt() {self._createdAt = nil}

  public var model: Clarifai_Api_Model {
    get {return _model ?? Clarifai_Api_Model()}
    set {_model = newValue}
  }
  /// Returns true if `model` has been explicitly set.
  public var hasModel: Bool {return self._model != nil}
  /// Clears the value of `model`. Subsequent reads from it will return its default value.
  public mutating func clearModel() {self._model = nil}

  public var input: Clarifai_Api_Input {
    get {return _input ?? Clarifai_Api_Input()}
    set {_input = newValue}
  }
  /// Returns true if `input` has been explicitly set.
  public var hasInput: Bool {return self._input != nil}
  /// Clears the value of `input`. Subsequent reads from it will return its default value.
  public mutating func clearInput() {self._input = nil}

  public var outputs: [Clarifai_Api_Output] = []

  /// Indicate if the output of this model is suppressed.
  public var suppressOutput: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _status: Clarifai_Api_Status_Status? = nil
  fileprivate var _createdAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _model: Clarifai_Api_Model? = nil
  fileprivate var _input: Clarifai_Api_Input? = nil
}

public struct Clarifai_Api_AppDuplication {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///the id of app duplication
  public var id: String = String()

  ///the id of new app
  public var newAppID: String = String()

  ///the name of new app
  public var newAppName: String = String()

  ///the status of app duplication
  public var status: Clarifai_Api_Status_Status {
    get {return _status ?? Clarifai_Api_Status_Status()}
    set {_status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  public var hasStatus: Bool {return self._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  public mutating func clearStatus() {self._status = nil}

  ///when is the app duplication triggered
  public var createdAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _createdAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_createdAt = newValue}
  }
  /// Returns true if `createdAt` has been explicitly set.
  public var hasCreatedAt: Bool {return self._createdAt != nil}
  /// Clears the value of `createdAt`. Subsequent reads from it will return its default value.
  public mutating func clearCreatedAt() {self._createdAt = nil}

  ///The last time when is the status got updated
  public var lastModifiedAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _lastModifiedAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_lastModifiedAt = newValue}
  }
  /// Returns true if `lastModifiedAt` has been explicitly set.
  public var hasLastModifiedAt: Bool {return self._lastModifiedAt != nil}
  /// Clears the value of `lastModifiedAt`. Subsequent reads from it will return its default value.
  public mutating func clearLastModifiedAt() {self._lastModifiedAt = nil}

  /// Only copy resources depending on the filters
  public var filter: Clarifai_Api_AppDuplicationFilters {
    get {return _filter ?? Clarifai_Api_AppDuplicationFilters()}
    set {_filter = newValue}
  }
  /// Returns true if `filter` has been explicitly set.
  public var hasFilter: Bool {return self._filter != nil}
  /// Clears the value of `filter`. Subsequent reads from it will return its default value.
  public mutating func clearFilter() {self._filter = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _status: Clarifai_Api_Status_Status? = nil
  fileprivate var _createdAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _lastModifiedAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _filter: Clarifai_Api_AppDuplicationFilters? = nil
}

public struct Clarifai_Api_AppDuplicationFilters {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Copy only inputs and default annotations
  public var copyInputs: Bool = false

  /// Copy only concepts
  public var copyConcepts: Bool = false

  /// Copy annotations and what it depends on: inputs and concepts
  public var copyAnnotations: Bool = false

  /// Copy models and what it depends on: concepts
  public var copyModels: Bool = false

  /// Copy workflows and what it depends on: models and concepts
  public var copyWorkflows: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Task is the work that needs to be done for labeling the inputs in an app.
public struct Clarifai_Api_Task {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Unique ID for the task.
  public var id: String = String()

  /// When the task was created.
  /// The format is https://www.ietf.org/rfc/rfc3339.txt.
  /// Example: "2006-01-02T15:04:05.999999Z".
  public var createdAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _createdAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_createdAt = newValue}
  }
  /// Returns true if `createdAt` has been explicitly set.
  public var hasCreatedAt: Bool {return self._createdAt != nil}
  /// Clears the value of `createdAt`. Subsequent reads from it will return its default value.
  public mutating func clearCreatedAt() {self._createdAt = nil}

  /// Most recent time when the task was updated.
  /// The format is https://www.ietf.org/rfc/rfc3339.txt.
  /// Example: "2006-01-02T15:04:05.999999Z".
  public var modifiedAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _modifiedAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_modifiedAt = newValue}
  }
  /// Returns true if `modifiedAt` has been explicitly set.
  public var hasModifiedAt: Bool {return self._modifiedAt != nil}
  /// Clears the value of `modifiedAt`. Subsequent reads from it will return its default value.
  public mutating func clearModifiedAt() {self._modifiedAt = nil}

  /// Task type.
  public var type: Clarifai_Api_Task.TaskType = .typeNotSet

  /// Description of the task.
  public var description_p: String = String()

  /// Worker details.
  public var worker: Clarifai_Api_TaskWorker {
    get {return _worker ?? Clarifai_Api_TaskWorker()}
    set {_worker = newValue}
  }
  /// Returns true if `worker` has been explicitly set.
  public var hasWorker: Bool {return self._worker != nil}
  /// Clears the value of `worker`. Subsequent reads from it will return its default value.
  public mutating func clearWorker() {self._worker = nil}

  /// List of concept ids used in the work of this task if label type is classification.
  public var conceptIds: [String] = []

  /// List of inputs used in this task will be taken from this source.
  public var inputSource: Clarifai_Api_TaskInputSource {
    get {return _inputSource ?? Clarifai_Api_TaskInputSource()}
    set {_inputSource = newValue}
  }
  /// Returns true if `inputSource` has been explicitly set.
  public var hasInputSource: Bool {return self._inputSource != nil}
  /// Clears the value of `inputSource`. Subsequent reads from it will return its default value.
  public mutating func clearInputSource() {self._inputSource = nil}

  /// For model predictions on video: Sample delay for video predicting (1 frame per N milliseconds)
  public var sampleMs: UInt32 = 0

  /// AI assistant details.
  public var aiAssistant: Clarifai_Api_TaskAIAssistant {
    get {return _aiAssistant ?? Clarifai_Api_TaskAIAssistant()}
    set {_aiAssistant = newValue}
  }
  /// Returns true if `aiAssistant` has been explicitly set.
  public var hasAiAssistant: Bool {return self._aiAssistant != nil}
  /// Clears the value of `aiAssistant`. Subsequent reads from it will return its default value.
  public mutating func clearAiAssistant() {self._aiAssistant = nil}

  /// Review details.
  public var review: Clarifai_Api_TaskReview {
    get {return _review ?? Clarifai_Api_TaskReview()}
    set {_review = newValue}
  }
  /// Returns true if `review` has been explicitly set.
  public var hasReview: Bool {return self._review != nil}
  /// Clears the value of `review`. Subsequent reads from it will return its default value.
  public mutating func clearReview() {self._review = nil}

  /// Status of this task.
  public var status: Clarifai_Api_Status_Status {
    get {return _status ?? Clarifai_Api_Status_Status()}
    set {_status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  public var hasStatus: Bool {return self._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  public mutating func clearStatus() {self._status = nil}

  /// Add a title for this task to quickly recognise it in a list of tasks.
  public var name: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum TaskType: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case typeNotSet // = 0

    /// Concepts classification tasks annotate concepts for the overall image, frame of video or section of text.
    case conceptsClassification // = 1

    /// Bounding box detection tasks annotate rectangular bounding box regions around each concept in an image, frame of video or section of text.
    case boundingBoxDetection // = 2

    /// Polygon detection tasks annotate free-form regions around concepts in an image, frame of video or section of text.
    case polygonDetection // = 3
    case UNRECOGNIZED(Int)

    public init() {
      self = .typeNotSet
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .typeNotSet
      case 1: self = .conceptsClassification
      case 2: self = .boundingBoxDetection
      case 3: self = .polygonDetection
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .typeNotSet: return 0
      case .conceptsClassification: return 1
      case .boundingBoxDetection: return 2
      case .polygonDetection: return 3
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}

  fileprivate var _createdAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _modifiedAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _worker: Clarifai_Api_TaskWorker? = nil
  fileprivate var _inputSource: Clarifai_Api_TaskInputSource? = nil
  fileprivate var _aiAssistant: Clarifai_Api_TaskAIAssistant? = nil
  fileprivate var _review: Clarifai_Api_TaskReview? = nil
  fileprivate var _status: Clarifai_Api_Status_Status? = nil
}

#if swift(>=4.2)

extension Clarifai_Api_Task.TaskType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Clarifai_Api_Task.TaskType] = [
    .typeNotSet,
    .conceptsClassification,
    .boundingBoxDetection,
    .polygonDetection,
  ]
}

#endif  // swift(>=4.2)

public struct Clarifai_Api_TaskWorker {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Worker strategy.
  public var strategy: Clarifai_Api_TaskWorker.TaskWorkerStrategy = .workerStrategyNotSet

  /// Who will work on this task.
  public var userIds: [String] = []

  /// Info based on the worker strategy,
  public var strategyInfo: Clarifai_Api_TaskWorker.OneOf_StrategyInfo? = nil

  public var partitionedStrategyInfo: Clarifai_Api_TaskWorkerPartitionedStrategyInfo {
    get {
      if case .partitionedStrategyInfo(let v)? = strategyInfo {return v}
      return Clarifai_Api_TaskWorkerPartitionedStrategyInfo()
    }
    set {strategyInfo = .partitionedStrategyInfo(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Info based on the worker strategy,
  public enum OneOf_StrategyInfo: Equatable {
    case partitionedStrategyInfo(Clarifai_Api_TaskWorkerPartitionedStrategyInfo)

  #if !swift(>=4.1)
    public static func ==(lhs: Clarifai_Api_TaskWorker.OneOf_StrategyInfo, rhs: Clarifai_Api_TaskWorker.OneOf_StrategyInfo) -> Bool {
      switch (lhs, rhs) {
      case (.partitionedStrategyInfo(let l), .partitionedStrategyInfo(let r)): return l == r
      }
    }
  #endif
  }

  public enum TaskWorkerStrategy: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case workerStrategyNotSet // = 0

    /// The inputs will be partitioned in several partitions.
    /// Each worker will label one or more input partitions.
    case partitioned // = 2

    /// Each worker will label all inputs from input source.
    case full // = 3
    case UNRECOGNIZED(Int)

    public init() {
      self = .workerStrategyNotSet
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .workerStrategyNotSet
      case 2: self = .partitioned
      case 3: self = .full
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .workerStrategyNotSet: return 0
      case .partitioned: return 2
      case .full: return 3
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Clarifai_Api_TaskWorker.TaskWorkerStrategy: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Clarifai_Api_TaskWorker.TaskWorkerStrategy] = [
    .workerStrategyNotSet,
    .partitioned,
    .full,
  ]
}

#endif  // swift(>=4.2)

public struct Clarifai_Api_TaskWorkerPartitionedStrategyInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Define how the partitioning should work.
  public var type: Clarifai_Api_TaskWorkerPartitionedStrategyInfo.TaskWorkerPartitionedStrategy = .partitionedWorkerStrategyNotSet

  /// How many workers will label each input.
  public var workersPerInput: Int32 = 0

  /// In case of weighted partitioning, map user ids to weights.
  /// Each labeler will be assigned work proportional to its own weight as compared to the sum of total weight.
  ///
  /// EXAMPLE:
  /// If we have 3 workers, and weights = {1: 30, 2: 30, 3: 40},
  /// then first worker will have assigned 30% of the work,
  /// second worker will have assigned 30% of the work,
  /// and third worker will have assigned 40% of the work.
  /// You may use weights which add up to 100, but it's not necessary.
  /// For example, weights {1: 30, 2: 30, 3: 40} are equivalent with {1: 3, 2: 3, 3: 4}
  /// because they represent the same percentages: {1: 30%, 2: 30%, 3: 40%}.
  ///
  /// NOTE:
  /// Note that no worker should be assigned a weight percentage greater than 1/workers_per_input.
  /// It is mathematically impossible to partition the work in such a case.
  /// Why? Say, we have 3 workers. And workers_per_input = 2, i.e. each input must be labeled by 2 workers.
  /// Let's assign weights {1: 51%, 2: 25%, 3: 24%}.
  /// Note that first worker has a weight percentage higher than 1/workers_per_input = 1/2 = 50%.
  /// If we have 100 inputs, then a total of 100 * workers_per_input = 200 cumulative inputs will be labeled by these 3 workers.
  /// Worker 1 should label 102 cumulative inputs, while worker 2 and worker 3 will label 98 cumulative inputs together.
  /// No matter how we assign the 98 cumulative inputs, the 2 workers will be able to label up to 98 actual inputs.
  /// This means the remaining 2 inputs will be labeled only by worker 1. This contradicts the worker_per_input = 2 requirement.
  public var weights: SwiftProtobuf.Google_Protobuf_Struct {
    get {return _weights ?? SwiftProtobuf.Google_Protobuf_Struct()}
    set {_weights = newValue}
  }
  /// Returns true if `weights` has been explicitly set.
  public var hasWeights: Bool {return self._weights != nil}
  /// Clears the value of `weights`. Subsequent reads from it will return its default value.
  public mutating func clearWeights() {self._weights = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum TaskWorkerPartitionedStrategy: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case partitionedWorkerStrategyNotSet // = 0

    /// Each worker will label (approximately) the same number of inputs.
    case evenly // = 1

    /// Each worker will have an assigned weight.
    /// See weights field for more details.
    case weighted // = 2
    case UNRECOGNIZED(Int)

    public init() {
      self = .partitionedWorkerStrategyNotSet
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .partitionedWorkerStrategyNotSet
      case 1: self = .evenly
      case 2: self = .weighted
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .partitionedWorkerStrategyNotSet: return 0
      case .evenly: return 1
      case .weighted: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}

  fileprivate var _weights: SwiftProtobuf.Google_Protobuf_Struct? = nil
}

#if swift(>=4.2)

extension Clarifai_Api_TaskWorkerPartitionedStrategyInfo.TaskWorkerPartitionedStrategy: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Clarifai_Api_TaskWorkerPartitionedStrategyInfo.TaskWorkerPartitionedStrategy] = [
    .partitionedWorkerStrategyNotSet,
    .evenly,
    .weighted,
  ]
}

#endif  // swift(>=4.2)

public struct Clarifai_Api_TaskInputSource {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Type of input source.
  public var type: Clarifai_Api_TaskInputSource.TaskInputSourceType = .inputSourceTypeNotSet

  /// If type is SAVED_SEARCH, then this is the saved search id.
  public var id: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum TaskInputSourceType: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case inputSourceTypeNotSet // = 0

    /// Use all inputs in the app.
    case allInputs // = 1

    /// Use the inputs from a saved search.
    case savedSearch // = 2
    case UNRECOGNIZED(Int)

    public init() {
      self = .inputSourceTypeNotSet
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .inputSourceTypeNotSet
      case 1: self = .allInputs
      case 2: self = .savedSearch
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .inputSourceTypeNotSet: return 0
      case .allInputs: return 1
      case .savedSearch: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Clarifai_Api_TaskInputSource.TaskInputSourceType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Clarifai_Api_TaskInputSource.TaskInputSourceType] = [
    .inputSourceTypeNotSet,
    .allInputs,
    .savedSearch,
  ]
}

#endif  // swift(>=4.2)

public struct Clarifai_Api_TaskReview {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Task review strategy.
  public var strategy: Clarifai_Api_TaskReview.TaskReviewStrategy = .notSet

  /// Who will review this task.
  public var userIds: [String] = []

  /// Info based on the review strategy,
  public var strategyInfo: Clarifai_Api_TaskReview.OneOf_StrategyInfo? = nil

  public var manualStrategyInfo: Clarifai_Api_TaskReviewManualStrategyInfo {
    get {
      if case .manualStrategyInfo(let v)? = strategyInfo {return v}
      return Clarifai_Api_TaskReviewManualStrategyInfo()
    }
    set {strategyInfo = .manualStrategyInfo(newValue)}
  }

  public var consensusStrategyInfo: Clarifai_Api_TaskReviewConsensusStrategyInfo {
    get {
      if case .consensusStrategyInfo(let v)? = strategyInfo {return v}
      return Clarifai_Api_TaskReviewConsensusStrategyInfo()
    }
    set {strategyInfo = .consensusStrategyInfo(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Info based on the review strategy,
  public enum OneOf_StrategyInfo: Equatable {
    case manualStrategyInfo(Clarifai_Api_TaskReviewManualStrategyInfo)
    case consensusStrategyInfo(Clarifai_Api_TaskReviewConsensusStrategyInfo)

  #if !swift(>=4.1)
    public static func ==(lhs: Clarifai_Api_TaskReview.OneOf_StrategyInfo, rhs: Clarifai_Api_TaskReview.OneOf_StrategyInfo) -> Bool {
      switch (lhs, rhs) {
      case (.manualStrategyInfo(let l), .manualStrategyInfo(let r)): return l == r
      case (.consensusStrategyInfo(let l), .consensusStrategyInfo(let r)): return l == r
      default: return false
      }
    }
  #endif
  }

  public enum TaskReviewStrategy: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case notSet // = 0

    /// No review is needed.
    case none // = 1

    /// Manual review strategy.
    case manual // = 2

    /// Consensus review strategy.
    case consensus // = 3
    case UNRECOGNIZED(Int)

    public init() {
      self = .notSet
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .notSet
      case 1: self = .none
      case 2: self = .manual
      case 3: self = .consensus
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .notSet: return 0
      case .none: return 1
      case .manual: return 2
      case .consensus: return 3
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Clarifai_Api_TaskReview.TaskReviewStrategy: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Clarifai_Api_TaskReview.TaskReviewStrategy] = [
    .notSet,
    .none,
    .manual,
    .consensus,
  ]
}

#endif  // swift(>=4.2)

public struct Clarifai_Api_TaskReviewManualStrategyInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// This field represents the percentage of inputs that will be reviewed by reviewers. It is a value between 0 and 1.
  public var samplePercentage: Float = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Clarifai_Api_TaskReviewConsensusStrategyInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The number of labelers that need to agree in order to automatically approve an annotation.
  public var approvalThreshold: UInt32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Clarifai_Api_TaskAIAssistant {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The worker is helped by an AI assistant.
  /// This field is the workflow id which is used to assist the worker with predictions.
  /// If empty, then AI assistant is disabled.
  public var workflowID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Collector is a data pathway from a CollectorSource to an app to collect data automatically.
/// For example, a CollectorSource
public struct Clarifai_Api_Collector {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Unique ID for the collector.
  public var id: String = String()

  /// Human readable description for the collector.
  public var description_p: String = String()

  /// When the collector is created. We follow the XXXX timestamp
  /// format. We use https://www.ietf.org/rfc/rfc3339.txt format:
  /// "2006-01-02T15:04:05.999999Z" so you can expect results like
  /// the following from the API:
  /// "2017-04-11T21:50:50.223962Z"
  public var createdAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _createdAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_createdAt = newValue}
  }
  /// Returns true if `createdAt` has been explicitly set.
  public var hasCreatedAt: Bool {return self._createdAt != nil}
  /// Clears the value of `createdAt`. Subsequent reads from it will return its default value.
  public mutating func clearCreatedAt() {self._createdAt = nil}

  /// This is a workflow to run inline in model predict calls. It should ONLY have very fast and
  /// light-weight models in it as it will effect the speed of the predictions being made.
  /// This workflow's purpose is to filter down the inputs to queue for the collector to process.
  /// The input to this workflow is going to be the OUTPUT of the model, not the input to the model
  /// since we want to encourage having fast workflows that can also take advantage of the model
  /// outputs to make deciions (for example: thresholding based on concepts). If the workflow
  /// output has any field that is non-empty then the input will be queued for the collector
  /// to process with the post_queue_workflow_id.
  public var preQueueWorkflowID: String = String()

  /// A workflow to run to after the collector is processing the queued input. This workflow
  /// uses the original input to the model as input to the workflow so that you can run additional
  /// models as well on that input to decide whether to queue the model or not. If the workflow
  /// output has any field that is non-empty then it will be passed on to POST /inputs to
  /// the destination app.
  public var postQueueWorkflowID: String = String()

  /// The source of the collector to feed data into this app.
  /// Note(zeiler): if we wanted more than one source per collector we could make this it's own
  /// object and introduce /collectors/{collector_id}/sources
  /// We will keep it simple for now and have just one source per collector since a user can make
  /// more than one collector in the same app anyways.
  public var collectorSource: Clarifai_Api_CollectorSource {
    get {return _collectorSource ?? Clarifai_Api_CollectorSource()}
    set {_collectorSource = newValue}
  }
  /// Returns true if `collectorSource` has been explicitly set.
  public var hasCollectorSource: Bool {return self._collectorSource != nil}
  /// Clears the value of `collectorSource`. Subsequent reads from it will return its default value.
  public mutating func clearCollectorSource() {self._collectorSource = nil}

  /// Status for the collector. This allows you to pause a collector without having to delete it as
  /// an example.
  public var status: Clarifai_Api_Status_Status {
    get {return _status ?? Clarifai_Api_Status_Status()}
    set {_status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  public var hasStatus: Bool {return self._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  public mutating func clearStatus() {self._status = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _createdAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _collectorSource: Clarifai_Api_CollectorSource? = nil
  fileprivate var _status: Clarifai_Api_Status_Status? = nil
}

/// Configuration for the source to collect data from.
/// Only one of the fields can be present at a time.
public struct Clarifai_Api_CollectorSource {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Collect from the inputs passed in for PostModelOutputs predictions of a specific model.
  /// This does not apply to models used within workflows, only PostModelOutputs calls.
  public var apiPostModelOutputsCollectorSource: Clarifai_Api_APIPostModelOutputsCollectorSource {
    get {return _apiPostModelOutputsCollectorSource ?? Clarifai_Api_APIPostModelOutputsCollectorSource()}
    set {_apiPostModelOutputsCollectorSource = newValue}
  }
  /// Returns true if `apiPostModelOutputsCollectorSource` has been explicitly set.
  public var hasApiPostModelOutputsCollectorSource: Bool {return self._apiPostModelOutputsCollectorSource != nil}
  /// Clears the value of `apiPostModelOutputsCollectorSource`. Subsequent reads from it will return its default value.
  public mutating func clearApiPostModelOutputsCollectorSource() {self._apiPostModelOutputsCollectorSource = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _apiPostModelOutputsCollectorSource: Clarifai_Api_APIPostModelOutputsCollectorSource? = nil
}

/// This is configuration for using the inputs send for model prediction in our API as
/// as the source for data.
public struct Clarifai_Api_APIPostModelOutputsCollectorSource {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// To define the model that we should collect from we need to specify the following 4 IDs:
  /// The User ID of the model we want to collect from.
  /// This is User B in the example.
  public var modelUserID: String = String()

  /// The App ID of the model we want to collect from.
  public var modelAppID: String = String()

  /// The Model ID of the model we want to collect from.
  public var modelID: String = String()

  /// The Version ID of the model we want to collect from.
  public var modelVersionID: String = String()

  /// This key is used to POST /inputs into your app by the collector. It can be an API key or a
  /// PAT. This needs the permissions that are needed for POST /inputs for the app_id this
  /// Collector is defined in.
  public var postInputsKeyID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/////////////////////////////////////////////////////////////////////////////////
/// Stats Collection Objects.
/////////////////////////////////////////////////////////////////////////////////
public struct Clarifai_Api_StatValue {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The time of the event. Defaults to now().
  public var time: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _time ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_time = newValue}
  }
  /// Returns true if `time` has been explicitly set.
  public var hasTime: Bool {return self._time != nil}
  /// Clears the value of `time`. Subsequent reads from it will return its default value.
  public mutating func clearTime() {self._time = nil}

  /// A value for the metric you're recording.
  public var value: Float = 0

  /// List of tags to attach to this stat. Each should contain one colon so that the first part will
  /// be used as a tag group while the second being the tag itself. For example: ["task_id:a",
  /// "worker_id:1"]. These tag groups like "task_id" or "worker_id" are important for aggregating
  /// values in the StatValueAggregateQuery.
  public var tags: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _time: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

public struct Clarifai_Api_StatValueAggregateResult {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The list of repeated aggregate values and their counts.
  public var statValueAggregates: [Clarifai_Api_StatValueAggregate] = []

  /// The query that created these results.
  public var statValueAggregateQuery: Clarifai_Api_StatValueAggregateQuery {
    get {return _statValueAggregateQuery ?? Clarifai_Api_StatValueAggregateQuery()}
    set {_statValueAggregateQuery = newValue}
  }
  /// Returns true if `statValueAggregateQuery` has been explicitly set.
  public var hasStatValueAggregateQuery: Bool {return self._statValueAggregateQuery != nil}
  /// Clears the value of `statValueAggregateQuery`. Subsequent reads from it will return its default value.
  public mutating func clearStatValueAggregateQuery() {self._statValueAggregateQuery = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _statValueAggregateQuery: Clarifai_Api_StatValueAggregateQuery? = nil
}

public struct Clarifai_Api_StatValueAggregate {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The time of the aggregation. For example, if you aggregate over "HOUR" buckets then you can
  /// expect each hour that has atleast one value (matching the rest of your query fields) will have
  /// a StatValueAggregate with the time filled into that hour.
  public var time: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _time ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_time = newValue}
  }
  /// Returns true if `time` has been explicitly set.
  public var hasTime: Bool {return self._time != nil}
  /// Clears the value of `time`. Subsequent reads from it will return its default value.
  public mutating func clearTime() {self._time = nil}

  /// The value aggregated according to the stat_value_agg_type
  public var aggregateValue: Float = 0

  /// The count of the stat values that were used in this aggregation.
  public var count: UInt64 = 0

  /// The tags for this aggregated_value and count. This will be filled in if tag groups were used in
  /// the query to group aggregations.
  public var tags: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _time: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

public struct Clarifai_Api_StatValueAggregateQuery {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// These tags are used to filter down the values before they are aggregated. For example,
  /// if you want to aggregate values for "task_id:a" you could specify that as a tag here.
  public var tags: [String] = []

  /// These are tag groups to aggregate over. So for example if you added stat values with tags
  /// "task_id:a" and others with "task_id:b", then added ["task_id"] to the task group, it the
  /// aggregation would return StatValueAggregate values for each task_id. If you provide more than
  /// one tag_group the response will return all rolled up combinations of them. For example
  /// ["task_id", "something"] where "something:1" and "something:2" were used as tags for some
  /// values then you'd get StatValueAggregate values back for:
  /// task_id | something
  /// a       | 1
  /// a       | 2
  /// b       | 1
  /// b       | 1
  public var tagGroups: [String] = []

  /// Aggregation function to use over the values. Count(value) is also always returns.
  /// Defaults to 'sum' if not provided.
  public var statValueAggType: Clarifai_Api_StatValueAggType = .sum

  /// Aggregation bins for time where the values will be aggregated at this bin granualarity.
  /// And the "time" field will be returned in StatValueAggregate object.
  /// If not provided then bins are not used, and all time is aggregated over.
  public var statTimeAggType: Clarifai_Api_StatTimeAggType = .noTimeAgg

  /// If provided the time range over which values will be >= this time. If not provided then
  /// all values will be used back to start of time.
  public var startTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _startTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_startTime = newValue}
  }
  /// Returns true if `startTime` has been explicitly set.
  public var hasStartTime: Bool {return self._startTime != nil}
  /// Clears the value of `startTime`. Subsequent reads from it will return its default value.
  public mutating func clearStartTime() {self._startTime = nil}

  /// If provided the time range over which values will be <= this time. If not provided then all
  /// values will be used up until now().
  public var endTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _endTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_endTime = newValue}
  }
  /// Returns true if `endTime` has been explicitly set.
  public var hasEndTime: Bool {return self._endTime != nil}
  /// Clears the value of `endTime`. Subsequent reads from it will return its default value.
  public mutating func clearEndTime() {self._endTime = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _startTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _endTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "clarifai.api"

extension Clarifai_Api_ExpirationAction: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "EXPIRATION_ACTION_NOT_SET"),
    1: .same(proto: "DELAY"),
    2: .same(proto: "EXPIRY"),
  ]
}

extension Clarifai_Api_LicenseScope: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "LICENSE_SCOPE_NOT_SET"),
    1: .same(proto: "PREDICT"),
    2: .same(proto: "TRAIN"),
    3: .same(proto: "SEARCH"),
  ]
}

extension Clarifai_Api_ValueComparator: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "CONCEPT_THRESHOLD_NOT_SET"),
    1: .same(proto: "GREATER_THAN"),
    2: .same(proto: "GREATER_THAN_OR_EQUAL"),
    3: .same(proto: "LESS_THAN"),
    4: .same(proto: "LESS_THAN_OR_EQUAL"),
    5: .same(proto: "EQUAL"),
  ]
}

extension Clarifai_Api_EvaluationType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "Classification"),
    1: .same(proto: "Detection"),
  ]
}

extension Clarifai_Api_APIEventType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "API_EVENT_TYPE_NOT_SET"),
    1: .same(proto: "ON_PREM_PREDICT"),
    2: .same(proto: "ON_PREM_TRAIN"),
    3: .same(proto: "ON_PREM_SEARCH"),
  ]
}

extension Clarifai_Api_UsageIntervalType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "undef"),
    1: .same(proto: "day"),
    2: .same(proto: "month"),
    3: .same(proto: "year"),
  ]
}

extension Clarifai_Api_StatValueAggType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "SUM"),
    1: .same(proto: "AVG"),
  ]
}

extension Clarifai_Api_StatTimeAggType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NO_TIME_AGG"),
    1: .same(proto: "YEAR"),
    2: .same(proto: "MONTH"),
    3: .same(proto: "WEEK"),
    4: .same(proto: "DAY"),
    5: .same(proto: "HOUR"),
    6: .same(proto: "MINUTE"),
  ]
}

extension Clarifai_Api_Annotation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Annotation"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .standard(proto: "input_id"),
    3: .same(proto: "data"),
    13: .standard(proto: "annotation_info"),
    15: .standard(proto: "user_id"),
    16: .standard(proto: "model_version_id"),
    14: .standard(proto: "embed_model_version_id"),
    7: .same(proto: "status"),
    8: .standard(proto: "created_at"),
    9: .standard(proto: "modified_at"),
    10: .same(proto: "trusted"),
    17: .standard(proto: "input_level"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.id)
      case 2: try decoder.decodeSingularStringField(value: &self.inputID)
      case 3: try decoder.decodeSingularMessageField(value: &self._data)
      case 7: try decoder.decodeSingularMessageField(value: &self._status)
      case 8: try decoder.decodeSingularMessageField(value: &self._createdAt)
      case 9: try decoder.decodeSingularMessageField(value: &self._modifiedAt)
      case 10: try decoder.decodeSingularBoolField(value: &self.trusted)
      case 13: try decoder.decodeSingularMessageField(value: &self._annotationInfo)
      case 14: try decoder.decodeSingularStringField(value: &self.embedModelVersionID)
      case 15: try decoder.decodeSingularStringField(value: &self.userID)
      case 16: try decoder.decodeSingularStringField(value: &self.modelVersionID)
      case 17: try decoder.decodeSingularBoolField(value: &self.inputLevel)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if !self.inputID.isEmpty {
      try visitor.visitSingularStringField(value: self.inputID, fieldNumber: 2)
    }
    if let v = self._data {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    if let v = self._status {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }
    if let v = self._createdAt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    }
    if let v = self._modifiedAt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    }
    if self.trusted != false {
      try visitor.visitSingularBoolField(value: self.trusted, fieldNumber: 10)
    }
    if let v = self._annotationInfo {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
    }
    if !self.embedModelVersionID.isEmpty {
      try visitor.visitSingularStringField(value: self.embedModelVersionID, fieldNumber: 14)
    }
    if !self.userID.isEmpty {
      try visitor.visitSingularStringField(value: self.userID, fieldNumber: 15)
    }
    if !self.modelVersionID.isEmpty {
      try visitor.visitSingularStringField(value: self.modelVersionID, fieldNumber: 16)
    }
    if self.inputLevel != false {
      try visitor.visitSingularBoolField(value: self.inputLevel, fieldNumber: 17)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_Annotation, rhs: Clarifai_Api_Annotation) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.inputID != rhs.inputID {return false}
    if lhs._data != rhs._data {return false}
    if lhs._annotationInfo != rhs._annotationInfo {return false}
    if lhs.userID != rhs.userID {return false}
    if lhs.modelVersionID != rhs.modelVersionID {return false}
    if lhs.embedModelVersionID != rhs.embedModelVersionID {return false}
    if lhs._status != rhs._status {return false}
    if lhs._createdAt != rhs._createdAt {return false}
    if lhs._modifiedAt != rhs._modifiedAt {return false}
    if lhs.trusted != rhs.trusted {return false}
    if lhs.inputLevel != rhs.inputLevel {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_App: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".App"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "name"),
    3: .standard(proto: "default_language"),
    4: .standard(proto: "default_workflow_id"),
    5: .standard(proto: "user_id"),
    6: .standard(proto: "created_at"),
    7: .standard(proto: "legal_consent_status"),
    13: .same(proto: "metadata"),
    14: .same(proto: "description"),
    15: .standard(proto: "sample_ms"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.id)
      case 2: try decoder.decodeSingularStringField(value: &self.name)
      case 3: try decoder.decodeSingularStringField(value: &self.defaultLanguage)
      case 4: try decoder.decodeSingularStringField(value: &self.defaultWorkflowID)
      case 5: try decoder.decodeSingularStringField(value: &self.userID)
      case 6: try decoder.decodeSingularMessageField(value: &self._createdAt)
      case 7: try decoder.decodeSingularUInt32Field(value: &self.legalConsentStatus)
      case 13: try decoder.decodeSingularMessageField(value: &self._metadata)
      case 14: try decoder.decodeSingularStringField(value: &self.description_p)
      case 15: try decoder.decodeSingularUInt32Field(value: &self.sampleMs)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 2)
    }
    if !self.defaultLanguage.isEmpty {
      try visitor.visitSingularStringField(value: self.defaultLanguage, fieldNumber: 3)
    }
    if !self.defaultWorkflowID.isEmpty {
      try visitor.visitSingularStringField(value: self.defaultWorkflowID, fieldNumber: 4)
    }
    if !self.userID.isEmpty {
      try visitor.visitSingularStringField(value: self.userID, fieldNumber: 5)
    }
    if let v = self._createdAt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }
    if self.legalConsentStatus != 0 {
      try visitor.visitSingularUInt32Field(value: self.legalConsentStatus, fieldNumber: 7)
    }
    if let v = self._metadata {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 14)
    }
    if self.sampleMs != 0 {
      try visitor.visitSingularUInt32Field(value: self.sampleMs, fieldNumber: 15)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_App, rhs: Clarifai_Api_App) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.name != rhs.name {return false}
    if lhs.defaultLanguage != rhs.defaultLanguage {return false}
    if lhs.defaultWorkflowID != rhs.defaultWorkflowID {return false}
    if lhs.userID != rhs.userID {return false}
    if lhs._createdAt != rhs._createdAt {return false}
    if lhs.legalConsentStatus != rhs.legalConsentStatus {return false}
    if lhs._metadata != rhs._metadata {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.sampleMs != rhs.sampleMs {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_AppQuery: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AppQuery"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.name)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_AppQuery, rhs: Clarifai_Api_AppQuery) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_Collaborator: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Collaborator"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "app"),
    3: .same(proto: "user"),
    4: .same(proto: "scopes"),
    5: .same(proto: "endpoints"),
    6: .standard(proto: "created_at"),
    7: .standard(proto: "modified_at"),
    8: .standard(proto: "deleted_at"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.id)
      case 2: try decoder.decodeSingularMessageField(value: &self._app)
      case 3: try decoder.decodeSingularMessageField(value: &self._user)
      case 4: try decoder.decodeRepeatedStringField(value: &self.scopes)
      case 5: try decoder.decodeRepeatedStringField(value: &self.endpoints)
      case 6: try decoder.decodeSingularMessageField(value: &self._createdAt)
      case 7: try decoder.decodeSingularMessageField(value: &self._modifiedAt)
      case 8: try decoder.decodeSingularMessageField(value: &self._deletedAt)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if let v = self._app {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if let v = self._user {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    if !self.scopes.isEmpty {
      try visitor.visitRepeatedStringField(value: self.scopes, fieldNumber: 4)
    }
    if !self.endpoints.isEmpty {
      try visitor.visitRepeatedStringField(value: self.endpoints, fieldNumber: 5)
    }
    if let v = self._createdAt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }
    if let v = self._modifiedAt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }
    if let v = self._deletedAt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_Collaborator, rhs: Clarifai_Api_Collaborator) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs._app != rhs._app {return false}
    if lhs._user != rhs._user {return false}
    if lhs.scopes != rhs.scopes {return false}
    if lhs.endpoints != rhs.endpoints {return false}
    if lhs._createdAt != rhs._createdAt {return false}
    if lhs._modifiedAt != rhs._modifiedAt {return false}
    if lhs._deletedAt != rhs._deletedAt {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_Collaboration: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Collaboration"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "app"),
    2: .standard(proto: "app_owner"),
    3: .same(proto: "scopes"),
    4: .same(proto: "endpoints"),
    5: .standard(proto: "created_at"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._app)
      case 2: try decoder.decodeSingularMessageField(value: &self._appOwner)
      case 3: try decoder.decodeRepeatedStringField(value: &self.scopes)
      case 4: try decoder.decodeRepeatedStringField(value: &self.endpoints)
      case 5: try decoder.decodeSingularMessageField(value: &self._createdAt)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._app {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._appOwner {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if !self.scopes.isEmpty {
      try visitor.visitRepeatedStringField(value: self.scopes, fieldNumber: 3)
    }
    if !self.endpoints.isEmpty {
      try visitor.visitRepeatedStringField(value: self.endpoints, fieldNumber: 4)
    }
    if let v = self._createdAt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_Collaboration, rhs: Clarifai_Api_Collaboration) -> Bool {
    if lhs._app != rhs._app {return false}
    if lhs._appOwner != rhs._appOwner {return false}
    if lhs.scopes != rhs.scopes {return false}
    if lhs.endpoints != rhs.endpoints {return false}
    if lhs._createdAt != rhs._createdAt {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_Audio: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Audio"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "url"),
    2: .same(proto: "base64"),
    4: .standard(proto: "allow_duplicate_url"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.url)
      case 2: try decoder.decodeSingularBytesField(value: &self.base64)
      case 4: try decoder.decodeSingularBoolField(value: &self.allowDuplicateURL)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.url.isEmpty {
      try visitor.visitSingularStringField(value: self.url, fieldNumber: 1)
    }
    if !self.base64.isEmpty {
      try visitor.visitSingularBytesField(value: self.base64, fieldNumber: 2)
    }
    if self.allowDuplicateURL != false {
      try visitor.visitSingularBoolField(value: self.allowDuplicateURL, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_Audio, rhs: Clarifai_Api_Audio) -> Bool {
    if lhs.url != rhs.url {return false}
    if lhs.base64 != rhs.base64 {return false}
    if lhs.allowDuplicateURL != rhs.allowDuplicateURL {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_Cluster: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Cluster"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "count"),
    3: .same(proto: "score"),
    4: .same(proto: "hits"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.id)
      case 2: try decoder.decodeSingularUInt32Field(value: &self.count)
      case 3: try decoder.decodeSingularFloatField(value: &self.score)
      case 4: try decoder.decodeRepeatedMessageField(value: &self.hits)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if self.count != 0 {
      try visitor.visitSingularUInt32Field(value: self.count, fieldNumber: 2)
    }
    if self.score != 0 {
      try visitor.visitSingularFloatField(value: self.score, fieldNumber: 3)
    }
    if !self.hits.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.hits, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_Cluster, rhs: Clarifai_Api_Cluster) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.count != rhs.count {return false}
    if lhs.score != rhs.score {return false}
    if lhs.hits != rhs.hits {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_Color: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Color"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "raw_hex"),
    2: .same(proto: "w3c"),
    3: .same(proto: "value"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.rawHex)
      case 2: try decoder.decodeSingularMessageField(value: &self._w3C)
      case 3: try decoder.decodeSingularFloatField(value: &self.value)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.rawHex.isEmpty {
      try visitor.visitSingularStringField(value: self.rawHex, fieldNumber: 1)
    }
    if let v = self._w3C {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if self.value != 0 {
      try visitor.visitSingularFloatField(value: self.value, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_Color, rhs: Clarifai_Api_Color) -> Bool {
    if lhs.rawHex != rhs.rawHex {return false}
    if lhs._w3C != rhs._w3C {return false}
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_W3C: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".W3C"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "hex"),
    2: .same(proto: "name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.hex)
      case 2: try decoder.decodeSingularStringField(value: &self.name)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.hex.isEmpty {
      try visitor.visitSingularStringField(value: self.hex, fieldNumber: 1)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_W3C, rhs: Clarifai_Api_W3C) -> Bool {
    if lhs.hex != rhs.hex {return false}
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_UserAppIDSet: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UserAppIDSet"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_id"),
    2: .standard(proto: "app_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.userID)
      case 2: try decoder.decodeSingularStringField(value: &self.appID)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.userID.isEmpty {
      try visitor.visitSingularStringField(value: self.userID, fieldNumber: 1)
    }
    if !self.appID.isEmpty {
      try visitor.visitSingularStringField(value: self.appID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_UserAppIDSet, rhs: Clarifai_Api_UserAppIDSet) -> Bool {
    if lhs.userID != rhs.userID {return false}
    if lhs.appID != rhs.appID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_PatchAction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PatchAction"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "op"),
    2: .standard(proto: "merge_conflict_resolution"),
    3: .same(proto: "path"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.op)
      case 2: try decoder.decodeSingularStringField(value: &self.mergeConflictResolution)
      case 3: try decoder.decodeSingularStringField(value: &self.path)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.op.isEmpty {
      try visitor.visitSingularStringField(value: self.op, fieldNumber: 1)
    }
    if !self.mergeConflictResolution.isEmpty {
      try visitor.visitSingularStringField(value: self.mergeConflictResolution, fieldNumber: 2)
    }
    if !self.path.isEmpty {
      try visitor.visitSingularStringField(value: self.path, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_PatchAction, rhs: Clarifai_Api_PatchAction) -> Bool {
    if lhs.op != rhs.op {return false}
    if lhs.mergeConflictResolution != rhs.mergeConflictResolution {return false}
    if lhs.path != rhs.path {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_Concept: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Concept"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "name"),
    3: .same(proto: "value"),
    4: .standard(proto: "created_at"),
    5: .same(proto: "language"),
    6: .standard(proto: "app_id"),
    7: .same(proto: "definition"),
    8: .standard(proto: "vocab_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.id)
      case 2: try decoder.decodeSingularStringField(value: &self.name)
      case 3: try decoder.decodeSingularFloatField(value: &self.value)
      case 4: try decoder.decodeSingularMessageField(value: &self._createdAt)
      case 5: try decoder.decodeSingularStringField(value: &self.language)
      case 6: try decoder.decodeSingularStringField(value: &self.appID)
      case 7: try decoder.decodeSingularStringField(value: &self.definition)
      case 8: try decoder.decodeSingularStringField(value: &self.vocabID)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 2)
    }
    if self.value != 0 {
      try visitor.visitSingularFloatField(value: self.value, fieldNumber: 3)
    }
    if let v = self._createdAt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }
    if !self.language.isEmpty {
      try visitor.visitSingularStringField(value: self.language, fieldNumber: 5)
    }
    if !self.appID.isEmpty {
      try visitor.visitSingularStringField(value: self.appID, fieldNumber: 6)
    }
    if !self.definition.isEmpty {
      try visitor.visitSingularStringField(value: self.definition, fieldNumber: 7)
    }
    if !self.vocabID.isEmpty {
      try visitor.visitSingularStringField(value: self.vocabID, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_Concept, rhs: Clarifai_Api_Concept) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.name != rhs.name {return false}
    if lhs.value != rhs.value {return false}
    if lhs._createdAt != rhs._createdAt {return false}
    if lhs.language != rhs.language {return false}
    if lhs.appID != rhs.appID {return false}
    if lhs.definition != rhs.definition {return false}
    if lhs.vocabID != rhs.vocabID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_ConceptCount: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ConceptCount"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "name"),
    3: .standard(proto: "concept_type_count"),
    4: .standard(proto: "detail_concept_count"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.id)
      case 2: try decoder.decodeSingularStringField(value: &self.name)
      case 3: try decoder.decodeSingularMessageField(value: &self._conceptTypeCount)
      case 4: try decoder.decodeSingularMessageField(value: &self._detailConceptCount)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 2)
    }
    if let v = self._conceptTypeCount {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    if let v = self._detailConceptCount {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_ConceptCount, rhs: Clarifai_Api_ConceptCount) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.name != rhs.name {return false}
    if lhs._conceptTypeCount != rhs._conceptTypeCount {return false}
    if lhs._detailConceptCount != rhs._detailConceptCount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_ConceptTypeCount: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ConceptTypeCount"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "positive"),
    2: .same(proto: "negative"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularUInt32Field(value: &self.positive)
      case 2: try decoder.decodeSingularUInt32Field(value: &self.negative)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.positive != 0 {
      try visitor.visitSingularUInt32Field(value: self.positive, fieldNumber: 1)
    }
    if self.negative != 0 {
      try visitor.visitSingularUInt32Field(value: self.negative, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_ConceptTypeCount, rhs: Clarifai_Api_ConceptTypeCount) -> Bool {
    if lhs.positive != rhs.positive {return false}
    if lhs.negative != rhs.negative {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_DetailConceptCount: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DetailConceptCount"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "processed"),
    2: .standard(proto: "to_process"),
    3: .same(proto: "errors"),
    4: .same(proto: "processing"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._processed)
      case 2: try decoder.decodeSingularMessageField(value: &self._toProcess)
      case 3: try decoder.decodeSingularMessageField(value: &self._errors)
      case 4: try decoder.decodeSingularMessageField(value: &self._processing)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._processed {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._toProcess {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if let v = self._errors {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    if let v = self._processing {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_DetailConceptCount, rhs: Clarifai_Api_DetailConceptCount) -> Bool {
    if lhs._processed != rhs._processed {return false}
    if lhs._toProcess != rhs._toProcess {return false}
    if lhs._errors != rhs._errors {return false}
    if lhs._processing != rhs._processing {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_ConceptQuery: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ConceptQuery"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "language"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.name)
      case 2: try decoder.decodeSingularStringField(value: &self.language)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.language.isEmpty {
      try visitor.visitSingularStringField(value: self.language, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_ConceptQuery, rhs: Clarifai_Api_ConceptQuery) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.language != rhs.language {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_ConceptRelation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ConceptRelation"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .standard(proto: "subject_concept"),
    3: .standard(proto: "object_concept"),
    4: .same(proto: "predicate"),
    5: .standard(proto: "knowledge_graph_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.id)
      case 2: try decoder.decodeSingularMessageField(value: &self._subjectConcept)
      case 3: try decoder.decodeSingularMessageField(value: &self._objectConcept)
      case 4: try decoder.decodeSingularStringField(value: &self.predicate)
      case 5: try decoder.decodeSingularStringField(value: &self.knowledgeGraphID)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if let v = self._subjectConcept {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if let v = self._objectConcept {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    if !self.predicate.isEmpty {
      try visitor.visitSingularStringField(value: self.predicate, fieldNumber: 4)
    }
    if !self.knowledgeGraphID.isEmpty {
      try visitor.visitSingularStringField(value: self.knowledgeGraphID, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_ConceptRelation, rhs: Clarifai_Api_ConceptRelation) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs._subjectConcept != rhs._subjectConcept {return false}
    if lhs._objectConcept != rhs._objectConcept {return false}
    if lhs.predicate != rhs.predicate {return false}
    if lhs.knowledgeGraphID != rhs.knowledgeGraphID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_KnowledgeGraph: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".KnowledgeGraph"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "name"),
    3: .same(proto: "description"),
    4: .standard(proto: "examples_app_id"),
    5: .standard(proto: "sampled_examples_app_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.id)
      case 2: try decoder.decodeSingularStringField(value: &self.name)
      case 3: try decoder.decodeSingularStringField(value: &self.description_p)
      case 4: try decoder.decodeSingularStringField(value: &self.examplesAppID)
      case 5: try decoder.decodeSingularStringField(value: &self.sampledExamplesAppID)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 2)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 3)
    }
    if !self.examplesAppID.isEmpty {
      try visitor.visitSingularStringField(value: self.examplesAppID, fieldNumber: 4)
    }
    if !self.sampledExamplesAppID.isEmpty {
      try visitor.visitSingularStringField(value: self.sampledExamplesAppID, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_KnowledgeGraph, rhs: Clarifai_Api_KnowledgeGraph) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.name != rhs.name {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.examplesAppID != rhs.examplesAppID {return false}
    if lhs.sampledExamplesAppID != rhs.sampledExamplesAppID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_ConceptMappingJob: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ConceptMappingJob"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "knowledge_graph_id"),
    2: .standard(proto: "concept_ids"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.knowledgeGraphID)
      case 2: try decoder.decodeRepeatedStringField(value: &self.conceptIds)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.knowledgeGraphID.isEmpty {
      try visitor.visitSingularStringField(value: self.knowledgeGraphID, fieldNumber: 1)
    }
    if !self.conceptIds.isEmpty {
      try visitor.visitRepeatedStringField(value: self.conceptIds, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_ConceptMappingJob, rhs: Clarifai_Api_ConceptMappingJob) -> Bool {
    if lhs.knowledgeGraphID != rhs.knowledgeGraphID {return false}
    if lhs.conceptIds != rhs.conceptIds {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_ConceptLanguage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ConceptLanguage"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "name"),
    3: .same(proto: "definition"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.id)
      case 2: try decoder.decodeSingularStringField(value: &self.name)
      case 3: try decoder.decodeSingularStringField(value: &self.definition)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 2)
    }
    if !self.definition.isEmpty {
      try visitor.visitSingularStringField(value: self.definition, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_ConceptLanguage, rhs: Clarifai_Api_ConceptLanguage) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.name != rhs.name {return false}
    if lhs.definition != rhs.definition {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_Data: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Data"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "image"),
    2: .same(proto: "video"),
    3: .same(proto: "concepts"),
    5: .same(proto: "metadata"),
    6: .same(proto: "geo"),
    7: .same(proto: "colors"),
    8: .same(proto: "clusters"),
    9: .same(proto: "embeddings"),
    11: .same(proto: "regions"),
    12: .same(proto: "frames"),
    13: .same(proto: "text"),
    14: .same(proto: "audio"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._image)
      case 2: try decoder.decodeSingularMessageField(value: &self._video)
      case 3: try decoder.decodeRepeatedMessageField(value: &self.concepts)
      case 5: try decoder.decodeSingularMessageField(value: &self._metadata)
      case 6: try decoder.decodeSingularMessageField(value: &self._geo)
      case 7: try decoder.decodeRepeatedMessageField(value: &self.colors)
      case 8: try decoder.decodeRepeatedMessageField(value: &self.clusters)
      case 9: try decoder.decodeRepeatedMessageField(value: &self.embeddings)
      case 11: try decoder.decodeRepeatedMessageField(value: &self.regions)
      case 12: try decoder.decodeRepeatedMessageField(value: &self.frames)
      case 13: try decoder.decodeSingularMessageField(value: &self._text)
      case 14: try decoder.decodeSingularMessageField(value: &self._audio)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._image {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._video {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if !self.concepts.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.concepts, fieldNumber: 3)
    }
    if let v = self._metadata {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }
    if let v = self._geo {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }
    if !self.colors.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.colors, fieldNumber: 7)
    }
    if !self.clusters.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.clusters, fieldNumber: 8)
    }
    if !self.embeddings.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.embeddings, fieldNumber: 9)
    }
    if !self.regions.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.regions, fieldNumber: 11)
    }
    if !self.frames.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.frames, fieldNumber: 12)
    }
    if let v = self._text {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
    }
    if let v = self._audio {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_Data, rhs: Clarifai_Api_Data) -> Bool {
    if lhs._image != rhs._image {return false}
    if lhs._video != rhs._video {return false}
    if lhs.concepts != rhs.concepts {return false}
    if lhs._metadata != rhs._metadata {return false}
    if lhs._geo != rhs._geo {return false}
    if lhs.colors != rhs.colors {return false}
    if lhs.clusters != rhs.clusters {return false}
    if lhs.embeddings != rhs.embeddings {return false}
    if lhs.regions != rhs.regions {return false}
    if lhs.frames != rhs.frames {return false}
    if lhs._text != rhs._text {return false}
    if lhs._audio != rhs._audio {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_Region: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Region"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .standard(proto: "region_info"),
    3: .same(proto: "data"),
    4: .same(proto: "value"),
    5: .standard(proto: "track_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.id)
      case 2: try decoder.decodeSingularMessageField(value: &self._regionInfo)
      case 3: try decoder.decodeSingularMessageField(value: &self._data)
      case 4: try decoder.decodeSingularFloatField(value: &self.value)
      case 5: try decoder.decodeSingularStringField(value: &self.trackID)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if let v = self._regionInfo {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if let v = self._data {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    if self.value != 0 {
      try visitor.visitSingularFloatField(value: self.value, fieldNumber: 4)
    }
    if !self.trackID.isEmpty {
      try visitor.visitSingularStringField(value: self.trackID, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_Region, rhs: Clarifai_Api_Region) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs._regionInfo != rhs._regionInfo {return false}
    if lhs._data != rhs._data {return false}
    if lhs.value != rhs.value {return false}
    if lhs.trackID != rhs.trackID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_RegionInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RegionInfo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "bounding_box"),
    4: .same(proto: "mask"),
    5: .same(proto: "polygon"),
    6: .same(proto: "point"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._boundingBox)
      case 4: try decoder.decodeSingularMessageField(value: &self._mask)
      case 5: try decoder.decodeSingularMessageField(value: &self._polygon)
      case 6: try decoder.decodeSingularMessageField(value: &self._point)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._boundingBox {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._mask {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }
    if let v = self._polygon {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }
    if let v = self._point {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_RegionInfo, rhs: Clarifai_Api_RegionInfo) -> Bool {
    if lhs._boundingBox != rhs._boundingBox {return false}
    if lhs._mask != rhs._mask {return false}
    if lhs._polygon != rhs._polygon {return false}
    if lhs._point != rhs._point {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_BoundingBox: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".BoundingBox"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "top_row"),
    2: .standard(proto: "left_col"),
    3: .standard(proto: "bottom_row"),
    4: .standard(proto: "right_col"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularFloatField(value: &self.topRow)
      case 2: try decoder.decodeSingularFloatField(value: &self.leftCol)
      case 3: try decoder.decodeSingularFloatField(value: &self.bottomRow)
      case 4: try decoder.decodeSingularFloatField(value: &self.rightCol)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.topRow != 0 {
      try visitor.visitSingularFloatField(value: self.topRow, fieldNumber: 1)
    }
    if self.leftCol != 0 {
      try visitor.visitSingularFloatField(value: self.leftCol, fieldNumber: 2)
    }
    if self.bottomRow != 0 {
      try visitor.visitSingularFloatField(value: self.bottomRow, fieldNumber: 3)
    }
    if self.rightCol != 0 {
      try visitor.visitSingularFloatField(value: self.rightCol, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_BoundingBox, rhs: Clarifai_Api_BoundingBox) -> Bool {
    if lhs.topRow != rhs.topRow {return false}
    if lhs.leftCol != rhs.leftCol {return false}
    if lhs.bottomRow != rhs.bottomRow {return false}
    if lhs.rightCol != rhs.rightCol {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_FrameInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".FrameInfo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "index"),
    2: .same(proto: "time"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularUInt32Field(value: &self.index)
      case 2: try decoder.decodeSingularUInt32Field(value: &self.time)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.index != 0 {
      try visitor.visitSingularUInt32Field(value: self.index, fieldNumber: 1)
    }
    if self.time != 0 {
      try visitor.visitSingularUInt32Field(value: self.time, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_FrameInfo, rhs: Clarifai_Api_FrameInfo) -> Bool {
    if lhs.index != rhs.index {return false}
    if lhs.time != rhs.time {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_Frame: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Frame"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "frame_info"),
    2: .same(proto: "data"),
    3: .same(proto: "id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._frameInfo)
      case 2: try decoder.decodeSingularMessageField(value: &self._data)
      case 3: try decoder.decodeSingularStringField(value: &self.id)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._frameInfo {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._data {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_Frame, rhs: Clarifai_Api_Frame) -> Bool {
    if lhs._frameInfo != rhs._frameInfo {return false}
    if lhs._data != rhs._data {return false}
    if lhs.id != rhs.id {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_Mask: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Mask"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "color"),
    2: .same(proto: "image"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._color)
      case 2: try decoder.decodeSingularMessageField(value: &self._image)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._color {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._image {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_Mask, rhs: Clarifai_Api_Mask) -> Bool {
    if lhs._color != rhs._color {return false}
    if lhs._image != rhs._image {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_Polygon: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Polygon"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "points"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.points)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.points.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.points, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_Polygon, rhs: Clarifai_Api_Polygon) -> Bool {
    if lhs.points != rhs.points {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_Point: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Point"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "row"),
    2: .same(proto: "col"),
    3: .same(proto: "z"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularFloatField(value: &self.row)
      case 2: try decoder.decodeSingularFloatField(value: &self.col)
      case 3: try decoder.decodeSingularFloatField(value: &self.z)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.row != 0 {
      try visitor.visitSingularFloatField(value: self.row, fieldNumber: 1)
    }
    if self.col != 0 {
      try visitor.visitSingularFloatField(value: self.col, fieldNumber: 2)
    }
    if self.z != 0 {
      try visitor.visitSingularFloatField(value: self.z, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_Point, rhs: Clarifai_Api_Point) -> Bool {
    if lhs.row != rhs.row {return false}
    if lhs.col != rhs.col {return false}
    if lhs.z != rhs.z {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_Embedding: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Embedding"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "vector"),
    2: .standard(proto: "num_dimensions"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedFloatField(value: &self.vector)
      case 2: try decoder.decodeSingularUInt32Field(value: &self.numDimensions)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.vector.isEmpty {
      try visitor.visitPackedFloatField(value: self.vector, fieldNumber: 1)
    }
    if self.numDimensions != 0 {
      try visitor.visitSingularUInt32Field(value: self.numDimensions, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_Embedding, rhs: Clarifai_Api_Embedding) -> Bool {
    if lhs.vector != rhs.vector {return false}
    if lhs.numDimensions != rhs.numDimensions {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_GeoPoint: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GeoPoint"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "longitude"),
    2: .same(proto: "latitude"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularFloatField(value: &self.longitude)
      case 2: try decoder.decodeSingularFloatField(value: &self.latitude)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.longitude != 0 {
      try visitor.visitSingularFloatField(value: self.longitude, fieldNumber: 1)
    }
    if self.latitude != 0 {
      try visitor.visitSingularFloatField(value: self.latitude, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_GeoPoint, rhs: Clarifai_Api_GeoPoint) -> Bool {
    if lhs.longitude != rhs.longitude {return false}
    if lhs.latitude != rhs.latitude {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_GeoLimit: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GeoLimit"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .same(proto: "value"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.type)
      case 2: try decoder.decodeSingularFloatField(value: &self.value)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.type.isEmpty {
      try visitor.visitSingularStringField(value: self.type, fieldNumber: 1)
    }
    if self.value != 0 {
      try visitor.visitSingularFloatField(value: self.value, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_GeoLimit, rhs: Clarifai_Api_GeoLimit) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_GeoBoxedPoint: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GeoBoxedPoint"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "geo_point"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._geoPoint)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._geoPoint {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_GeoBoxedPoint, rhs: Clarifai_Api_GeoBoxedPoint) -> Bool {
    if lhs._geoPoint != rhs._geoPoint {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_Geo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Geo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "geo_point"),
    2: .standard(proto: "geo_limit"),
    3: .standard(proto: "geo_box"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._geoPoint)
      case 2: try decoder.decodeSingularMessageField(value: &self._geoLimit)
      case 3: try decoder.decodeRepeatedMessageField(value: &self.geoBox)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._geoPoint {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._geoLimit {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if !self.geoBox.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.geoBox, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_Geo, rhs: Clarifai_Api_Geo) -> Bool {
    if lhs._geoPoint != rhs._geoPoint {return false}
    if lhs._geoLimit != rhs._geoLimit {return false}
    if lhs.geoBox != rhs.geoBox {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_Image: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Image"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "url"),
    2: .same(proto: "base64"),
    4: .standard(proto: "allow_duplicate_url"),
    5: .same(proto: "hosted"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.url)
      case 2: try decoder.decodeSingularBytesField(value: &self.base64)
      case 4: try decoder.decodeSingularBoolField(value: &self.allowDuplicateURL)
      case 5: try decoder.decodeSingularMessageField(value: &self._hosted)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.url.isEmpty {
      try visitor.visitSingularStringField(value: self.url, fieldNumber: 1)
    }
    if !self.base64.isEmpty {
      try visitor.visitSingularBytesField(value: self.base64, fieldNumber: 2)
    }
    if self.allowDuplicateURL != false {
      try visitor.visitSingularBoolField(value: self.allowDuplicateURL, fieldNumber: 4)
    }
    if let v = self._hosted {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_Image, rhs: Clarifai_Api_Image) -> Bool {
    if lhs.url != rhs.url {return false}
    if lhs.base64 != rhs.base64 {return false}
    if lhs.allowDuplicateURL != rhs.allowDuplicateURL {return false}
    if lhs._hosted != rhs._hosted {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_HostedURL: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".HostedURL"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "prefix"),
    2: .same(proto: "suffix"),
    3: .same(proto: "sizes"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.prefix)
      case 2: try decoder.decodeSingularStringField(value: &self.suffix)
      case 3: try decoder.decodeRepeatedStringField(value: &self.sizes)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.prefix.isEmpty {
      try visitor.visitSingularStringField(value: self.prefix, fieldNumber: 1)
    }
    if !self.suffix.isEmpty {
      try visitor.visitSingularStringField(value: self.suffix, fieldNumber: 2)
    }
    if !self.sizes.isEmpty {
      try visitor.visitRepeatedStringField(value: self.sizes, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_HostedURL, rhs: Clarifai_Api_HostedURL) -> Bool {
    if lhs.prefix != rhs.prefix {return false}
    if lhs.suffix != rhs.suffix {return false}
    if lhs.sizes != rhs.sizes {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_Input: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Input"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "data"),
    4: .standard(proto: "created_at"),
    5: .standard(proto: "modified_at"),
    6: .same(proto: "status"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.id)
      case 2: try decoder.decodeSingularMessageField(value: &self._data)
      case 4: try decoder.decodeSingularMessageField(value: &self._createdAt)
      case 5: try decoder.decodeSingularMessageField(value: &self._modifiedAt)
      case 6: try decoder.decodeSingularMessageField(value: &self._status)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if let v = self._data {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if let v = self._createdAt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }
    if let v = self._modifiedAt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }
    if let v = self._status {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_Input, rhs: Clarifai_Api_Input) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs._data != rhs._data {return false}
    if lhs._createdAt != rhs._createdAt {return false}
    if lhs._modifiedAt != rhs._modifiedAt {return false}
    if lhs._status != rhs._status {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_InputCount: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".InputCount"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "processed"),
    2: .standard(proto: "to_process"),
    3: .same(proto: "errors"),
    4: .same(proto: "processing"),
    5: .same(proto: "reindexed"),
    6: .standard(proto: "to_reindex"),
    7: .standard(proto: "reindex_errors"),
    8: .same(proto: "reindexing"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularUInt32Field(value: &self.processed)
      case 2: try decoder.decodeSingularUInt32Field(value: &self.toProcess)
      case 3: try decoder.decodeSingularUInt32Field(value: &self.errors)
      case 4: try decoder.decodeSingularUInt32Field(value: &self.processing)
      case 5: try decoder.decodeSingularUInt32Field(value: &self.reindexed)
      case 6: try decoder.decodeSingularUInt32Field(value: &self.toReindex)
      case 7: try decoder.decodeSingularUInt32Field(value: &self.reindexErrors)
      case 8: try decoder.decodeSingularUInt32Field(value: &self.reindexing)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.processed != 0 {
      try visitor.visitSingularUInt32Field(value: self.processed, fieldNumber: 1)
    }
    if self.toProcess != 0 {
      try visitor.visitSingularUInt32Field(value: self.toProcess, fieldNumber: 2)
    }
    if self.errors != 0 {
      try visitor.visitSingularUInt32Field(value: self.errors, fieldNumber: 3)
    }
    if self.processing != 0 {
      try visitor.visitSingularUInt32Field(value: self.processing, fieldNumber: 4)
    }
    if self.reindexed != 0 {
      try visitor.visitSingularUInt32Field(value: self.reindexed, fieldNumber: 5)
    }
    if self.toReindex != 0 {
      try visitor.visitSingularUInt32Field(value: self.toReindex, fieldNumber: 6)
    }
    if self.reindexErrors != 0 {
      try visitor.visitSingularUInt32Field(value: self.reindexErrors, fieldNumber: 7)
    }
    if self.reindexing != 0 {
      try visitor.visitSingularUInt32Field(value: self.reindexing, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_InputCount, rhs: Clarifai_Api_InputCount) -> Bool {
    if lhs.processed != rhs.processed {return false}
    if lhs.toProcess != rhs.toProcess {return false}
    if lhs.errors != rhs.errors {return false}
    if lhs.processing != rhs.processing {return false}
    if lhs.reindexed != rhs.reindexed {return false}
    if lhs.toReindex != rhs.toReindex {return false}
    if lhs.reindexErrors != rhs.reindexErrors {return false}
    if lhs.reindexing != rhs.reindexing {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_WorkflowResultsSimilarity: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".WorkflowResultsSimilarity"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "probe_input"),
    2: .standard(proto: "pool_results"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._probeInput)
      case 2: try decoder.decodeRepeatedMessageField(value: &self.poolResults)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._probeInput {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if !self.poolResults.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.poolResults, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_WorkflowResultsSimilarity, rhs: Clarifai_Api_WorkflowResultsSimilarity) -> Bool {
    if lhs._probeInput != rhs._probeInput {return false}
    if lhs.poolResults != rhs.poolResults {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_Key: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Key"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    8: .same(proto: "type"),
    2: .same(proto: "description"),
    3: .same(proto: "scopes"),
    7: .same(proto: "endpoints"),
    4: .same(proto: "apps"),
    5: .standard(proto: "created_at"),
    6: .standard(proto: "expires_at"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.id)
      case 2: try decoder.decodeSingularStringField(value: &self.description_p)
      case 3: try decoder.decodeRepeatedStringField(value: &self.scopes)
      case 4: try decoder.decodeRepeatedMessageField(value: &self.apps)
      case 5: try decoder.decodeSingularMessageField(value: &self._createdAt)
      case 6: try decoder.decodeSingularMessageField(value: &self._expiresAt)
      case 7: try decoder.decodeRepeatedStringField(value: &self.endpoints)
      case 8: try decoder.decodeSingularStringField(value: &self.type)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 2)
    }
    if !self.scopes.isEmpty {
      try visitor.visitRepeatedStringField(value: self.scopes, fieldNumber: 3)
    }
    if !self.apps.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.apps, fieldNumber: 4)
    }
    if let v = self._createdAt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }
    if let v = self._expiresAt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }
    if !self.endpoints.isEmpty {
      try visitor.visitRepeatedStringField(value: self.endpoints, fieldNumber: 7)
    }
    if !self.type.isEmpty {
      try visitor.visitSingularStringField(value: self.type, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_Key, rhs: Clarifai_Api_Key) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.type != rhs.type {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.scopes != rhs.scopes {return false}
    if lhs.endpoints != rhs.endpoints {return false}
    if lhs.apps != rhs.apps {return false}
    if lhs._createdAt != rhs._createdAt {return false}
    if lhs._expiresAt != rhs._expiresAt {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_Model: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Model"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "name"),
    3: .standard(proto: "created_at"),
    4: .standard(proto: "app_id"),
    5: .standard(proto: "output_info"),
    6: .standard(proto: "model_version"),
    7: .standard(proto: "display_name"),
    9: .standard(proto: "user_id"),
    12: .standard(proto: "input_info"),
    13: .standard(proto: "train_info"),
    14: .standard(proto: "model_type_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.id)
      case 2: try decoder.decodeSingularStringField(value: &self.name)
      case 3: try decoder.decodeSingularMessageField(value: &self._createdAt)
      case 4: try decoder.decodeSingularStringField(value: &self.appID)
      case 5: try decoder.decodeSingularMessageField(value: &self._outputInfo)
      case 6: try decoder.decodeSingularMessageField(value: &self._modelVersion)
      case 7: try decoder.decodeSingularStringField(value: &self.displayName)
      case 9: try decoder.decodeSingularStringField(value: &self.userID)
      case 12: try decoder.decodeSingularMessageField(value: &self._inputInfo)
      case 13: try decoder.decodeSingularMessageField(value: &self._trainInfo)
      case 14: try decoder.decodeSingularStringField(value: &self.modelTypeID)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 2)
    }
    if let v = self._createdAt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    if !self.appID.isEmpty {
      try visitor.visitSingularStringField(value: self.appID, fieldNumber: 4)
    }
    if let v = self._outputInfo {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }
    if let v = self._modelVersion {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }
    if !self.displayName.isEmpty {
      try visitor.visitSingularStringField(value: self.displayName, fieldNumber: 7)
    }
    if !self.userID.isEmpty {
      try visitor.visitSingularStringField(value: self.userID, fieldNumber: 9)
    }
    if let v = self._inputInfo {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
    }
    if let v = self._trainInfo {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
    }
    if !self.modelTypeID.isEmpty {
      try visitor.visitSingularStringField(value: self.modelTypeID, fieldNumber: 14)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_Model, rhs: Clarifai_Api_Model) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.name != rhs.name {return false}
    if lhs._createdAt != rhs._createdAt {return false}
    if lhs.appID != rhs.appID {return false}
    if lhs._outputInfo != rhs._outputInfo {return false}
    if lhs._modelVersion != rhs._modelVersion {return false}
    if lhs.displayName != rhs.displayName {return false}
    if lhs.userID != rhs.userID {return false}
    if lhs._inputInfo != rhs._inputInfo {return false}
    if lhs._trainInfo != rhs._trainInfo {return false}
    if lhs.modelTypeID != rhs.modelTypeID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_OutputInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".OutputInfo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "data"),
    2: .standard(proto: "output_config"),
    3: .same(proto: "message"),
    4: .same(proto: "type"),
    5: .standard(proto: "type_ext"),
    6: .standard(proto: "fields_map"),
    7: .same(proto: "params"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._data)
      case 2: try decoder.decodeSingularMessageField(value: &self._outputConfig)
      case 3: try decoder.decodeSingularStringField(value: &self.message)
      case 4: try decoder.decodeSingularStringField(value: &self.type)
      case 5: try decoder.decodeSingularStringField(value: &self.typeExt)
      case 6: try decoder.decodeSingularMessageField(value: &self._fieldsMap)
      case 7: try decoder.decodeSingularMessageField(value: &self._params)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._data {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._outputConfig {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 3)
    }
    if !self.type.isEmpty {
      try visitor.visitSingularStringField(value: self.type, fieldNumber: 4)
    }
    if !self.typeExt.isEmpty {
      try visitor.visitSingularStringField(value: self.typeExt, fieldNumber: 5)
    }
    if let v = self._fieldsMap {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }
    if let v = self._params {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_OutputInfo, rhs: Clarifai_Api_OutputInfo) -> Bool {
    if lhs._data != rhs._data {return false}
    if lhs._outputConfig != rhs._outputConfig {return false}
    if lhs.message != rhs.message {return false}
    if lhs.type != rhs.type {return false}
    if lhs.typeExt != rhs.typeExt {return false}
    if lhs._fieldsMap != rhs._fieldsMap {return false}
    if lhs._params != rhs._params {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_InputInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".InputInfo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "fields_map"),
    2: .same(proto: "params"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._fieldsMap)
      case 2: try decoder.decodeSingularMessageField(value: &self._params)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._fieldsMap {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._params {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_InputInfo, rhs: Clarifai_Api_InputInfo) -> Bool {
    if lhs._fieldsMap != rhs._fieldsMap {return false}
    if lhs._params != rhs._params {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_TrainInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TrainInfo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "params"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._params)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._params {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_TrainInfo, rhs: Clarifai_Api_TrainInfo) -> Bool {
    if lhs._params != rhs._params {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_OutputConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".OutputConfig"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "concepts_mutually_exclusive"),
    2: .standard(proto: "closed_environment"),
    3: .standard(proto: "existing_model_id"),
    4: .same(proto: "language"),
    5: .standard(proto: "hyper_parameters"),
    6: .standard(proto: "max_concepts"),
    7: .standard(proto: "min_value"),
    8: .standard(proto: "select_concepts"),
    9: .standard(proto: "training_timeout"),
    10: .standard(proto: "sample_ms"),
    13: .standard(proto: "hyper_params"),
    14: .standard(proto: "embed_model_version_id"),
    15: .standard(proto: "fail_on_missing_positive_examples"),
    17: .standard(proto: "model_metadata"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBoolField(value: &self.conceptsMutuallyExclusive)
      case 2: try decoder.decodeSingularBoolField(value: &self.closedEnvironment)
      case 3: try decoder.decodeSingularStringField(value: &self.existingModelID)
      case 4: try decoder.decodeSingularStringField(value: &self.language)
      case 5: try decoder.decodeSingularStringField(value: &self.hyperParameters)
      case 6: try decoder.decodeSingularUInt32Field(value: &self.maxConcepts)
      case 7: try decoder.decodeSingularFloatField(value: &self.minValue)
      case 8: try decoder.decodeRepeatedMessageField(value: &self.selectConcepts)
      case 9: try decoder.decodeSingularUInt32Field(value: &self.trainingTimeout)
      case 10: try decoder.decodeSingularUInt32Field(value: &self.sampleMs)
      case 13: try decoder.decodeSingularMessageField(value: &self._hyperParams)
      case 14: try decoder.decodeSingularStringField(value: &self.embedModelVersionID)
      case 15: try decoder.decodeSingularBoolField(value: &self.failOnMissingPositiveExamples)
      case 17: try decoder.decodeSingularMessageField(value: &self._modelMetadata)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.conceptsMutuallyExclusive != false {
      try visitor.visitSingularBoolField(value: self.conceptsMutuallyExclusive, fieldNumber: 1)
    }
    if self.closedEnvironment != false {
      try visitor.visitSingularBoolField(value: self.closedEnvironment, fieldNumber: 2)
    }
    if !self.existingModelID.isEmpty {
      try visitor.visitSingularStringField(value: self.existingModelID, fieldNumber: 3)
    }
    if !self.language.isEmpty {
      try visitor.visitSingularStringField(value: self.language, fieldNumber: 4)
    }
    if !self.hyperParameters.isEmpty {
      try visitor.visitSingularStringField(value: self.hyperParameters, fieldNumber: 5)
    }
    if self.maxConcepts != 0 {
      try visitor.visitSingularUInt32Field(value: self.maxConcepts, fieldNumber: 6)
    }
    if self.minValue != 0 {
      try visitor.visitSingularFloatField(value: self.minValue, fieldNumber: 7)
    }
    if !self.selectConcepts.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.selectConcepts, fieldNumber: 8)
    }
    if self.trainingTimeout != 0 {
      try visitor.visitSingularUInt32Field(value: self.trainingTimeout, fieldNumber: 9)
    }
    if self.sampleMs != 0 {
      try visitor.visitSingularUInt32Field(value: self.sampleMs, fieldNumber: 10)
    }
    if let v = self._hyperParams {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
    }
    if !self.embedModelVersionID.isEmpty {
      try visitor.visitSingularStringField(value: self.embedModelVersionID, fieldNumber: 14)
    }
    if self.failOnMissingPositiveExamples != false {
      try visitor.visitSingularBoolField(value: self.failOnMissingPositiveExamples, fieldNumber: 15)
    }
    if let v = self._modelMetadata {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 17)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_OutputConfig, rhs: Clarifai_Api_OutputConfig) -> Bool {
    if lhs.conceptsMutuallyExclusive != rhs.conceptsMutuallyExclusive {return false}
    if lhs.closedEnvironment != rhs.closedEnvironment {return false}
    if lhs.existingModelID != rhs.existingModelID {return false}
    if lhs.language != rhs.language {return false}
    if lhs.hyperParameters != rhs.hyperParameters {return false}
    if lhs.maxConcepts != rhs.maxConcepts {return false}
    if lhs.minValue != rhs.minValue {return false}
    if lhs.selectConcepts != rhs.selectConcepts {return false}
    if lhs.trainingTimeout != rhs.trainingTimeout {return false}
    if lhs.sampleMs != rhs.sampleMs {return false}
    if lhs._hyperParams != rhs._hyperParams {return false}
    if lhs.embedModelVersionID != rhs.embedModelVersionID {return false}
    if lhs.failOnMissingPositiveExamples != rhs.failOnMissingPositiveExamples {return false}
    if lhs._modelMetadata != rhs._modelMetadata {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_ModelType: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ModelType"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "title"),
    3: .same(proto: "description"),
    4: .same(proto: "type"),
    5: .standard(proto: "input_fields"),
    6: .standard(proto: "output_fields"),
    8: .same(proto: "trainable"),
    9: .same(proto: "creatable"),
    10: .standard(proto: "internal_only"),
    11: .standard(proto: "model_type_fields"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.id)
      case 2: try decoder.decodeSingularStringField(value: &self.title)
      case 3: try decoder.decodeSingularStringField(value: &self.description_p)
      case 4: try decoder.decodeSingularStringField(value: &self.type)
      case 5: try decoder.decodeRepeatedStringField(value: &self.inputFields)
      case 6: try decoder.decodeRepeatedStringField(value: &self.outputFields)
      case 8: try decoder.decodeSingularBoolField(value: &self.trainable)
      case 9: try decoder.decodeSingularBoolField(value: &self.creatable)
      case 10: try decoder.decodeSingularBoolField(value: &self.internalOnly)
      case 11: try decoder.decodeRepeatedMessageField(value: &self.modelTypeFields)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if !self.title.isEmpty {
      try visitor.visitSingularStringField(value: self.title, fieldNumber: 2)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 3)
    }
    if !self.type.isEmpty {
      try visitor.visitSingularStringField(value: self.type, fieldNumber: 4)
    }
    if !self.inputFields.isEmpty {
      try visitor.visitRepeatedStringField(value: self.inputFields, fieldNumber: 5)
    }
    if !self.outputFields.isEmpty {
      try visitor.visitRepeatedStringField(value: self.outputFields, fieldNumber: 6)
    }
    if self.trainable != false {
      try visitor.visitSingularBoolField(value: self.trainable, fieldNumber: 8)
    }
    if self.creatable != false {
      try visitor.visitSingularBoolField(value: self.creatable, fieldNumber: 9)
    }
    if self.internalOnly != false {
      try visitor.visitSingularBoolField(value: self.internalOnly, fieldNumber: 10)
    }
    if !self.modelTypeFields.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.modelTypeFields, fieldNumber: 11)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_ModelType, rhs: Clarifai_Api_ModelType) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.title != rhs.title {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.type != rhs.type {return false}
    if lhs.inputFields != rhs.inputFields {return false}
    if lhs.outputFields != rhs.outputFields {return false}
    if lhs.trainable != rhs.trainable {return false}
    if lhs.creatable != rhs.creatable {return false}
    if lhs.internalOnly != rhs.internalOnly {return false}
    if lhs.modelTypeFields != rhs.modelTypeFields {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_ModelTypeField: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ModelTypeField"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "path"),
    2: .standard(proto: "field_type"),
    3: .standard(proto: "default_value"),
    4: .same(proto: "description"),
    5: .same(proto: "placeholder"),
    6: .standard(proto: "model_type_enum_options"),
    7: .standard(proto: "internal_only"),
    8: .same(proto: "required"),
    9: .standard(proto: "model_type_range_info"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.path)
      case 2: try decoder.decodeSingularEnumField(value: &self.fieldType)
      case 3: try decoder.decodeSingularMessageField(value: &self._defaultValue)
      case 4: try decoder.decodeSingularStringField(value: &self.description_p)
      case 5: try decoder.decodeSingularStringField(value: &self.placeholder)
      case 6: try decoder.decodeRepeatedMessageField(value: &self.modelTypeEnumOptions)
      case 7: try decoder.decodeSingularBoolField(value: &self.internalOnly)
      case 8: try decoder.decodeSingularBoolField(value: &self.required)
      case 9: try decoder.decodeSingularMessageField(value: &self._modelTypeRangeInfo)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.path.isEmpty {
      try visitor.visitSingularStringField(value: self.path, fieldNumber: 1)
    }
    if self.fieldType != .invalidModelTypeFieldType {
      try visitor.visitSingularEnumField(value: self.fieldType, fieldNumber: 2)
    }
    if let v = self._defaultValue {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 4)
    }
    if !self.placeholder.isEmpty {
      try visitor.visitSingularStringField(value: self.placeholder, fieldNumber: 5)
    }
    if !self.modelTypeEnumOptions.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.modelTypeEnumOptions, fieldNumber: 6)
    }
    if self.internalOnly != false {
      try visitor.visitSingularBoolField(value: self.internalOnly, fieldNumber: 7)
    }
    if self.required != false {
      try visitor.visitSingularBoolField(value: self.required, fieldNumber: 8)
    }
    if let v = self._modelTypeRangeInfo {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_ModelTypeField, rhs: Clarifai_Api_ModelTypeField) -> Bool {
    if lhs.path != rhs.path {return false}
    if lhs.fieldType != rhs.fieldType {return false}
    if lhs._defaultValue != rhs._defaultValue {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.placeholder != rhs.placeholder {return false}
    if lhs.modelTypeEnumOptions != rhs.modelTypeEnumOptions {return false}
    if lhs.internalOnly != rhs.internalOnly {return false}
    if lhs.required != rhs.required {return false}
    if lhs._modelTypeRangeInfo != rhs._modelTypeRangeInfo {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_ModelTypeField.ModelTypeFieldType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "INVALID_MODEL_TYPE_FIELD_TYPE"),
    1: .same(proto: "BOOLEAN"),
    2: .same(proto: "STRING"),
    3: .same(proto: "NUMBER"),
    4: .same(proto: "ARRAY_OF_CONCEPTS"),
    5: .same(proto: "ARRAY_OF_CONCEPTS_WITH_THRESHOLD"),
    7: .same(proto: "RANGE"),
    8: .same(proto: "ENUM"),
    9: .same(proto: "COLLABORATORS"),
    10: .same(proto: "JSON"),
    11: .same(proto: "ARRAY_OF_NUMBERS"),
    12: .same(proto: "WORKFLOW_EMBED_MODELS"),
  ]
}

extension Clarifai_Api_ModelTypeRangeInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ModelTypeRangeInfo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "min"),
    2: .same(proto: "max"),
    3: .same(proto: "step"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularFloatField(value: &self.min)
      case 2: try decoder.decodeSingularFloatField(value: &self.max)
      case 3: try decoder.decodeSingularFloatField(value: &self.step)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.min != 0 {
      try visitor.visitSingularFloatField(value: self.min, fieldNumber: 1)
    }
    if self.max != 0 {
      try visitor.visitSingularFloatField(value: self.max, fieldNumber: 2)
    }
    if self.step != 0 {
      try visitor.visitSingularFloatField(value: self.step, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_ModelTypeRangeInfo, rhs: Clarifai_Api_ModelTypeRangeInfo) -> Bool {
    if lhs.min != rhs.min {return false}
    if lhs.max != rhs.max {return false}
    if lhs.step != rhs.step {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_ModelTypeEnumOption: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ModelTypeEnumOption"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "description"),
    3: .standard(proto: "model_type_fields"),
    4: .standard(proto: "internal_only"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.id)
      case 2: try decoder.decodeSingularStringField(value: &self.description_p)
      case 3: try decoder.decodeRepeatedMessageField(value: &self.modelTypeFields)
      case 4: try decoder.decodeSingularBoolField(value: &self.internalOnly)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 2)
    }
    if !self.modelTypeFields.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.modelTypeFields, fieldNumber: 3)
    }
    if self.internalOnly != false {
      try visitor.visitSingularBoolField(value: self.internalOnly, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_ModelTypeEnumOption, rhs: Clarifai_Api_ModelTypeEnumOption) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.modelTypeFields != rhs.modelTypeFields {return false}
    if lhs.internalOnly != rhs.internalOnly {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_ModelQuery: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ModelQuery"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "type"),
    3: .standard(proto: "model_type_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.name)
      case 2: try decoder.decodeSingularStringField(value: &self.type)
      case 3: try decoder.decodeSingularStringField(value: &self.modelTypeID)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.type.isEmpty {
      try visitor.visitSingularStringField(value: self.type, fieldNumber: 2)
    }
    if !self.modelTypeID.isEmpty {
      try visitor.visitSingularStringField(value: self.modelTypeID, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_ModelQuery, rhs: Clarifai_Api_ModelQuery) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.type != rhs.type {return false}
    if lhs.modelTypeID != rhs.modelTypeID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_ModelVersion: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ModelVersion"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .standard(proto: "created_at"),
    3: .same(proto: "status"),
    4: .standard(proto: "active_concept_count"),
    5: .same(proto: "metrics"),
    6: .standard(proto: "total_input_count"),
    10: .standard(proto: "completed_at"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.id)
      case 2: try decoder.decodeSingularMessageField(value: &self._createdAt)
      case 3: try decoder.decodeSingularMessageField(value: &self._status)
      case 4: try decoder.decodeSingularUInt32Field(value: &self.activeConceptCount)
      case 5: try decoder.decodeSingularMessageField(value: &self._metrics)
      case 6: try decoder.decodeSingularUInt32Field(value: &self.totalInputCount)
      case 10: try decoder.decodeSingularMessageField(value: &self._completedAt)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if let v = self._createdAt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if let v = self._status {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    if self.activeConceptCount != 0 {
      try visitor.visitSingularUInt32Field(value: self.activeConceptCount, fieldNumber: 4)
    }
    if let v = self._metrics {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }
    if self.totalInputCount != 0 {
      try visitor.visitSingularUInt32Field(value: self.totalInputCount, fieldNumber: 6)
    }
    if let v = self._completedAt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_ModelVersion, rhs: Clarifai_Api_ModelVersion) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs._createdAt != rhs._createdAt {return false}
    if lhs._status != rhs._status {return false}
    if lhs.activeConceptCount != rhs.activeConceptCount {return false}
    if lhs._metrics != rhs._metrics {return false}
    if lhs.totalInputCount != rhs.totalInputCount {return false}
    if lhs._completedAt != rhs._completedAt {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_PretrainedModelConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PretrainedModelConfig"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "type"),
    3: .standard(proto: "input_fields_map"),
    4: .standard(proto: "output_fields_map"),
    5: .standard(proto: "data_provider_params"),
    6: .standard(proto: "model_zip_url"),
    7: .same(proto: "overwrite"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.id)
      case 2: try decoder.decodeSingularStringField(value: &self.type)
      case 3: try decoder.decodeSingularMessageField(value: &self._inputFieldsMap)
      case 4: try decoder.decodeSingularMessageField(value: &self._outputFieldsMap)
      case 5: try decoder.decodeSingularStringField(value: &self.dataProviderParams)
      case 6: try decoder.decodeSingularStringField(value: &self.modelZipURL)
      case 7: try decoder.decodeSingularBoolField(value: &self.overwrite)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if !self.type.isEmpty {
      try visitor.visitSingularStringField(value: self.type, fieldNumber: 2)
    }
    if let v = self._inputFieldsMap {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    if let v = self._outputFieldsMap {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }
    if !self.dataProviderParams.isEmpty {
      try visitor.visitSingularStringField(value: self.dataProviderParams, fieldNumber: 5)
    }
    if !self.modelZipURL.isEmpty {
      try visitor.visitSingularStringField(value: self.modelZipURL, fieldNumber: 6)
    }
    if self.overwrite != false {
      try visitor.visitSingularBoolField(value: self.overwrite, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_PretrainedModelConfig, rhs: Clarifai_Api_PretrainedModelConfig) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.type != rhs.type {return false}
    if lhs._inputFieldsMap != rhs._inputFieldsMap {return false}
    if lhs._outputFieldsMap != rhs._outputFieldsMap {return false}
    if lhs.dataProviderParams != rhs.dataProviderParams {return false}
    if lhs.modelZipURL != rhs.modelZipURL {return false}
    if lhs.overwrite != rhs.overwrite {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_TrainStats: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TrainStats"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "loss_curve"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.lossCurve)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.lossCurve.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.lossCurve, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_TrainStats, rhs: Clarifai_Api_TrainStats) -> Bool {
    if lhs.lossCurve != rhs.lossCurve {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_LossCurveEntry: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LossCurveEntry"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "epoch"),
    2: .standard(proto: "global_step"),
    3: .same(proto: "cost"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularUInt32Field(value: &self.epoch)
      case 2: try decoder.decodeSingularUInt32Field(value: &self.globalStep)
      case 3: try decoder.decodeSingularFloatField(value: &self.cost)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.epoch != 0 {
      try visitor.visitSingularUInt32Field(value: self.epoch, fieldNumber: 1)
    }
    if self.globalStep != 0 {
      try visitor.visitSingularUInt32Field(value: self.globalStep, fieldNumber: 2)
    }
    if self.cost != 0 {
      try visitor.visitSingularFloatField(value: self.cost, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_LossCurveEntry, rhs: Clarifai_Api_LossCurveEntry) -> Bool {
    if lhs.epoch != rhs.epoch {return false}
    if lhs.globalStep != rhs.globalStep {return false}
    if lhs.cost != rhs.cost {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_LabelCount: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LabelCount"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "concept_name"),
    2: .same(proto: "count"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.conceptName)
      case 2: try decoder.decodeSingularUInt32Field(value: &self.count)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.conceptName.isEmpty {
      try visitor.visitSingularStringField(value: self.conceptName, fieldNumber: 1)
    }
    if self.count != 0 {
      try visitor.visitSingularUInt32Field(value: self.count, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_LabelCount, rhs: Clarifai_Api_LabelCount) -> Bool {
    if lhs.conceptName != rhs.conceptName {return false}
    if lhs.count != rhs.count {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_LabelDistribution: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LabelDistribution"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "positive_label_counts"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.positiveLabelCounts)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.positiveLabelCounts.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.positiveLabelCounts, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_LabelDistribution, rhs: Clarifai_Api_LabelDistribution) -> Bool {
    if lhs.positiveLabelCounts != rhs.positiveLabelCounts {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_CooccurrenceMatrixEntry: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CooccurrenceMatrixEntry"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "row"),
    2: .same(proto: "col"),
    3: .same(proto: "count"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.row)
      case 2: try decoder.decodeSingularStringField(value: &self.col)
      case 3: try decoder.decodeSingularUInt32Field(value: &self.count)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.row.isEmpty {
      try visitor.visitSingularStringField(value: self.row, fieldNumber: 1)
    }
    if !self.col.isEmpty {
      try visitor.visitSingularStringField(value: self.col, fieldNumber: 2)
    }
    if self.count != 0 {
      try visitor.visitSingularUInt32Field(value: self.count, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_CooccurrenceMatrixEntry, rhs: Clarifai_Api_CooccurrenceMatrixEntry) -> Bool {
    if lhs.row != rhs.row {return false}
    if lhs.col != rhs.col {return false}
    if lhs.count != rhs.count {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_CooccurrenceMatrix: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CooccurrenceMatrix"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "matrix"),
    2: .standard(proto: "concept_ids"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.matrix)
      case 2: try decoder.decodeRepeatedStringField(value: &self.conceptIds)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.matrix.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.matrix, fieldNumber: 1)
    }
    if !self.conceptIds.isEmpty {
      try visitor.visitRepeatedStringField(value: self.conceptIds, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_CooccurrenceMatrix, rhs: Clarifai_Api_CooccurrenceMatrix) -> Bool {
    if lhs.matrix != rhs.matrix {return false}
    if lhs.conceptIds != rhs.conceptIds {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_ConfusionMatrixEntry: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ConfusionMatrixEntry"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "predicted"),
    2: .same(proto: "actual"),
    4: .same(proto: "value"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.predicted)
      case 2: try decoder.decodeSingularStringField(value: &self.actual)
      case 4: try decoder.decodeSingularFloatField(value: &self.value)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.predicted.isEmpty {
      try visitor.visitSingularStringField(value: self.predicted, fieldNumber: 1)
    }
    if !self.actual.isEmpty {
      try visitor.visitSingularStringField(value: self.actual, fieldNumber: 2)
    }
    if self.value != 0 {
      try visitor.visitSingularFloatField(value: self.value, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_ConfusionMatrixEntry, rhs: Clarifai_Api_ConfusionMatrixEntry) -> Bool {
    if lhs.predicted != rhs.predicted {return false}
    if lhs.actual != rhs.actual {return false}
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_ConfusionMatrix: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ConfusionMatrix"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "matrix"),
    2: .standard(proto: "concept_ids"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.matrix)
      case 2: try decoder.decodeRepeatedStringField(value: &self.conceptIds)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.matrix.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.matrix, fieldNumber: 1)
    }
    if !self.conceptIds.isEmpty {
      try visitor.visitRepeatedStringField(value: self.conceptIds, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_ConfusionMatrix, rhs: Clarifai_Api_ConfusionMatrix) -> Bool {
    if lhs.matrix != rhs.matrix {return false}
    if lhs.conceptIds != rhs.conceptIds {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_ROC: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ROC"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "fpr"),
    2: .same(proto: "tpr"),
    3: .same(proto: "thresholds"),
    4: .standard(proto: "fpr_per_image"),
    5: .standard(proto: "fpr_per_object"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedFloatField(value: &self.fpr)
      case 2: try decoder.decodeRepeatedFloatField(value: &self.tpr)
      case 3: try decoder.decodeRepeatedFloatField(value: &self.thresholds)
      case 4: try decoder.decodeRepeatedFloatField(value: &self.fprPerImage)
      case 5: try decoder.decodeRepeatedFloatField(value: &self.fprPerObject)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.fpr.isEmpty {
      try visitor.visitPackedFloatField(value: self.fpr, fieldNumber: 1)
    }
    if !self.tpr.isEmpty {
      try visitor.visitPackedFloatField(value: self.tpr, fieldNumber: 2)
    }
    if !self.thresholds.isEmpty {
      try visitor.visitPackedFloatField(value: self.thresholds, fieldNumber: 3)
    }
    if !self.fprPerImage.isEmpty {
      try visitor.visitPackedFloatField(value: self.fprPerImage, fieldNumber: 4)
    }
    if !self.fprPerObject.isEmpty {
      try visitor.visitPackedFloatField(value: self.fprPerObject, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_ROC, rhs: Clarifai_Api_ROC) -> Bool {
    if lhs.fpr != rhs.fpr {return false}
    if lhs.tpr != rhs.tpr {return false}
    if lhs.thresholds != rhs.thresholds {return false}
    if lhs.fprPerImage != rhs.fprPerImage {return false}
    if lhs.fprPerObject != rhs.fprPerObject {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_PrecisionRecallCurve: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PrecisionRecallCurve"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "recall"),
    2: .same(proto: "precision"),
    3: .same(proto: "thresholds"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedFloatField(value: &self.recall)
      case 2: try decoder.decodeRepeatedFloatField(value: &self.precision)
      case 3: try decoder.decodeRepeatedFloatField(value: &self.thresholds)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.recall.isEmpty {
      try visitor.visitPackedFloatField(value: self.recall, fieldNumber: 1)
    }
    if !self.precision.isEmpty {
      try visitor.visitPackedFloatField(value: self.precision, fieldNumber: 2)
    }
    if !self.thresholds.isEmpty {
      try visitor.visitPackedFloatField(value: self.thresholds, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_PrecisionRecallCurve, rhs: Clarifai_Api_PrecisionRecallCurve) -> Bool {
    if lhs.recall != rhs.recall {return false}
    if lhs.precision != rhs.precision {return false}
    if lhs.thresholds != rhs.thresholds {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_BinaryMetrics: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".BinaryMetrics"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "num_pos"),
    2: .standard(proto: "num_neg"),
    3: .standard(proto: "num_tot"),
    4: .standard(proto: "roc_auc"),
    5: .same(proto: "f1"),
    6: .same(proto: "concept"),
    7: .standard(proto: "roc_curve"),
    8: .standard(proto: "precision_recall_curve"),
    9: .standard(proto: "avg_precision"),
    10: .standard(proto: "area_name"),
    11: .standard(proto: "area_min"),
    12: .standard(proto: "area_max"),
    13: .same(proto: "iou"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularUInt32Field(value: &self.numPos)
      case 2: try decoder.decodeSingularUInt32Field(value: &self.numNeg)
      case 3: try decoder.decodeSingularUInt32Field(value: &self.numTot)
      case 4: try decoder.decodeSingularFloatField(value: &self.rocAuc)
      case 5: try decoder.decodeSingularFloatField(value: &self.f1)
      case 6: try decoder.decodeSingularMessageField(value: &self._concept)
      case 7: try decoder.decodeSingularMessageField(value: &self._rocCurve)
      case 8: try decoder.decodeSingularMessageField(value: &self._precisionRecallCurve)
      case 9: try decoder.decodeSingularFloatField(value: &self.avgPrecision)
      case 10: try decoder.decodeSingularStringField(value: &self.areaName)
      case 11: try decoder.decodeSingularDoubleField(value: &self.areaMin)
      case 12: try decoder.decodeSingularDoubleField(value: &self.areaMax)
      case 13: try decoder.decodeSingularFloatField(value: &self.iou)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.numPos != 0 {
      try visitor.visitSingularUInt32Field(value: self.numPos, fieldNumber: 1)
    }
    if self.numNeg != 0 {
      try visitor.visitSingularUInt32Field(value: self.numNeg, fieldNumber: 2)
    }
    if self.numTot != 0 {
      try visitor.visitSingularUInt32Field(value: self.numTot, fieldNumber: 3)
    }
    if self.rocAuc != 0 {
      try visitor.visitSingularFloatField(value: self.rocAuc, fieldNumber: 4)
    }
    if self.f1 != 0 {
      try visitor.visitSingularFloatField(value: self.f1, fieldNumber: 5)
    }
    if let v = self._concept {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }
    if let v = self._rocCurve {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }
    if let v = self._precisionRecallCurve {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    }
    if self.avgPrecision != 0 {
      try visitor.visitSingularFloatField(value: self.avgPrecision, fieldNumber: 9)
    }
    if !self.areaName.isEmpty {
      try visitor.visitSingularStringField(value: self.areaName, fieldNumber: 10)
    }
    if self.areaMin != 0 {
      try visitor.visitSingularDoubleField(value: self.areaMin, fieldNumber: 11)
    }
    if self.areaMax != 0 {
      try visitor.visitSingularDoubleField(value: self.areaMax, fieldNumber: 12)
    }
    if self.iou != 0 {
      try visitor.visitSingularFloatField(value: self.iou, fieldNumber: 13)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_BinaryMetrics, rhs: Clarifai_Api_BinaryMetrics) -> Bool {
    if lhs.numPos != rhs.numPos {return false}
    if lhs.numNeg != rhs.numNeg {return false}
    if lhs.numTot != rhs.numTot {return false}
    if lhs.rocAuc != rhs.rocAuc {return false}
    if lhs.f1 != rhs.f1 {return false}
    if lhs._concept != rhs._concept {return false}
    if lhs._rocCurve != rhs._rocCurve {return false}
    if lhs._precisionRecallCurve != rhs._precisionRecallCurve {return false}
    if lhs.avgPrecision != rhs.avgPrecision {return false}
    if lhs.areaName != rhs.areaName {return false}
    if lhs.areaMin != rhs.areaMin {return false}
    if lhs.areaMax != rhs.areaMax {return false}
    if lhs.iou != rhs.iou {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_EvalTestSetEntry: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".EvalTestSetEntry"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "url"),
    3: .standard(proto: "predicted_concepts"),
    4: .standard(proto: "ground_truth_concepts"),
    5: .same(proto: "annotation"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.id)
      case 2: try decoder.decodeSingularStringField(value: &self.url)
      case 3: try decoder.decodeRepeatedMessageField(value: &self.predictedConcepts)
      case 4: try decoder.decodeRepeatedMessageField(value: &self.groundTruthConcepts)
      case 5: try decoder.decodeSingularMessageField(value: &self._annotation)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if !self.url.isEmpty {
      try visitor.visitSingularStringField(value: self.url, fieldNumber: 2)
    }
    if !self.predictedConcepts.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.predictedConcepts, fieldNumber: 3)
    }
    if !self.groundTruthConcepts.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.groundTruthConcepts, fieldNumber: 4)
    }
    if let v = self._annotation {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_EvalTestSetEntry, rhs: Clarifai_Api_EvalTestSetEntry) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.url != rhs.url {return false}
    if lhs.predictedConcepts != rhs.predictedConcepts {return false}
    if lhs.groundTruthConcepts != rhs.groundTruthConcepts {return false}
    if lhs._annotation != rhs._annotation {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_LOPQEvalResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LOPQEvalResult"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "k"),
    2: .standard(proto: "recall_vs_brute_force"),
    3: .standard(proto: "kendall_tau_vs_brute_force"),
    4: .standard(proto: "most_frequent_code_percent"),
    5: .standard(proto: "lopq_ndcg"),
    6: .standard(proto: "brute_force_ndcg"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularInt32Field(value: &self.k)
      case 2: try decoder.decodeSingularFloatField(value: &self.recallVsBruteForce)
      case 3: try decoder.decodeSingularFloatField(value: &self.kendallTauVsBruteForce)
      case 4: try decoder.decodeSingularFloatField(value: &self.mostFrequentCodePercent)
      case 5: try decoder.decodeSingularFloatField(value: &self.lopqNdcg)
      case 6: try decoder.decodeSingularFloatField(value: &self.bruteForceNdcg)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.k != 0 {
      try visitor.visitSingularInt32Field(value: self.k, fieldNumber: 1)
    }
    if self.recallVsBruteForce != 0 {
      try visitor.visitSingularFloatField(value: self.recallVsBruteForce, fieldNumber: 2)
    }
    if self.kendallTauVsBruteForce != 0 {
      try visitor.visitSingularFloatField(value: self.kendallTauVsBruteForce, fieldNumber: 3)
    }
    if self.mostFrequentCodePercent != 0 {
      try visitor.visitSingularFloatField(value: self.mostFrequentCodePercent, fieldNumber: 4)
    }
    if self.lopqNdcg != 0 {
      try visitor.visitSingularFloatField(value: self.lopqNdcg, fieldNumber: 5)
    }
    if self.bruteForceNdcg != 0 {
      try visitor.visitSingularFloatField(value: self.bruteForceNdcg, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_LOPQEvalResult, rhs: Clarifai_Api_LOPQEvalResult) -> Bool {
    if lhs.k != rhs.k {return false}
    if lhs.recallVsBruteForce != rhs.recallVsBruteForce {return false}
    if lhs.kendallTauVsBruteForce != rhs.kendallTauVsBruteForce {return false}
    if lhs.mostFrequentCodePercent != rhs.mostFrequentCodePercent {return false}
    if lhs.lopqNdcg != rhs.lopqNdcg {return false}
    if lhs.bruteForceNdcg != rhs.bruteForceNdcg {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_MetricsSummary: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MetricsSummary"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "top1_accuracy"),
    2: .standard(proto: "top5_accuracy"),
    3: .standard(proto: "macro_avg_roc_auc"),
    4: .standard(proto: "macro_std_roc_auc"),
    5: .standard(proto: "macro_avg_f1_score"),
    6: .standard(proto: "macro_std_f1_score"),
    7: .standard(proto: "macro_avg_precision"),
    8: .standard(proto: "macro_avg_recall"),
    10: .standard(proto: "mean_avg_precision_iou_50"),
    11: .standard(proto: "mean_avg_precision_iou_range"),
    9: .standard(proto: "lopq_metrics"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularFloatField(value: &self.top1Accuracy)
      case 2: try decoder.decodeSingularFloatField(value: &self.top5Accuracy)
      case 3: try decoder.decodeSingularFloatField(value: &self.macroAvgRocAuc)
      case 4: try decoder.decodeSingularFloatField(value: &self.macroStdRocAuc)
      case 5: try decoder.decodeSingularFloatField(value: &self.macroAvgF1Score)
      case 6: try decoder.decodeSingularFloatField(value: &self.macroStdF1Score)
      case 7: try decoder.decodeSingularFloatField(value: &self.macroAvgPrecision)
      case 8: try decoder.decodeSingularFloatField(value: &self.macroAvgRecall)
      case 9: try decoder.decodeRepeatedMessageField(value: &self.lopqMetrics)
      case 10: try decoder.decodeSingularFloatField(value: &self.meanAvgPrecisionIou50)
      case 11: try decoder.decodeSingularFloatField(value: &self.meanAvgPrecisionIouRange)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.top1Accuracy != 0 {
      try visitor.visitSingularFloatField(value: self.top1Accuracy, fieldNumber: 1)
    }
    if self.top5Accuracy != 0 {
      try visitor.visitSingularFloatField(value: self.top5Accuracy, fieldNumber: 2)
    }
    if self.macroAvgRocAuc != 0 {
      try visitor.visitSingularFloatField(value: self.macroAvgRocAuc, fieldNumber: 3)
    }
    if self.macroStdRocAuc != 0 {
      try visitor.visitSingularFloatField(value: self.macroStdRocAuc, fieldNumber: 4)
    }
    if self.macroAvgF1Score != 0 {
      try visitor.visitSingularFloatField(value: self.macroAvgF1Score, fieldNumber: 5)
    }
    if self.macroStdF1Score != 0 {
      try visitor.visitSingularFloatField(value: self.macroStdF1Score, fieldNumber: 6)
    }
    if self.macroAvgPrecision != 0 {
      try visitor.visitSingularFloatField(value: self.macroAvgPrecision, fieldNumber: 7)
    }
    if self.macroAvgRecall != 0 {
      try visitor.visitSingularFloatField(value: self.macroAvgRecall, fieldNumber: 8)
    }
    if !self.lopqMetrics.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.lopqMetrics, fieldNumber: 9)
    }
    if self.meanAvgPrecisionIou50 != 0 {
      try visitor.visitSingularFloatField(value: self.meanAvgPrecisionIou50, fieldNumber: 10)
    }
    if self.meanAvgPrecisionIouRange != 0 {
      try visitor.visitSingularFloatField(value: self.meanAvgPrecisionIouRange, fieldNumber: 11)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_MetricsSummary, rhs: Clarifai_Api_MetricsSummary) -> Bool {
    if lhs.top1Accuracy != rhs.top1Accuracy {return false}
    if lhs.top5Accuracy != rhs.top5Accuracy {return false}
    if lhs.macroAvgRocAuc != rhs.macroAvgRocAuc {return false}
    if lhs.macroStdRocAuc != rhs.macroStdRocAuc {return false}
    if lhs.macroAvgF1Score != rhs.macroAvgF1Score {return false}
    if lhs.macroStdF1Score != rhs.macroStdF1Score {return false}
    if lhs.macroAvgPrecision != rhs.macroAvgPrecision {return false}
    if lhs.macroAvgRecall != rhs.macroAvgRecall {return false}
    if lhs.meanAvgPrecisionIou50 != rhs.meanAvgPrecisionIou50 {return false}
    if lhs.meanAvgPrecisionIouRange != rhs.meanAvgPrecisionIouRange {return false}
    if lhs.lopqMetrics != rhs.lopqMetrics {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_EvalMetrics: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".EvalMetrics"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
    10: .same(proto: "id"),
    2: .same(proto: "summary"),
    3: .standard(proto: "confusion_matrix"),
    4: .standard(proto: "cooccurrence_matrix"),
    5: .standard(proto: "label_counts"),
    6: .standard(proto: "binary_metrics"),
    7: .standard(proto: "test_set"),
    8: .standard(proto: "metrics_by_area"),
    9: .standard(proto: "metrics_by_class"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._status)
      case 2: try decoder.decodeSingularMessageField(value: &self._summary)
      case 3: try decoder.decodeSingularMessageField(value: &self._confusionMatrix)
      case 4: try decoder.decodeSingularMessageField(value: &self._cooccurrenceMatrix)
      case 5: try decoder.decodeSingularMessageField(value: &self._labelCounts)
      case 6: try decoder.decodeRepeatedMessageField(value: &self.binaryMetrics)
      case 7: try decoder.decodeRepeatedMessageField(value: &self.testSet)
      case 8: try decoder.decodeRepeatedMessageField(value: &self.metricsByArea)
      case 9: try decoder.decodeRepeatedMessageField(value: &self.metricsByClass)
      case 10: try decoder.decodeSingularStringField(value: &self.id)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._status {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._summary {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if let v = self._confusionMatrix {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    if let v = self._cooccurrenceMatrix {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }
    if let v = self._labelCounts {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }
    if !self.binaryMetrics.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.binaryMetrics, fieldNumber: 6)
    }
    if !self.testSet.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.testSet, fieldNumber: 7)
    }
    if !self.metricsByArea.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.metricsByArea, fieldNumber: 8)
    }
    if !self.metricsByClass.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.metricsByClass, fieldNumber: 9)
    }
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 10)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_EvalMetrics, rhs: Clarifai_Api_EvalMetrics) -> Bool {
    if lhs._status != rhs._status {return false}
    if lhs.id != rhs.id {return false}
    if lhs._summary != rhs._summary {return false}
    if lhs._confusionMatrix != rhs._confusionMatrix {return false}
    if lhs._cooccurrenceMatrix != rhs._cooccurrenceMatrix {return false}
    if lhs._labelCounts != rhs._labelCounts {return false}
    if lhs.binaryMetrics != rhs.binaryMetrics {return false}
    if lhs.testSet != rhs.testSet {return false}
    if lhs.metricsByArea != rhs.metricsByArea {return false}
    if lhs.metricsByClass != rhs.metricsByClass {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_FieldsValue: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".FieldsValue"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "confusion_matrix"),
    2: .standard(proto: "cooccurrence_matrix"),
    3: .standard(proto: "label_counts"),
    4: .standard(proto: "binary_metrics"),
    5: .standard(proto: "test_set"),
    6: .standard(proto: "metrics_by_area"),
    7: .standard(proto: "metrics_by_class"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBoolField(value: &self.confusionMatrix)
      case 2: try decoder.decodeSingularBoolField(value: &self.cooccurrenceMatrix)
      case 3: try decoder.decodeSingularBoolField(value: &self.labelCounts)
      case 4: try decoder.decodeSingularBoolField(value: &self.binaryMetrics)
      case 5: try decoder.decodeSingularBoolField(value: &self.testSet)
      case 6: try decoder.decodeSingularBoolField(value: &self.metricsByArea)
      case 7: try decoder.decodeSingularBoolField(value: &self.metricsByClass)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.confusionMatrix != false {
      try visitor.visitSingularBoolField(value: self.confusionMatrix, fieldNumber: 1)
    }
    if self.cooccurrenceMatrix != false {
      try visitor.visitSingularBoolField(value: self.cooccurrenceMatrix, fieldNumber: 2)
    }
    if self.labelCounts != false {
      try visitor.visitSingularBoolField(value: self.labelCounts, fieldNumber: 3)
    }
    if self.binaryMetrics != false {
      try visitor.visitSingularBoolField(value: self.binaryMetrics, fieldNumber: 4)
    }
    if self.testSet != false {
      try visitor.visitSingularBoolField(value: self.testSet, fieldNumber: 5)
    }
    if self.metricsByArea != false {
      try visitor.visitSingularBoolField(value: self.metricsByArea, fieldNumber: 6)
    }
    if self.metricsByClass != false {
      try visitor.visitSingularBoolField(value: self.metricsByClass, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_FieldsValue, rhs: Clarifai_Api_FieldsValue) -> Bool {
    if lhs.confusionMatrix != rhs.confusionMatrix {return false}
    if lhs.cooccurrenceMatrix != rhs.cooccurrenceMatrix {return false}
    if lhs.labelCounts != rhs.labelCounts {return false}
    if lhs.binaryMetrics != rhs.binaryMetrics {return false}
    if lhs.testSet != rhs.testSet {return false}
    if lhs.metricsByArea != rhs.metricsByArea {return false}
    if lhs.metricsByClass != rhs.metricsByClass {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_Output: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Output"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "status"),
    3: .standard(proto: "created_at"),
    4: .same(proto: "model"),
    5: .same(proto: "input"),
    6: .same(proto: "data"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.id)
      case 2: try decoder.decodeSingularMessageField(value: &self._status)
      case 3: try decoder.decodeSingularMessageField(value: &self._createdAt)
      case 4: try decoder.decodeSingularMessageField(value: &self._model)
      case 5: try decoder.decodeSingularMessageField(value: &self._input)
      case 6: try decoder.decodeSingularMessageField(value: &self._data)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if let v = self._status {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if let v = self._createdAt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    if let v = self._model {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }
    if let v = self._input {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }
    if let v = self._data {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_Output, rhs: Clarifai_Api_Output) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs._status != rhs._status {return false}
    if lhs._createdAt != rhs._createdAt {return false}
    if lhs._model != rhs._model {return false}
    if lhs._input != rhs._input {return false}
    if lhs._data != rhs._data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_ScopeDeps: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ScopeDeps"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "scope"),
    2: .standard(proto: "depending_scopes"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.scope)
      case 2: try decoder.decodeRepeatedStringField(value: &self.dependingScopes)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.scope.isEmpty {
      try visitor.visitSingularStringField(value: self.scope, fieldNumber: 1)
    }
    if !self.dependingScopes.isEmpty {
      try visitor.visitRepeatedStringField(value: self.dependingScopes, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_ScopeDeps, rhs: Clarifai_Api_ScopeDeps) -> Bool {
    if lhs.scope != rhs.scope {return false}
    if lhs.dependingScopes != rhs.dependingScopes {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_EndpointDeps: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".EndpointDeps"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "endpoint"),
    2: .standard(proto: "depending_scopes"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.endpoint)
      case 2: try decoder.decodeRepeatedStringField(value: &self.dependingScopes)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.endpoint.isEmpty {
      try visitor.visitSingularStringField(value: self.endpoint, fieldNumber: 1)
    }
    if !self.dependingScopes.isEmpty {
      try visitor.visitRepeatedStringField(value: self.dependingScopes, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_EndpointDeps, rhs: Clarifai_Api_EndpointDeps) -> Bool {
    if lhs.endpoint != rhs.endpoint {return false}
    if lhs.dependingScopes != rhs.dependingScopes {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_Hit: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Hit"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "score"),
    2: .same(proto: "input"),
    3: .same(proto: "annotation"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularFloatField(value: &self.score)
      case 2: try decoder.decodeSingularMessageField(value: &self._input)
      case 3: try decoder.decodeSingularMessageField(value: &self._annotation)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.score != 0 {
      try visitor.visitSingularFloatField(value: self.score, fieldNumber: 1)
    }
    if let v = self._input {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if let v = self._annotation {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_Hit, rhs: Clarifai_Api_Hit) -> Bool {
    if lhs.score != rhs.score {return false}
    if lhs._input != rhs._input {return false}
    if lhs._annotation != rhs._annotation {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_And: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".And"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "input"),
    2: .same(proto: "output"),
    3: .same(proto: "negate"),
    4: .same(proto: "annotation"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._input)
      case 2: try decoder.decodeSingularMessageField(value: &self._output)
      case 3: try decoder.decodeSingularBoolField(value: &self.negate)
      case 4: try decoder.decodeSingularMessageField(value: &self._annotation)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._input {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._output {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if self.negate != false {
      try visitor.visitSingularBoolField(value: self.negate, fieldNumber: 3)
    }
    if let v = self._annotation {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_And, rhs: Clarifai_Api_And) -> Bool {
    if lhs._input != rhs._input {return false}
    if lhs._output != rhs._output {return false}
    if lhs.negate != rhs.negate {return false}
    if lhs._annotation != rhs._annotation {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_Query: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Query"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ands"),
    2: .same(proto: "language"),
    3: .same(proto: "filters"),
    4: .same(proto: "ranks"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.ands)
      case 2: try decoder.decodeSingularStringField(value: &self.language)
      case 3: try decoder.decodeRepeatedMessageField(value: &self.filters)
      case 4: try decoder.decodeRepeatedMessageField(value: &self.ranks)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.ands.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.ands, fieldNumber: 1)
    }
    if !self.language.isEmpty {
      try visitor.visitSingularStringField(value: self.language, fieldNumber: 2)
    }
    if !self.filters.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.filters, fieldNumber: 3)
    }
    if !self.ranks.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.ranks, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_Query, rhs: Clarifai_Api_Query) -> Bool {
    if lhs.ands != rhs.ands {return false}
    if lhs.language != rhs.language {return false}
    if lhs.filters != rhs.filters {return false}
    if lhs.ranks != rhs.ranks {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_Search: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Search"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "query"),
    2: .same(proto: "id"),
    3: .standard(proto: "application_id"),
    4: .same(proto: "name"),
    5: .standard(proto: "as_of"),
    6: .standard(proto: "git_hash"),
    7: .standard(proto: "created_at"),
    8: .standard(proto: "modified_at"),
    9: .same(proto: "algorithm"),
    10: .same(proto: "save"),
    11: .standard(proto: "min_value"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._query)
      case 2: try decoder.decodeSingularStringField(value: &self.id)
      case 3: try decoder.decodeSingularStringField(value: &self.applicationID)
      case 4: try decoder.decodeSingularStringField(value: &self.name)
      case 5: try decoder.decodeSingularMessageField(value: &self._asOf)
      case 6: try decoder.decodeSingularStringField(value: &self.gitHash)
      case 7: try decoder.decodeSingularMessageField(value: &self._createdAt)
      case 8: try decoder.decodeSingularMessageField(value: &self._modifiedAt)
      case 9: try decoder.decodeSingularStringField(value: &self.algorithm)
      case 10: try decoder.decodeSingularBoolField(value: &self.save)
      case 11: try decoder.decodeSingularFloatField(value: &self.minValue)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._query {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 2)
    }
    if !self.applicationID.isEmpty {
      try visitor.visitSingularStringField(value: self.applicationID, fieldNumber: 3)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 4)
    }
    if let v = self._asOf {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }
    if !self.gitHash.isEmpty {
      try visitor.visitSingularStringField(value: self.gitHash, fieldNumber: 6)
    }
    if let v = self._createdAt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }
    if let v = self._modifiedAt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    }
    if !self.algorithm.isEmpty {
      try visitor.visitSingularStringField(value: self.algorithm, fieldNumber: 9)
    }
    if self.save != false {
      try visitor.visitSingularBoolField(value: self.save, fieldNumber: 10)
    }
    if self.minValue != 0 {
      try visitor.visitSingularFloatField(value: self.minValue, fieldNumber: 11)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_Search, rhs: Clarifai_Api_Search) -> Bool {
    if lhs._query != rhs._query {return false}
    if lhs.id != rhs.id {return false}
    if lhs.applicationID != rhs.applicationID {return false}
    if lhs.name != rhs.name {return false}
    if lhs._asOf != rhs._asOf {return false}
    if lhs.gitHash != rhs.gitHash {return false}
    if lhs._createdAt != rhs._createdAt {return false}
    if lhs._modifiedAt != rhs._modifiedAt {return false}
    if lhs.algorithm != rhs.algorithm {return false}
    if lhs.save != rhs.save {return false}
    if lhs.minValue != rhs.minValue {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_Filter: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Filter"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    3: .same(proto: "negate"),
    4: .same(proto: "annotation"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 3: try decoder.decodeSingularBoolField(value: &self.negate)
      case 4: try decoder.decodeSingularMessageField(value: &self._annotation)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.negate != false {
      try visitor.visitSingularBoolField(value: self.negate, fieldNumber: 3)
    }
    if let v = self._annotation {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_Filter, rhs: Clarifai_Api_Filter) -> Bool {
    if lhs.negate != rhs.negate {return false}
    if lhs._annotation != rhs._annotation {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_Rank: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Rank"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    3: .same(proto: "negate"),
    4: .same(proto: "annotation"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 3: try decoder.decodeSingularBoolField(value: &self.negate)
      case 4: try decoder.decodeSingularMessageField(value: &self._annotation)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.negate != false {
      try visitor.visitSingularBoolField(value: self.negate, fieldNumber: 3)
    }
    if let v = self._annotation {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_Rank, rhs: Clarifai_Api_Rank) -> Bool {
    if lhs.negate != rhs.negate {return false}
    if lhs._annotation != rhs._annotation {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_AnnotationSearchMetrics: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AnnotationSearchMetrics"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "ground_truth"),
    2: .standard(proto: "search_to_eval"),
    3: .same(proto: "metrics"),
    4: .same(proto: "data"),
    5: .standard(proto: "active_concept_count"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._groundTruth)
      case 2: try decoder.decodeSingularMessageField(value: &self._searchToEval)
      case 3: try decoder.decodeSingularMessageField(value: &self._metrics)
      case 4: try decoder.decodeSingularMessageField(value: &self._data)
      case 5: try decoder.decodeSingularUInt32Field(value: &self.activeConceptCount)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._groundTruth {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._searchToEval {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if let v = self._metrics {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    if let v = self._data {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }
    if self.activeConceptCount != 0 {
      try visitor.visitSingularUInt32Field(value: self.activeConceptCount, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_AnnotationSearchMetrics, rhs: Clarifai_Api_AnnotationSearchMetrics) -> Bool {
    if lhs._groundTruth != rhs._groundTruth {return false}
    if lhs._searchToEval != rhs._searchToEval {return false}
    if lhs._metrics != rhs._metrics {return false}
    if lhs._data != rhs._data {return false}
    if lhs.activeConceptCount != rhs.activeConceptCount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_Text: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Text"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "raw"),
    2: .same(proto: "url"),
    3: .standard(proto: "allow_duplicate_url"),
    4: .same(proto: "hosted"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.raw)
      case 2: try decoder.decodeSingularStringField(value: &self.url)
      case 3: try decoder.decodeSingularBoolField(value: &self.allowDuplicateURL)
      case 4: try decoder.decodeSingularMessageField(value: &self._hosted)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.raw.isEmpty {
      try visitor.visitSingularStringField(value: self.raw, fieldNumber: 1)
    }
    if !self.url.isEmpty {
      try visitor.visitSingularStringField(value: self.url, fieldNumber: 2)
    }
    if self.allowDuplicateURL != false {
      try visitor.visitSingularBoolField(value: self.allowDuplicateURL, fieldNumber: 3)
    }
    if let v = self._hosted {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_Text, rhs: Clarifai_Api_Text) -> Bool {
    if lhs.raw != rhs.raw {return false}
    if lhs.url != rhs.url {return false}
    if lhs.allowDuplicateURL != rhs.allowDuplicateURL {return false}
    if lhs._hosted != rhs._hosted {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_User: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".User"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .standard(proto: "primary_email"),
    3: .standard(proto: "first_name"),
    4: .standard(proto: "last_name"),
    5: .standard(proto: "company_name"),
    7: .standard(proto: "bill_type"),
    6: .standard(proto: "created_at"),
    8: .standard(proto: "date_gdpr_consent"),
    9: .standard(proto: "date_tos_consent"),
    10: .standard(proto: "date_marketing_consent"),
    11: .same(proto: "metadata"),
    12: .standard(proto: "email_addresses"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.id)
      case 2: try decoder.decodeSingularStringField(value: &self.primaryEmail)
      case 3: try decoder.decodeSingularStringField(value: &self.firstName)
      case 4: try decoder.decodeSingularStringField(value: &self.lastName)
      case 5: try decoder.decodeSingularStringField(value: &self.companyName)
      case 6: try decoder.decodeSingularMessageField(value: &self._createdAt)
      case 7: try decoder.decodeSingularStringField(value: &self.billType)
      case 8: try decoder.decodeSingularMessageField(value: &self._dateGdprConsent)
      case 9: try decoder.decodeSingularMessageField(value: &self._dateTosConsent)
      case 10: try decoder.decodeSingularMessageField(value: &self._dateMarketingConsent)
      case 11: try decoder.decodeSingularMessageField(value: &self._metadata)
      case 12: try decoder.decodeRepeatedMessageField(value: &self.emailAddresses)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if !self.primaryEmail.isEmpty {
      try visitor.visitSingularStringField(value: self.primaryEmail, fieldNumber: 2)
    }
    if !self.firstName.isEmpty {
      try visitor.visitSingularStringField(value: self.firstName, fieldNumber: 3)
    }
    if !self.lastName.isEmpty {
      try visitor.visitSingularStringField(value: self.lastName, fieldNumber: 4)
    }
    if !self.companyName.isEmpty {
      try visitor.visitSingularStringField(value: self.companyName, fieldNumber: 5)
    }
    if let v = self._createdAt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }
    if !self.billType.isEmpty {
      try visitor.visitSingularStringField(value: self.billType, fieldNumber: 7)
    }
    if let v = self._dateGdprConsent {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    }
    if let v = self._dateTosConsent {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    }
    if let v = self._dateMarketingConsent {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
    }
    if let v = self._metadata {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
    }
    if !self.emailAddresses.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.emailAddresses, fieldNumber: 12)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_User, rhs: Clarifai_Api_User) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.primaryEmail != rhs.primaryEmail {return false}
    if lhs.firstName != rhs.firstName {return false}
    if lhs.lastName != rhs.lastName {return false}
    if lhs.companyName != rhs.companyName {return false}
    if lhs.billType != rhs.billType {return false}
    if lhs._createdAt != rhs._createdAt {return false}
    if lhs._dateGdprConsent != rhs._dateGdprConsent {return false}
    if lhs._dateTosConsent != rhs._dateTosConsent {return false}
    if lhs._dateMarketingConsent != rhs._dateMarketingConsent {return false}
    if lhs._metadata != rhs._metadata {return false}
    if lhs.emailAddresses != rhs.emailAddresses {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_EmailAddress: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".EmailAddress"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "email"),
    2: .same(proto: "primary"),
    3: .same(proto: "verified"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.email)
      case 2: try decoder.decodeSingularBoolField(value: &self.primary)
      case 3: try decoder.decodeSingularBoolField(value: &self.verified)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.email.isEmpty {
      try visitor.visitSingularStringField(value: self.email, fieldNumber: 1)
    }
    if self.primary != false {
      try visitor.visitSingularBoolField(value: self.primary, fieldNumber: 2)
    }
    if self.verified != false {
      try visitor.visitSingularBoolField(value: self.verified, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_EmailAddress, rhs: Clarifai_Api_EmailAddress) -> Bool {
    if lhs.email != rhs.email {return false}
    if lhs.primary != rhs.primary {return false}
    if lhs.verified != rhs.verified {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_Password: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Password"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "plaintext"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.plaintext)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.plaintext.isEmpty {
      try visitor.visitSingularStringField(value: self.plaintext, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_Password, rhs: Clarifai_Api_Password) -> Bool {
    if lhs.plaintext != rhs.plaintext {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_PasswordViolations: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PasswordViolations"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "minimum_length"),
    2: .standard(proto: "maximum_length"),
    3: .standard(proto: "upper_case_needed"),
    4: .standard(proto: "lower_case_needed"),
    5: .standard(proto: "numeric_needed"),
    6: .standard(proto: "non_alphanumeric_needed"),
    7: .standard(proto: "password_reuse"),
    8: .standard(proto: "exclude_names"),
    9: .standard(proto: "exclude_email"),
    10: .standard(proto: "no_confusing_letters"),
    11: .standard(proto: "no_simple_passwords"),
    12: .standard(proto: "no_common_vocabs"),
    13: .standard(proto: "no_overlap_with_old"),
    14: .standard(proto: "password_lifespan"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBoolField(value: &self.minimumLength)
      case 2: try decoder.decodeSingularBoolField(value: &self.maximumLength)
      case 3: try decoder.decodeSingularBoolField(value: &self.upperCaseNeeded)
      case 4: try decoder.decodeSingularBoolField(value: &self.lowerCaseNeeded)
      case 5: try decoder.decodeSingularBoolField(value: &self.numericNeeded)
      case 6: try decoder.decodeSingularBoolField(value: &self.nonAlphanumericNeeded)
      case 7: try decoder.decodeSingularBoolField(value: &self.passwordReuse)
      case 8: try decoder.decodeSingularBoolField(value: &self.excludeNames)
      case 9: try decoder.decodeSingularBoolField(value: &self.excludeEmail)
      case 10: try decoder.decodeSingularBoolField(value: &self.noConfusingLetters)
      case 11: try decoder.decodeSingularBoolField(value: &self.noSimplePasswords)
      case 12: try decoder.decodeSingularBoolField(value: &self.noCommonVocabs)
      case 13: try decoder.decodeSingularBoolField(value: &self.noOverlapWithOld)
      case 14: try decoder.decodeSingularBoolField(value: &self.passwordLifespan)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.minimumLength != false {
      try visitor.visitSingularBoolField(value: self.minimumLength, fieldNumber: 1)
    }
    if self.maximumLength != false {
      try visitor.visitSingularBoolField(value: self.maximumLength, fieldNumber: 2)
    }
    if self.upperCaseNeeded != false {
      try visitor.visitSingularBoolField(value: self.upperCaseNeeded, fieldNumber: 3)
    }
    if self.lowerCaseNeeded != false {
      try visitor.visitSingularBoolField(value: self.lowerCaseNeeded, fieldNumber: 4)
    }
    if self.numericNeeded != false {
      try visitor.visitSingularBoolField(value: self.numericNeeded, fieldNumber: 5)
    }
    if self.nonAlphanumericNeeded != false {
      try visitor.visitSingularBoolField(value: self.nonAlphanumericNeeded, fieldNumber: 6)
    }
    if self.passwordReuse != false {
      try visitor.visitSingularBoolField(value: self.passwordReuse, fieldNumber: 7)
    }
    if self.excludeNames != false {
      try visitor.visitSingularBoolField(value: self.excludeNames, fieldNumber: 8)
    }
    if self.excludeEmail != false {
      try visitor.visitSingularBoolField(value: self.excludeEmail, fieldNumber: 9)
    }
    if self.noConfusingLetters != false {
      try visitor.visitSingularBoolField(value: self.noConfusingLetters, fieldNumber: 10)
    }
    if self.noSimplePasswords != false {
      try visitor.visitSingularBoolField(value: self.noSimplePasswords, fieldNumber: 11)
    }
    if self.noCommonVocabs != false {
      try visitor.visitSingularBoolField(value: self.noCommonVocabs, fieldNumber: 12)
    }
    if self.noOverlapWithOld != false {
      try visitor.visitSingularBoolField(value: self.noOverlapWithOld, fieldNumber: 13)
    }
    if self.passwordLifespan != false {
      try visitor.visitSingularBoolField(value: self.passwordLifespan, fieldNumber: 14)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_PasswordViolations, rhs: Clarifai_Api_PasswordViolations) -> Bool {
    if lhs.minimumLength != rhs.minimumLength {return false}
    if lhs.maximumLength != rhs.maximumLength {return false}
    if lhs.upperCaseNeeded != rhs.upperCaseNeeded {return false}
    if lhs.lowerCaseNeeded != rhs.lowerCaseNeeded {return false}
    if lhs.numericNeeded != rhs.numericNeeded {return false}
    if lhs.nonAlphanumericNeeded != rhs.nonAlphanumericNeeded {return false}
    if lhs.passwordReuse != rhs.passwordReuse {return false}
    if lhs.excludeNames != rhs.excludeNames {return false}
    if lhs.excludeEmail != rhs.excludeEmail {return false}
    if lhs.noConfusingLetters != rhs.noConfusingLetters {return false}
    if lhs.noSimplePasswords != rhs.noSimplePasswords {return false}
    if lhs.noCommonVocabs != rhs.noCommonVocabs {return false}
    if lhs.noOverlapWithOld != rhs.noOverlapWithOld {return false}
    if lhs.passwordLifespan != rhs.passwordLifespan {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_Video: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Video"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "url"),
    2: .same(proto: "base64"),
    4: .standard(proto: "allow_duplicate_url"),
    5: .standard(proto: "thumbnail_url"),
    6: .same(proto: "hosted"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.url)
      case 2: try decoder.decodeSingularBytesField(value: &self.base64)
      case 4: try decoder.decodeSingularBoolField(value: &self.allowDuplicateURL)
      case 5: try decoder.decodeSingularStringField(value: &self.thumbnailURL)
      case 6: try decoder.decodeSingularMessageField(value: &self._hosted)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.url.isEmpty {
      try visitor.visitSingularStringField(value: self.url, fieldNumber: 1)
    }
    if !self.base64.isEmpty {
      try visitor.visitSingularBytesField(value: self.base64, fieldNumber: 2)
    }
    if self.allowDuplicateURL != false {
      try visitor.visitSingularBoolField(value: self.allowDuplicateURL, fieldNumber: 4)
    }
    if !self.thumbnailURL.isEmpty {
      try visitor.visitSingularStringField(value: self.thumbnailURL, fieldNumber: 5)
    }
    if let v = self._hosted {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_Video, rhs: Clarifai_Api_Video) -> Bool {
    if lhs.url != rhs.url {return false}
    if lhs.base64 != rhs.base64 {return false}
    if lhs.allowDuplicateURL != rhs.allowDuplicateURL {return false}
    if lhs.thumbnailURL != rhs.thumbnailURL {return false}
    if lhs._hosted != rhs._hosted {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_Workflow: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Workflow"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .standard(proto: "app_id"),
    3: .standard(proto: "created_at"),
    4: .same(proto: "nodes"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.id)
      case 2: try decoder.decodeSingularStringField(value: &self.appID)
      case 3: try decoder.decodeSingularMessageField(value: &self._createdAt)
      case 4: try decoder.decodeRepeatedMessageField(value: &self.nodes)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if !self.appID.isEmpty {
      try visitor.visitSingularStringField(value: self.appID, fieldNumber: 2)
    }
    if let v = self._createdAt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    if !self.nodes.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.nodes, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_Workflow, rhs: Clarifai_Api_Workflow) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.appID != rhs.appID {return false}
    if lhs._createdAt != rhs._createdAt {return false}
    if lhs.nodes != rhs.nodes {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_WorkflowNode: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".WorkflowNode"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "model"),
    3: .standard(proto: "node_inputs"),
    4: .standard(proto: "suppress_output"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.id)
      case 2: try decoder.decodeSingularMessageField(value: &self._model)
      case 3: try decoder.decodeRepeatedMessageField(value: &self.nodeInputs)
      case 4: try decoder.decodeSingularBoolField(value: &self.suppressOutput)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if let v = self._model {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if !self.nodeInputs.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.nodeInputs, fieldNumber: 3)
    }
    if self.suppressOutput != false {
      try visitor.visitSingularBoolField(value: self.suppressOutput, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_WorkflowNode, rhs: Clarifai_Api_WorkflowNode) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs._model != rhs._model {return false}
    if lhs.nodeInputs != rhs.nodeInputs {return false}
    if lhs.suppressOutput != rhs.suppressOutput {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_NodeInput: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".NodeInput"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "node_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.nodeID)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.nodeID.isEmpty {
      try visitor.visitSingularStringField(value: self.nodeID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_NodeInput, rhs: Clarifai_Api_NodeInput) -> Bool {
    if lhs.nodeID != rhs.nodeID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_WorkflowResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".WorkflowResult"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "status"),
    3: .standard(proto: "created_at"),
    4: .same(proto: "model"),
    5: .same(proto: "input"),
    6: .same(proto: "outputs"),
    7: .standard(proto: "suppress_output"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.id)
      case 2: try decoder.decodeSingularMessageField(value: &self._status)
      case 3: try decoder.decodeSingularMessageField(value: &self._createdAt)
      case 4: try decoder.decodeSingularMessageField(value: &self._model)
      case 5: try decoder.decodeSingularMessageField(value: &self._input)
      case 6: try decoder.decodeRepeatedMessageField(value: &self.outputs)
      case 7: try decoder.decodeSingularBoolField(value: &self.suppressOutput)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if let v = self._status {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if let v = self._createdAt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    if let v = self._model {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }
    if let v = self._input {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }
    if !self.outputs.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.outputs, fieldNumber: 6)
    }
    if self.suppressOutput != false {
      try visitor.visitSingularBoolField(value: self.suppressOutput, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_WorkflowResult, rhs: Clarifai_Api_WorkflowResult) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs._status != rhs._status {return false}
    if lhs._createdAt != rhs._createdAt {return false}
    if lhs._model != rhs._model {return false}
    if lhs._input != rhs._input {return false}
    if lhs.outputs != rhs.outputs {return false}
    if lhs.suppressOutput != rhs.suppressOutput {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_AppDuplication: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AppDuplication"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .standard(proto: "new_app_id"),
    3: .standard(proto: "new_app_name"),
    4: .same(proto: "status"),
    5: .standard(proto: "created_at"),
    6: .standard(proto: "last_modified_at"),
    7: .same(proto: "filter"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.id)
      case 2: try decoder.decodeSingularStringField(value: &self.newAppID)
      case 3: try decoder.decodeSingularStringField(value: &self.newAppName)
      case 4: try decoder.decodeSingularMessageField(value: &self._status)
      case 5: try decoder.decodeSingularMessageField(value: &self._createdAt)
      case 6: try decoder.decodeSingularMessageField(value: &self._lastModifiedAt)
      case 7: try decoder.decodeSingularMessageField(value: &self._filter)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if !self.newAppID.isEmpty {
      try visitor.visitSingularStringField(value: self.newAppID, fieldNumber: 2)
    }
    if !self.newAppName.isEmpty {
      try visitor.visitSingularStringField(value: self.newAppName, fieldNumber: 3)
    }
    if let v = self._status {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }
    if let v = self._createdAt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }
    if let v = self._lastModifiedAt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }
    if let v = self._filter {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_AppDuplication, rhs: Clarifai_Api_AppDuplication) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.newAppID != rhs.newAppID {return false}
    if lhs.newAppName != rhs.newAppName {return false}
    if lhs._status != rhs._status {return false}
    if lhs._createdAt != rhs._createdAt {return false}
    if lhs._lastModifiedAt != rhs._lastModifiedAt {return false}
    if lhs._filter != rhs._filter {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_AppDuplicationFilters: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AppDuplicationFilters"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "copy_inputs"),
    2: .standard(proto: "copy_concepts"),
    3: .standard(proto: "copy_annotations"),
    4: .standard(proto: "copy_models"),
    5: .standard(proto: "copy_workflows"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBoolField(value: &self.copyInputs)
      case 2: try decoder.decodeSingularBoolField(value: &self.copyConcepts)
      case 3: try decoder.decodeSingularBoolField(value: &self.copyAnnotations)
      case 4: try decoder.decodeSingularBoolField(value: &self.copyModels)
      case 5: try decoder.decodeSingularBoolField(value: &self.copyWorkflows)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.copyInputs != false {
      try visitor.visitSingularBoolField(value: self.copyInputs, fieldNumber: 1)
    }
    if self.copyConcepts != false {
      try visitor.visitSingularBoolField(value: self.copyConcepts, fieldNumber: 2)
    }
    if self.copyAnnotations != false {
      try visitor.visitSingularBoolField(value: self.copyAnnotations, fieldNumber: 3)
    }
    if self.copyModels != false {
      try visitor.visitSingularBoolField(value: self.copyModels, fieldNumber: 4)
    }
    if self.copyWorkflows != false {
      try visitor.visitSingularBoolField(value: self.copyWorkflows, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_AppDuplicationFilters, rhs: Clarifai_Api_AppDuplicationFilters) -> Bool {
    if lhs.copyInputs != rhs.copyInputs {return false}
    if lhs.copyConcepts != rhs.copyConcepts {return false}
    if lhs.copyAnnotations != rhs.copyAnnotations {return false}
    if lhs.copyModels != rhs.copyModels {return false}
    if lhs.copyWorkflows != rhs.copyWorkflows {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_Task: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Task"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .standard(proto: "created_at"),
    3: .standard(proto: "modified_at"),
    4: .same(proto: "type"),
    5: .same(proto: "description"),
    6: .same(proto: "worker"),
    7: .standard(proto: "concept_ids"),
    8: .standard(proto: "input_source"),
    9: .standard(proto: "sample_ms"),
    10: .standard(proto: "ai_assistant"),
    11: .same(proto: "review"),
    12: .same(proto: "status"),
    13: .same(proto: "name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.id)
      case 2: try decoder.decodeSingularMessageField(value: &self._createdAt)
      case 3: try decoder.decodeSingularMessageField(value: &self._modifiedAt)
      case 4: try decoder.decodeSingularEnumField(value: &self.type)
      case 5: try decoder.decodeSingularStringField(value: &self.description_p)
      case 6: try decoder.decodeSingularMessageField(value: &self._worker)
      case 7: try decoder.decodeRepeatedStringField(value: &self.conceptIds)
      case 8: try decoder.decodeSingularMessageField(value: &self._inputSource)
      case 9: try decoder.decodeSingularUInt32Field(value: &self.sampleMs)
      case 10: try decoder.decodeSingularMessageField(value: &self._aiAssistant)
      case 11: try decoder.decodeSingularMessageField(value: &self._review)
      case 12: try decoder.decodeSingularMessageField(value: &self._status)
      case 13: try decoder.decodeSingularStringField(value: &self.name)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if let v = self._createdAt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if let v = self._modifiedAt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    if self.type != .typeNotSet {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 4)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 5)
    }
    if let v = self._worker {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }
    if !self.conceptIds.isEmpty {
      try visitor.visitRepeatedStringField(value: self.conceptIds, fieldNumber: 7)
    }
    if let v = self._inputSource {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    }
    if self.sampleMs != 0 {
      try visitor.visitSingularUInt32Field(value: self.sampleMs, fieldNumber: 9)
    }
    if let v = self._aiAssistant {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
    }
    if let v = self._review {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
    }
    if let v = self._status {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 13)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_Task, rhs: Clarifai_Api_Task) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs._createdAt != rhs._createdAt {return false}
    if lhs._modifiedAt != rhs._modifiedAt {return false}
    if lhs.type != rhs.type {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs._worker != rhs._worker {return false}
    if lhs.conceptIds != rhs.conceptIds {return false}
    if lhs._inputSource != rhs._inputSource {return false}
    if lhs.sampleMs != rhs.sampleMs {return false}
    if lhs._aiAssistant != rhs._aiAssistant {return false}
    if lhs._review != rhs._review {return false}
    if lhs._status != rhs._status {return false}
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_Task.TaskType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "TYPE_NOT_SET"),
    1: .same(proto: "CONCEPTS_CLASSIFICATION"),
    2: .same(proto: "BOUNDING_BOX_DETECTION"),
    3: .same(proto: "POLYGON_DETECTION"),
  ]
}

extension Clarifai_Api_TaskWorker: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TaskWorker"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "strategy"),
    2: .standard(proto: "user_ids"),
    3: .standard(proto: "partitioned_strategy_info"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularEnumField(value: &self.strategy)
      case 2: try decoder.decodeRepeatedStringField(value: &self.userIds)
      case 3:
        var v: Clarifai_Api_TaskWorkerPartitionedStrategyInfo?
        if let current = self.strategyInfo {
          try decoder.handleConflictingOneOf()
          if case .partitionedStrategyInfo(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.strategyInfo = .partitionedStrategyInfo(v)}
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.strategy != .workerStrategyNotSet {
      try visitor.visitSingularEnumField(value: self.strategy, fieldNumber: 1)
    }
    if !self.userIds.isEmpty {
      try visitor.visitRepeatedStringField(value: self.userIds, fieldNumber: 2)
    }
    if case .partitionedStrategyInfo(let v)? = self.strategyInfo {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_TaskWorker, rhs: Clarifai_Api_TaskWorker) -> Bool {
    if lhs.strategy != rhs.strategy {return false}
    if lhs.userIds != rhs.userIds {return false}
    if lhs.strategyInfo != rhs.strategyInfo {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_TaskWorker.TaskWorkerStrategy: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "WORKER_STRATEGY_NOT_SET"),
    2: .same(proto: "PARTITIONED"),
    3: .same(proto: "FULL"),
  ]
}

extension Clarifai_Api_TaskWorkerPartitionedStrategyInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TaskWorkerPartitionedStrategyInfo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .standard(proto: "workers_per_input"),
    3: .same(proto: "weights"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularEnumField(value: &self.type)
      case 2: try decoder.decodeSingularInt32Field(value: &self.workersPerInput)
      case 3: try decoder.decodeSingularMessageField(value: &self._weights)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.type != .partitionedWorkerStrategyNotSet {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 1)
    }
    if self.workersPerInput != 0 {
      try visitor.visitSingularInt32Field(value: self.workersPerInput, fieldNumber: 2)
    }
    if let v = self._weights {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_TaskWorkerPartitionedStrategyInfo, rhs: Clarifai_Api_TaskWorkerPartitionedStrategyInfo) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.workersPerInput != rhs.workersPerInput {return false}
    if lhs._weights != rhs._weights {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_TaskWorkerPartitionedStrategyInfo.TaskWorkerPartitionedStrategy: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "PARTITIONED_WORKER_STRATEGY_NOT_SET"),
    1: .same(proto: "EVENLY"),
    2: .same(proto: "WEIGHTED"),
  ]
}

extension Clarifai_Api_TaskInputSource: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TaskInputSource"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .same(proto: "id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularEnumField(value: &self.type)
      case 2: try decoder.decodeSingularStringField(value: &self.id)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.type != .inputSourceTypeNotSet {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 1)
    }
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_TaskInputSource, rhs: Clarifai_Api_TaskInputSource) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.id != rhs.id {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_TaskInputSource.TaskInputSourceType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "INPUT_SOURCE_TYPE_NOT_SET"),
    1: .same(proto: "ALL_INPUTS"),
    2: .same(proto: "SAVED_SEARCH"),
  ]
}

extension Clarifai_Api_TaskReview: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TaskReview"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "strategy"),
    2: .standard(proto: "user_ids"),
    3: .standard(proto: "manual_strategy_info"),
    4: .standard(proto: "consensus_strategy_info"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularEnumField(value: &self.strategy)
      case 2: try decoder.decodeRepeatedStringField(value: &self.userIds)
      case 3:
        var v: Clarifai_Api_TaskReviewManualStrategyInfo?
        if let current = self.strategyInfo {
          try decoder.handleConflictingOneOf()
          if case .manualStrategyInfo(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.strategyInfo = .manualStrategyInfo(v)}
      case 4:
        var v: Clarifai_Api_TaskReviewConsensusStrategyInfo?
        if let current = self.strategyInfo {
          try decoder.handleConflictingOneOf()
          if case .consensusStrategyInfo(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.strategyInfo = .consensusStrategyInfo(v)}
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.strategy != .notSet {
      try visitor.visitSingularEnumField(value: self.strategy, fieldNumber: 1)
    }
    if !self.userIds.isEmpty {
      try visitor.visitRepeatedStringField(value: self.userIds, fieldNumber: 2)
    }
    switch self.strategyInfo {
    case .manualStrategyInfo(let v)?:
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    case .consensusStrategyInfo(let v)?:
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_TaskReview, rhs: Clarifai_Api_TaskReview) -> Bool {
    if lhs.strategy != rhs.strategy {return false}
    if lhs.userIds != rhs.userIds {return false}
    if lhs.strategyInfo != rhs.strategyInfo {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_TaskReview.TaskReviewStrategy: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "TASK_REVIEW_STRATEGY_NOT_SET"),
    1: .same(proto: "NONE"),
    2: .same(proto: "MANUAL"),
    3: .same(proto: "CONSENSUS"),
  ]
}

extension Clarifai_Api_TaskReviewManualStrategyInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TaskReviewManualStrategyInfo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "sample_percentage"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularFloatField(value: &self.samplePercentage)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.samplePercentage != 0 {
      try visitor.visitSingularFloatField(value: self.samplePercentage, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_TaskReviewManualStrategyInfo, rhs: Clarifai_Api_TaskReviewManualStrategyInfo) -> Bool {
    if lhs.samplePercentage != rhs.samplePercentage {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_TaskReviewConsensusStrategyInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TaskReviewConsensusStrategyInfo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .standard(proto: "approval_threshold"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 2: try decoder.decodeSingularUInt32Field(value: &self.approvalThreshold)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.approvalThreshold != 0 {
      try visitor.visitSingularUInt32Field(value: self.approvalThreshold, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_TaskReviewConsensusStrategyInfo, rhs: Clarifai_Api_TaskReviewConsensusStrategyInfo) -> Bool {
    if lhs.approvalThreshold != rhs.approvalThreshold {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_TaskAIAssistant: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TaskAIAssistant"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "workflow_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.workflowID)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.workflowID.isEmpty {
      try visitor.visitSingularStringField(value: self.workflowID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_TaskAIAssistant, rhs: Clarifai_Api_TaskAIAssistant) -> Bool {
    if lhs.workflowID != rhs.workflowID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_Collector: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Collector"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "description"),
    3: .standard(proto: "created_at"),
    4: .standard(proto: "pre_queue_workflow_id"),
    5: .standard(proto: "post_queue_workflow_id"),
    6: .standard(proto: "collector_source"),
    7: .same(proto: "status"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.id)
      case 2: try decoder.decodeSingularStringField(value: &self.description_p)
      case 3: try decoder.decodeSingularMessageField(value: &self._createdAt)
      case 4: try decoder.decodeSingularStringField(value: &self.preQueueWorkflowID)
      case 5: try decoder.decodeSingularStringField(value: &self.postQueueWorkflowID)
      case 6: try decoder.decodeSingularMessageField(value: &self._collectorSource)
      case 7: try decoder.decodeSingularMessageField(value: &self._status)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 2)
    }
    if let v = self._createdAt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    if !self.preQueueWorkflowID.isEmpty {
      try visitor.visitSingularStringField(value: self.preQueueWorkflowID, fieldNumber: 4)
    }
    if !self.postQueueWorkflowID.isEmpty {
      try visitor.visitSingularStringField(value: self.postQueueWorkflowID, fieldNumber: 5)
    }
    if let v = self._collectorSource {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }
    if let v = self._status {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_Collector, rhs: Clarifai_Api_Collector) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs._createdAt != rhs._createdAt {return false}
    if lhs.preQueueWorkflowID != rhs.preQueueWorkflowID {return false}
    if lhs.postQueueWorkflowID != rhs.postQueueWorkflowID {return false}
    if lhs._collectorSource != rhs._collectorSource {return false}
    if lhs._status != rhs._status {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_CollectorSource: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CollectorSource"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .standard(proto: "api_post_model_outputs_collector_source"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 2: try decoder.decodeSingularMessageField(value: &self._apiPostModelOutputsCollectorSource)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._apiPostModelOutputsCollectorSource {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_CollectorSource, rhs: Clarifai_Api_CollectorSource) -> Bool {
    if lhs._apiPostModelOutputsCollectorSource != rhs._apiPostModelOutputsCollectorSource {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_APIPostModelOutputsCollectorSource: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".APIPostModelOutputsCollectorSource"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "model_user_id"),
    2: .standard(proto: "model_app_id"),
    3: .standard(proto: "model_id"),
    4: .standard(proto: "model_version_id"),
    5: .standard(proto: "post_inputs_key_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.modelUserID)
      case 2: try decoder.decodeSingularStringField(value: &self.modelAppID)
      case 3: try decoder.decodeSingularStringField(value: &self.modelID)
      case 4: try decoder.decodeSingularStringField(value: &self.modelVersionID)
      case 5: try decoder.decodeSingularStringField(value: &self.postInputsKeyID)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.modelUserID.isEmpty {
      try visitor.visitSingularStringField(value: self.modelUserID, fieldNumber: 1)
    }
    if !self.modelAppID.isEmpty {
      try visitor.visitSingularStringField(value: self.modelAppID, fieldNumber: 2)
    }
    if !self.modelID.isEmpty {
      try visitor.visitSingularStringField(value: self.modelID, fieldNumber: 3)
    }
    if !self.modelVersionID.isEmpty {
      try visitor.visitSingularStringField(value: self.modelVersionID, fieldNumber: 4)
    }
    if !self.postInputsKeyID.isEmpty {
      try visitor.visitSingularStringField(value: self.postInputsKeyID, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_APIPostModelOutputsCollectorSource, rhs: Clarifai_Api_APIPostModelOutputsCollectorSource) -> Bool {
    if lhs.modelUserID != rhs.modelUserID {return false}
    if lhs.modelAppID != rhs.modelAppID {return false}
    if lhs.modelID != rhs.modelID {return false}
    if lhs.modelVersionID != rhs.modelVersionID {return false}
    if lhs.postInputsKeyID != rhs.postInputsKeyID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_StatValue: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".StatValue"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "time"),
    2: .same(proto: "value"),
    3: .same(proto: "tags"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._time)
      case 2: try decoder.decodeSingularFloatField(value: &self.value)
      case 3: try decoder.decodeRepeatedStringField(value: &self.tags)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._time {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if self.value != 0 {
      try visitor.visitSingularFloatField(value: self.value, fieldNumber: 2)
    }
    if !self.tags.isEmpty {
      try visitor.visitRepeatedStringField(value: self.tags, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_StatValue, rhs: Clarifai_Api_StatValue) -> Bool {
    if lhs._time != rhs._time {return false}
    if lhs.value != rhs.value {return false}
    if lhs.tags != rhs.tags {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_StatValueAggregateResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".StatValueAggregateResult"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "stat_value_aggregates"),
    2: .standard(proto: "stat_value_aggregate_query"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.statValueAggregates)
      case 2: try decoder.decodeSingularMessageField(value: &self._statValueAggregateQuery)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.statValueAggregates.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.statValueAggregates, fieldNumber: 1)
    }
    if let v = self._statValueAggregateQuery {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_StatValueAggregateResult, rhs: Clarifai_Api_StatValueAggregateResult) -> Bool {
    if lhs.statValueAggregates != rhs.statValueAggregates {return false}
    if lhs._statValueAggregateQuery != rhs._statValueAggregateQuery {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_StatValueAggregate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".StatValueAggregate"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "time"),
    2: .standard(proto: "aggregate_value"),
    3: .same(proto: "count"),
    4: .same(proto: "tags"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._time)
      case 2: try decoder.decodeSingularFloatField(value: &self.aggregateValue)
      case 3: try decoder.decodeSingularUInt64Field(value: &self.count)
      case 4: try decoder.decodeRepeatedStringField(value: &self.tags)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._time {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if self.aggregateValue != 0 {
      try visitor.visitSingularFloatField(value: self.aggregateValue, fieldNumber: 2)
    }
    if self.count != 0 {
      try visitor.visitSingularUInt64Field(value: self.count, fieldNumber: 3)
    }
    if !self.tags.isEmpty {
      try visitor.visitRepeatedStringField(value: self.tags, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_StatValueAggregate, rhs: Clarifai_Api_StatValueAggregate) -> Bool {
    if lhs._time != rhs._time {return false}
    if lhs.aggregateValue != rhs.aggregateValue {return false}
    if lhs.count != rhs.count {return false}
    if lhs.tags != rhs.tags {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_StatValueAggregateQuery: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".StatValueAggregateQuery"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "tags"),
    2: .standard(proto: "tag_groups"),
    3: .standard(proto: "stat_value_agg_type"),
    4: .standard(proto: "stat_time_agg_type"),
    5: .standard(proto: "start_time"),
    6: .standard(proto: "end_time"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedStringField(value: &self.tags)
      case 2: try decoder.decodeRepeatedStringField(value: &self.tagGroups)
      case 3: try decoder.decodeSingularEnumField(value: &self.statValueAggType)
      case 4: try decoder.decodeSingularEnumField(value: &self.statTimeAggType)
      case 5: try decoder.decodeSingularMessageField(value: &self._startTime)
      case 6: try decoder.decodeSingularMessageField(value: &self._endTime)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.tags.isEmpty {
      try visitor.visitRepeatedStringField(value: self.tags, fieldNumber: 1)
    }
    if !self.tagGroups.isEmpty {
      try visitor.visitRepeatedStringField(value: self.tagGroups, fieldNumber: 2)
    }
    if self.statValueAggType != .sum {
      try visitor.visitSingularEnumField(value: self.statValueAggType, fieldNumber: 3)
    }
    if self.statTimeAggType != .noTimeAgg {
      try visitor.visitSingularEnumField(value: self.statTimeAggType, fieldNumber: 4)
    }
    if let v = self._startTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }
    if let v = self._endTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_StatValueAggregateQuery, rhs: Clarifai_Api_StatValueAggregateQuery) -> Bool {
    if lhs.tags != rhs.tags {return false}
    if lhs.tagGroups != rhs.tagGroups {return false}
    if lhs.statValueAggType != rhs.statValueAggType {return false}
    if lhs.statTimeAggType != rhs.statTimeAggType {return false}
    if lhs._startTime != rhs._startTime {return false}
    if lhs._endTime != rhs._endTime {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
