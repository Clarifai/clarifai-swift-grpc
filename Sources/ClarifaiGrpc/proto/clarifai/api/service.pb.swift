// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: proto/clarifai/api/service.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

public enum Clarifai_Api_OrganizationInvitationStatus: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case notSet // = 0
  case pending // = 1
  case accepted // = 2
  case cancelled // = 3
  case declined // = 4
  case expired // = 5
  case UNRECOGNIZED(Int)

  public init() {
    self = .notSet
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .notSet
    case 1: self = .pending
    case 2: self = .accepted
    case 3: self = .cancelled
    case 4: self = .declined
    case 5: self = .expired
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .notSet: return 0
    case .pending: return 1
    case .accepted: return 2
    case .cancelled: return 3
    case .declined: return 4
    case .expired: return 5
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Clarifai_Api_OrganizationInvitationStatus: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Clarifai_Api_OrganizationInvitationStatus] = [
    .notSet,
    .pending,
    .accepted,
    .cancelled,
    .declined,
    .expired,
  ]
}

#endif  // swift(>=4.2)

public enum Clarifai_Api_PutTaskAssignmentsRequestAction: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case notSet // = 0

  /// Create a list of task assignments for labeler => 10 inputs are assigned to the labeler.
  /// This is a fully sync action.
  /// If task assignments already exist, then return existing task assignments.
  case labelStart // = 1

  /// Submit task assignments => mark task assignment work as completed.
  /// This is a partially sync action.
  /// Sync: task assignments are updated as follows:
  /// * when review_strategy is NONE, then task assignment status is updated to SUCCESS.
  /// * when review strategy is CONSENSUS, then task assignment status is updated to AWAITING_CONSENSUS_REVIEW.
  /// * when review strategy is MANUAL, then task assignment status is updated to AWAITING_REVIEW.
  /// If task assignments are already submitted, then no update is performed on them.
  /// Async: annotations added for the same input as the task assignment are updated as follows:
  /// * when review_strategy is NONE, then annotation status is updated to SUCCESS.
  /// * when review strategy is CONSENSUS, then annotation status is updated to SUCCESS (if it reaches consensus) or AWAITING_REVIEW (if it does not reach consensus).
  /// * when review strategy is MANUAL, then annotation status is updated to AWAITING_REVIEW.
  case labelSubmit // = 2

  /// Assign task assignments for reviewer to review => 10 task assignments are assigned to the reviewer.
  /// This is a fully sync action.
  /// If task assignments are already assigned for review, then return existing task assignments.
  case reviewStart // = 10

  /// Approve task assignments.
  /// There are two types of configurations:
  /// * Batch approve: approve a list of task assignment IDs;
  /// * Bulk approve: approve all task assignments from a list of workers.
  /// This is a partially sync action.
  /// Sync: task assignments are updated to SUCCESS
  /// Async: annotations added for the same input as the task assignment are updated to SUCCESS
  case reviewApprove // = 11

  /// Request changes for task assignments.
  /// There are two types of configurations:
  /// * Batch request changes: request changes for a list of task assignment IDs;
  /// * Bulk request changes: request changes for all task assignments from a list of workers.
  /// This is a partially sync action.
  /// Sync: task assignments are updated to PENDING
  /// Async: annotations added for the same input as the task assignment are updated to PENDING
  case reviewRequestChanges // = 12

  /// Reject task assignments.
  /// There are two types of configurations:
  /// * Batch reject: reject a list of task assignment IDs;
  /// * Bulk reject: reject all task assignments from a list of workers.
  /// This is a partially sync action.
  /// Sync: task assignments are updated to REVIEW_DENIED
  /// Async: annotations added for the same input as the task assignment are updated to REVIEW_DENIED
  case reviewReject // = 13
  case UNRECOGNIZED(Int)

  public init() {
    self = .notSet
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .notSet
    case 1: self = .labelStart
    case 2: self = .labelSubmit
    case 10: self = .reviewStart
    case 11: self = .reviewApprove
    case 12: self = .reviewRequestChanges
    case 13: self = .reviewReject
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .notSet: return 0
    case .labelStart: return 1
    case .labelSubmit: return 2
    case .reviewStart: return 10
    case .reviewApprove: return 11
    case .reviewRequestChanges: return 12
    case .reviewReject: return 13
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Clarifai_Api_PutTaskAssignmentsRequestAction: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Clarifai_Api_PutTaskAssignmentsRequestAction] = [
    .notSet,
    .labelStart,
    .labelSubmit,
    .reviewStart,
    .reviewApprove,
    .reviewRequestChanges,
    .reviewReject,
  ]
}

#endif  // swift(>=4.2)

/// Split the results into pages.
public struct Clarifai_Api_Pagination {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// (optional URL parameter) The page number. Pagination is used to split the results into chunks. Defaults to 1.
  public var page: UInt32 = 0

  /// (optional URL parameter) The number of results that will be contained in each page. Defaults to 128.
  public var perPage: UInt32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// GetAnnotationRequest
public struct Clarifai_Api_GetAnnotationRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var userAppID: Clarifai_Api_UserAppIDSet {
    get {return _userAppID ?? Clarifai_Api_UserAppIDSet()}
    set {_userAppID = newValue}
  }
  /// Returns true if `userAppID` has been explicitly set.
  public var hasUserAppID: Bool {return self._userAppID != nil}
  /// Clears the value of `userAppID`. Subsequent reads from it will return its default value.
  public mutating func clearUserAppID() {self._userAppID = nil}

  public var annotationID: String = String()

  public var inputID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _userAppID: Clarifai_Api_UserAppIDSet? = nil
}

/// ListAnnotationsRequest
public struct Clarifai_Api_ListAnnotationsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var userAppID: Clarifai_Api_UserAppIDSet {
    get {return _userAppID ?? Clarifai_Api_UserAppIDSet()}
    set {_userAppID = newValue}
  }
  /// Returns true if `userAppID` has been explicitly set.
  public var hasUserAppID: Bool {return self._userAppID != nil}
  /// Clears the value of `userAppID`. Subsequent reads from it will return its default value.
  public mutating func clearUserAppID() {self._userAppID = nil}

  /// List annotations for these IDs
  public var ids: [String] = []

  /// List annotations for these Input IDs
  /// Note that 'ids' are optional but if the are provided the number and order in
  /// 'ids' and 'input_ids' should match
  /// If you do not specify 'ids' all the annotations for 'input_ids' are returned
  /// If a you do not specify both 'input_ids' and 'ids' all the annotations in the app are returned
  public var inputIds: [String] = []

  /// Only return the annotations that has one of these user IDs, effectively operating as an
  /// OR among them to filter down the results.
  /// If model_version_ids or workflow_version_ids are also provided, these user_ids are OR'd with them as well because
  /// we want the union of all worker (user, model or workflow) annotations in the results of ListAnnotations request.
  /// Setting user_ids does also set list_all_annotations=True.
  public var userIds: [String] = []

  /// Only return the annotations that has one of these model version IDs, effectively operating as an
  /// OR among them to filter down the results.
  /// If user_ids or workflow_version_ids are also provided, these model_version_ids are OR'd with them as well because
  /// we want the union of all worker (user, model or workflow) annotations in the results of ListAnnotations request.
  /// Setting model_version_ids does also set list_all_annotations=True.
  public var modelVersionIds: [String] = []

  /// Only return the annotations that has one of these workflow version IDs, effectively operating as an
  /// OR among them to filter down the results.
  /// If user_ids or model_version_ids are also provided, these workflow_version_ids are OR'd with them as well because
  /// we want the union of all worker (user, model or workflow) annotations in the results of ListAnnotations request.
  /// Setting workflow_version_ids does also set list_all_annotations=True.
  public var workflowVersionIds: [String] = []

  /// Set status to filter by a list of statuses
  /// If not statuses are provided then annotations with any status will be returned.
  public var statuses: [Clarifai_Api_Status_Status] = []

  /// Set this flag to list both trusted and not trusted annotations
  /// by default it's listing only trusted annotations
  public var listAllAnnotations: Bool = false

  /// Set this flag to return the model output for model annotations in the response.
  public var returnModelOutput: Bool = false

  /// (optional URL parameter) The page number. Pagination is used to split the results into chunks.
  /// Defaults to 1.
  public var page: UInt32 = 0

  /// (optional URL parameter) The number of results that will be contained in each page. Defaults
  /// to 128.
  public var perPage: UInt32 = 0

  /// Flag to filter annotations by task_id
  public var taskID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _userAppID: Clarifai_Api_UserAppIDSet? = nil
}

/// PostAnnotationsRequest
public struct Clarifai_Api_PostAnnotationsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var userAppID: Clarifai_Api_UserAppIDSet {
    get {return _userAppID ?? Clarifai_Api_UserAppIDSet()}
    set {_userAppID = newValue}
  }
  /// Returns true if `userAppID` has been explicitly set.
  public var hasUserAppID: Bool {return self._userAppID != nil}
  /// Clears the value of `userAppID`. Subsequent reads from it will return its default value.
  public mutating func clearUserAppID() {self._userAppID = nil}

  public var annotations: [Clarifai_Api_Annotation] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _userAppID: Clarifai_Api_UserAppIDSet? = nil
}

/// PatchAnnotationsRequest
public struct Clarifai_Api_PatchAnnotationsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var userAppID: Clarifai_Api_UserAppIDSet {
    get {return _userAppID ?? Clarifai_Api_UserAppIDSet()}
    set {_userAppID = newValue}
  }
  /// Returns true if `userAppID` has been explicitly set.
  public var hasUserAppID: Bool {return self._userAppID != nil}
  /// Clears the value of `userAppID`. Subsequent reads from it will return its default value.
  public mutating func clearUserAppID() {self._userAppID = nil}

  public var annotations: [Clarifai_Api_Annotation] = []

  /// The action to perform on the patched objects
  /// For now actions 'merge', 'overwrite', and 'remove' are supported
  public var action: String = String()

  /// If the request is a "remove" action and the annotation is left with empty data,
  /// then setting delete_if_empty_data to true will delete the annotation,
  /// if possible (for example, will not delete an input-level annotation).
  public var deleteIfEmptyData: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _userAppID: Clarifai_Api_UserAppIDSet? = nil
}

/// PatchAnnotationsStatusRequest
public struct Clarifai_Api_PatchAnnotationsStatusRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var userAppID: Clarifai_Api_UserAppIDSet {
    get {return _userAppID ?? Clarifai_Api_UserAppIDSet()}
    set {_userAppID = newValue}
  }
  /// Returns true if `userAppID` has been explicitly set.
  public var hasUserAppID: Bool {return self._userAppID != nil}
  /// Clears the value of `userAppID`. Subsequent reads from it will return its default value.
  public mutating func clearUserAppID() {self._userAppID = nil}

  /// Filter by user IDs
  public var userIds: [String] = []

  /// Filter by task ID
  public var taskID: String = String()

  /// Filter by Status codes
  public var statusCodes: [Clarifai_Api_Status_StatusCode] = []

  /// 'overwrite' is supported
  public var action: String = String()

  /// Update filtered annotations to this status
  public var statusCode: Clarifai_Api_Status_StatusCode = .zero

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _userAppID: Clarifai_Api_UserAppIDSet? = nil
}

/// PatchAnnotationsStatusResponse
public struct Clarifai_Api_PatchAnnotationsStatusResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var status: Clarifai_Api_Status_Status {
    get {return _status ?? Clarifai_Api_Status_Status()}
    set {_status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  public var hasStatus: Bool {return self._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  public mutating func clearStatus() {self._status = nil}

  public var userIds: [String] = []

  public var updatedCount: UInt32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _status: Clarifai_Api_Status_Status? = nil
}

/// DeleteAnnotationRequest
public struct Clarifai_Api_DeleteAnnotationRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var userAppID: Clarifai_Api_UserAppIDSet {
    get {return _userAppID ?? Clarifai_Api_UserAppIDSet()}
    set {_userAppID = newValue}
  }
  /// Returns true if `userAppID` has been explicitly set.
  public var hasUserAppID: Bool {return self._userAppID != nil}
  /// Clears the value of `userAppID`. Subsequent reads from it will return its default value.
  public mutating func clearUserAppID() {self._userAppID = nil}

  public var inputID: String = String()

  public var annotationID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _userAppID: Clarifai_Api_UserAppIDSet? = nil
}

/// Request to delete several things by the list of ids.
public struct Clarifai_Api_DeleteAnnotationsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var userAppID: Clarifai_Api_UserAppIDSet {
    get {return _userAppID ?? Clarifai_Api_UserAppIDSet()}
    set {_userAppID = newValue}
  }
  /// Returns true if `userAppID` has been explicitly set.
  public var hasUserAppID: Bool {return self._userAppID != nil}
  /// Clears the value of `userAppID`. Subsequent reads from it will return its default value.
  public mutating func clearUserAppID() {self._userAppID = nil}

  /// Delete annotations with IDs
  public var ids: [String] = []

  /// Delete annotations for these Input IDs
  /// Note that 'ids' are optional but if the are provided the number and order in
  /// 'ids' and 'input_ids' should match
  /// If you do not specifiy 'ids' all the annotations for 'input_ids' are deleted
  /// However you need to specify at least one value for 'input_ids'
  /// i.e. this API does not support deleting all annotations
  public var inputIds: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _userAppID: Clarifai_Api_UserAppIDSet? = nil
}

/// ListAnnotationTracksRequest
public struct Clarifai_Api_ListAnnotationTracksRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var userAppID: Clarifai_Api_UserAppIDSet {
    get {return _userAppID ?? Clarifai_Api_UserAppIDSet()}
    set {_userAppID = newValue}
  }
  /// Returns true if `userAppID` has been explicitly set.
  public var hasUserAppID: Bool {return self._userAppID != nil}
  /// Clears the value of `userAppID`. Subsequent reads from it will return its default value.
  public mutating func clearUserAppID() {self._userAppID = nil}

  public var ids: [String] = []

  public var inputID: String = String()

  public var page: UInt32 = 0

  public var perPage: UInt32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _userAppID: Clarifai_Api_UserAppIDSet? = nil
}

/// PostAnnotationTracksRequest
public struct Clarifai_Api_PostAnnotationTracksRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var userAppID: Clarifai_Api_UserAppIDSet {
    get {return _userAppID ?? Clarifai_Api_UserAppIDSet()}
    set {_userAppID = newValue}
  }
  /// Returns true if `userAppID` has been explicitly set.
  public var hasUserAppID: Bool {return self._userAppID != nil}
  /// Clears the value of `userAppID`. Subsequent reads from it will return its default value.
  public mutating func clearUserAppID() {self._userAppID = nil}

  public var annotationTracks: [Clarifai_Api_AnnotationTrack] = []

  public var inputID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _userAppID: Clarifai_Api_UserAppIDSet? = nil
}

/// PatchAnnotationTracksRequest
public struct Clarifai_Api_PatchAnnotationTracksRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var userAppID: Clarifai_Api_UserAppIDSet {
    get {return _userAppID ?? Clarifai_Api_UserAppIDSet()}
    set {_userAppID = newValue}
  }
  /// Returns true if `userAppID` has been explicitly set.
  public var hasUserAppID: Bool {return self._userAppID != nil}
  /// Clears the value of `userAppID`. Subsequent reads from it will return its default value.
  public mutating func clearUserAppID() {self._userAppID = nil}

  public var annotationTracks: [Clarifai_Api_AnnotationTrack] = []

  public var inputID: String = String()

  /// Use always 'overwrite'
  public var action: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _userAppID: Clarifai_Api_UserAppIDSet? = nil
}

/// DeleteAnnotationTracksRequest
public struct Clarifai_Api_DeleteAnnotationTracksRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var userAppID: Clarifai_Api_UserAppIDSet {
    get {return _userAppID ?? Clarifai_Api_UserAppIDSet()}
    set {_userAppID = newValue}
  }
  /// Returns true if `userAppID` has been explicitly set.
  public var hasUserAppID: Bool {return self._userAppID != nil}
  /// Clears the value of `userAppID`. Subsequent reads from it will return its default value.
  public mutating func clearUserAppID() {self._userAppID = nil}

  public var ids: [String] = []

  public var inputID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _userAppID: Clarifai_Api_UserAppIDSet? = nil
}

/// MultiAnnotationTrackResponse
public struct Clarifai_Api_MultiAnnotationTrackResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var status: Clarifai_Api_Status_Status {
    get {return _status ?? Clarifai_Api_Status_Status()}
    set {_status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  public var hasStatus: Bool {return self._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  public mutating func clearStatus() {self._status = nil}

  public var annotationTracks: [Clarifai_Api_AnnotationTrack] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _status: Clarifai_Api_Status_Status? = nil
}

/// SingleAnnotationResponse
public struct Clarifai_Api_SingleAnnotationResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var status: Clarifai_Api_Status_Status {
    get {return _status ?? Clarifai_Api_Status_Status()}
    set {_status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  public var hasStatus: Bool {return self._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  public mutating func clearStatus() {self._status = nil}

  public var annotation: Clarifai_Api_Annotation {
    get {return _annotation ?? Clarifai_Api_Annotation()}
    set {_annotation = newValue}
  }
  /// Returns true if `annotation` has been explicitly set.
  public var hasAnnotation: Bool {return self._annotation != nil}
  /// Clears the value of `annotation`. Subsequent reads from it will return its default value.
  public mutating func clearAnnotation() {self._annotation = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _status: Clarifai_Api_Status_Status? = nil
  fileprivate var _annotation: Clarifai_Api_Annotation? = nil
}

/// MultiAnnotationResponse
public struct Clarifai_Api_MultiAnnotationResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var status: Clarifai_Api_Status_Status {
    get {return _status ?? Clarifai_Api_Status_Status()}
    set {_status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  public var hasStatus: Bool {return self._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  public mutating func clearStatus() {self._status = nil}

  public var annotations: [Clarifai_Api_Annotation] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _status: Clarifai_Api_Status_Status? = nil
}

/// ListAnnotationWorkersRequest
public struct Clarifai_Api_ListAnnotationWorkersRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var userAppID: Clarifai_Api_UserAppIDSet {
    get {return _userAppID ?? Clarifai_Api_UserAppIDSet()}
    set {_userAppID = newValue}
  }
  /// Returns true if `userAppID` has been explicitly set.
  public var hasUserAppID: Bool {return self._userAppID != nil}
  /// Clears the value of `userAppID`. Subsequent reads from it will return its default value.
  public mutating func clearUserAppID() {self._userAppID = nil}

  /// (optional URL parameter) The page number. Pagination is used to split the results into chunks.
  /// Defaults to 1.
  public var page: UInt32 = 0

  /// (optional URL parameter) The number of results that will be contained in each page. Defaults
  /// to 128.
  public var perPage: UInt32 = 0

  /// (optional URL parameter) List of additional fields to be included in the response.
  /// Currently supported: all, names
  public var additionalFields: [String] = []

  /// (optional URL parameter) Only list workers that have created trusted annotations.
  public var trustedOnly: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _userAppID: Clarifai_Api_UserAppIDSet? = nil
}

/// MultiWorkerResponse
public struct Clarifai_Api_MultiWorkerResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var status: Clarifai_Api_Status_Status {
    get {return _status ?? Clarifai_Api_Status_Status()}
    set {_status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  public var hasStatus: Bool {return self._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  public mutating func clearStatus() {self._status = nil}

  public var workers: [Clarifai_Api_Worker] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _status: Clarifai_Api_Status_Status? = nil
}

/// GetAppRequest
public struct Clarifai_Api_GetAppRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var userAppID: Clarifai_Api_UserAppIDSet {
    get {return _userAppID ?? Clarifai_Api_UserAppIDSet()}
    set {_userAppID = newValue}
  }
  /// Returns true if `userAppID` has been explicitly set.
  public var hasUserAppID: Bool {return self._userAppID != nil}
  /// Clears the value of `userAppID`. Subsequent reads from it will return its default value.
  public mutating func clearUserAppID() {self._userAppID = nil}

  /// (optional URL parameter) List of additional fields to be included in the response. Currently supported: all, stars, counts
  public var additionalFields: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _userAppID: Clarifai_Api_UserAppIDSet? = nil
}

/// ListAppsRequest
public struct Clarifai_Api_ListAppsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var userAppID: Clarifai_Api_UserAppIDSet {
    get {return _userAppID ?? Clarifai_Api_UserAppIDSet()}
    set {_userAppID = newValue}
  }
  /// Returns true if `userAppID` has been explicitly set.
  public var hasUserAppID: Bool {return self._userAppID != nil}
  /// Clears the value of `userAppID`. Subsequent reads from it will return its default value.
  public mutating func clearUserAppID() {self._userAppID = nil}

  /// (optional URL parameter) The page number. Pagination is used to split the results into chunks.
  /// Defaults to 1.
  public var page: UInt32 = 0

  /// (optional URL parameter) The number of results that will be contained in each page. Defaults
  /// to 128.
  public var perPage: UInt32 = 0

  /// (optional URL parameter) List of additional fields to be included in the response. Currently supported: all, stars, counts
  public var additionalFields: [String] = []

  /// Sorting options:
  /// Whether to sort in ascending order. If false, will order in descending order.
  public var sortAscending: Bool = false

  public var sortBy: Clarifai_Api_ListAppsRequest.OneOf_SortBy? = nil

  /// Whether to order by the name.
  public var sortByName: Bool {
    get {
      if case .sortByName(let v)? = sortBy {return v}
      return false
    }
    set {sortBy = .sortByName(newValue)}
  }

  /// Whether to order by the modified_at time.
  /// If none of the sort options is set to true, will sort by modified_at.
  public var sortByModifiedAt: Bool {
    get {
      if case .sortByModifiedAt(let v)? = sortBy {return v}
      return false
    }
    set {sortBy = .sortByModifiedAt(newValue)}
  }

  /// Whether to order by the created_at time.
  public var sortByCreatedAt: Bool {
    get {
      if case .sortByCreatedAt(let v)? = sortBy {return v}
      return false
    }
    set {sortBy = .sortByCreatedAt(newValue)}
  }

  /// Whether to order by the number of users stared the app
  public var sortByStarCount: Bool {
    get {
      if case .sortByStarCount(let v)? = sortBy {return v}
      return false
    }
    set {sortBy = .sortByStarCount(newValue)}
  }

  /// Whether to order by the id
  public var sortByID: Bool {
    get {
      if case .sortByID(let v)? = sortBy {return v}
      return false
    }
    set {sortBy = .sortByID(newValue)}
  }

  /// Filtering options:
  /// If true, we only return apps that are handpicked by clarifai staff
  public var featuredOnly: Bool = false

  /// If true, we only return apps that are starred by the requesting user
  public var starredOnly: Bool = false

  /// If true, we only return apps that are marked as a template by the app owner.
  public var templateOnly: Bool = false

  /// Filter by visibility of the app. If set, only return apps with the specified visibility.
  public var visibility: Clarifai_Api_Visibility {
    get {return _visibility ?? Clarifai_Api_Visibility()}
    set {_visibility = newValue}
  }
  /// Returns true if `visibility` has been explicitly set.
  public var hasVisibility: Bool {return self._visibility != nil}
  /// Clears the value of `visibility`. Subsequent reads from it will return its default value.
  public mutating func clearVisibility() {self._visibility = nil}

  /// Searching options:
  /// Specify a search parameter in order to perform keyword search on the
  /// following fields of the application:
  ///   - id
  ///   - name
  ///   - description
  ///   - notes
  ///   - user_id (unless user_app_id.user_id is already set)
  ///
  /// Keywords are both normalized for search (so searching for "satisfy" matches "satisfied")
  /// and used for partial prefix-matching (so searching for "clari" matches "clarifai").
  ///
  /// NOTE: Both the list of fields searched and the exact keyword matching
  /// rules are subject to change and not guaranteed to be backwards-compatible.
  public var search: String = String()

  /// Query various text fields (id, name, description, and notes) that can contain the words in the query string
  /// Deprecated: use search instead.
  public var query: String = String()

  /// Filter by the id, name and notes of the app. This supports wilcard queries like "gen*" to match "general" as an example.
  /// Deprecated: use search instead.
  public var name: String = String()

  /// Filter by the user-unique-id of the app. This supports wilcard queries like "gen*" to match "general" as an example.
  /// Deprecated: use search instead.
  public var id: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_SortBy: Equatable {
    /// Whether to order by the name.
    case sortByName(Bool)
    /// Whether to order by the modified_at time.
    /// If none of the sort options is set to true, will sort by modified_at.
    case sortByModifiedAt(Bool)
    /// Whether to order by the created_at time.
    case sortByCreatedAt(Bool)
    /// Whether to order by the number of users stared the app
    case sortByStarCount(Bool)
    /// Whether to order by the id
    case sortByID(Bool)

  #if !swift(>=4.1)
    public static func ==(lhs: Clarifai_Api_ListAppsRequest.OneOf_SortBy, rhs: Clarifai_Api_ListAppsRequest.OneOf_SortBy) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.sortByName, .sortByName): return {
        guard case .sortByName(let l) = lhs, case .sortByName(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.sortByModifiedAt, .sortByModifiedAt): return {
        guard case .sortByModifiedAt(let l) = lhs, case .sortByModifiedAt(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.sortByCreatedAt, .sortByCreatedAt): return {
        guard case .sortByCreatedAt(let l) = lhs, case .sortByCreatedAt(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.sortByStarCount, .sortByStarCount): return {
        guard case .sortByStarCount(let l) = lhs, case .sortByStarCount(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.sortByID, .sortByID): return {
        guard case .sortByID(let l) = lhs, case .sortByID(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}

  fileprivate var _userAppID: Clarifai_Api_UserAppIDSet? = nil
  fileprivate var _visibility: Clarifai_Api_Visibility? = nil
}

/// PostAppsRequest
public struct Clarifai_Api_PostAppsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var userAppID: Clarifai_Api_UserAppIDSet {
    get {return _userAppID ?? Clarifai_Api_UserAppIDSet()}
    set {_userAppID = newValue}
  }
  /// Returns true if `userAppID` has been explicitly set.
  public var hasUserAppID: Bool {return self._userAppID != nil}
  /// Clears the value of `userAppID`. Subsequent reads from it will return its default value.
  public mutating func clearUserAppID() {self._userAppID = nil}

  public var apps: [Clarifai_Api_App] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _userAppID: Clarifai_Api_UserAppIDSet? = nil
}

/// DeleteAppRequest
public struct Clarifai_Api_DeleteAppRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var userAppID: Clarifai_Api_UserAppIDSet {
    get {return _userAppID ?? Clarifai_Api_UserAppIDSet()}
    set {_userAppID = newValue}
  }
  /// Returns true if `userAppID` has been explicitly set.
  public var hasUserAppID: Bool {return self._userAppID != nil}
  /// Clears the value of `userAppID`. Subsequent reads from it will return its default value.
  public mutating func clearUserAppID() {self._userAppID = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _userAppID: Clarifai_Api_UserAppIDSet? = nil
}

/// PatchAppsRequest
public struct Clarifai_Api_PatchAppsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var userAppID: Clarifai_Api_UserAppIDSet {
    get {return _userAppID ?? Clarifai_Api_UserAppIDSet()}
    set {_userAppID = newValue}
  }
  /// Returns true if `userAppID` has been explicitly set.
  public var hasUserAppID: Bool {return self._userAppID != nil}
  /// Clears the value of `userAppID`. Subsequent reads from it will return its default value.
  public mutating func clearUserAppID() {self._userAppID = nil}

  public var apps: [Clarifai_Api_App] = []

  /// The action to perform on the patched App objects except App.Metadata
  /// Supported values: 'overwrite' and 'remove'.
  ///
  /// Note that 'remove' can only be used to remove the app image by setting
  /// 'image.url' in the request to the current value returned for that app.
  public var action: String = String()

  /// The action to perform on the patched App.Metadata
  public var metadataAction: Clarifai_Api_PatchAction {
    get {return _metadataAction ?? Clarifai_Api_PatchAction()}
    set {_metadataAction = newValue}
  }
  /// Returns true if `metadataAction` has been explicitly set.
  public var hasMetadataAction: Bool {return self._metadataAction != nil}
  /// Clears the value of `metadataAction`. Subsequent reads from it will return its default value.
  public mutating func clearMetadataAction() {self._metadataAction = nil}

  /// If set, the app will be automatically reindexed upon change of its base workflow.
  public var reindex: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _userAppID: Clarifai_Api_UserAppIDSet? = nil
  fileprivate var _metadataAction: Clarifai_Api_PatchAction? = nil
}

public struct Clarifai_Api_PatchAppsDetailsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var userAppID: Clarifai_Api_UserAppIDSet {
    get {return _userAppID ?? Clarifai_Api_UserAppIDSet()}
    set {_userAppID = newValue}
  }
  /// Returns true if `userAppID` has been explicitly set.
  public var hasUserAppID: Bool {return self._userAppID != nil}
  /// Clears the value of `userAppID`. Subsequent reads from it will return its default value.
  public mutating func clearUserAppID() {self._userAppID = nil}

  public var apps: [Clarifai_Api_App] = []

  /// The action to perform on the patched App objects
  /// Supported values: 'overwrite' and 'remove'.
  ///
  /// Note that 'remove' can only be used to remove the app image by setting
  /// 'image.url' in the request to the current value returned for that app.
  public var action: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _userAppID: Clarifai_Api_UserAppIDSet? = nil
}

/// PatchAppRequest
public struct Clarifai_Api_PatchAppRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var userAppID: Clarifai_Api_UserAppIDSet {
    get {return _userAppID ?? Clarifai_Api_UserAppIDSet()}
    set {_userAppID = newValue}
  }
  /// Returns true if `userAppID` has been explicitly set.
  public var hasUserAppID: Bool {return self._userAppID != nil}
  /// Clears the value of `userAppID`. Subsequent reads from it will return its default value.
  public mutating func clearUserAppID() {self._userAppID = nil}

  public var app: Clarifai_Api_App {
    get {return _app ?? Clarifai_Api_App()}
    set {_app = newValue}
  }
  /// Returns true if `app` has been explicitly set.
  public var hasApp: Bool {return self._app != nil}
  /// Clears the value of `app`. Subsequent reads from it will return its default value.
  public mutating func clearApp() {self._app = nil}

  /// The action to perform on the patched App object except App.Metadata
  /// Supported values: 'overwrite' and 'remove'.
  ///
  /// Note that 'remove' can only be used to remove the app image by setting
  /// 'image.url' in the request to the current value returned for the app.
  public var action: String = String()

  /// The action to perform on the patched App.Metadata
  public var metadataAction: Clarifai_Api_PatchAction {
    get {return _metadataAction ?? Clarifai_Api_PatchAction()}
    set {_metadataAction = newValue}
  }
  /// Returns true if `metadataAction` has been explicitly set.
  public var hasMetadataAction: Bool {return self._metadataAction != nil}
  /// Clears the value of `metadataAction`. Subsequent reads from it will return its default value.
  public mutating func clearMetadataAction() {self._metadataAction = nil}

  /// If set, the app will be automatically reindexed upon change of its base workflow.
  public var reindex: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _userAppID: Clarifai_Api_UserAppIDSet? = nil
  fileprivate var _app: Clarifai_Api_App? = nil
  fileprivate var _metadataAction: Clarifai_Api_PatchAction? = nil
}

/// PatchAppsIdsRequest
public struct Clarifai_Api_PatchAppsIdsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var userAppID: Clarifai_Api_UserAppIDSet {
    get {return _userAppID ?? Clarifai_Api_UserAppIDSet()}
    set {_userAppID = newValue}
  }
  /// Returns true if `userAppID` has been explicitly set.
  public var hasUserAppID: Bool {return self._userAppID != nil}
  /// Clears the value of `userAppID`. Subsequent reads from it will return its default value.
  public mutating func clearUserAppID() {self._userAppID = nil}

  /// Array containing 1 entry
  public var ids: [Clarifai_Api_IdUpdateSource] = []

  /// The action to perform on the patched objects
  /// Only 'overwrite' is supported
  public var action: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _userAppID: Clarifai_Api_UserAppIDSet? = nil
}

/// Search over the available applications.
public struct Clarifai_Api_PostAppsSearchesRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var userAppID: Clarifai_Api_UserAppIDSet {
    get {return _userAppID ?? Clarifai_Api_UserAppIDSet()}
    set {_userAppID = newValue}
  }
  /// Returns true if `userAppID` has been explicitly set.
  public var hasUserAppID: Bool {return self._userAppID != nil}
  /// Clears the value of `userAppID`. Subsequent reads from it will return its default value.
  public mutating func clearUserAppID() {self._userAppID = nil}

  /// The body of the request.
  public var appQuery: Clarifai_Api_AppQuery {
    get {return _appQuery ?? Clarifai_Api_AppQuery()}
    set {_appQuery = newValue}
  }
  /// Returns true if `appQuery` has been explicitly set.
  public var hasAppQuery: Bool {return self._appQuery != nil}
  /// Clears the value of `appQuery`. Subsequent reads from it will return its default value.
  public mutating func clearAppQuery() {self._appQuery = nil}

  /// Pagination parameters here since there are no url args in this
  /// POST request.
  public var pagination: Clarifai_Api_Pagination {
    get {return _pagination ?? Clarifai_Api_Pagination()}
    set {_pagination = newValue}
  }
  /// Returns true if `pagination` has been explicitly set.
  public var hasPagination: Bool {return self._pagination != nil}
  /// Clears the value of `pagination`. Subsequent reads from it will return its default value.
  public mutating func clearPagination() {self._pagination = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _userAppID: Clarifai_Api_UserAppIDSet? = nil
  fileprivate var _appQuery: Clarifai_Api_AppQuery? = nil
  fileprivate var _pagination: Clarifai_Api_Pagination? = nil
}

/// SingleAppResponse
public struct Clarifai_Api_SingleAppResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var status: Clarifai_Api_Status_Status {
    get {return _status ?? Clarifai_Api_Status_Status()}
    set {_status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  public var hasStatus: Bool {return self._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  public mutating func clearStatus() {self._status = nil}

  public var app: Clarifai_Api_App {
    get {return _app ?? Clarifai_Api_App()}
    set {_app = newValue}
  }
  /// Returns true if `app` has been explicitly set.
  public var hasApp: Bool {return self._app != nil}
  /// Clears the value of `app`. Subsequent reads from it will return its default value.
  public mutating func clearApp() {self._app = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _status: Clarifai_Api_Status_Status? = nil
  fileprivate var _app: Clarifai_Api_App? = nil
}

/// MultiAppResponse
public struct Clarifai_Api_MultiAppResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var status: Clarifai_Api_Status_Status {
    get {return _status ?? Clarifai_Api_Status_Status()}
    set {_status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  public var hasStatus: Bool {return self._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  public mutating func clearStatus() {self._status = nil}

  public var apps: [Clarifai_Api_App] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _status: Clarifai_Api_Status_Status? = nil
}

/// ListCollaboratorsRequest
public struct Clarifai_Api_ListCollaboratorsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var userAppID: Clarifai_Api_UserAppIDSet {
    get {return _userAppID ?? Clarifai_Api_UserAppIDSet()}
    set {_userAppID = newValue}
  }
  /// Returns true if `userAppID` has been explicitly set.
  public var hasUserAppID: Bool {return self._userAppID != nil}
  /// Clears the value of `userAppID`. Subsequent reads from it will return its default value.
  public mutating func clearUserAppID() {self._userAppID = nil}

  /// Set this flag to list both deleted and not deleted collaborators
  /// by default it's listing only not deleted collaborators
  public var listAllCollaborators: Bool = false

  /// (optional URL parameter) The page number. Pagination is used to split the results into chunks.
  /// Defaults to 1.
  public var page: UInt32 = 0

  /// (optional URL parameter) The number of results that will be contained in each page. Defaults
  /// to 128.
  public var perPage: UInt32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _userAppID: Clarifai_Api_UserAppIDSet? = nil
}

/// PostCollaboratorsRequest
public struct Clarifai_Api_PostCollaboratorsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var userAppID: Clarifai_Api_UserAppIDSet {
    get {return _userAppID ?? Clarifai_Api_UserAppIDSet()}
    set {_userAppID = newValue}
  }
  /// Returns true if `userAppID` has been explicitly set.
  public var hasUserAppID: Bool {return self._userAppID != nil}
  /// Clears the value of `userAppID`. Subsequent reads from it will return its default value.
  public mutating func clearUserAppID() {self._userAppID = nil}

  public var collaborators: [Clarifai_Api_Collaborator] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _userAppID: Clarifai_Api_UserAppIDSet? = nil
}

/// PatchCollaboratorsRequest
public struct Clarifai_Api_PatchCollaboratorsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var userAppID: Clarifai_Api_UserAppIDSet {
    get {return _userAppID ?? Clarifai_Api_UserAppIDSet()}
    set {_userAppID = newValue}
  }
  /// Returns true if `userAppID` has been explicitly set.
  public var hasUserAppID: Bool {return self._userAppID != nil}
  /// Clears the value of `userAppID`. Subsequent reads from it will return its default value.
  public mutating func clearUserAppID() {self._userAppID = nil}

  public var collaborators: [Clarifai_Api_Collaborator] = []

  /// The action to perform on the patched objects
  /// For now only action 'overwrite' is supported
  public var action: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _userAppID: Clarifai_Api_UserAppIDSet? = nil
}

/// DeleteCollaboratorsRequest
public struct Clarifai_Api_DeleteCollaboratorsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var userAppID: Clarifai_Api_UserAppIDSet {
    get {return _userAppID ?? Clarifai_Api_UserAppIDSet()}
    set {_userAppID = newValue}
  }
  /// Returns true if `userAppID` has been explicitly set.
  public var hasUserAppID: Bool {return self._userAppID != nil}
  /// Clears the value of `userAppID`. Subsequent reads from it will return its default value.
  public mutating func clearUserAppID() {self._userAppID = nil}

  public var collaboratorIds: [String] = []

  public var userEmails: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _userAppID: Clarifai_Api_UserAppIDSet? = nil
}

/// MultiCollaboratorsResponse
public struct Clarifai_Api_MultiCollaboratorsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var status: Clarifai_Api_Status_Status {
    get {return _status ?? Clarifai_Api_Status_Status()}
    set {_status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  public var hasStatus: Bool {return self._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  public mutating func clearStatus() {self._status = nil}

  public var collaborators: [Clarifai_Api_Collaborator] = []

  /// The owner of the application.
  ///
  /// When listing users that have access to the application, i.e. collaborators,
  /// it is often relevant to also include the application owner, so return
  /// their information here for convenience.
  ///
  /// Note: app_owner is only returned by ListCollaborators and only if the
  /// owner is a regular user, not an organization.
  public var appOwner: Clarifai_Api_User {
    get {return _appOwner ?? Clarifai_Api_User()}
    set {_appOwner = newValue}
  }
  /// Returns true if `appOwner` has been explicitly set.
  public var hasAppOwner: Bool {return self._appOwner != nil}
  /// Clears the value of `appOwner`. Subsequent reads from it will return its default value.
  public mutating func clearAppOwner() {self._appOwner = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _status: Clarifai_Api_Status_Status? = nil
  fileprivate var _appOwner: Clarifai_Api_User? = nil
}

/// ListCollaborationsRequest
public struct Clarifai_Api_ListCollaborationsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var userAppID: Clarifai_Api_UserAppIDSet {
    get {return _userAppID ?? Clarifai_Api_UserAppIDSet()}
    set {_userAppID = newValue}
  }
  /// Returns true if `userAppID` has been explicitly set.
  public var hasUserAppID: Bool {return self._userAppID != nil}
  /// Clears the value of `userAppID`. Subsequent reads from it will return its default value.
  public mutating func clearUserAppID() {self._userAppID = nil}

  /// (optional URL parameter) The page number. Pagination is used to split the results into chunks.
  /// Defaults to 1.
  public var page: UInt32 = 0

  /// (optional URL parameter) The number of results that will be contained in each page. Defaults
  /// to 128.
  public var perPage: UInt32 = 0

  /// Filtering options:
  /// If true, we only return collaborations on apps that are marked as a template by the app owner.
  public var templateOnly: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _userAppID: Clarifai_Api_UserAppIDSet? = nil
}

/// MultiCollaborationsResponse
public struct Clarifai_Api_MultiCollaborationsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var status: Clarifai_Api_Status_Status {
    get {return _status ?? Clarifai_Api_Status_Status()}
    set {_status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  public var hasStatus: Bool {return self._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  public mutating func clearStatus() {self._status = nil}

  public var collaborations: [Clarifai_Api_Collaboration] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _status: Clarifai_Api_Status_Status? = nil
}

/// GetStatusCodeRequest
public struct Clarifai_Api_GetStatusCodeRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var statusCodeID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// ListStatusCodesRequest
public struct Clarifai_Api_ListStatusCodesRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// SingleStatusCodeResponse
public struct Clarifai_Api_SingleStatusCodeResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Status of this request.
  public var status: Clarifai_Api_Status_Status {
    get {return _status ?? Clarifai_Api_Status_Status()}
    set {_status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  public var hasStatus: Bool {return self._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  public mutating func clearStatus() {self._status = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _status: Clarifai_Api_Status_Status? = nil
}

/// MultiStatusCodeResponse
public struct Clarifai_Api_MultiStatusCodeResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var status: Clarifai_Api_Status_Status {
    get {return _status ?? Clarifai_Api_Status_Status()}
    set {_status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  public var hasStatus: Bool {return self._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  public mutating func clearStatus() {self._status = nil}

  public var statuses: [Clarifai_Api_Status_Status] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _status: Clarifai_Api_Status_Status? = nil
}

/// GetConceptRequest
public struct Clarifai_Api_GetConceptRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var userAppID: Clarifai_Api_UserAppIDSet {
    get {return _userAppID ?? Clarifai_Api_UserAppIDSet()}
    set {_userAppID = newValue}
  }
  /// Returns true if `userAppID` has been explicitly set.
  public var hasUserAppID: Bool {return self._userAppID != nil}
  /// Clears the value of `userAppID`. Subsequent reads from it will return its default value.
  public mutating func clearUserAppID() {self._userAppID = nil}

  /// The concept's id.
  public var conceptID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _userAppID: Clarifai_Api_UserAppIDSet? = nil
}

/// ListConceptsRequest
public struct Clarifai_Api_ListConceptsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var userAppID: Clarifai_Api_UserAppIDSet {
    get {return _userAppID ?? Clarifai_Api_UserAppIDSet()}
    set {_userAppID = newValue}
  }
  /// Returns true if `userAppID` has been explicitly set.
  public var hasUserAppID: Bool {return self._userAppID != nil}
  /// Clears the value of `userAppID`. Subsequent reads from it will return its default value.
  public mutating func clearUserAppID() {self._userAppID = nil}

  /// (optional URL parameter) The page number. Pagination is used to split the results into chunks.
  /// Defaults to 1.
  public var page: UInt32 = 0

  /// (optional URL parameter) The number of results that will be contained in each page. Defaults
  /// to 128.
  public var perPage: UInt32 = 0

  /// Fuzzy match on concept ID
  public var id: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _userAppID: Clarifai_Api_UserAppIDSet? = nil
}

/// ListModelConceptsRequest
public struct Clarifai_Api_ListModelConceptsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var userAppID: Clarifai_Api_UserAppIDSet {
    get {return _userAppID ?? Clarifai_Api_UserAppIDSet()}
    set {_userAppID = newValue}
  }
  /// Returns true if `userAppID` has been explicitly set.
  public var hasUserAppID: Bool {return self._userAppID != nil}
  /// Clears the value of `userAppID`. Subsequent reads from it will return its default value.
  public mutating func clearUserAppID() {self._userAppID = nil}

  /// Model id
  public var modelID: String = String()

  /// Model version Id. Optional, if not provided latest model version is used.
  public var versionID: String = String()

  /// (optional URL parameter) The page number. Pagination is used to split the results into chunks.
  /// Defaults to 1.
  public var page: UInt32 = 0

  /// (optional URL parameter) The number of results that will be contained in each page. Defaults
  /// to 128.
  public var perPage: UInt32 = 0

  /// Searching options:
  /// Specify a search parameter in order to perform keyword search on the
  /// following fields of the concept:
  ///   - id
  ///   - name
  ///
  /// Keywords are used for partial prefix-matching (so searching for "larif" matches "clarifai").
  ///
  /// NOTE: Both the list of fields searched and the exact keyword matching
  /// rules are subject to change and not guaranteed to be backwards-compatible.
  public var search: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _userAppID: Clarifai_Api_UserAppIDSet? = nil
}

/// PostConceptsSearchesRequest
public struct Clarifai_Api_PostConceptsSearchesRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Ids present in the url of the request.
  public var userAppID: Clarifai_Api_UserAppIDSet {
    get {return _userAppID ?? Clarifai_Api_UserAppIDSet()}
    set {_userAppID = newValue}
  }
  /// Returns true if `userAppID` has been explicitly set.
  public var hasUserAppID: Bool {return self._userAppID != nil}
  /// Clears the value of `userAppID`. Subsequent reads from it will return its default value.
  public mutating func clearUserAppID() {self._userAppID = nil}

  /// The body of the request.
  public var conceptQuery: Clarifai_Api_ConceptQuery {
    get {return _conceptQuery ?? Clarifai_Api_ConceptQuery()}
    set {_conceptQuery = newValue}
  }
  /// Returns true if `conceptQuery` has been explicitly set.
  public var hasConceptQuery: Bool {return self._conceptQuery != nil}
  /// Clears the value of `conceptQuery`. Subsequent reads from it will return its default value.
  public mutating func clearConceptQuery() {self._conceptQuery = nil}

  /// Request additional info to be retrieved for each concept in the response.
  public var extraInfo: Clarifai_Api_ConceptExtraInfoRequest {
    get {return _extraInfo ?? Clarifai_Api_ConceptExtraInfoRequest()}
    set {_extraInfo = newValue}
  }
  /// Returns true if `extraInfo` has been explicitly set.
  public var hasExtraInfo: Bool {return self._extraInfo != nil}
  /// Clears the value of `extraInfo`. Subsequent reads from it will return its default value.
  public mutating func clearExtraInfo() {self._extraInfo = nil}

  /// Pagination parameters here since there are no url args in this
  /// POST request.
  public var pagination: Clarifai_Api_Pagination {
    get {return _pagination ?? Clarifai_Api_Pagination()}
    set {_pagination = newValue}
  }
  /// Returns true if `pagination` has been explicitly set.
  public var hasPagination: Bool {return self._pagination != nil}
  /// Clears the value of `pagination`. Subsequent reads from it will return its default value.
  public mutating func clearPagination() {self._pagination = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _userAppID: Clarifai_Api_UserAppIDSet? = nil
  fileprivate var _conceptQuery: Clarifai_Api_ConceptQuery? = nil
  fileprivate var _extraInfo: Clarifai_Api_ConceptExtraInfoRequest? = nil
  fileprivate var _pagination: Clarifai_Api_Pagination? = nil
}

public struct Clarifai_Api_ConceptExtraInfoRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Determine if the concept is searchable by rank using this model.
  /// Currently, only embedder models are supported.
  /// ########## Supported fields ##########
  /// - app_id
  /// - id
  /// - model_version.id
  /// - user_id
  public var rankableModel: Clarifai_Api_Model {
    get {return _rankableModel ?? Clarifai_Api_Model()}
    set {_rankableModel = newValue}
  }
  /// Returns true if `rankableModel` has been explicitly set.
  public var hasRankableModel: Bool {return self._rankableModel != nil}
  /// Clears the value of `rankableModel`. Subsequent reads from it will return its default value.
  public mutating func clearRankableModel() {self._rankableModel = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _rankableModel: Clarifai_Api_Model? = nil
}

/// PostConceptsRequest
public struct Clarifai_Api_PostConceptsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var userAppID: Clarifai_Api_UserAppIDSet {
    get {return _userAppID ?? Clarifai_Api_UserAppIDSet()}
    set {_userAppID = newValue}
  }
  /// Returns true if `userAppID` has been explicitly set.
  public var hasUserAppID: Bool {return self._userAppID != nil}
  /// Clears the value of `userAppID`. Subsequent reads from it will return its default value.
  public mutating func clearUserAppID() {self._userAppID = nil}

  /// The concepts to add.
  public var concepts: [Clarifai_Api_Concept] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _userAppID: Clarifai_Api_UserAppIDSet? = nil
}

/// PatchConceptsRequest
public struct Clarifai_Api_PatchConceptsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var userAppID: Clarifai_Api_UserAppIDSet {
    get {return _userAppID ?? Clarifai_Api_UserAppIDSet()}
    set {_userAppID = newValue}
  }
  /// Returns true if `userAppID` has been explicitly set.
  public var hasUserAppID: Bool {return self._userAppID != nil}
  /// Clears the value of `userAppID`. Subsequent reads from it will return its default value.
  public mutating func clearUserAppID() {self._userAppID = nil}

  /// The concepts to patch.
  public var concepts: [Clarifai_Api_Concept] = []

  /// The action to perform on the patched objects
  /// For now ony action 'overwrite' is supported
  public var action: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _userAppID: Clarifai_Api_UserAppIDSet? = nil
}

/// GetConceptCountsRequest
public struct Clarifai_Api_GetConceptCountsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var userAppID: Clarifai_Api_UserAppIDSet {
    get {return _userAppID ?? Clarifai_Api_UserAppIDSet()}
    set {_userAppID = newValue}
  }
  /// Returns true if `userAppID` has been explicitly set.
  public var hasUserAppID: Bool {return self._userAppID != nil}
  /// Clears the value of `userAppID`. Subsequent reads from it will return its default value.
  public mutating func clearUserAppID() {self._userAppID = nil}

  /// (optional URL parameter) The page number. Pagination is used to split the results into chunks.
  /// Defaults to 1.
  public var page: UInt32 = 0

  /// (optional URL parameter) The number of results that will be contained in each page. Defaults
  /// to 128.
  public var perPage: UInt32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _userAppID: Clarifai_Api_UserAppIDSet? = nil
}

/// SingleConceptResponse
public struct Clarifai_Api_SingleConceptResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The response status.
  public var status: Clarifai_Api_Status_Status {
    get {return _status ?? Clarifai_Api_Status_Status()}
    set {_status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  public var hasStatus: Bool {return self._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  public mutating func clearStatus() {self._status = nil}

  /// The returned concept.
  public var concept: Clarifai_Api_Concept {
    get {return _concept ?? Clarifai_Api_Concept()}
    set {_concept = newValue}
  }
  /// Returns true if `concept` has been explicitly set.
  public var hasConcept: Bool {return self._concept != nil}
  /// Clears the value of `concept`. Subsequent reads from it will return its default value.
  public mutating func clearConcept() {self._concept = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _status: Clarifai_Api_Status_Status? = nil
  fileprivate var _concept: Clarifai_Api_Concept? = nil
}

/// MultiConceptResponse
public struct Clarifai_Api_MultiConceptResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The response status.
  public var status: Clarifai_Api_Status_Status {
    get {return _status ?? Clarifai_Api_Status_Status()}
    set {_status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  public var hasStatus: Bool {return self._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  public mutating func clearStatus() {self._status = nil}

  /// The returned concepts.
  public var concepts: [Clarifai_Api_Concept] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _status: Clarifai_Api_Status_Status? = nil
}

/// MultiConceptCountResponse
public struct Clarifai_Api_MultiConceptCountResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The response status.
  public var status: Clarifai_Api_Status_Status {
    get {return _status ?? Clarifai_Api_Status_Status()}
    set {_status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  public var hasStatus: Bool {return self._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  public mutating func clearStatus() {self._status = nil}

  /// The returned concept counts.
  public var conceptCounts: [Clarifai_Api_ConceptCount] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _status: Clarifai_Api_Status_Status? = nil
}

/// GET all relations such that the concept_id refers to the subject of the relation
public struct Clarifai_Api_ListConceptRelationsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The user_id and app_id information.
  public var userAppID: Clarifai_Api_UserAppIDSet {
    get {return _userAppID ?? Clarifai_Api_UserAppIDSet()}
    set {_userAppID = newValue}
  }
  /// Returns true if `userAppID` has been explicitly set.
  public var hasUserAppID: Bool {return self._userAppID != nil}
  /// Clears the value of `userAppID`. Subsequent reads from it will return its default value.
  public mutating func clearUserAppID() {self._userAppID = nil}

  /// The subject concept id in your app to get all the relationships for.
  /// Leave as an empty string (GET /concepts/relations) to list ALL the relations in the app.
  ///
  /// When listing all the relations it will only return one direction of the relationship
  /// with the predicate acting on the subject and not the inverse like is done when providing a
  /// concept_id so that we can return a reliable page size always.
  ///
  /// When providing a concept_id, if a hyponym is present in the DB such as:
  /// 'honey' (subject), 'hyponym' (predicate for "is a kind of"), 'food' (object)
  /// then you can list the concept relations for 'honey' and get hyponym predicate with 'food'
  /// object.
  /// But you can also list the concept relations for 'food' and it will return the same hyponym
  /// relationship with 'honey' as object and 'hypernym' as predicate.
  /// Synonyms by nature are symmetrical relationships so either side can be the concept_id (subject)
  /// when listing the relations.
  public var conceptID: String = String()

  /// If predicate is provided then only list relations with that predicate.
  ///
  /// Note that if no subject is set in concept_id and predicate is set to
  /// 'hypernym', then it will return any stored hyponyms as hypernyms with
  /// just the subject and object swapped since they are reversed relations.
  ///
  /// Valid predicates are:
  /// - 'hypernym'
  /// - 'hyponym'
  /// - 'synonym'
  public var predicate: String = String()

  /// If knowledge_graph_id is provided then just list relations from that knowledge graph.
  /// If not provided then list relations from all knowledge graphs including the global one for this
  /// app one (ie. knowledge_graph "") and any specific ones in the app.
  public var knowledgeGraphID: String = String()

  /// (optional URL parameter) The page number. Pagination is used to split the results into chunks.
  /// Defaults to 1.
  public var page: UInt32 = 0

  /// (optional URL parameter) The number of results that will be contained in each page. Defaults
  /// to 128.
  public var perPage: UInt32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _userAppID: Clarifai_Api_UserAppIDSet? = nil
}

/// POST new concept relations
public struct Clarifai_Api_PostConceptRelationsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The user_id and app_id information.
  public var userAppID: Clarifai_Api_UserAppIDSet {
    get {return _userAppID ?? Clarifai_Api_UserAppIDSet()}
    set {_userAppID = newValue}
  }
  /// Returns true if `userAppID` has been explicitly set.
  public var hasUserAppID: Bool {return self._userAppID != nil}
  /// Clears the value of `userAppID`. Subsequent reads from it will return its default value.
  public mutating func clearUserAppID() {self._userAppID = nil}

  /// The subject concept id you're going to add relations for.
  public var conceptID: String = String()

  /// The relationships you're going to add.
  public var conceptRelations: [Clarifai_Api_ConceptRelation] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _userAppID: Clarifai_Api_UserAppIDSet? = nil
}

/// DELETE concept relations
public struct Clarifai_Api_DeleteConceptRelationsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The user_id and app_id information.
  public var userAppID: Clarifai_Api_UserAppIDSet {
    get {return _userAppID ?? Clarifai_Api_UserAppIDSet()}
    set {_userAppID = newValue}
  }
  /// Returns true if `userAppID` has been explicitly set.
  public var hasUserAppID: Bool {return self._userAppID != nil}
  /// Clears the value of `userAppID`. Subsequent reads from it will return its default value.
  public mutating func clearUserAppID() {self._userAppID = nil}

  /// The concept to delete relationship for.
  public var conceptID: String = String()

  /// The concept relationship ids to delete.
  public var ids: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _userAppID: Clarifai_Api_UserAppIDSet? = nil
}

/// GET all knowledge graphs
public struct Clarifai_Api_ListKnowledgeGraphsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The user_id and app_id information.
  public var userAppID: Clarifai_Api_UserAppIDSet {
    get {return _userAppID ?? Clarifai_Api_UserAppIDSet()}
    set {_userAppID = newValue}
  }
  /// Returns true if `userAppID` has been explicitly set.
  public var hasUserAppID: Bool {return self._userAppID != nil}
  /// Clears the value of `userAppID`. Subsequent reads from it will return its default value.
  public mutating func clearUserAppID() {self._userAppID = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _userAppID: Clarifai_Api_UserAppIDSet? = nil
}

/// POST new knowledge graphs
public struct Clarifai_Api_PostKnowledgeGraphsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The user_id and app_id information.
  public var userAppID: Clarifai_Api_UserAppIDSet {
    get {return _userAppID ?? Clarifai_Api_UserAppIDSet()}
    set {_userAppID = newValue}
  }
  /// Returns true if `userAppID` has been explicitly set.
  public var hasUserAppID: Bool {return self._userAppID != nil}
  /// Clears the value of `userAppID`. Subsequent reads from it will return its default value.
  public mutating func clearUserAppID() {self._userAppID = nil}

  public var knowledgeGraphs: [Clarifai_Api_KnowledgeGraph] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _userAppID: Clarifai_Api_UserAppIDSet? = nil
}

/// MultiConceptRelationResponse
public struct Clarifai_Api_MultiConceptRelationResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The response status.
  public var status: Clarifai_Api_Status_Status {
    get {return _status ?? Clarifai_Api_Status_Status()}
    set {_status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  public var hasStatus: Bool {return self._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  public mutating func clearStatus() {self._status = nil}

  /// The returned concept relations.
  public var conceptRelations: [Clarifai_Api_ConceptRelation] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _status: Clarifai_Api_Status_Status? = nil
}

/// MultiKnowledgeGraphResponse
public struct Clarifai_Api_MultiKnowledgeGraphResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The response status.
  public var status: Clarifai_Api_Status_Status {
    get {return _status ?? Clarifai_Api_Status_Status()}
    set {_status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  public var hasStatus: Bool {return self._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  public mutating func clearStatus() {self._status = nil}

  /// The returned knowledge graphs.
  public var knowledgeGraphs: [Clarifai_Api_KnowledgeGraph] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _status: Clarifai_Api_Status_Status? = nil
}

/// GET single concept language for the given concept.
public struct Clarifai_Api_GetConceptLanguageRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var userAppID: Clarifai_Api_UserAppIDSet {
    get {return _userAppID ?? Clarifai_Api_UserAppIDSet()}
    set {_userAppID = newValue}
  }
  /// Returns true if `userAppID` has been explicitly set.
  public var hasUserAppID: Bool {return self._userAppID != nil}
  /// Clears the value of `userAppID`. Subsequent reads from it will return its default value.
  public mutating func clearUserAppID() {self._userAppID = nil}

  public var conceptID: String = String()

  /// This is the language identifier.
  public var language: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _userAppID: Clarifai_Api_UserAppIDSet? = nil
}

/// List multiple concept languages for the given concept.
public struct Clarifai_Api_ListConceptLanguagesRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var userAppID: Clarifai_Api_UserAppIDSet {
    get {return _userAppID ?? Clarifai_Api_UserAppIDSet()}
    set {_userAppID = newValue}
  }
  /// Returns true if `userAppID` has been explicitly set.
  public var hasUserAppID: Bool {return self._userAppID != nil}
  /// Clears the value of `userAppID`. Subsequent reads from it will return its default value.
  public mutating func clearUserAppID() {self._userAppID = nil}

  public var conceptID: String = String()

  /// (optional URL parameter) The page number. Pagination is used to split the results into chunks.
  /// Defaults to 1.
  public var page: UInt32 = 0

  /// (optional URL parameter) The number of results that will be contained in each page. Defaults
  /// to 128.
  public var perPage: UInt32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _userAppID: Clarifai_Api_UserAppIDSet? = nil
}

/// PATCH multiple concept languages for the given concept.
public struct Clarifai_Api_PatchConceptLanguagesRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var userAppID: Clarifai_Api_UserAppIDSet {
    get {return _userAppID ?? Clarifai_Api_UserAppIDSet()}
    set {_userAppID = newValue}
  }
  /// Returns true if `userAppID` has been explicitly set.
  public var hasUserAppID: Bool {return self._userAppID != nil}
  /// Clears the value of `userAppID`. Subsequent reads from it will return its default value.
  public mutating func clearUserAppID() {self._userAppID = nil}

  public var conceptID: String = String()

  public var conceptLanguages: [Clarifai_Api_ConceptLanguage] = []

  /// The action to perform with the objects in the PATCH.
  public var action: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _userAppID: Clarifai_Api_UserAppIDSet? = nil
}

/// POST multiple concept languages for the given concept.
public struct Clarifai_Api_PostConceptLanguagesRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var userAppID: Clarifai_Api_UserAppIDSet {
    get {return _userAppID ?? Clarifai_Api_UserAppIDSet()}
    set {_userAppID = newValue}
  }
  /// Returns true if `userAppID` has been explicitly set.
  public var hasUserAppID: Bool {return self._userAppID != nil}
  /// Clears the value of `userAppID`. Subsequent reads from it will return its default value.
  public mutating func clearUserAppID() {self._userAppID = nil}

  public var conceptID: String = String()

  public var conceptLanguages: [Clarifai_Api_ConceptLanguage] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _userAppID: Clarifai_Api_UserAppIDSet? = nil
}

/// SingleConceptLanguageResponse
public struct Clarifai_Api_SingleConceptLanguageResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var status: Clarifai_Api_Status_Status {
    get {return _status ?? Clarifai_Api_Status_Status()}
    set {_status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  public var hasStatus: Bool {return self._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  public mutating func clearStatus() {self._status = nil}

  public var conceptLanguage: Clarifai_Api_ConceptLanguage {
    get {return _conceptLanguage ?? Clarifai_Api_ConceptLanguage()}
    set {_conceptLanguage = newValue}
  }
  /// Returns true if `conceptLanguage` has been explicitly set.
  public var hasConceptLanguage: Bool {return self._conceptLanguage != nil}
  /// Clears the value of `conceptLanguage`. Subsequent reads from it will return its default value.
  public mutating func clearConceptLanguage() {self._conceptLanguage = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _status: Clarifai_Api_Status_Status? = nil
  fileprivate var _conceptLanguage: Clarifai_Api_ConceptLanguage? = nil
}

/// MultiConceptLanguageResponse
public struct Clarifai_Api_MultiConceptLanguageResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var status: Clarifai_Api_Status_Status {
    get {return _status ?? Clarifai_Api_Status_Status()}
    set {_status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  public var hasStatus: Bool {return self._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  public mutating func clearStatus() {self._status = nil}

  public var conceptLanguages: [Clarifai_Api_ConceptLanguage] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _status: Clarifai_Api_Status_Status? = nil
}

/// GetInputRequest
public struct Clarifai_Api_GetInputRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var userAppID: Clarifai_Api_UserAppIDSet {
    get {return _userAppID ?? Clarifai_Api_UserAppIDSet()}
    set {_userAppID = newValue}
  }
  /// Returns true if `userAppID` has been explicitly set.
  public var hasUserAppID: Bool {return self._userAppID != nil}
  /// Clears the value of `userAppID`. Subsequent reads from it will return its default value.
  public mutating func clearUserAppID() {self._userAppID = nil}

  public var inputID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _userAppID: Clarifai_Api_UserAppIDSet? = nil
}

public struct Clarifai_Api_GetVideoManifestRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var userAppID: Clarifai_Api_UserAppIDSet {
    get {return _userAppID ?? Clarifai_Api_UserAppIDSet()}
    set {_userAppID = newValue}
  }
  /// Returns true if `userAppID` has been explicitly set.
  public var hasUserAppID: Bool {return self._userAppID != nil}
  /// Clears the value of `userAppID`. Subsequent reads from it will return its default value.
  public mutating func clearUserAppID() {self._userAppID = nil}

  public var inputID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _userAppID: Clarifai_Api_UserAppIDSet? = nil
}

/// GetInputSamplesRequest
public struct Clarifai_Api_GetInputSamplesRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var userAppID: Clarifai_Api_UserAppIDSet {
    get {return _userAppID ?? Clarifai_Api_UserAppIDSet()}
    set {_userAppID = newValue}
  }
  /// Returns true if `userAppID` has been explicitly set.
  public var hasUserAppID: Bool {return self._userAppID != nil}
  /// Clears the value of `userAppID`. Subsequent reads from it will return its default value.
  public mutating func clearUserAppID() {self._userAppID = nil}

  public var taskID: String = String()

  /// URL param. If zero ids provided, returns for all task labelers
  public var userIds: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _userAppID: Clarifai_Api_UserAppIDSet? = nil
}

/// ListInputsRequest
public struct Clarifai_Api_ListInputsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var userAppID: Clarifai_Api_UserAppIDSet {
    get {return _storage._userAppID ?? Clarifai_Api_UserAppIDSet()}
    set {_uniqueStorage()._userAppID = newValue}
  }
  /// Returns true if `userAppID` has been explicitly set.
  public var hasUserAppID: Bool {return _storage._userAppID != nil}
  /// Clears the value of `userAppID`. Subsequent reads from it will return its default value.
  public mutating func clearUserAppID() {_uniqueStorage()._userAppID = nil}

  /// (optional URL parameter) The page number. Pagination is used to split the results into chunks.
  /// Defaults to 1.
  public var page: UInt32 {
    get {return _storage._page}
    set {_uniqueStorage()._page = newValue}
  }

  /// (optional URL parameter) The number of results that will be contained in each page. Defaults
  /// to 128.
  public var perPage: UInt32 {
    get {return _storage._perPage}
    set {_uniqueStorage()._perPage = newValue}
  }

  /// Set status to filter by status
  public var status: Clarifai_Api_Status_Status {
    get {return _storage._status ?? Clarifai_Api_Status_Status()}
    set {_uniqueStorage()._status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  public var hasStatus: Bool {return _storage._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  public mutating func clearStatus() {_uniqueStorage()._status = nil}

  public var ids: [String] {
    get {return _storage._ids}
    set {_uniqueStorage()._ids = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// StreamInputsRequest
public struct Clarifai_Api_StreamInputsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var userAppID: Clarifai_Api_UserAppIDSet {
    get {return _userAppID ?? Clarifai_Api_UserAppIDSet()}
    set {_userAppID = newValue}
  }
  /// Returns true if `userAppID` has been explicitly set.
  public var hasUserAppID: Bool {return self._userAppID != nil}
  /// Clears the value of `userAppID`. Subsequent reads from it will return its default value.
  public mutating func clearUserAppID() {self._userAppID = nil}

  /// (optional URL parameter) The number of results that will be contained in each page. Defaults
  /// to 20.
  public var perPage: UInt32 = 0

  public var lastID: String = String()

  /// By default, the endpoint return inputs by the time when it is added.
  /// If this is set to true, we will return inputs by id.
  public var orderByID: Bool = false

  public var descending: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _userAppID: Clarifai_Api_UserAppIDSet? = nil
}

/// PostInputsRequest
public struct Clarifai_Api_PostInputsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var userAppID: Clarifai_Api_UserAppIDSet {
    get {return _userAppID ?? Clarifai_Api_UserAppIDSet()}
    set {_userAppID = newValue}
  }
  /// Returns true if `userAppID` has been explicitly set.
  public var hasUserAppID: Bool {return self._userAppID != nil}
  /// Clears the value of `userAppID`. Subsequent reads from it will return its default value.
  public mutating func clearUserAppID() {self._userAppID = nil}

  /// List of inputs to post.
  /// For each input, the following fields are used:
  /// * id
  /// * data
  /// * dataset_ids
  public var inputs: [Clarifai_Api_Input] = []

  /// Collect statistics about created inputs in job with given ID.
  /// * If job ID is empty, then job is not created.
  /// * If job ID is non-empty and doesn't already exist, then a new job will be created with given ID.
  /// * If job ID does already exist, then new inputs statistics are merged with previous inputs statistics.
  public var inputsAddJobID: String = String()

  /// How to handle input ID conflicts.
  public var inputIDConflictResolution: Clarifai_Api_InputIDConflictResolution = .notSet

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _userAppID: Clarifai_Api_UserAppIDSet? = nil
}

/// PatchInputsRequest
public struct Clarifai_Api_PatchInputsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var userAppID: Clarifai_Api_UserAppIDSet {
    get {return _userAppID ?? Clarifai_Api_UserAppIDSet()}
    set {_userAppID = newValue}
  }
  /// Returns true if `userAppID` has been explicitly set.
  public var hasUserAppID: Bool {return self._userAppID != nil}
  /// Clears the value of `userAppID`. Subsequent reads from it will return its default value.
  public mutating func clearUserAppID() {self._userAppID = nil}

  /// List of inputs to patch.
  /// Inputs are identified by id field.
  /// For each input, the following fields are patchable:
  /// * data
  public var inputs: [Clarifai_Api_Input] = []

  /// The action to perform on the patched objects
  /// For now actions 'merge', 'overwrite', and 'remove' are supported
  public var action: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _userAppID: Clarifai_Api_UserAppIDSet? = nil
}

/// DeleteInputRequest
public struct Clarifai_Api_DeleteInputRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var userAppID: Clarifai_Api_UserAppIDSet {
    get {return _userAppID ?? Clarifai_Api_UserAppIDSet()}
    set {_userAppID = newValue}
  }
  /// Returns true if `userAppID` has been explicitly set.
  public var hasUserAppID: Bool {return self._userAppID != nil}
  /// Clears the value of `userAppID`. Subsequent reads from it will return its default value.
  public mutating func clearUserAppID() {self._userAppID = nil}

  public var inputID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _userAppID: Clarifai_Api_UserAppIDSet? = nil
}

/// Request to delete several things by the list of ids.
public struct Clarifai_Api_DeleteInputsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var userAppID: Clarifai_Api_UserAppIDSet {
    get {return _userAppID ?? Clarifai_Api_UserAppIDSet()}
    set {_userAppID = newValue}
  }
  /// Returns true if `userAppID` has been explicitly set.
  public var hasUserAppID: Bool {return self._userAppID != nil}
  /// Clears the value of `userAppID`. Subsequent reads from it will return its default value.
  public mutating func clearUserAppID() {self._userAppID = nil}

  public var ids: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _userAppID: Clarifai_Api_UserAppIDSet? = nil
}

/// SingleInputResponse
public struct Clarifai_Api_SingleInputResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var status: Clarifai_Api_Status_Status {
    get {return _status ?? Clarifai_Api_Status_Status()}
    set {_status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  public var hasStatus: Bool {return self._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  public mutating func clearStatus() {self._status = nil}

  public var input: Clarifai_Api_Input {
    get {return _input ?? Clarifai_Api_Input()}
    set {_input = newValue}
  }
  /// Returns true if `input` has been explicitly set.
  public var hasInput: Bool {return self._input != nil}
  /// Clears the value of `input`. Subsequent reads from it will return its default value.
  public mutating func clearInput() {self._input = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _status: Clarifai_Api_Status_Status? = nil
  fileprivate var _input: Clarifai_Api_Input? = nil
}

public struct Clarifai_Api_GetVideoManifestResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var status: Clarifai_Api_Status_Status {
    get {return _status ?? Clarifai_Api_Status_Status()}
    set {_status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  public var hasStatus: Bool {return self._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  public mutating func clearStatus() {self._status = nil}

  /// MPEG-dash manifest as data-URI, base64-encoded
  /// Can be empty if status is FAILED
  /// Can be fallback manifest if status is MIXED_STATUS
  public var manifestURL: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _status: Clarifai_Api_Status_Status? = nil
}

/// MultiInputResponse
public struct Clarifai_Api_MultiInputResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var status: Clarifai_Api_Status_Status {
    get {return _status ?? Clarifai_Api_Status_Status()}
    set {_status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  public var hasStatus: Bool {return self._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  public mutating func clearStatus() {self._status = nil}

  public var inputs: [Clarifai_Api_Input] = []

  public var inputsAddJob: Clarifai_Api_InputsAddJob {
    get {return _inputsAddJob ?? Clarifai_Api_InputsAddJob()}
    set {_inputsAddJob = newValue}
  }
  /// Returns true if `inputsAddJob` has been explicitly set.
  public var hasInputsAddJob: Bool {return self._inputsAddJob != nil}
  /// Clears the value of `inputsAddJob`. Subsequent reads from it will return its default value.
  public mutating func clearInputsAddJob() {self._inputsAddJob = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _status: Clarifai_Api_Status_Status? = nil
  fileprivate var _inputsAddJob: Clarifai_Api_InputsAddJob? = nil
}

/// MultiInputAnnotationResponse
public struct Clarifai_Api_MultiInputAnnotationResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var status: Clarifai_Api_Status_Status {
    get {return _status ?? Clarifai_Api_Status_Status()}
    set {_status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  public var hasStatus: Bool {return self._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  public mutating func clearStatus() {self._status = nil}

  public var hits: [Clarifai_Api_Hit] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _status: Clarifai_Api_Status_Status? = nil
}

/// SingleInputCountResponse
public struct Clarifai_Api_SingleInputCountResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var status: Clarifai_Api_Status_Status {
    get {return _storage._status ?? Clarifai_Api_Status_Status()}
    set {_uniqueStorage()._status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  public var hasStatus: Bool {return _storage._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  public mutating func clearStatus() {_uniqueStorage()._status = nil}

  public var counts: Clarifai_Api_InputCount {
    get {return _storage._counts ?? Clarifai_Api_InputCount()}
    set {_uniqueStorage()._counts = newValue}
  }
  /// Returns true if `counts` has been explicitly set.
  public var hasCounts: Bool {return _storage._counts != nil}
  /// Clears the value of `counts`. Subsequent reads from it will return its default value.
  public mutating func clearCounts() {_uniqueStorage()._counts = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// GetInputCountRequest
public struct Clarifai_Api_GetInputCountRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var userAppID: Clarifai_Api_UserAppIDSet {
    get {return _userAppID ?? Clarifai_Api_UserAppIDSet()}
    set {_userAppID = newValue}
  }
  /// Returns true if `userAppID` has been explicitly set.
  public var hasUserAppID: Bool {return self._userAppID != nil}
  /// Clears the value of `userAppID`. Subsequent reads from it will return its default value.
  public mutating func clearUserAppID() {self._userAppID = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _userAppID: Clarifai_Api_UserAppIDSet? = nil
}

/// ListDatasetsRequest
public struct Clarifai_Api_ListDatasetsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var userAppID: Clarifai_Api_UserAppIDSet {
    get {return _userAppID ?? Clarifai_Api_UserAppIDSet()}
    set {_userAppID = newValue}
  }
  /// Returns true if `userAppID` has been explicitly set.
  public var hasUserAppID: Bool {return self._userAppID != nil}
  /// Clears the value of `userAppID`. Subsequent reads from it will return its default value.
  public mutating func clearUserAppID() {self._userAppID = nil}

  /// (optional URL parameter) The page number. Pagination is used to split the results into chunks.
  /// Defaults to 1.
  public var page: UInt32 = 0

  /// (optional URL parameter) The number of results that will be contained in each page. Defaults
  /// to 128.
  public var perPage: UInt32 = 0

  public var additionalFields: [String] = []

  /// Sorting options:
  /// Whether to sort in ascending order. If false, will order in descending order.
  public var sortAscending: Bool = false

  public var sortBy: Clarifai_Api_ListDatasetsRequest.OneOf_SortBy? = nil

  /// Whether to order by the created_at time.
  public var sortByCreatedAt: Bool {
    get {
      if case .sortByCreatedAt(let v)? = sortBy {return v}
      return false
    }
    set {sortBy = .sortByCreatedAt(newValue)}
  }

  /// Whether to order by the number of users stared the app
  public var sortByStarCount: Bool {
    get {
      if case .sortByStarCount(let v)? = sortBy {return v}
      return false
    }
    set {sortBy = .sortByStarCount(newValue)}
  }

  /// If neither sort option is set to true, will sort by modified_at.
  public var sortByModifiedAt: Bool {
    get {
      if case .sortByModifiedAt(let v)? = sortBy {return v}
      return false
    }
    set {sortBy = .sortByModifiedAt(newValue)}
  }

  /// Whether to order by the external id
  public var sortByID: Bool {
    get {
      if case .sortByID(let v)? = sortBy {return v}
      return false
    }
    set {sortBy = .sortByID(newValue)}
  }

  /// Filtering options:
  public var starredOnly: Bool = false

  /// Filter datasets by bookmark. If set, only return bookmarked datasets. Otherwise none bookmarked datasets only.
  public var bookmark: Bool = false

  /// Searching options:
  /// Specify a search parameter in order to perform keyword search on the
  /// following fields of the dataset:
  ///   - id
  ///   - description
  ///   - notes
  ///   - user_id (unless user_app_id.user_id is already set)
  ///
  /// Keywords are both normalized for search (so searching for "satisfy" matches "satisfied")
  /// and used for partial prefix-matching (so searching for "clari" matches "clarifai").
  ///
  /// NOTE: Both the list of fields searched and the exact keyword matching
  /// rules are subject to change and not guaranteed to be backwards-compatible.
  public var search: String = String()

  /// Fuzzy filter on dataset ID
  /// Deprecated: use search instead.
  public var id: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_SortBy: Equatable {
    /// Whether to order by the created_at time.
    case sortByCreatedAt(Bool)
    /// Whether to order by the number of users stared the app
    case sortByStarCount(Bool)
    /// If neither sort option is set to true, will sort by modified_at.
    case sortByModifiedAt(Bool)
    /// Whether to order by the external id
    case sortByID(Bool)

  #if !swift(>=4.1)
    public static func ==(lhs: Clarifai_Api_ListDatasetsRequest.OneOf_SortBy, rhs: Clarifai_Api_ListDatasetsRequest.OneOf_SortBy) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.sortByCreatedAt, .sortByCreatedAt): return {
        guard case .sortByCreatedAt(let l) = lhs, case .sortByCreatedAt(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.sortByStarCount, .sortByStarCount): return {
        guard case .sortByStarCount(let l) = lhs, case .sortByStarCount(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.sortByModifiedAt, .sortByModifiedAt): return {
        guard case .sortByModifiedAt(let l) = lhs, case .sortByModifiedAt(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.sortByID, .sortByID): return {
        guard case .sortByID(let l) = lhs, case .sortByID(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}

  fileprivate var _userAppID: Clarifai_Api_UserAppIDSet? = nil
}

/// GetDatasetRequest
public struct Clarifai_Api_GetDatasetRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var userAppID: Clarifai_Api_UserAppIDSet {
    get {return _userAppID ?? Clarifai_Api_UserAppIDSet()}
    set {_userAppID = newValue}
  }
  /// Returns true if `userAppID` has been explicitly set.
  public var hasUserAppID: Bool {return self._userAppID != nil}
  /// Clears the value of `userAppID`. Subsequent reads from it will return its default value.
  public mutating func clearUserAppID() {self._userAppID = nil}

  /// Identify dataset by id.
  public var datasetID: String = String()

  public var additionalFields: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _userAppID: Clarifai_Api_UserAppIDSet? = nil
}

/// Request to add one or more datasets.
public struct Clarifai_Api_PostDatasetsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var userAppID: Clarifai_Api_UserAppIDSet {
    get {return _userAppID ?? Clarifai_Api_UserAppIDSet()}
    set {_userAppID = newValue}
  }
  /// Returns true if `userAppID` has been explicitly set.
  public var hasUserAppID: Bool {return self._userAppID != nil}
  /// Clears the value of `userAppID`. Subsequent reads from it will return its default value.
  public mutating func clearUserAppID() {self._userAppID = nil}

  /// List of datasets that are requested to be added.
  public var datasets: [Clarifai_Api_Dataset] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _userAppID: Clarifai_Api_UserAppIDSet? = nil
}

/// Request to patch several datasets.
public struct Clarifai_Api_PatchDatasetsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var userAppID: Clarifai_Api_UserAppIDSet {
    get {return _userAppID ?? Clarifai_Api_UserAppIDSet()}
    set {_userAppID = newValue}
  }
  /// Returns true if `userAppID` has been explicitly set.
  public var hasUserAppID: Bool {return self._userAppID != nil}
  /// Clears the value of `userAppID`. Subsequent reads from it will return its default value.
  public mutating func clearUserAppID() {self._userAppID = nil}

  /// List of datasets that are requested to be updated.
  public var datasets: [Clarifai_Api_Dataset] = []

  /// The action to perform on the patched objects
  /// Supported values: 'overwrite', 'merge', and 'remove'.
  ///
  /// Note that 'remove' can only be used to remove the dataset image by setting
  /// 'image.url' in the request to the current value returned for that dataset.
  public var action: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _userAppID: Clarifai_Api_UserAppIDSet? = nil
}

/// Request to delete several datasets by list of ids.
public struct Clarifai_Api_DeleteDatasetsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var userAppID: Clarifai_Api_UserAppIDSet {
    get {return _userAppID ?? Clarifai_Api_UserAppIDSet()}
    set {_userAppID = newValue}
  }
  /// Returns true if `userAppID` has been explicitly set.
  public var hasUserAppID: Bool {return self._userAppID != nil}
  /// Clears the value of `userAppID`. Subsequent reads from it will return its default value.
  public mutating func clearUserAppID() {self._userAppID = nil}

  public var datasetIds: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _userAppID: Clarifai_Api_UserAppIDSet? = nil
}

/// MultiDatasetResponse
public struct Clarifai_Api_MultiDatasetResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var status: Clarifai_Api_Status_Status {
    get {return _status ?? Clarifai_Api_Status_Status()}
    set {_status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  public var hasStatus: Bool {return self._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  public mutating func clearStatus() {self._status = nil}

  public var datasets: [Clarifai_Api_Dataset] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _status: Clarifai_Api_Status_Status? = nil
}

/// SingleDatasetResponse
public struct Clarifai_Api_SingleDatasetResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var status: Clarifai_Api_Status_Status {
    get {return _status ?? Clarifai_Api_Status_Status()}
    set {_status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  public var hasStatus: Bool {return self._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  public mutating func clearStatus() {self._status = nil}

  public var dataset: Clarifai_Api_Dataset {
    get {return _dataset ?? Clarifai_Api_Dataset()}
    set {_dataset = newValue}
  }
  /// Returns true if `dataset` has been explicitly set.
  public var hasDataset: Bool {return self._dataset != nil}
  /// Clears the value of `dataset`. Subsequent reads from it will return its default value.
  public mutating func clearDataset() {self._dataset = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _status: Clarifai_Api_Status_Status? = nil
  fileprivate var _dataset: Clarifai_Api_Dataset? = nil
}

/// ListDatasetInputsRequest
public struct Clarifai_Api_ListDatasetInputsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var userAppID: Clarifai_Api_UserAppIDSet {
    get {return _userAppID ?? Clarifai_Api_UserAppIDSet()}
    set {_userAppID = newValue}
  }
  /// Returns true if `userAppID` has been explicitly set.
  public var hasUserAppID: Bool {return self._userAppID != nil}
  /// Clears the value of `userAppID`. Subsequent reads from it will return its default value.
  public mutating func clearUserAppID() {self._userAppID = nil}

  /// Identify dataset by id.
  public var datasetID: String = String()

  /// (optional URL parameter) The page number. Pagination is used to split the results into chunks.
  /// Defaults to 1.
  public var page: UInt32 = 0

  /// (optional URL parameter) The number of results that will be contained in each page. Defaults
  /// to 128.
  public var perPage: UInt32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _userAppID: Clarifai_Api_UserAppIDSet? = nil
}

/// GetDatasetInputRequest
public struct Clarifai_Api_GetDatasetInputRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var userAppID: Clarifai_Api_UserAppIDSet {
    get {return _userAppID ?? Clarifai_Api_UserAppIDSet()}
    set {_userAppID = newValue}
  }
  /// Returns true if `userAppID` has been explicitly set.
  public var hasUserAppID: Bool {return self._userAppID != nil}
  /// Clears the value of `userAppID`. Subsequent reads from it will return its default value.
  public mutating func clearUserAppID() {self._userAppID = nil}

  /// Identify dataset by id.
  public var datasetID: String = String()

  /// Identify dataset input by id.
  public var inputID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _userAppID: Clarifai_Api_UserAppIDSet? = nil
}

/// Request to add one or more datasets.
public struct Clarifai_Api_PostDatasetInputsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var userAppID: Clarifai_Api_UserAppIDSet {
    get {return _userAppID ?? Clarifai_Api_UserAppIDSet()}
    set {_userAppID = newValue}
  }
  /// Returns true if `userAppID` has been explicitly set.
  public var hasUserAppID: Bool {return self._userAppID != nil}
  /// Clears the value of `userAppID`. Subsequent reads from it will return its default value.
  public mutating func clearUserAppID() {self._userAppID = nil}

  /// Identify dataset by id.
  public var datasetID: String = String()

  /// List of inputs that are requested to be added to this dataset.
  /// Identify each input by id field. All other inputs fields are ignored.
  public var datasetInputs: [Clarifai_Api_DatasetInput] = []

  /// Query to search inputs to be added to this dataset.
  public var search: Clarifai_Api_Search {
    get {return _search ?? Clarifai_Api_Search()}
    set {_search = newValue}
  }
  /// Returns true if `search` has been explicitly set.
  public var hasSearch: Bool {return self._search != nil}
  /// Clears the value of `search`. Subsequent reads from it will return its default value.
  public mutating func clearSearch() {self._search = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _userAppID: Clarifai_Api_UserAppIDSet? = nil
  fileprivate var _search: Clarifai_Api_Search? = nil
}

/// Request to delete several dataset inputs by list of ids.
public struct Clarifai_Api_DeleteDatasetInputsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var userAppID: Clarifai_Api_UserAppIDSet {
    get {return _userAppID ?? Clarifai_Api_UserAppIDSet()}
    set {_userAppID = newValue}
  }
  /// Returns true if `userAppID` has been explicitly set.
  public var hasUserAppID: Bool {return self._userAppID != nil}
  /// Clears the value of `userAppID`. Subsequent reads from it will return its default value.
  public mutating func clearUserAppID() {self._userAppID = nil}

  /// Identify dataset by id.
  public var datasetID: String = String()

  /// Specify which inputs to delete from dataset.
  public var inputIds: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _userAppID: Clarifai_Api_UserAppIDSet? = nil
}

/// MultiDatasetInputResponse
public struct Clarifai_Api_MultiDatasetInputResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var status: Clarifai_Api_Status_Status {
    get {return _status ?? Clarifai_Api_Status_Status()}
    set {_status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  public var hasStatus: Bool {return self._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  public mutating func clearStatus() {self._status = nil}

  public var datasetInputs: [Clarifai_Api_DatasetInput] = []

  public var bulkOperation: Clarifai_Api_BulkOperation {
    get {return _bulkOperation ?? Clarifai_Api_BulkOperation()}
    set {_bulkOperation = newValue}
  }
  /// Returns true if `bulkOperation` has been explicitly set.
  public var hasBulkOperation: Bool {return self._bulkOperation != nil}
  /// Clears the value of `bulkOperation`. Subsequent reads from it will return its default value.
  public mutating func clearBulkOperation() {self._bulkOperation = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _status: Clarifai_Api_Status_Status? = nil
  fileprivate var _bulkOperation: Clarifai_Api_BulkOperation? = nil
}

/// SingleDatasetInputResponse
public struct Clarifai_Api_SingleDatasetInputResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var status: Clarifai_Api_Status_Status {
    get {return _status ?? Clarifai_Api_Status_Status()}
    set {_status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  public var hasStatus: Bool {return self._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  public mutating func clearStatus() {self._status = nil}

  public var datasetInput: Clarifai_Api_DatasetInput {
    get {return _datasetInput ?? Clarifai_Api_DatasetInput()}
    set {_datasetInput = newValue}
  }
  /// Returns true if `datasetInput` has been explicitly set.
  public var hasDatasetInput: Bool {return self._datasetInput != nil}
  /// Clears the value of `datasetInput`. Subsequent reads from it will return its default value.
  public mutating func clearDatasetInput() {self._datasetInput = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _status: Clarifai_Api_Status_Status? = nil
  fileprivate var _datasetInput: Clarifai_Api_DatasetInput? = nil
}

/// ListDatasetVersionsRequest
public struct Clarifai_Api_ListDatasetVersionsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var userAppID: Clarifai_Api_UserAppIDSet {
    get {return _userAppID ?? Clarifai_Api_UserAppIDSet()}
    set {_userAppID = newValue}
  }
  /// Returns true if `userAppID` has been explicitly set.
  public var hasUserAppID: Bool {return self._userAppID != nil}
  /// Clears the value of `userAppID`. Subsequent reads from it will return its default value.
  public mutating func clearUserAppID() {self._userAppID = nil}

  /// Identify dataset by id.
  public var datasetID: String = String()

  /// (optional URL parameter) The page number. Pagination is used to split the results into chunks.
  /// Defaults to 1.
  public var page: UInt32 = 0

  /// (optional URL parameter) The number of results that will be contained in each page. Defaults
  /// to 128.
  public var perPage: UInt32 = 0

  /// (optional URL parameter) Filter by origin of dataset version
  public var requestOrigins: [Clarifai_Api_DatasetVersionRequestOrigin] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _userAppID: Clarifai_Api_UserAppIDSet? = nil
}

/// GetDatasetVersionRequest
public struct Clarifai_Api_GetDatasetVersionRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var userAppID: Clarifai_Api_UserAppIDSet {
    get {return _userAppID ?? Clarifai_Api_UserAppIDSet()}
    set {_userAppID = newValue}
  }
  /// Returns true if `userAppID` has been explicitly set.
  public var hasUserAppID: Bool {return self._userAppID != nil}
  /// Clears the value of `userAppID`. Subsequent reads from it will return its default value.
  public mutating func clearUserAppID() {self._userAppID = nil}

  /// Identify dataset by id.
  public var datasetID: String = String()

  /// Identify dataset version by id.
  public var datasetVersionID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _userAppID: Clarifai_Api_UserAppIDSet? = nil
}

/// ListDatasetVersionMetricsGroupsRequest
public struct Clarifai_Api_ListDatasetVersionMetricsGroupsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var userAppID: Clarifai_Api_UserAppIDSet {
    get {return _userAppID ?? Clarifai_Api_UserAppIDSet()}
    set {_userAppID = newValue}
  }
  /// Returns true if `userAppID` has been explicitly set.
  public var hasUserAppID: Bool {return self._userAppID != nil}
  /// Clears the value of `userAppID`. Subsequent reads from it will return its default value.
  public mutating func clearUserAppID() {self._userAppID = nil}

  /// Identify dataset by id.
  public var datasetID: String = String()

  /// Identify dataset version by id.
  public var datasetVersionID: String = String()

  /// (optional URL parameter) The page number. Pagination is used to split the results into chunks.
  /// Defaults to 1.
  public var page: UInt32 = 0

  /// (optional URL parameter) The number of results that will be contained in each page. Defaults
  /// to 128.
  public var perPage: UInt32 = 0

  /// Filter by parent path. Multiple parent paths are OR-ed. Empty list results in no filter.
  public var parentPaths: [String] = []

  /// Filter by parent type. Multiple types are OR-ed. Empty list results in no filter.
  public var types: [Clarifai_Api_DatasetVersionMetricsGroupType] = []

  /// Filter by value. Multiple values are OR-ed. Empty list results in no filter.
  public var values: [SwiftProtobuf.Google_Protobuf_Value] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _userAppID: Clarifai_Api_UserAppIDSet? = nil
}

/// Request to add one or more dataset versions.
public struct Clarifai_Api_PostDatasetVersionsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var userAppID: Clarifai_Api_UserAppIDSet {
    get {return _userAppID ?? Clarifai_Api_UserAppIDSet()}
    set {_userAppID = newValue}
  }
  /// Returns true if `userAppID` has been explicitly set.
  public var hasUserAppID: Bool {return self._userAppID != nil}
  /// Clears the value of `userAppID`. Subsequent reads from it will return its default value.
  public mutating func clearUserAppID() {self._userAppID = nil}

  /// Identify dataset by id.
  public var datasetID: String = String()

  /// List of dataset versions that are requested to be added.
  public var datasetVersions: [Clarifai_Api_DatasetVersion] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _userAppID: Clarifai_Api_UserAppIDSet? = nil
}

/// Request to patch several dataset versions.
public struct Clarifai_Api_PatchDatasetVersionsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var userAppID: Clarifai_Api_UserAppIDSet {
    get {return _userAppID ?? Clarifai_Api_UserAppIDSet()}
    set {_userAppID = newValue}
  }
  /// Returns true if `userAppID` has been explicitly set.
  public var hasUserAppID: Bool {return self._userAppID != nil}
  /// Clears the value of `userAppID`. Subsequent reads from it will return its default value.
  public mutating func clearUserAppID() {self._userAppID = nil}

  /// Identify dataset by id.
  public var datasetID: String = String()

  /// List of dataset versions that are requested to be updated.
  public var datasetVersions: [Clarifai_Api_DatasetVersion] = []

  /// The action to perform on the patched objects
  /// For now, only 'overwrite' action is supported
  public var action: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _userAppID: Clarifai_Api_UserAppIDSet? = nil
}

/// Request to delete several dataset versions by list of ids.
public struct Clarifai_Api_DeleteDatasetVersionsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var userAppID: Clarifai_Api_UserAppIDSet {
    get {return _userAppID ?? Clarifai_Api_UserAppIDSet()}
    set {_userAppID = newValue}
  }
  /// Returns true if `userAppID` has been explicitly set.
  public var hasUserAppID: Bool {return self._userAppID != nil}
  /// Clears the value of `userAppID`. Subsequent reads from it will return its default value.
  public mutating func clearUserAppID() {self._userAppID = nil}

  /// Identify dataset by id.
  public var datasetID: String = String()

  public var datasetVersionIds: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _userAppID: Clarifai_Api_UserAppIDSet? = nil
}

/// Request to create exports of a dataset version.
public struct Clarifai_Api_PutDatasetVersionExportsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var userAppID: Clarifai_Api_UserAppIDSet {
    get {return _userAppID ?? Clarifai_Api_UserAppIDSet()}
    set {_userAppID = newValue}
  }
  /// Returns true if `userAppID` has been explicitly set.
  public var hasUserAppID: Bool {return self._userAppID != nil}
  /// Clears the value of `userAppID`. Subsequent reads from it will return its default value.
  public mutating func clearUserAppID() {self._userAppID = nil}

  /// Identify dataset by id.
  public var datasetID: String = String()

  /// Identify dataset version by id.
  public var datasetVersionID: String = String()

  /// exports is the list of requested dataset version exports.
  /// Only setting the 'format' field of the export is supported.
  public var exports: [Clarifai_Api_DatasetVersionExport] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _userAppID: Clarifai_Api_UserAppIDSet? = nil
}

public struct Clarifai_Api_MultiDatasetVersionResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var status: Clarifai_Api_Status_Status {
    get {return _status ?? Clarifai_Api_Status_Status()}
    set {_status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  public var hasStatus: Bool {return self._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  public mutating func clearStatus() {self._status = nil}

  public var datasetVersions: [Clarifai_Api_DatasetVersion] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _status: Clarifai_Api_Status_Status? = nil
}

public struct Clarifai_Api_MultiDatasetVersionExportResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var status: Clarifai_Api_Status_Status {
    get {return _status ?? Clarifai_Api_Status_Status()}
    set {_status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  public var hasStatus: Bool {return self._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  public mutating func clearStatus() {self._status = nil}

  public var exports: [Clarifai_Api_DatasetVersionExport] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _status: Clarifai_Api_Status_Status? = nil
}

public struct Clarifai_Api_MultiDatasetVersionMetricsGroupResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var status: Clarifai_Api_Status_Status {
    get {return _status ?? Clarifai_Api_Status_Status()}
    set {_status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  public var hasStatus: Bool {return self._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  public mutating func clearStatus() {self._status = nil}

  public var datasetVersionMetricsGroups: [Clarifai_Api_DatasetVersionMetricsGroup] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _status: Clarifai_Api_Status_Status? = nil
}

public struct Clarifai_Api_SingleDatasetVersionResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var status: Clarifai_Api_Status_Status {
    get {return _status ?? Clarifai_Api_Status_Status()}
    set {_status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  public var hasStatus: Bool {return self._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  public mutating func clearStatus() {self._status = nil}

  public var datasetVersion: Clarifai_Api_DatasetVersion {
    get {return _datasetVersion ?? Clarifai_Api_DatasetVersion()}
    set {_datasetVersion = newValue}
  }
  /// Returns true if `datasetVersion` has been explicitly set.
  public var hasDatasetVersion: Bool {return self._datasetVersion != nil}
  /// Clears the value of `datasetVersion`. Subsequent reads from it will return its default value.
  public mutating func clearDatasetVersion() {self._datasetVersion = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _status: Clarifai_Api_Status_Status? = nil
  fileprivate var _datasetVersion: Clarifai_Api_DatasetVersion? = nil
}

/////////////////////////////////////////////////////
/// Model prediction related stuff needs inputs and produces outputs.
/////////////////////////////////////////////////////
/// Model prediction.
public struct Clarifai_Api_PostModelOutputsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var userAppID: Clarifai_Api_UserAppIDSet {
    get {return _userAppID ?? Clarifai_Api_UserAppIDSet()}
    set {_userAppID = newValue}
  }
  /// Returns true if `userAppID` has been explicitly set.
  public var hasUserAppID: Bool {return self._userAppID != nil}
  /// Clears the value of `userAppID`. Subsequent reads from it will return its default value.
  public mutating func clearUserAppID() {self._userAppID = nil}

  public var modelID: String = String()

  public var versionID: String = String()

  public var inputs: [Clarifai_Api_Input] = []

  /// This allows you to specify config options for the model such as
  /// the language which appear's in the model's output_info.
  public var model: Clarifai_Api_Model {
    get {return _model ?? Clarifai_Api_Model()}
    set {_model = newValue}
  }
  /// Returns true if `model` has been explicitly set.
  public var hasModel: Bool {return self._model != nil}
  /// Clears the value of `model`. Subsequent reads from it will return its default value.
  public mutating func clearModel() {self._model = nil}

  /// Allow filtering of prediction requests down to specific Nodepools, Deployments or Runners
  public var runnerSelector: Clarifai_Api_RunnerSelector {
    get {return _runnerSelector ?? Clarifai_Api_RunnerSelector()}
    set {_runnerSelector = newValue}
  }
  /// Returns true if `runnerSelector` has been explicitly set.
  public var hasRunnerSelector: Bool {return self._runnerSelector != nil}
  /// Clears the value of `runnerSelector`. Subsequent reads from it will return its default value.
  public mutating func clearRunnerSelector() {self._runnerSelector = nil}

  /// Configure the prediction cache to avoid expensive compute for predict requests
  public var usePredictCache: Bool = false

  /// Configuration to provide logs summarization when request errors out
  public var enableLogSummaryOnError: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _userAppID: Clarifai_Api_UserAppIDSet? = nil
  fileprivate var _model: Clarifai_Api_Model? = nil
  fileprivate var _runnerSelector: Clarifai_Api_RunnerSelector? = nil
}

/// Listing the inputs that went into training this model.
public struct Clarifai_Api_ListModelInputsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var userAppID: Clarifai_Api_UserAppIDSet {
    get {return _userAppID ?? Clarifai_Api_UserAppIDSet()}
    set {_userAppID = newValue}
  }
  /// Returns true if `userAppID` has been explicitly set.
  public var hasUserAppID: Bool {return self._userAppID != nil}
  /// Clears the value of `userAppID`. Subsequent reads from it will return its default value.
  public mutating func clearUserAppID() {self._userAppID = nil}

  public var modelID: String = String()

  public var versionID: String = String()

  /// (optional URL parameter) The page number. Pagination is used to split the results into chunks.
  /// Defaults to 1.
  public var page: UInt32 = 0

  /// (optional URL parameter) The number of results that will be contained in each page. Defaults
  /// to 128.
  public var perPage: UInt32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _userAppID: Clarifai_Api_UserAppIDSet? = nil
}

public struct Clarifai_Api_PostComputePlaneMetricsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// List of ComputePlaneMetrics.
  public var computePlaneMetrics: [Clarifai_Api_ComputePlaneMetrics] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Clarifai_Api_PostLogEntriesRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// List of log entries to be stored.
  public var logEntries: [Clarifai_Api_LogEntry] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Clarifai_Api_ListLogEntriesRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// (optional URL parameter) The page number. Pagination is used to split the results into chunks.
  /// Defaults to last page.
  public var page: UInt32 {
    get {return _storage._page}
    set {_uniqueStorage()._page = newValue}
  }

  /// (optional URL parameter) The number of results that will be contained in each page. Defaults
  /// to 32.
  public var perPage: UInt32 {
    get {return _storage._perPage}
    set {_uniqueStorage()._perPage = newValue}
  }

  /// The type of log entry. Choose from [agent, builder, builder.events, runner, runner.events, pipeline.version.run]
  public var logType: String {
    get {return _storage._logType}
    set {_uniqueStorage()._logType = newValue}
  }

  /// Who the logs are for.
  /// The user app id, if a user produced the logs.
  public var userAppID: Clarifai_Api_UserAppIDSet {
    get {return _storage._userAppID ?? Clarifai_Api_UserAppIDSet()}
    set {_uniqueStorage()._userAppID = newValue}
  }
  /// Returns true if `userAppID` has been explicitly set.
  public var hasUserAppID: Bool {return _storage._userAppID != nil}
  /// Clears the value of `userAppID`. Subsequent reads from it will return its default value.
  public mutating func clearUserAppID() {_uniqueStorage()._userAppID = nil}

  /// The Model ID, if a model produced the logs.
  public var modelID: String {
    get {return _storage._modelID}
    set {_uniqueStorage()._modelID = newValue}
  }

  /// The Version ID, if a model version produced the logs.
  public var modelVersionID: String {
    get {return _storage._modelVersionID}
    set {_uniqueStorage()._modelVersionID = newValue}
  }

  /// Workflow Id, if a workflow produced the logs.
  public var workflowID: String {
    get {return _storage._workflowID}
    set {_uniqueStorage()._workflowID = newValue}
  }

  /// Where the logs came from.
  public var computeClusterUserID: String {
    get {return _storage._computeClusterUserID}
    set {_uniqueStorage()._computeClusterUserID = newValue}
  }

  public var computeClusterID: String {
    get {return _storage._computeClusterID}
    set {_uniqueStorage()._computeClusterID = newValue}
  }

  public var nodepoolID: String {
    get {return _storage._nodepoolID}
    set {_uniqueStorage()._nodepoolID = newValue}
  }

  public var runnerID: String {
    get {return _storage._runnerID}
    set {_uniqueStorage()._runnerID = newValue}
  }

  /// Pipelines that produced the logs for a given pipeline run with log_type: pipeline.version.run
  /// Must include user_app_id with user_id and app_id as well.
  public var pipelineID: String {
    get {return _storage._pipelineID}
    set {_uniqueStorage()._pipelineID = newValue}
  }

  public var pipelineVersionID: String {
    get {return _storage._pipelineVersionID}
    set {_uniqueStorage()._pipelineVersionID = newValue}
  }

  public var pipelineVersionRunID: String {
    get {return _storage._pipelineVersionRunID}
    set {_uniqueStorage()._pipelineVersionRunID = newValue}
  }

  /// During pipeline step build provide these IDs.
  public var pipelineStepID: String {
    get {return _storage._pipelineStepID}
    set {_uniqueStorage()._pipelineStepID = newValue}
  }

  public var pipelineStepVersionID: String {
    get {return _storage._pipelineStepVersionID}
    set {_uniqueStorage()._pipelineStepVersionID = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Clarifai_Api_StreamLogEntriesRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The type of log entry. Examples: model, agent, build, training.
  public var logType: String = String()

  /// Who the logs are for.
  /// The user app id, if a user produced the logs.
  public var userAppID: Clarifai_Api_UserAppIDSet {
    get {return _userAppID ?? Clarifai_Api_UserAppIDSet()}
    set {_userAppID = newValue}
  }
  /// Returns true if `userAppID` has been explicitly set.
  public var hasUserAppID: Bool {return self._userAppID != nil}
  /// Clears the value of `userAppID`. Subsequent reads from it will return its default value.
  public mutating func clearUserAppID() {self._userAppID = nil}

  /// For models if you set log_type to "builder" then you get the model build logs.
  /// The Model ID, if a model produced the logs.
  public var modelID: String = String()

  /// The Version ID, if a model version produced the logs.
  public var modelVersionID: String = String()

  /// Workflow Id, if a workflow produced the logs.
  public var workflowID: String = String()

  /// Where the logs came from.
  public var computeClusterUserID: String = String()

  public var computeClusterID: String = String()

  public var nodepoolID: String = String()

  public var runnerID: String = String()

  /// Pipelines that produced the logs with log_type: pipeline.version.run
  /// Must include user_app_id with user_id and app_id as well.
  public var pipelineID: String = String()

  public var pipelineVersionID: String = String()

  public var pipelineVersionRunID: String = String()

  /// During pipeline step build provide these IDs with log_type: builder
  /// Must include user_app_id with user_id and app_id as well.
  public var pipelineStepID: String = String()

  public var pipelineStepVersionID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _userAppID: Clarifai_Api_UserAppIDSet? = nil
}

/// GetKeyRequest
public struct Clarifai_Api_GetKeyRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var userAppID: Clarifai_Api_UserAppIDSet {
    get {return _userAppID ?? Clarifai_Api_UserAppIDSet()}
    set {_userAppID = newValue}
  }
  /// Returns true if `userAppID` has been explicitly set.
  public var hasUserAppID: Bool {return self._userAppID != nil}
  /// Clears the value of `userAppID`. Subsequent reads from it will return its default value.
  public mutating func clearUserAppID() {self._userAppID = nil}

  public var keyID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _userAppID: Clarifai_Api_UserAppIDSet? = nil
}

/// ListKeysRequest
public struct Clarifai_Api_ListKeysRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var userAppID: Clarifai_Api_UserAppIDSet {
    get {return _userAppID ?? Clarifai_Api_UserAppIDSet()}
    set {_userAppID = newValue}
  }
  /// Returns true if `userAppID` has been explicitly set.
  public var hasUserAppID: Bool {return self._userAppID != nil}
  /// Clears the value of `userAppID`. Subsequent reads from it will return its default value.
  public mutating func clearUserAppID() {self._userAppID = nil}

  /// (optional URL parameter) The page number. Pagination is used to split the results into chunks.
  /// Defaults to 1.
  public var page: UInt32 = 0

  /// (optional URL parameter) The number of results that will be contained in each page. Defaults
  /// to 128.
  public var perPage: UInt32 = 0

  /// Filtering options:
  /// If true, only return keys that have not expired.
  public var notExpired: Bool = false

  /// Only return keys that have the listed scopes.
  public var scopes: [String] = []

  /// Only return keys that have the listed endpoints.
  public var endpoints: [String] = []

  /// Only return keys with the listed type.
  public var type: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _userAppID: Clarifai_Api_UserAppIDSet? = nil
}

/// ListAppKeysRequest
public struct Clarifai_Api_ListAppKeysRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var userAppID: Clarifai_Api_UserAppIDSet {
    get {return _userAppID ?? Clarifai_Api_UserAppIDSet()}
    set {_userAppID = newValue}
  }
  /// Returns true if `userAppID` has been explicitly set.
  public var hasUserAppID: Bool {return self._userAppID != nil}
  /// Clears the value of `userAppID`. Subsequent reads from it will return its default value.
  public mutating func clearUserAppID() {self._userAppID = nil}

  /// (optional URL parameter) The page number. Pagination is used to split the results into chunks.
  /// Defaults to 1.
  public var page: UInt32 = 0

  /// (optional URL parameter) The number of results that will be contained in each page. Defaults
  /// to 128.
  public var perPage: UInt32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _userAppID: Clarifai_Api_UserAppIDSet? = nil
}

/// PostKeysRequest
public struct Clarifai_Api_PostKeysRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var userAppID: Clarifai_Api_UserAppIDSet {
    get {return _userAppID ?? Clarifai_Api_UserAppIDSet()}
    set {_userAppID = newValue}
  }
  /// Returns true if `userAppID` has been explicitly set.
  public var hasUserAppID: Bool {return self._userAppID != nil}
  /// Clears the value of `userAppID`. Subsequent reads from it will return its default value.
  public mutating func clearUserAppID() {self._userAppID = nil}

  public var keys: [Clarifai_Api_Key] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _userAppID: Clarifai_Api_UserAppIDSet? = nil
}

/// DeleteKeyRequest
public struct Clarifai_Api_DeleteKeyRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var userAppID: Clarifai_Api_UserAppIDSet {
    get {return _userAppID ?? Clarifai_Api_UserAppIDSet()}
    set {_userAppID = newValue}
  }
  /// Returns true if `userAppID` has been explicitly set.
  public var hasUserAppID: Bool {return self._userAppID != nil}
  /// Clears the value of `userAppID`. Subsequent reads from it will return its default value.
  public mutating func clearUserAppID() {self._userAppID = nil}

  public var keyID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _userAppID: Clarifai_Api_UserAppIDSet? = nil
}

/// PatchKeysRequest
public struct Clarifai_Api_PatchKeysRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var userAppID: Clarifai_Api_UserAppIDSet {
    get {return _userAppID ?? Clarifai_Api_UserAppIDSet()}
    set {_userAppID = newValue}
  }
  /// Returns true if `userAppID` has been explicitly set.
  public var hasUserAppID: Bool {return self._userAppID != nil}
  /// Clears the value of `userAppID`. Subsequent reads from it will return its default value.
  public mutating func clearUserAppID() {self._userAppID = nil}

  public var keys: [Clarifai_Api_Key] = []

  /// The action to perform on the patched objects
  /// For now only action 'overwrite' is supported
  public var action: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _userAppID: Clarifai_Api_UserAppIDSet? = nil
}

/// SingleKeyResponse
public struct Clarifai_Api_SingleKeyResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var status: Clarifai_Api_Status_Status {
    get {return _storage._status ?? Clarifai_Api_Status_Status()}
    set {_uniqueStorage()._status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  public var hasStatus: Bool {return _storage._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  public mutating func clearStatus() {_uniqueStorage()._status = nil}

  public var key: Clarifai_Api_Key {
    get {return _storage._key ?? Clarifai_Api_Key()}
    set {_uniqueStorage()._key = newValue}
  }
  /// Returns true if `key` has been explicitly set.
  public var hasKey: Bool {return _storage._key != nil}
  /// Clears the value of `key`. Subsequent reads from it will return its default value.
  public mutating func clearKey() {_uniqueStorage()._key = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// MultiKeyResponse
public struct Clarifai_Api_MultiKeyResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var status: Clarifai_Api_Status_Status {
    get {return _status ?? Clarifai_Api_Status_Status()}
    set {_status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  public var hasStatus: Bool {return self._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  public mutating func clearStatus() {self._status = nil}

  public var keys: [Clarifai_Api_Key] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _status: Clarifai_Api_Status_Status? = nil
}

/// GetModelRequest
public struct Clarifai_Api_GetModelRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var userAppID: Clarifai_Api_UserAppIDSet {
    get {return _userAppID ?? Clarifai_Api_UserAppIDSet()}
    set {_userAppID = newValue}
  }
  /// Returns true if `userAppID` has been explicitly set.
  public var hasUserAppID: Bool {return self._userAppID != nil}
  /// Clears the value of `userAppID`. Subsequent reads from it will return its default value.
  public mutating func clearUserAppID() {self._userAppID = nil}

  public var modelID: String = String()

  /// This is included so that we can re-use this request for multiple
  /// rpcs with and without the version_id.
  public var versionID: String = String()

  public var language: String = String()

  public var trainedBefore: Bool = false

  /// (optional URL parameter) List of additional fields to be included in the response. Currently supported: all, stars, outputs, presets
  public var additionalFields: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _userAppID: Clarifai_Api_UserAppIDSet? = nil
}

/// ListModelsRequest
public struct Clarifai_Api_ListModelsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var userAppID: Clarifai_Api_UserAppIDSet {
    get {return _storage._userAppID ?? Clarifai_Api_UserAppIDSet()}
    set {_uniqueStorage()._userAppID = newValue}
  }
  /// Returns true if `userAppID` has been explicitly set.
  public var hasUserAppID: Bool {return _storage._userAppID != nil}
  /// Clears the value of `userAppID`. Subsequent reads from it will return its default value.
  public mutating func clearUserAppID() {_uniqueStorage()._userAppID = nil}

  /// (optional URL parameter) The page number. Pagination is used to split the results into chunks.
  /// Defaults to 1.
  public var page: UInt32 {
    get {return _storage._page}
    set {_uniqueStorage()._page = newValue}
  }

  /// (optional URL parameter) The number of results that will be contained in each page. Defaults
  /// to 128.
  public var perPage: UInt32 {
    get {return _storage._perPage}
    set {_uniqueStorage()._perPage = newValue}
  }

  /// (optional URL parameter) List of additional fields to be included in the response. Currently supported: all, stars, outputs, presets, counts
  public var additionalFields: [String] {
    get {return _storage._additionalFields}
    set {_uniqueStorage()._additionalFields = newValue}
  }

  /// Sorting options:
  /// Whether to sort in ascending order. If false, will order in descending order.
  public var sortAscending: Bool {
    get {return _storage._sortAscending}
    set {_uniqueStorage()._sortAscending = newValue}
  }

  public var sortBy: OneOf_SortBy? {
    get {return _storage._sortBy}
    set {_uniqueStorage()._sortBy = newValue}
  }

  /// Whether to order by the name
  public var sortByName: Bool {
    get {
      if case .sortByName(let v)? = _storage._sortBy {return v}
      return false
    }
    set {_uniqueStorage()._sortBy = .sortByName(newValue)}
  }

  /// Whether to order by the number of training inputs
  public var sortByNumInputs: Bool {
    get {
      if case .sortByNumInputs(let v)? = _storage._sortBy {return v}
      return false
    }
    set {_uniqueStorage()._sortBy = .sortByNumInputs(newValue)}
  }

  /// Whether to order by the modified_at time of the latest model version.
  /// If none of the sort options is set to true, will sort by modified_at.
  public var sortByModifiedAt: Bool {
    get {
      if case .sortByModifiedAt(let v)? = _storage._sortBy {return v}
      return false
    }
    set {_uniqueStorage()._sortBy = .sortByModifiedAt(newValue)}
  }

  /// Whether to order by the created_at
  public var sortByCreatedAt: Bool {
    get {
      if case .sortByCreatedAt(let v)? = _storage._sortBy {return v}
      return false
    }
    set {_uniqueStorage()._sortBy = .sortByCreatedAt(newValue)}
  }

  /// Whether to order by count of stars
  public var sortByStarCount: Bool {
    get {
      if case .sortByStarCount(let v)? = _storage._sortBy {return v}
      return false
    }
    set {_uniqueStorage()._sortBy = .sortByStarCount(newValue)}
  }

  /// Filtering options:
  /// Filter models by the specific model_type_id. See ListModelTypes for the list of ModelType.Id's
  /// supported.
  public var modelTypeID: String {
    get {return _storage._modelTypeID}
    set {_uniqueStorage()._modelTypeID = newValue}
  }

  /// If true, we only return models that have the status MODEL_TRAINED, which includes non-trainable model types.
  public var trainedOnly: Bool {
    get {return _storage._trainedOnly}
    set {_uniqueStorage()._trainedOnly = newValue}
  }

  /// The list of input fields to the model.
  /// For example, you can specify 'image', which will return models that make inferences on images like visual-classifier models.
  public var inputFields: [String] {
    get {return _storage._inputFields}
    set {_uniqueStorage()._inputFields = newValue}
  }

  /// The list of output fields to the model.
  /// For example, you can specify 'regions[...].data.concepts', which will return visual-detector models.
  public var outputFields: [String] {
    get {return _storage._outputFields}
    set {_uniqueStorage()._outputFields = newValue}
  }

  /// Filter by the license of the model version
  public var license: String {
    get {return _storage._license}
    set {_uniqueStorage()._license = newValue}
  }

  /// If true, we only return models that are handpicked by clarifai staff
  public var featuredOnly: Bool {
    get {return _storage._featuredOnly}
    set {_uniqueStorage()._featuredOnly = newValue}
  }

  /// If true, we only return models that are starred by the requesting user
  public var starredOnly: Bool {
    get {return _storage._starredOnly}
    set {_uniqueStorage()._starredOnly = newValue}
  }

  /// List of toolkit tags to filter by
  public var toolkits: [String] {
    get {return _storage._toolkits}
    set {_uniqueStorage()._toolkits = newValue}
  }

  /// List of use_case tags to filter by
  public var useCases: [String] {
    get {return _storage._useCases}
    set {_uniqueStorage()._useCases = newValue}
  }

  /// List of language tags to filter by
  public var languages: [String] {
    get {return _storage._languages}
    set {_uniqueStorage()._languages = newValue}
  }

  /// Old API behavior resulted in returning clarifai main models when calling ListModels while scoped to an app. While we transition
  /// away from that, we can use this flag to not always fetch clarifai main models, unless that is the app we are explicitly listing for.
  public var dontFetchFromMain: Bool {
    get {return _storage._dontFetchFromMain}
    set {_uniqueStorage()._dontFetchFromMain = newValue}
  }

  /// Filter models by bookmark. If set, only return bookmarked models. Otherwise none bookmarked models only.
  /// Note: you can not filter `trained_only` and bookmark at the same time.
  /// When filter by bookmark, we will return trained and untrained models.
  public var bookmark: Bool {
    get {return _storage._bookmark}
    set {_uniqueStorage()._bookmark = newValue}
  }

  /// Searching options:
  /// Specify a search parameter in order to perform keyword search on the
  /// following fields of the model:
  ///   - id
  ///   - name
  ///   - description
  ///   - notes
  ///   - user_id (unless user_app_id.user_id is already set)
  ///
  /// Keywords are both normalized for search (so searching for "satisfy" matches "satisfied")
  /// and used for partial prefix-matching (so searching for "clari" matches "clarifai").
  ///
  /// NOTE: Both the list of fields searched and the exact keyword matching
  /// rules are subject to change and not guaranteed to be backwards-compatible.
  public var search: String {
    get {return _storage._search}
    set {_uniqueStorage()._search = newValue}
  }

  /// Query name, description and id fields, that can contain the words in the query string. Does NOT support wildcards - full words only. Supports operators "OR" and "-" as NOT.
  /// Deprecated: use search instead.
  public var query: String {
    get {return _storage._query}
    set {_uniqueStorage()._query = newValue}
  }

  /// Filter by the description and id of the model. This supports wildcard queries like "gen*" to match "general" as an example.
  /// Deprecated: use search instead.
  public var name: String {
    get {return _storage._name}
    set {_uniqueStorage()._name = newValue}
  }

  /// Extends the name filter to include the user_id of the application owner that the model belongs to.
  /// Deprecated: use search instead of name.
  public var filterByUserID: Bool {
    get {return _storage._filterByUserID}
    set {_uniqueStorage()._filterByUserID = newValue}
  }

  /// Filter by the model version ids. If set, only return the model of these versions.
  public var modelVersionIds: [String] {
    get {return _storage._modelVersionIds}
    set {_uniqueStorage()._modelVersionIds = newValue}
  }

  /// Filter by LicenseType
  public var licenseType: Clarifai_Api_LicenseType {
    get {return _storage._licenseType}
    set {_uniqueStorage()._licenseType = newValue}
  }

  /// Filter by Source
  public var source: UInt32 {
    get {return _storage._source}
    set {_uniqueStorage()._source = newValue}
  }

  /// Filter by Creator
  public var creator: String {
    get {return _storage._creator}
    set {_uniqueStorage()._creator = newValue}
  }

  /// Filter by model versions runners with replicas >= min_replicas.
  public var minReplicas: UInt32 {
    get {return _storage._minReplicas}
    set {_uniqueStorage()._minReplicas = newValue}
  }

  /// If true, show replica counts for models.
  public var showReplicas: Bool {
    get {return _storage._showReplicas}
    set {_uniqueStorage()._showReplicas = newValue}
  }

  /// Filter by visibility of the model. If set, only return models with the specified visibility.
  public var visibility: Clarifai_Api_Visibility {
    get {return _storage._visibility ?? Clarifai_Api_Visibility()}
    set {_uniqueStorage()._visibility = newValue}
  }
  /// Returns true if `visibility` has been explicitly set.
  public var hasVisibility: Bool {return _storage._visibility != nil}
  /// Clears the value of `visibility`. Subsequent reads from it will return its default value.
  public mutating func clearVisibility() {_uniqueStorage()._visibility = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_SortBy: Equatable {
    /// Whether to order by the name
    case sortByName(Bool)
    /// Whether to order by the number of training inputs
    case sortByNumInputs(Bool)
    /// Whether to order by the modified_at time of the latest model version.
    /// If none of the sort options is set to true, will sort by modified_at.
    case sortByModifiedAt(Bool)
    /// Whether to order by the created_at
    case sortByCreatedAt(Bool)
    /// Whether to order by count of stars
    case sortByStarCount(Bool)

  #if !swift(>=4.1)
    public static func ==(lhs: Clarifai_Api_ListModelsRequest.OneOf_SortBy, rhs: Clarifai_Api_ListModelsRequest.OneOf_SortBy) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.sortByName, .sortByName): return {
        guard case .sortByName(let l) = lhs, case .sortByName(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.sortByNumInputs, .sortByNumInputs): return {
        guard case .sortByNumInputs(let l) = lhs, case .sortByNumInputs(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.sortByModifiedAt, .sortByModifiedAt): return {
        guard case .sortByModifiedAt(let l) = lhs, case .sortByModifiedAt(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.sortByCreatedAt, .sortByCreatedAt): return {
        guard case .sortByCreatedAt(let l) = lhs, case .sortByCreatedAt(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.sortByStarCount, .sortByStarCount): return {
        guard case .sortByStarCount(let l) = lhs, case .sortByStarCount(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// ResourceCountRequest
public struct Clarifai_Api_GetResourceCountsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var userAppID: Clarifai_Api_UserAppIDSet {
    get {return _userAppID ?? Clarifai_Api_UserAppIDSet()}
    set {_userAppID = newValue}
  }
  /// Returns true if `userAppID` has been explicitly set.
  public var hasUserAppID: Bool {return self._userAppID != nil}
  /// Clears the value of `userAppID`. Subsequent reads from it will return its default value.
  public mutating func clearUserAppID() {self._userAppID = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _userAppID: Clarifai_Api_UserAppIDSet? = nil
}

/// ResourceCountResponse
public struct Clarifai_Api_GetResourceCountsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var status: Clarifai_Api_Status_Status {
    get {return _storage._status ?? Clarifai_Api_Status_Status()}
    set {_uniqueStorage()._status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  public var hasStatus: Bool {return _storage._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  public mutating func clearStatus() {_uniqueStorage()._status = nil}

  public var datasets: Int64 {
    get {return _storage._datasets}
    set {_uniqueStorage()._datasets = newValue}
  }

  public var models: Int64 {
    get {return _storage._models}
    set {_uniqueStorage()._models = newValue}
  }

  public var workflows: Int64 {
    get {return _storage._workflows}
    set {_uniqueStorage()._workflows = newValue}
  }

  public var modules: Int64 {
    get {return _storage._modules}
    set {_uniqueStorage()._modules = newValue}
  }

  public var inputs: Int64 {
    get {return _storage._inputs}
    set {_uniqueStorage()._inputs = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Clarifai_Api_PatchModelToolkitsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var userAppID: Clarifai_Api_UserAppIDSet {
    get {return _userAppID ?? Clarifai_Api_UserAppIDSet()}
    set {_userAppID = newValue}
  }
  /// Returns true if `userAppID` has been explicitly set.
  public var hasUserAppID: Bool {return self._userAppID != nil}
  /// Clears the value of `userAppID`. Subsequent reads from it will return its default value.
  public mutating func clearUserAppID() {self._userAppID = nil}

  public var modelID: String = String()

  public var toolkits: [String] = []

  ///overwrite supported
  public var action: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _userAppID: Clarifai_Api_UserAppIDSet? = nil
}

/// PatchModelCheckConsentsRequest
public struct Clarifai_Api_PatchModelCheckConsentsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var userAppID: Clarifai_Api_UserAppIDSet {
    get {return _userAppID ?? Clarifai_Api_UserAppIDSet()}
    set {_userAppID = newValue}
  }
  /// Returns true if `userAppID` has been explicitly set.
  public var hasUserAppID: Bool {return self._userAppID != nil}
  /// Clears the value of `userAppID`. Subsequent reads from it will return its default value.
  public mutating func clearUserAppID() {self._userAppID = nil}

  /// the model id
  public var modelID: String = String()

  /// the consents
  public var checkConsents: [String] = []

  ///overwrite supported
  public var action: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _userAppID: Clarifai_Api_UserAppIDSet? = nil
}

public struct Clarifai_Api_PatchModelUseCasesRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var userAppID: Clarifai_Api_UserAppIDSet {
    get {return _userAppID ?? Clarifai_Api_UserAppIDSet()}
    set {_userAppID = newValue}
  }
  /// Returns true if `userAppID` has been explicitly set.
  public var hasUserAppID: Bool {return self._userAppID != nil}
  /// Clears the value of `userAppID`. Subsequent reads from it will return its default value.
  public mutating func clearUserAppID() {self._userAppID = nil}

  public var modelID: String = String()

  public var usecases: [String] = []

  ///overwrite supported
  public var action: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _userAppID: Clarifai_Api_UserAppIDSet? = nil
}

public struct Clarifai_Api_PatchModelLanguagesRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var userAppID: Clarifai_Api_UserAppIDSet {
    get {return _userAppID ?? Clarifai_Api_UserAppIDSet()}
    set {_userAppID = newValue}
  }
  /// Returns true if `userAppID` has been explicitly set.
  public var hasUserAppID: Bool {return self._userAppID != nil}
  /// Clears the value of `userAppID`. Subsequent reads from it will return its default value.
  public mutating func clearUserAppID() {self._userAppID = nil}

  public var modelID: String = String()

  public var languages: [String] = []

  /// Only overwrite supported
  public var action: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _userAppID: Clarifai_Api_UserAppIDSet? = nil
}

public struct Clarifai_Api_MultiModelToolkitResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var status: Clarifai_Api_Status_Status {
    get {return _status ?? Clarifai_Api_Status_Status()}
    set {_status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  public var hasStatus: Bool {return self._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  public mutating func clearStatus() {self._status = nil}

  public var toolkits: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _status: Clarifai_Api_Status_Status? = nil
}

public struct Clarifai_Api_MultiModelCheckConsentResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var status: Clarifai_Api_Status_Status {
    get {return _status ?? Clarifai_Api_Status_Status()}
    set {_status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  public var hasStatus: Bool {return self._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  public mutating func clearStatus() {self._status = nil}

  public var checkConsents: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _status: Clarifai_Api_Status_Status? = nil
}

public struct Clarifai_Api_MultiModelUseCaseResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var status: Clarifai_Api_Status_Status {
    get {return _status ?? Clarifai_Api_Status_Status()}
    set {_status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  public var hasStatus: Bool {return self._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  public mutating func clearStatus() {self._status = nil}

  public var usecases: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _status: Clarifai_Api_Status_Status? = nil
}

public struct Clarifai_Api_MultiModelLanguageResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var status: Clarifai_Api_Status_Status {
    get {return _status ?? Clarifai_Api_Status_Status()}
    set {_status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  public var hasStatus: Bool {return self._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  public mutating func clearStatus() {self._status = nil}

  public var languages: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _status: Clarifai_Api_Status_Status? = nil
}

/// PostModelsRequest
public struct Clarifai_Api_PostModelsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var userAppID: Clarifai_Api_UserAppIDSet {
    get {return _userAppID ?? Clarifai_Api_UserAppIDSet()}
    set {_userAppID = newValue}
  }
  /// Returns true if `userAppID` has been explicitly set.
  public var hasUserAppID: Bool {return self._userAppID != nil}
  /// Clears the value of `userAppID`. Subsequent reads from it will return its default value.
  public mutating func clearUserAppID() {self._userAppID = nil}

  /// NOTE: inconsistent since "model" is not plural, please use "models" below.
  /// Previously you could only create one model at a time.
  /// We still support this but you should pass it as models=[model] so
  /// that this endpoint is consistent with the rest of our API.
  public var model: Clarifai_Api_Model {
    get {return _model ?? Clarifai_Api_Model()}
    set {_model = newValue}
  }
  /// Returns true if `model` has been explicitly set.
  public var hasModel: Bool {return self._model != nil}
  /// Clears the value of `model`. Subsequent reads from it will return its default value.
  public mutating func clearModel() {self._model = nil}

  /// This allows you to create one or more model by posting it to the API.
  public var models: [Clarifai_Api_Model] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _userAppID: Clarifai_Api_UserAppIDSet? = nil
  fileprivate var _model: Clarifai_Api_Model? = nil
}

/// PatchModelsRequest
public struct Clarifai_Api_PatchModelsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var userAppID: Clarifai_Api_UserAppIDSet {
    get {return _userAppID ?? Clarifai_Api_UserAppIDSet()}
    set {_userAppID = newValue}
  }
  /// Returns true if `userAppID` has been explicitly set.
  public var hasUserAppID: Bool {return self._userAppID != nil}
  /// Clears the value of `userAppID`. Subsequent reads from it will return its default value.
  public mutating func clearUserAppID() {self._userAppID = nil}

  public var models: [Clarifai_Api_Model] = []

  /// The action to perform on the patched objects
  /// For now actions 'merge', 'overwrite', and 'remove' are supported
  ///
  /// Note that 'remove' can be used to remove the model image by setting
  /// 'image.url' in the request to the current value returned for that model.
  /// This cannot be used in a request that is patching other fields as well.
  public var action: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _userAppID: Clarifai_Api_UserAppIDSet? = nil
}

public struct Clarifai_Api_IdUpdateSource {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///old id
  public var id: String = String()

  ///new id
  public var newID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// PatchModelIdsRequest
public struct Clarifai_Api_PatchModelIdsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var userAppID: Clarifai_Api_UserAppIDSet {
    get {return _userAppID ?? Clarifai_Api_UserAppIDSet()}
    set {_userAppID = newValue}
  }
  /// Returns true if `userAppID` has been explicitly set.
  public var hasUserAppID: Bool {return self._userAppID != nil}
  /// Clears the value of `userAppID`. Subsequent reads from it will return its default value.
  public mutating func clearUserAppID() {self._userAppID = nil}

  /// Array containing 1 entry
  public var ids: [Clarifai_Api_IdUpdateSource] = []

  /// The action to perform on the patched objects
  /// Only 'overwrite' is supported
  public var action: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _userAppID: Clarifai_Api_UserAppIDSet? = nil
}

/// DeleteModelRequest
public struct Clarifai_Api_DeleteModelRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var userAppID: Clarifai_Api_UserAppIDSet {
    get {return _userAppID ?? Clarifai_Api_UserAppIDSet()}
    set {_userAppID = newValue}
  }
  /// Returns true if `userAppID` has been explicitly set.
  public var hasUserAppID: Bool {return self._userAppID != nil}
  /// Clears the value of `userAppID`. Subsequent reads from it will return its default value.
  public mutating func clearUserAppID() {self._userAppID = nil}

  public var modelID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _userAppID: Clarifai_Api_UserAppIDSet? = nil
}

/// Request to delete several things by the list of ids.
public struct Clarifai_Api_DeleteModelsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var userAppID: Clarifai_Api_UserAppIDSet {
    get {return _userAppID ?? Clarifai_Api_UserAppIDSet()}
    set {_userAppID = newValue}
  }
  /// Returns true if `userAppID` has been explicitly set.
  public var hasUserAppID: Bool {return self._userAppID != nil}
  /// Clears the value of `userAppID`. Subsequent reads from it will return its default value.
  public mutating func clearUserAppID() {self._userAppID = nil}

  public var ids: [String] = []

  public var deleteAll: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _userAppID: Clarifai_Api_UserAppIDSet? = nil
}

/// Search over the available models.
public struct Clarifai_Api_PostModelsSearchesRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Ids present in the url of the request.
  public var userAppID: Clarifai_Api_UserAppIDSet {
    get {return _userAppID ?? Clarifai_Api_UserAppIDSet()}
    set {_userAppID = newValue}
  }
  /// Returns true if `userAppID` has been explicitly set.
  public var hasUserAppID: Bool {return self._userAppID != nil}
  /// Clears the value of `userAppID`. Subsequent reads from it will return its default value.
  public mutating func clearUserAppID() {self._userAppID = nil}

  /// The body of the request.
  public var modelQuery: Clarifai_Api_ModelQuery {
    get {return _modelQuery ?? Clarifai_Api_ModelQuery()}
    set {_modelQuery = newValue}
  }
  /// Returns true if `modelQuery` has been explicitly set.
  public var hasModelQuery: Bool {return self._modelQuery != nil}
  /// Clears the value of `modelQuery`. Subsequent reads from it will return its default value.
  public mutating func clearModelQuery() {self._modelQuery = nil}

  /// Pagination parameters here since there are no url args in this
  /// POST request.
  public var pagination: Clarifai_Api_Pagination {
    get {return _pagination ?? Clarifai_Api_Pagination()}
    set {_pagination = newValue}
  }
  /// Returns true if `pagination` has been explicitly set.
  public var hasPagination: Bool {return self._pagination != nil}
  /// Clears the value of `pagination`. Subsequent reads from it will return its default value.
  public mutating func clearPagination() {self._pagination = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _userAppID: Clarifai_Api_UserAppIDSet? = nil
  fileprivate var _modelQuery: Clarifai_Api_ModelQuery? = nil
  fileprivate var _pagination: Clarifai_Api_Pagination? = nil
}

/// SingleModelResponse
public struct Clarifai_Api_SingleModelResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var status: Clarifai_Api_Status_Status {
    get {return _status ?? Clarifai_Api_Status_Status()}
    set {_status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  public var hasStatus: Bool {return self._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  public mutating func clearStatus() {self._status = nil}

  public var model: Clarifai_Api_Model {
    get {return _model ?? Clarifai_Api_Model()}
    set {_model = newValue}
  }
  /// Returns true if `model` has been explicitly set.
  public var hasModel: Bool {return self._model != nil}
  /// Clears the value of `model`. Subsequent reads from it will return its default value.
  public mutating func clearModel() {self._model = nil}

  public var workflowCount: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _status: Clarifai_Api_Status_Status? = nil
  fileprivate var _model: Clarifai_Api_Model? = nil
}

/// MultiModelResponse
public struct Clarifai_Api_MultiModelResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var status: Clarifai_Api_Status_Status {
    get {return _status ?? Clarifai_Api_Status_Status()}
    set {_status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  public var hasStatus: Bool {return self._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  public mutating func clearStatus() {self._status = nil}

  public var models: [Clarifai_Api_Model] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _status: Clarifai_Api_Status_Status? = nil
}

/// PatchModelVersionsRequest
public struct Clarifai_Api_PatchModelVersionsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var userAppID: Clarifai_Api_UserAppIDSet {
    get {return _userAppID ?? Clarifai_Api_UserAppIDSet()}
    set {_userAppID = newValue}
  }
  /// Returns true if `userAppID` has been explicitly set.
  public var hasUserAppID: Bool {return self._userAppID != nil}
  /// Clears the value of `userAppID`. Subsequent reads from it will return its default value.
  public mutating func clearUserAppID() {self._userAppID = nil}

  public var modelID: String = String()

  public var modelVersions: [Clarifai_Api_ModelVersion] = []

  /// The action to perform on the patched objects
  /// For now actions 'merge', 'overwrite', and 'remove' are supported
  public var action: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _userAppID: Clarifai_Api_UserAppIDSet? = nil
}

/// request for different endpoints currently.
public struct Clarifai_Api_GetModelVersionRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var userAppID: Clarifai_Api_UserAppIDSet {
    get {return _userAppID ?? Clarifai_Api_UserAppIDSet()}
    set {_userAppID = newValue}
  }
  /// Returns true if `userAppID` has been explicitly set.
  public var hasUserAppID: Bool {return self._userAppID != nil}
  /// Clears the value of `userAppID`. Subsequent reads from it will return its default value.
  public mutating func clearUserAppID() {self._userAppID = nil}

  public var modelID: String = String()

  public var versionID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _userAppID: Clarifai_Api_UserAppIDSet? = nil
}

/// ListModelVersionsRequest
public struct Clarifai_Api_ListModelVersionsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var userAppID: Clarifai_Api_UserAppIDSet {
    get {return _userAppID ?? Clarifai_Api_UserAppIDSet()}
    set {_userAppID = newValue}
  }
  /// Returns true if `userAppID` has been explicitly set.
  public var hasUserAppID: Bool {return self._userAppID != nil}
  /// Clears the value of `userAppID`. Subsequent reads from it will return its default value.
  public mutating func clearUserAppID() {self._userAppID = nil}

  public var modelID: String = String()

  /// (optional URL parameter) The page number. Pagination is used to split the results into chunks.
  /// Defaults to 1.
  public var page: UInt32 = 0

  /// (optional URL parameter) The number of results that will be contained in each page. Defaults
  /// to 128.
  public var perPage: UInt32 = 0

  /// Filtering options:
  /// To list only the model versions that have these concept ids present in them.
  public var conceptIds: [String] = []

  /// To list only the model versions that have been trained.
  public var trainedOnly: Bool = false

  /// Sorting options:
  /// Whether to sort in ascending order. If false, will order in descending order.
  public var sortAscending: Bool = false

  public var sortBy: Clarifai_Api_ListModelVersionsRequest.OneOf_SortBy? = nil

  /// Whether to order by the status code
  public var sortByStatusCode: Bool {
    get {
      if case .sortByStatusCode(let v)? = sortBy {return v}
      return false
    }
    set {sortBy = .sortByStatusCode(newValue)}
  }

  /// Whether to order by the number of training inputs
  public var sortByNumInputs: Bool {
    get {
      if case .sortByNumInputs(let v)? = sortBy {return v}
      return false
    }
    set {sortBy = .sortByNumInputs(newValue)}
  }

  /// Whether to sort by the description
  public var sortByDescription: Bool {
    get {
      if case .sortByDescription(let v)? = sortBy {return v}
      return false
    }
    set {sortBy = .sortByDescription(newValue)}
  }

  /// Whether to order by the created_at time
  /// If neither sort option is set to true, will sort by created_at.
  public var sortByCreatedAt: Bool {
    get {
      if case .sortByCreatedAt(let v)? = sortBy {return v}
      return false
    }
    set {sortBy = .sortByCreatedAt(newValue)}
  }

  /// Filter by model versions runners with replicas >= min_replicas.
  public var minReplicas: UInt32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_SortBy: Equatable {
    /// Whether to order by the status code
    case sortByStatusCode(Bool)
    /// Whether to order by the number of training inputs
    case sortByNumInputs(Bool)
    /// Whether to sort by the description
    case sortByDescription(Bool)
    /// Whether to order by the created_at time
    /// If neither sort option is set to true, will sort by created_at.
    case sortByCreatedAt(Bool)

  #if !swift(>=4.1)
    public static func ==(lhs: Clarifai_Api_ListModelVersionsRequest.OneOf_SortBy, rhs: Clarifai_Api_ListModelVersionsRequest.OneOf_SortBy) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.sortByStatusCode, .sortByStatusCode): return {
        guard case .sortByStatusCode(let l) = lhs, case .sortByStatusCode(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.sortByNumInputs, .sortByNumInputs): return {
        guard case .sortByNumInputs(let l) = lhs, case .sortByNumInputs(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.sortByDescription, .sortByDescription): return {
        guard case .sortByDescription(let l) = lhs, case .sortByDescription(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.sortByCreatedAt, .sortByCreatedAt): return {
        guard case .sortByCreatedAt(let l) = lhs, case .sortByCreatedAt(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}

  fileprivate var _userAppID: Clarifai_Api_UserAppIDSet? = nil
}

/// DeleteModelVersionRequest
public struct Clarifai_Api_DeleteModelVersionRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var userAppID: Clarifai_Api_UserAppIDSet {
    get {return _userAppID ?? Clarifai_Api_UserAppIDSet()}
    set {_userAppID = newValue}
  }
  /// Returns true if `userAppID` has been explicitly set.
  public var hasUserAppID: Bool {return self._userAppID != nil}
  /// Clears the value of `userAppID`. Subsequent reads from it will return its default value.
  public mutating func clearUserAppID() {self._userAppID = nil}

  public var modelID: String = String()

  public var versionID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _userAppID: Clarifai_Api_UserAppIDSet? = nil
}

/// SingleModelVersionResponse
public struct Clarifai_Api_SingleModelVersionResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var status: Clarifai_Api_Status_Status {
    get {return _status ?? Clarifai_Api_Status_Status()}
    set {_status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  public var hasStatus: Bool {return self._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  public mutating func clearStatus() {self._status = nil}

  public var modelVersion: Clarifai_Api_ModelVersion {
    get {return _modelVersion ?? Clarifai_Api_ModelVersion()}
    set {_modelVersion = newValue}
  }
  /// Returns true if `modelVersion` has been explicitly set.
  public var hasModelVersion: Bool {return self._modelVersion != nil}
  /// Clears the value of `modelVersion`. Subsequent reads from it will return its default value.
  public mutating func clearModelVersion() {self._modelVersion = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _status: Clarifai_Api_Status_Status? = nil
  fileprivate var _modelVersion: Clarifai_Api_ModelVersion? = nil
}

/// MultiModelVersionResponse
public struct Clarifai_Api_MultiModelVersionResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var status: Clarifai_Api_Status_Status {
    get {return _status ?? Clarifai_Api_Status_Status()}
    set {_status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  public var hasStatus: Bool {return self._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  public mutating func clearStatus() {self._status = nil}

  public var modelVersions: [Clarifai_Api_ModelVersion] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _status: Clarifai_Api_Status_Status? = nil
}

/// Create (train) a new model version.
public struct Clarifai_Api_PostModelVersionsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var userAppID: Clarifai_Api_UserAppIDSet {
    get {return _userAppID ?? Clarifai_Api_UserAppIDSet()}
    set {_userAppID = newValue}
  }
  /// Returns true if `userAppID` has been explicitly set.
  public var hasUserAppID: Bool {return self._userAppID != nil}
  /// Clears the value of `userAppID`. Subsequent reads from it will return its default value.
  public mutating func clearUserAppID() {self._userAppID = nil}

  public var modelID: String = String()

  public var modelVersions: [Clarifai_Api_ModelVersion] = []

  /// Description about this training run
  public var description_p: String = String()

  /// When evaluate_after_training set to true, we will do evaluation immediately after training finishes.
  /// We will merge this with default_eval_info.
  public var evalInfo: Clarifai_Api_EvalInfo {
    get {return _evalInfo ?? Clarifai_Api_EvalInfo()}
    set {_evalInfo = newValue}
  }
  /// Returns true if `evalInfo` has been explicitly set.
  public var hasEvalInfo: Bool {return self._evalInfo != nil}
  /// Clears the value of `evalInfo`. Subsequent reads from it will return its default value.
  public mutating func clearEvalInfo() {self._evalInfo = nil}

  /// When set to true, we will convert the model into a containerized model after training.
  public var doMigration: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _userAppID: Clarifai_Api_UserAppIDSet? = nil
  fileprivate var _evalInfo: Clarifai_Api_EvalInfo? = nil
}

public struct Clarifai_Api_PostModelVersionsUploadRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var uploadData: Clarifai_Api_PostModelVersionsUploadRequest.OneOf_UploadData? = nil

  public var uploadConfig: Clarifai_Api_PostModelVersionsUploadConfig {
    get {
      if case .uploadConfig(let v)? = uploadData {return v}
      return Clarifai_Api_PostModelVersionsUploadConfig()
    }
    set {uploadData = .uploadConfig(newValue)}
  }

  public var contentPart: Clarifai_Api_UploadContentPart {
    get {
      if case .contentPart(let v)? = uploadData {return v}
      return Clarifai_Api_UploadContentPart()
    }
    set {uploadData = .contentPart(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_UploadData: Equatable {
    case uploadConfig(Clarifai_Api_PostModelVersionsUploadConfig)
    case contentPart(Clarifai_Api_UploadContentPart)

  #if !swift(>=4.1)
    public static func ==(lhs: Clarifai_Api_PostModelVersionsUploadRequest.OneOf_UploadData, rhs: Clarifai_Api_PostModelVersionsUploadRequest.OneOf_UploadData) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.uploadConfig, .uploadConfig): return {
        guard case .uploadConfig(let l) = lhs, case .uploadConfig(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.contentPart, .contentPart): return {
        guard case .contentPart(let l) = lhs, case .contentPart(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

public struct Clarifai_Api_PostModelVersionsUploadResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var status: Clarifai_Api_Status_Status {
    get {return _status ?? Clarifai_Api_Status_Status()}
    set {_status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  public var hasStatus: Bool {return self._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  public mutating func clearStatus() {self._status = nil}

  public var bytesRemaining: UInt64 = 0

  /// ID of the model version being uploaded
  public var modelVersionID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _status: Clarifai_Api_Status_Status? = nil
}

public struct Clarifai_Api_PostModelVersionsUploadConfig {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var userAppID: Clarifai_Api_UserAppIDSet {
    get {return _userAppID ?? Clarifai_Api_UserAppIDSet()}
    set {_userAppID = newValue}
  }
  /// Returns true if `userAppID` has been explicitly set.
  public var hasUserAppID: Bool {return self._userAppID != nil}
  /// Clears the value of `userAppID`. Subsequent reads from it will return its default value.
  public mutating func clearUserAppID() {self._userAppID = nil}

  /// Model to create version for
  public var modelID: String = String()

  /// Specification for the model version to be uploaded
  public var modelVersion: Clarifai_Api_ModelVersion {
    get {return _modelVersion ?? Clarifai_Api_ModelVersion()}
    set {_modelVersion = newValue}
  }
  /// Returns true if `modelVersion` has been explicitly set.
  public var hasModelVersion: Bool {return self._modelVersion != nil}
  /// Clears the value of `modelVersion`. Subsequent reads from it will return its default value.
  public mutating func clearModelVersion() {self._modelVersion = nil}

  /// Number of bytes in the model files to be uploaded
  public var totalSize: UInt64 = 0

  /// Whether the uploaded package will be a .tar.gz which contains a Dockerfile or the standard .zip
  public var isV3: Bool = false

  /// Number of bytes requested for the build process.
  public var storageRequestSize: UInt64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _userAppID: Clarifai_Api_UserAppIDSet? = nil
  fileprivate var _modelVersion: Clarifai_Api_ModelVersion? = nil
}

/// PutModelVersionExportsRequest
public struct Clarifai_Api_PutModelVersionExportsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var userAppID: Clarifai_Api_UserAppIDSet {
    get {return _userAppID ?? Clarifai_Api_UserAppIDSet()}
    set {_userAppID = newValue}
  }
  /// Returns true if `userAppID` has been explicitly set.
  public var hasUserAppID: Bool {return self._userAppID != nil}
  /// Clears the value of `userAppID`. Subsequent reads from it will return its default value.
  public mutating func clearUserAppID() {self._userAppID = nil}

  public var modelID: String = String()

  public var versionID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _userAppID: Clarifai_Api_UserAppIDSet? = nil
}

/// GetModelVersionExportRequest
public struct Clarifai_Api_GetModelVersionExportRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var userAppID: Clarifai_Api_UserAppIDSet {
    get {return _userAppID ?? Clarifai_Api_UserAppIDSet()}
    set {_userAppID = newValue}
  }
  /// Returns true if `userAppID` has been explicitly set.
  public var hasUserAppID: Bool {return self._userAppID != nil}
  /// Clears the value of `userAppID`. Subsequent reads from it will return its default value.
  public mutating func clearUserAppID() {self._userAppID = nil}

  public var modelID: String = String()

  public var versionID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _userAppID: Clarifai_Api_UserAppIDSet? = nil
}

/// SingleModelVersionExportResponse
public struct Clarifai_Api_SingleModelVersionExportResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var status: Clarifai_Api_Status_Status {
    get {return _storage._status ?? Clarifai_Api_Status_Status()}
    set {_uniqueStorage()._status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  public var hasStatus: Bool {return _storage._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  public mutating func clearStatus() {_uniqueStorage()._status = nil}

  public var export: Clarifai_Api_ModelVersionExport {
    get {return _storage._export ?? Clarifai_Api_ModelVersionExport()}
    set {_uniqueStorage()._export = newValue}
  }
  /// Returns true if `export` has been explicitly set.
  public var hasExport: Bool {return _storage._export != nil}
  /// Clears the value of `export`. Subsequent reads from it will return its default value.
  public mutating func clearExport() {_uniqueStorage()._export = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Clarifai_Api_PostWorkflowVersionsUnPublishRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var userAppID: Clarifai_Api_UserAppIDSet {
    get {return _userAppID ?? Clarifai_Api_UserAppIDSet()}
    set {_userAppID = newValue}
  }
  /// Returns true if `userAppID` has been explicitly set.
  public var hasUserAppID: Bool {return self._userAppID != nil}
  /// Clears the value of `userAppID`. Subsequent reads from it will return its default value.
  public mutating func clearUserAppID() {self._userAppID = nil}

  public var workflowID: String = String()

  public var publications: [Clarifai_Api_WorkflowVersionUnPublishRequest] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _userAppID: Clarifai_Api_UserAppIDSet? = nil
}

public struct Clarifai_Api_PostWorkflowVersionsPublishRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var userAppID: Clarifai_Api_UserAppIDSet {
    get {return _userAppID ?? Clarifai_Api_UserAppIDSet()}
    set {_userAppID = newValue}
  }
  /// Returns true if `userAppID` has been explicitly set.
  public var hasUserAppID: Bool {return self._userAppID != nil}
  /// Clears the value of `userAppID`. Subsequent reads from it will return its default value.
  public mutating func clearUserAppID() {self._userAppID = nil}

  public var workflowID: String = String()

  public var publications: [Clarifai_Api_WorkflowVersionPublishRequest] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _userAppID: Clarifai_Api_UserAppIDSet? = nil
}

public struct Clarifai_Api_WorkflowVersionPublishRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var versionID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Clarifai_Api_WorkflowVersionUnPublishRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var versionID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// ModelVersionPublishRequest
public struct Clarifai_Api_ModelVersionPublishRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var versionID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// PostModelVersionsPublishRequest
public struct Clarifai_Api_PostModelVersionsPublishRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var userAppID: Clarifai_Api_UserAppIDSet {
    get {return _userAppID ?? Clarifai_Api_UserAppIDSet()}
    set {_userAppID = newValue}
  }
  /// Returns true if `userAppID` has been explicitly set.
  public var hasUserAppID: Bool {return self._userAppID != nil}
  /// Clears the value of `userAppID`. Subsequent reads from it will return its default value.
  public mutating func clearUserAppID() {self._userAppID = nil}

  public var modelID: String = String()

  public var publications: [Clarifai_Api_ModelVersionPublishRequest] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _userAppID: Clarifai_Api_UserAppIDSet? = nil
}

/// ModelVersionUnpublishRequest
public struct Clarifai_Api_ModelVersionUnpublishRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var versionID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// PostModelVersionsUnPublishRequest
public struct Clarifai_Api_PostModelVersionsUnPublishRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var userAppID: Clarifai_Api_UserAppIDSet {
    get {return _userAppID ?? Clarifai_Api_UserAppIDSet()}
    set {_userAppID = newValue}
  }
  /// Returns true if `userAppID` has been explicitly set.
  public var hasUserAppID: Bool {return self._userAppID != nil}
  /// Clears the value of `userAppID`. Subsequent reads from it will return its default value.
  public mutating func clearUserAppID() {self._userAppID = nil}

  public var modelID: String = String()

  public var publications: [Clarifai_Api_ModelVersionUnpublishRequest] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _userAppID: Clarifai_Api_UserAppIDSet? = nil
}

/// Evaluate this model vesion
public struct Clarifai_Api_PostEvaluationsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var userAppID: Clarifai_Api_UserAppIDSet {
    get {return _userAppID ?? Clarifai_Api_UserAppIDSet()}
    set {_userAppID = newValue}
  }
  /// Returns true if `userAppID` has been explicitly set.
  public var hasUserAppID: Bool {return self._userAppID != nil}
  /// Clears the value of `userAppID`. Subsequent reads from it will return its default value.
  public mutating func clearUserAppID() {self._userAppID = nil}

  /// eval_info, id, model, and ground_truth_dataset will be used when creating the evaluation
  /// If no dataset is provided, all app data that is annotated with concepts from the model will be used.
  public var evalMetrics: [Clarifai_Api_EvalMetrics] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _userAppID: Clarifai_Api_UserAppIDSet? = nil
}

public struct Clarifai_Api_ListEvaluationsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var userAppID: Clarifai_Api_UserAppIDSet {
    get {return _userAppID ?? Clarifai_Api_UserAppIDSet()}
    set {_userAppID = newValue}
  }
  /// Returns true if `userAppID` has been explicitly set.
  public var hasUserAppID: Bool {return self._userAppID != nil}
  /// Clears the value of `userAppID`. Subsequent reads from it will return its default value.
  public mutating func clearUserAppID() {self._userAppID = nil}

  /// (optional URL parameter) The page number. Pagination is used to split the results into chunks.
  /// Defaults to 1.
  public var page: UInt32 = 0

  /// (optional URL parameter) The number of results that will be contained in each page. Defaults
  /// to 128.
  public var perPage: UInt32 = 0

  /// If true, sort in ascending order, otherwise sort in descending order.
  public var sortAscending: Bool = false

  public var sortBy: Clarifai_Api_ListEvaluationsRequest.OneOf_SortBy? = nil

  /// Whether to order by application id
  public var sortByAppID: Bool {
    get {
      if case .sortByAppID(let v)? = sortBy {return v}
      return false
    }
    set {sortBy = .sortByAppID(newValue)}
  }

  /// Whether to order by eval metric summary.macro_avg_roc_auc
  public var sortByRocAuc: Bool {
    get {
      if case .sortByRocAuc(let v)? = sortBy {return v}
      return false
    }
    set {sortBy = .sortByRocAuc(newValue)}
  }

  /// Whether to order by eval metric summary.f1
  public var sortByF1: Bool {
    get {
      if case .sortByF1(let v)? = sortBy {return v}
      return false
    }
    set {sortBy = .sortByF1(newValue)}
  }

  /// Whether to order by when the metric was created
  public var sortByCreatedAt: Bool {
    get {
      if case .sortByCreatedAt(let v)? = sortBy {return v}
      return false
    }
    set {sortBy = .sortByCreatedAt(newValue)}
  }

  /// Whether to order by eval metric summary.mean_avg_precision_iou_50
  public var sortByMeanAvgPrecision: Bool {
    get {
      if case .sortByMeanAvgPrecision(let v)? = sortBy {return v}
      return false
    }
    set {sortBy = .sortByMeanAvgPrecision(newValue)}
  }

  /// Whether to order by eval metric summary.macro_avg_precision
  public var sortByPrecision: Bool {
    get {
      if case .sortByPrecision(let v)? = sortBy {return v}
      return false
    }
    set {sortBy = .sortByPrecision(newValue)}
  }

  /// Whether to order by eval metric summary.macro_avg_recall
  public var sortByRecall: Bool {
    get {
      if case .sortByRecall(let v)? = sortBy {return v}
      return false
    }
    set {sortBy = .sortByRecall(newValue)}
  }

  public var sortByModelID: Bool {
    get {
      if case .sortByModelID(let v)? = sortBy {return v}
      return false
    }
    set {sortBy = .sortByModelID(newValue)}
  }

  public var sortByEvalDatasetID: Bool {
    get {
      if case .sortByEvalDatasetID(let v)? = sortBy {return v}
      return false
    }
    set {sortBy = .sortByEvalDatasetID(newValue)}
  }

  public var sortByTrainDatasetID: Bool {
    get {
      if case .sortByTrainDatasetID(let v)? = sortBy {return v}
      return false
    }
    set {sortBy = .sortByTrainDatasetID(newValue)}
  }

  /// Filter on model type id
  public var modelTypeID: String = String()

  /// Filter on dataset ID of the dataset version specified in the metric version
  public var evalDatasetIds: [String] = []

  /// Filter on dataset ID of the dataset version specified by the model version
  public var trainDatasetIds: [String] = []

  /// Filter on concept IDs specified in the modele version's output_info
  public var conceptIds: [String] = []

  /// Whether to show failed metrics, defaults to false
  public var showFailedMetrics: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_SortBy: Equatable {
    /// Whether to order by application id
    case sortByAppID(Bool)
    /// Whether to order by eval metric summary.macro_avg_roc_auc
    case sortByRocAuc(Bool)
    /// Whether to order by eval metric summary.f1
    case sortByF1(Bool)
    /// Whether to order by when the metric was created
    case sortByCreatedAt(Bool)
    /// Whether to order by eval metric summary.mean_avg_precision_iou_50
    case sortByMeanAvgPrecision(Bool)
    /// Whether to order by eval metric summary.macro_avg_precision
    case sortByPrecision(Bool)
    /// Whether to order by eval metric summary.macro_avg_recall
    case sortByRecall(Bool)
    case sortByModelID(Bool)
    case sortByEvalDatasetID(Bool)
    case sortByTrainDatasetID(Bool)

  #if !swift(>=4.1)
    public static func ==(lhs: Clarifai_Api_ListEvaluationsRequest.OneOf_SortBy, rhs: Clarifai_Api_ListEvaluationsRequest.OneOf_SortBy) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.sortByAppID, .sortByAppID): return {
        guard case .sortByAppID(let l) = lhs, case .sortByAppID(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.sortByRocAuc, .sortByRocAuc): return {
        guard case .sortByRocAuc(let l) = lhs, case .sortByRocAuc(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.sortByF1, .sortByF1): return {
        guard case .sortByF1(let l) = lhs, case .sortByF1(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.sortByCreatedAt, .sortByCreatedAt): return {
        guard case .sortByCreatedAt(let l) = lhs, case .sortByCreatedAt(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.sortByMeanAvgPrecision, .sortByMeanAvgPrecision): return {
        guard case .sortByMeanAvgPrecision(let l) = lhs, case .sortByMeanAvgPrecision(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.sortByPrecision, .sortByPrecision): return {
        guard case .sortByPrecision(let l) = lhs, case .sortByPrecision(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.sortByRecall, .sortByRecall): return {
        guard case .sortByRecall(let l) = lhs, case .sortByRecall(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.sortByModelID, .sortByModelID): return {
        guard case .sortByModelID(let l) = lhs, case .sortByModelID(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.sortByEvalDatasetID, .sortByEvalDatasetID): return {
        guard case .sortByEvalDatasetID(let l) = lhs, case .sortByEvalDatasetID(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.sortByTrainDatasetID, .sortByTrainDatasetID): return {
        guard case .sortByTrainDatasetID(let l) = lhs, case .sortByTrainDatasetID(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}

  fileprivate var _userAppID: Clarifai_Api_UserAppIDSet? = nil
}

public struct Clarifai_Api_GetEvaluationRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var userAppID: Clarifai_Api_UserAppIDSet {
    get {return _userAppID ?? Clarifai_Api_UserAppIDSet()}
    set {_userAppID = newValue}
  }
  /// Returns true if `userAppID` has been explicitly set.
  public var hasUserAppID: Bool {return self._userAppID != nil}
  /// Clears the value of `userAppID`. Subsequent reads from it will return its default value.
  public mutating func clearUserAppID() {self._userAppID = nil}

  public var evaluationID: String = String()

  /// Any of the fields you wish to return in the metrics
  /// By default, only the summary is returned.
  public var fields: Clarifai_Api_FieldsValue {
    get {return _fields ?? Clarifai_Api_FieldsValue()}
    set {_fields = newValue}
  }
  /// Returns true if `fields` has been explicitly set.
  public var hasFields: Bool {return self._fields != nil}
  /// Clears the value of `fields`. Subsequent reads from it will return its default value.
  public mutating func clearFields() {self._fields = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _userAppID: Clarifai_Api_UserAppIDSet? = nil
  fileprivate var _fields: Clarifai_Api_FieldsValue? = nil
}

/// Evaluate this model vesion
public struct Clarifai_Api_PostModelVersionEvaluationsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var userAppID: Clarifai_Api_UserAppIDSet {
    get {return _userAppID ?? Clarifai_Api_UserAppIDSet()}
    set {_userAppID = newValue}
  }
  /// Returns true if `userAppID` has been explicitly set.
  public var hasUserAppID: Bool {return self._userAppID != nil}
  /// Clears the value of `userAppID`. Subsequent reads from it will return its default value.
  public mutating func clearUserAppID() {self._userAppID = nil}

  public var modelID: String = String()

  public var modelVersionID: String = String()

  /// EvalInfo and ID will be used when creating the evaluation
  public var evalMetrics: [Clarifai_Api_EvalMetrics] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _userAppID: Clarifai_Api_UserAppIDSet? = nil
}

public struct Clarifai_Api_ListModelVersionEvaluationsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var userAppID: Clarifai_Api_UserAppIDSet {
    get {return _userAppID ?? Clarifai_Api_UserAppIDSet()}
    set {_userAppID = newValue}
  }
  /// Returns true if `userAppID` has been explicitly set.
  public var hasUserAppID: Bool {return self._userAppID != nil}
  /// Clears the value of `userAppID`. Subsequent reads from it will return its default value.
  public mutating func clearUserAppID() {self._userAppID = nil}

  public var modelID: String = String()

  public var modelVersionID: String = String()

  /// (optional URL parameter) The page number. Pagination is used to split the results into chunks.
  /// Defaults to 1.
  public var page: UInt32 = 0

  /// (optional URL parameter) The number of results that will be contained in each page. Defaults
  /// to 128.
  public var perPage: UInt32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _userAppID: Clarifai_Api_UserAppIDSet? = nil
}

public struct Clarifai_Api_GetModelVersionEvaluationRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var userAppID: Clarifai_Api_UserAppIDSet {
    get {return _userAppID ?? Clarifai_Api_UserAppIDSet()}
    set {_userAppID = newValue}
  }
  /// Returns true if `userAppID` has been explicitly set.
  public var hasUserAppID: Bool {return self._userAppID != nil}
  /// Clears the value of `userAppID`. Subsequent reads from it will return its default value.
  public mutating func clearUserAppID() {self._userAppID = nil}

  public var modelID: String = String()

  public var modelVersionID: String = String()

  public var evaluationID: String = String()

  /// Any of the fields you wish to return from multiclass_metrics
  /// By default, only the summary is returned.
  public var fields: Clarifai_Api_FieldsValue {
    get {return _fields ?? Clarifai_Api_FieldsValue()}
    set {_fields = newValue}
  }
  /// Returns true if `fields` has been explicitly set.
  public var hasFields: Bool {return self._fields != nil}
  /// Clears the value of `fields`. Subsequent reads from it will return its default value.
  public mutating func clearFields() {self._fields = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _userAppID: Clarifai_Api_UserAppIDSet? = nil
  fileprivate var _fields: Clarifai_Api_FieldsValue? = nil
}

public struct Clarifai_Api_SingleEvalMetricsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var status: Clarifai_Api_Status_Status {
    get {return _status ?? Clarifai_Api_Status_Status()}
    set {_status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  public var hasStatus: Bool {return self._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  public mutating func clearStatus() {self._status = nil}

  public var evalMetrics: Clarifai_Api_EvalMetrics {
    get {return _evalMetrics ?? Clarifai_Api_EvalMetrics()}
    set {_evalMetrics = newValue}
  }
  /// Returns true if `evalMetrics` has been explicitly set.
  public var hasEvalMetrics: Bool {return self._evalMetrics != nil}
  /// Clears the value of `evalMetrics`. Subsequent reads from it will return its default value.
  public mutating func clearEvalMetrics() {self._evalMetrics = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _status: Clarifai_Api_Status_Status? = nil
  fileprivate var _evalMetrics: Clarifai_Api_EvalMetrics? = nil
}

public struct Clarifai_Api_MultiEvalMetricsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var status: Clarifai_Api_Status_Status {
    get {return _status ?? Clarifai_Api_Status_Status()}
    set {_status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  public var hasStatus: Bool {return self._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  public mutating func clearStatus() {self._status = nil}

  public var evalMetrics: [Clarifai_Api_EvalMetrics] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _status: Clarifai_Api_Status_Status? = nil
}

/// Evaluate this model version.
public struct Clarifai_Api_PostModelVersionMetricsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var userAppID: Clarifai_Api_UserAppIDSet {
    get {return _userAppID ?? Clarifai_Api_UserAppIDSet()}
    set {_userAppID = newValue}
  }
  /// Returns true if `userAppID` has been explicitly set.
  public var hasUserAppID: Bool {return self._userAppID != nil}
  /// Clears the value of `userAppID`. Subsequent reads from it will return its default value.
  public mutating func clearUserAppID() {self._userAppID = nil}

  public var modelID: String = String()

  public var versionID: String = String()

  /// Use this to filter inputs that are used in evaluation
  public var testSearch: Clarifai_Api_Search {
    get {return _testSearch ?? Clarifai_Api_Search()}
    set {_testSearch = newValue}
  }
  /// Returns true if `testSearch` has been explicitly set.
  public var hasTestSearch: Bool {return self._testSearch != nil}
  /// Clears the value of `testSearch`. Subsequent reads from it will return its default value.
  public mutating func clearTestSearch() {self._testSearch = nil}

  /// evaluation info. Such as dataset used for evaluation.
  public var evalInfo: Clarifai_Api_EvalInfo {
    get {return _evalInfo ?? Clarifai_Api_EvalInfo()}
    set {_evalInfo = newValue}
  }
  /// Returns true if `evalInfo` has been explicitly set.
  public var hasEvalInfo: Bool {return self._evalInfo != nil}
  /// Clears the value of `evalInfo`. Subsequent reads from it will return its default value.
  public mutating func clearEvalInfo() {self._evalInfo = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _userAppID: Clarifai_Api_UserAppIDSet? = nil
  fileprivate var _testSearch: Clarifai_Api_Search? = nil
  fileprivate var _evalInfo: Clarifai_Api_EvalInfo? = nil
}

/// Get the already computed evaluation metrics for this model
/// version.
public struct Clarifai_Api_GetModelVersionMetricsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var userAppID: Clarifai_Api_UserAppIDSet {
    get {return _userAppID ?? Clarifai_Api_UserAppIDSet()}
    set {_userAppID = newValue}
  }
  /// Returns true if `userAppID` has been explicitly set.
  public var hasUserAppID: Bool {return self._userAppID != nil}
  /// Clears the value of `userAppID`. Subsequent reads from it will return its default value.
  public mutating func clearUserAppID() {self._userAppID = nil}

  public var modelID: String = String()

  public var versionID: String = String()

  /// Any of the fields you wish to return from multiclass_metrics
  /// By default, only the summary will be returned
  public var fields: Clarifai_Api_FieldsValue {
    get {return _fields ?? Clarifai_Api_FieldsValue()}
    set {_fields = newValue}
  }
  /// Returns true if `fields` has been explicitly set.
  public var hasFields: Bool {return self._fields != nil}
  /// Clears the value of `fields`. Subsequent reads from it will return its default value.
  public mutating func clearFields() {self._fields = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _userAppID: Clarifai_Api_UserAppIDSet? = nil
  fileprivate var _fields: Clarifai_Api_FieldsValue? = nil
}

/// GetModelTypeRequest
public struct Clarifai_Api_GetModelTypeRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// use and app combo. Not really used for this endpoint at this time so may go away in future.
  public var userAppID: Clarifai_Api_UserAppIDSet {
    get {return _userAppID ?? Clarifai_Api_UserAppIDSet()}
    set {_userAppID = newValue}
  }
  /// Returns true if `userAppID` has been explicitly set.
  public var hasUserAppID: Bool {return self._userAppID != nil}
  /// Clears the value of `userAppID`. Subsequent reads from it will return its default value.
  public mutating func clearUserAppID() {self._userAppID = nil}

  /// The specific ModelType.Id you want to retrieve.
  public var modelTypeID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _userAppID: Clarifai_Api_UserAppIDSet? = nil
}

/// ListModelTypesRequest
public struct Clarifai_Api_ListModelTypesRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// use and app combo. Not really used for this endpoint at this time so may go away in future.
  public var userAppID: Clarifai_Api_UserAppIDSet {
    get {return _userAppID ?? Clarifai_Api_UserAppIDSet()}
    set {_userAppID = newValue}
  }
  /// Returns true if `userAppID` has been explicitly set.
  public var hasUserAppID: Bool {return self._userAppID != nil}
  /// Clears the value of `userAppID`. Subsequent reads from it will return its default value.
  public mutating func clearUserAppID() {self._userAppID = nil}

  /// (optional URL parameter) The page number. Pagination is used to split the results into chunks.
  /// Defaults to 1.
  public var page: UInt32 = 0

  /// (optional URL parameter) The number of results that will be contained in each page. Defaults
  /// to 128.
  public var perPage: UInt32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _userAppID: Clarifai_Api_UserAppIDSet? = nil
}

/// ListOpenSourceLicensesRequest
public struct Clarifai_Api_ListOpenSourceLicensesRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// ListOpenSourceLicensesResponse
public struct Clarifai_Api_ListOpenSourceLicensesResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var status: Clarifai_Api_Status_Status {
    get {return _status ?? Clarifai_Api_Status_Status()}
    set {_status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  public var hasStatus: Bool {return self._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  public mutating func clearStatus() {self._status = nil}

  public var licenses: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _status: Clarifai_Api_Status_Status? = nil
}

/// SingleModelTypeResponse
public struct Clarifai_Api_SingleModelTypeResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Status of the response.
  public var status: Clarifai_Api_Status_Status {
    get {return _storage._status ?? Clarifai_Api_Status_Status()}
    set {_uniqueStorage()._status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  public var hasStatus: Bool {return _storage._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  public mutating func clearStatus() {_uniqueStorage()._status = nil}

  /// The retrieved ModelType object. .
  public var modelType: Clarifai_Api_ModelType {
    get {return _storage._modelType ?? Clarifai_Api_ModelType()}
    set {_uniqueStorage()._modelType = newValue}
  }
  /// Returns true if `modelType` has been explicitly set.
  public var hasModelType: Bool {return _storage._modelType != nil}
  /// Clears the value of `modelType`. Subsequent reads from it will return its default value.
  public mutating func clearModelType() {_uniqueStorage()._modelType = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// MultiModelTypeResponse
public struct Clarifai_Api_MultiModelTypeResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Status of the response.
  public var status: Clarifai_Api_Status_Status {
    get {return _status ?? Clarifai_Api_Status_Status()}
    set {_status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  public var hasStatus: Bool {return self._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  public mutating func clearStatus() {self._status = nil}

  /// List of ModelType objects.
  public var modelTypes: [Clarifai_Api_ModelType] = []

  /// List of model importers
  public var modelImporters: Clarifai_Api_ModelTypeField {
    get {return _modelImporters ?? Clarifai_Api_ModelTypeField()}
    set {_modelImporters = newValue}
  }
  /// Returns true if `modelImporters` has been explicitly set.
  public var hasModelImporters: Bool {return self._modelImporters != nil}
  /// Clears the value of `modelImporters`. Subsequent reads from it will return its default value.
  public mutating func clearModelImporters() {self._modelImporters = nil}

  /// Triton model envs that can be used for model upload
  public var tritonCondaEnvsInfo: [Clarifai_Api_TritonCondaEnvInfo] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _status: Clarifai_Api_Status_Status? = nil
  fileprivate var _modelImporters: Clarifai_Api_ModelTypeField? = nil
}

/// GetModelVersionInputExampleRequest
public struct Clarifai_Api_GetModelVersionInputExampleRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// authorization field  (contains app/user id info)
  public var userAppID: Clarifai_Api_UserAppIDSet {
    get {return _userAppID ?? Clarifai_Api_UserAppIDSet()}
    set {_userAppID = newValue}
  }
  /// Returns true if `userAppID` has been explicitly set.
  public var hasUserAppID: Bool {return self._userAppID != nil}
  /// Clears the value of `userAppID`. Subsequent reads from it will return its default value.
  public mutating func clearUserAppID() {self._userAppID = nil}

  /// id of model the example belongs to
  public var modelID: String = String()

  /// specific version the example belongs to
  public var modelVersionID: String = String()

  /// Id of example to fetch
  public var exampleID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _userAppID: Clarifai_Api_UserAppIDSet? = nil
}

/// ListModelVersionInputExamplesRequest
public struct Clarifai_Api_ListModelVersionInputExamplesRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// authorization field  (contains app/user id info)
  public var userAppID: Clarifai_Api_UserAppIDSet {
    get {return _userAppID ?? Clarifai_Api_UserAppIDSet()}
    set {_userAppID = newValue}
  }
  /// Returns true if `userAppID` has been explicitly set.
  public var hasUserAppID: Bool {return self._userAppID != nil}
  /// Clears the value of `userAppID`. Subsequent reads from it will return its default value.
  public mutating func clearUserAppID() {self._userAppID = nil}

  /// id of model the example belongs to
  public var modelID: String = String()

  /// specific version the example belongs to
  public var modelVersionID: String = String()

  /// Optional, defaults to 1.
  public var page: UInt32 = 0

  /// Optional, defaults to 128 references per page.
  public var perPage: UInt32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _userAppID: Clarifai_Api_UserAppIDSet? = nil
}

/// SingleModelVersionInputExampleResponse
public struct Clarifai_Api_SingleModelVersionInputExampleResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// status of response
  public var status: Clarifai_Api_Status_Status {
    get {return _storage._status ?? Clarifai_Api_Status_Status()}
    set {_uniqueStorage()._status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  public var hasStatus: Bool {return _storage._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  public mutating func clearStatus() {_uniqueStorage()._status = nil}

  /// model input example message
  public var modelVersionInputExample: Clarifai_Api_ModelVersionInputExample {
    get {return _storage._modelVersionInputExample ?? Clarifai_Api_ModelVersionInputExample()}
    set {_uniqueStorage()._modelVersionInputExample = newValue}
  }
  /// Returns true if `modelVersionInputExample` has been explicitly set.
  public var hasModelVersionInputExample: Bool {return _storage._modelVersionInputExample != nil}
  /// Clears the value of `modelVersionInputExample`. Subsequent reads from it will return its default value.
  public mutating func clearModelVersionInputExample() {_uniqueStorage()._modelVersionInputExample = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// MultiModelVersionInputExampleResponse
public struct Clarifai_Api_MultiModelVersionInputExampleResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// status of response
  public var status: Clarifai_Api_Status_Status {
    get {return _status ?? Clarifai_Api_Status_Status()}
    set {_status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  public var hasStatus: Bool {return self._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  public mutating func clearStatus() {self._status = nil}

  /// model input example messages
  public var modelVersionInputExamples: [Clarifai_Api_ModelVersionInputExample] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _status: Clarifai_Api_Status_Status? = nil
}

/// ListModelReferencesRequest
public struct Clarifai_Api_ListModelReferencesRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var userAppID: Clarifai_Api_UserAppIDSet {
    get {return _userAppID ?? Clarifai_Api_UserAppIDSet()}
    set {_userAppID = newValue}
  }
  /// Returns true if `userAppID` has been explicitly set.
  public var hasUserAppID: Bool {return self._userAppID != nil}
  /// Clears the value of `userAppID`. Subsequent reads from it will return its default value.
  public mutating func clearUserAppID() {self._userAppID = nil}

  public var modelID: String = String()

  /// Optional, defaults to 1.
  public var page: UInt32 = 0

  /// Optional, defaults to 128 references per page.
  public var perPage: UInt32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _userAppID: Clarifai_Api_UserAppIDSet? = nil
}

/// MultiModelReferenceResponse
public struct Clarifai_Api_MultiModelReferenceResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var status: Clarifai_Api_Status_Status {
    get {return _status ?? Clarifai_Api_Status_Status()}
    set {_status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  public var hasStatus: Bool {return self._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  public mutating func clearStatus() {self._status = nil}

  public var modelReferences: [Clarifai_Api_ModelReference] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _status: Clarifai_Api_Status_Status? = nil
}

/// MultiOutputResponse
public struct Clarifai_Api_MultiOutputResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var status: Clarifai_Api_Status_Status {
    get {return _status ?? Clarifai_Api_Status_Status()}
    set {_status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  public var hasStatus: Bool {return self._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  public mutating func clearStatus() {self._status = nil}

  /// For each input processed during model prediction we create one output.
  public var outputs: [Clarifai_Api_Output] = []

  /// Information on where the computation is executed down to specific Deployment, Nodepool and ComputeCluster
  public var runnerSelector: Clarifai_Api_RunnerSelector {
    get {return _runnerSelector ?? Clarifai_Api_RunnerSelector()}
    set {_runnerSelector = newValue}
  }
  /// Returns true if `runnerSelector` has been explicitly set.
  public var hasRunnerSelector: Bool {return self._runnerSelector != nil}
  /// Clears the value of `runnerSelector`. Subsequent reads from it will return its default value.
  public mutating func clearRunnerSelector() {self._runnerSelector = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _status: Clarifai_Api_Status_Status? = nil
  fileprivate var _runnerSelector: Clarifai_Api_RunnerSelector? = nil
}

public struct Clarifai_Api_MultiLogEntryResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var status: Clarifai_Api_Status_Status {
    get {return _status ?? Clarifai_Api_Status_Status()}
    set {_status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  public var hasStatus: Bool {return self._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  public mutating func clearStatus() {self._status = nil}

  /// Log entries.
  public var logEntries: [Clarifai_Api_LogEntry] = []

  /// The page the log entries are from. If the request's page was omitted or greater than the total pages, then this is set to the last page.
  public var page: UInt32 = 0

  /// The number of results contained in each page.
  public var perPage: UInt32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _status: Clarifai_Api_Status_Status? = nil
}

/// ListScopesRequest
public struct Clarifai_Api_ListScopesRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// If "personal_access_token" include scopes and endpoints available to personal access tokens.
  /// If "app_specific_key" include scopes and endpoints available to app-specific keys. (default)
  public var keyType: String = String()

  /// For all user specific information we include user_app_id to get the user_id in a consistent way
  public var userAppID: Clarifai_Api_UserAppIDSet {
    get {return _userAppID ?? Clarifai_Api_UserAppIDSet()}
    set {_userAppID = newValue}
  }
  /// Returns true if `userAppID` has been explicitly set.
  public var hasUserAppID: Bool {return self._userAppID != nil}
  /// Clears the value of `userAppID`. Subsequent reads from it will return its default value.
  public mutating func clearUserAppID() {self._userAppID = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _userAppID: Clarifai_Api_UserAppIDSet? = nil
}

/// MyScopesRequest
public struct Clarifai_Api_MyScopesRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var userAppID: Clarifai_Api_UserAppIDSet {
    get {return _userAppID ?? Clarifai_Api_UserAppIDSet()}
    set {_userAppID = newValue}
  }
  /// Returns true if `userAppID` has been explicitly set.
  public var hasUserAppID: Bool {return self._userAppID != nil}
  /// Clears the value of `userAppID`. Subsequent reads from it will return its default value.
  public mutating func clearUserAppID() {self._userAppID = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _userAppID: Clarifai_Api_UserAppIDSet? = nil
}

/// MyScopesUserRequest
public struct Clarifai_Api_MyScopesUserRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var userAppID: Clarifai_Api_UserAppIDSet {
    get {return _userAppID ?? Clarifai_Api_UserAppIDSet()}
    set {_userAppID = newValue}
  }
  /// Returns true if `userAppID` has been explicitly set.
  public var hasUserAppID: Bool {return self._userAppID != nil}
  /// Clears the value of `userAppID`. Subsequent reads from it will return its default value.
  public mutating func clearUserAppID() {self._userAppID = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _userAppID: Clarifai_Api_UserAppIDSet? = nil
}

/// MyScopesRootRequest
public struct Clarifai_Api_MyScopesRootRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// MultiScopeDepsResponse
public struct Clarifai_Api_MultiScopeDepsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The status of the request.
  public var status: Clarifai_Api_Status_Status {
    get {return _status ?? Clarifai_Api_Status_Status()}
    set {_status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  public var hasStatus: Bool {return self._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  public mutating func clearStatus() {self._status = nil}

  /// scopes is a list of low-level scopes and their dependencies.
  public var scopeDeps: [Clarifai_Api_ScopeDeps] = []

  /// endpoint_scopes is a listof all the publicly available endponts which can be
  /// used as scopes as well. A call to each of those endpoint depends on a subset
  /// of the above "scopes"
  public var endpointDeps: [Clarifai_Api_EndpointDeps] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _status: Clarifai_Api_Status_Status? = nil
}

/// MultiScopeResponse
public struct Clarifai_Api_MultiScopeResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The status of the request.
  public var status: Clarifai_Api_Status_Status {
    get {return _storage._status ?? Clarifai_Api_Status_Status()}
    set {_uniqueStorage()._status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  public var hasStatus: Bool {return _storage._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  public mutating func clearStatus() {_uniqueStorage()._status = nil}

  /// This is a list of the scopes that your key has.
  public var scopes: [String] {
    get {return _storage._scopes}
    set {_uniqueStorage()._scopes = newValue}
  }

  /// The app that the key has access to.
  public var app: Clarifai_Api_App {
    get {return _storage._app ?? Clarifai_Api_App()}
    set {_uniqueStorage()._app = newValue}
  }
  /// Returns true if `app` has been explicitly set.
  public var hasApp: Bool {return _storage._app != nil}
  /// Clears the value of `app`. Subsequent reads from it will return its default value.
  public mutating func clearApp() {_uniqueStorage()._app = nil}

  /// This is a list of endpoint permissions that your key has.
  public var endpoints: [String] {
    get {return _storage._endpoints}
    set {_uniqueStorage()._endpoints = newValue}
  }

  public var userFeatureFlags: String {
    get {return _storage._userFeatureFlags}
    set {_uniqueStorage()._userFeatureFlags = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// MultiScopeUserResponse
public struct Clarifai_Api_MultiScopeUserResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The status of the request.
  public var status: Clarifai_Api_Status_Status {
    get {return _status ?? Clarifai_Api_Status_Status()}
    set {_status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  public var hasStatus: Bool {return self._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  public mutating func clearStatus() {self._status = nil}

  /// This is a list of the scopes that your key has.
  public var scopes: [String] = []

  /// This is a list of endpoint permissions that your key has.
  public var endpoints: [String] = []

  public var userFeatureFlags: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _status: Clarifai_Api_Status_Status? = nil
}

/// MultiScopeRootResponse
public struct Clarifai_Api_MultiScopeRootResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The status of the request.
  public var status: Clarifai_Api_Status_Status {
    get {return _status ?? Clarifai_Api_Status_Status()}
    set {_status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  public var hasStatus: Bool {return self._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  public mutating func clearStatus() {self._status = nil}

  /// This is a list of the scopes that your key has.
  public var scopes: [String] = []

  /// This is a list of endpoint permissions that your key has.
  public var endpoints: [String] = []

  public var userFeatureFlags: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _status: Clarifai_Api_Status_Status? = nil
}

/// GetSearchRequest
public struct Clarifai_Api_GetSearchRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var userAppID: Clarifai_Api_UserAppIDSet {
    get {return _userAppID ?? Clarifai_Api_UserAppIDSet()}
    set {_userAppID = newValue}
  }
  /// Returns true if `userAppID` has been explicitly set.
  public var hasUserAppID: Bool {return self._userAppID != nil}
  /// Clears the value of `userAppID`. Subsequent reads from it will return its default value.
  public mutating func clearUserAppID() {self._userAppID = nil}

  public var id: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _userAppID: Clarifai_Api_UserAppIDSet? = nil
}

/// ListSearchesRequest
public struct Clarifai_Api_ListSearchesRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var userAppID: Clarifai_Api_UserAppIDSet {
    get {return _userAppID ?? Clarifai_Api_UserAppIDSet()}
    set {_userAppID = newValue}
  }
  /// Returns true if `userAppID` has been explicitly set.
  public var hasUserAppID: Bool {return self._userAppID != nil}
  /// Clears the value of `userAppID`. Subsequent reads from it will return its default value.
  public mutating func clearUserAppID() {self._userAppID = nil}

  /// (optional URL parameter) The page number. Pagination is used to split the results into chunks.
  /// Defaults to 1.
  public var page: UInt32 = 0

  /// (optional URL parameter) The number of results that will be contained in each page. Defaults
  /// to 128.
  public var perPage: UInt32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _userAppID: Clarifai_Api_UserAppIDSet? = nil
}

/// PostSearchesRequest
public struct Clarifai_Api_PostSearchesRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The user_id and app_id to query from.
  public var userAppID: Clarifai_Api_UserAppIDSet {
    get {return _userAppID ?? Clarifai_Api_UserAppIDSet()}
    set {_userAppID = newValue}
  }
  /// Returns true if `userAppID` has been explicitly set.
  public var hasUserAppID: Bool {return self._userAppID != nil}
  /// Clears the value of `userAppID`. Subsequent reads from it will return its default value.
  public mutating func clearUserAppID() {self._userAppID = nil}

  /// The query; this specifies how the data to be searched
  /// this will be replaced by "Searches"
  public var query: Clarifai_Api_Query {
    get {return _query ?? Clarifai_Api_Query()}
    set {_query = newValue}
  }
  /// Returns true if `query` has been explicitly set.
  public var hasQuery: Bool {return self._query != nil}
  /// Clears the value of `query`. Subsequent reads from it will return its default value.
  public mutating func clearQuery() {self._query = nil}

  /// The searched to be executed or saved
  /// Eventually the request level fields will be deprecated in favor of this object
  public var searches: [Clarifai_Api_Search] = []

  /// Pagination information to paginate through search result Hits.
  public var pagination: Clarifai_Api_Pagination {
    get {return _pagination ?? Clarifai_Api_Pagination()}
    set {_pagination = newValue}
  }
  /// Returns true if `pagination` has been explicitly set.
  public var hasPagination: Bool {return self._pagination != nil}
  /// Clears the value of `pagination`. Subsequent reads from it will return its default value.
  public mutating func clearPagination() {self._pagination = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _userAppID: Clarifai_Api_UserAppIDSet? = nil
  fileprivate var _query: Clarifai_Api_Query? = nil
  fileprivate var _pagination: Clarifai_Api_Pagination? = nil
}

public struct Clarifai_Api_PatchInputsSearchesRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The user_id and app_id to query from.
  public var userAppID: Clarifai_Api_UserAppIDSet {
    get {return _userAppID ?? Clarifai_Api_UserAppIDSet()}
    set {_userAppID = newValue}
  }
  /// Returns true if `userAppID` has been explicitly set.
  public var hasUserAppID: Bool {return self._userAppID != nil}
  /// Clears the value of `userAppID`. Subsequent reads from it will return its default value.
  public mutating func clearUserAppID() {self._userAppID = nil}

  /// The searches to be patched
  public var searches: [Clarifai_Api_Search] = []

  /// The action to perform on the patched Search objects
  /// For now only action 'overwrite' is supported
  public var action: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _userAppID: Clarifai_Api_UserAppIDSet? = nil
}

public struct Clarifai_Api_PatchAnnotationsSearchesRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The user_id and app_id to query from.
  public var userAppID: Clarifai_Api_UserAppIDSet {
    get {return _userAppID ?? Clarifai_Api_UserAppIDSet()}
    set {_userAppID = newValue}
  }
  /// Returns true if `userAppID` has been explicitly set.
  public var hasUserAppID: Bool {return self._userAppID != nil}
  /// Clears the value of `userAppID`. Subsequent reads from it will return its default value.
  public mutating func clearUserAppID() {self._userAppID = nil}

  /// The searches to be patched
  public var searches: [Clarifai_Api_Search] = []

  /// The action to perform on the patched Search objects
  /// For now only action 'overwrite' is supported
  public var action: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _userAppID: Clarifai_Api_UserAppIDSet? = nil
}

/// PatchSearchesRequest
public struct Clarifai_Api_PatchSearchesRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The user_id and app_id to query from.
  public var userAppID: Clarifai_Api_UserAppIDSet {
    get {return _userAppID ?? Clarifai_Api_UserAppIDSet()}
    set {_userAppID = newValue}
  }
  /// Returns true if `userAppID` has been explicitly set.
  public var hasUserAppID: Bool {return self._userAppID != nil}
  /// Clears the value of `userAppID`. Subsequent reads from it will return its default value.
  public mutating func clearUserAppID() {self._userAppID = nil}

  /// The searches to be patched
  public var searches: [Clarifai_Api_Search] = []

  /// The action to perform on the patched Search objects
  /// For now only action 'overwrite' is supported
  public var action: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _userAppID: Clarifai_Api_UserAppIDSet? = nil
}

/// PostSearchesByIDRequest performs returns results of a saved search given its ID
public struct Clarifai_Api_PostSearchesByIDRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var userAppID: Clarifai_Api_UserAppIDSet {
    get {return _userAppID ?? Clarifai_Api_UserAppIDSet()}
    set {_userAppID = newValue}
  }
  /// Returns true if `userAppID` has been explicitly set.
  public var hasUserAppID: Bool {return self._userAppID != nil}
  /// Clears the value of `userAppID`. Subsequent reads from it will return its default value.
  public mutating func clearUserAppID() {self._userAppID = nil}

  /// ID for saves search to be executed
  public var id: String = String()

  /// Pagination information to paginate through search result Hits.
  public var pagination: Clarifai_Api_Pagination {
    get {return _pagination ?? Clarifai_Api_Pagination()}
    set {_pagination = newValue}
  }
  /// Returns true if `pagination` has been explicitly set.
  public var hasPagination: Bool {return self._pagination != nil}
  /// Clears the value of `pagination`. Subsequent reads from it will return its default value.
  public mutating func clearPagination() {self._pagination = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _userAppID: Clarifai_Api_UserAppIDSet? = nil
  fileprivate var _pagination: Clarifai_Api_Pagination? = nil
}

/// DeleteSearchRequest
public struct Clarifai_Api_DeleteSearchRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var userAppID: Clarifai_Api_UserAppIDSet {
    get {return _userAppID ?? Clarifai_Api_UserAppIDSet()}
    set {_userAppID = newValue}
  }
  /// Returns true if `userAppID` has been explicitly set.
  public var hasUserAppID: Bool {return self._userAppID != nil}
  /// Clears the value of `userAppID`. Subsequent reads from it will return its default value.
  public mutating func clearUserAppID() {self._userAppID = nil}

  public var id: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _userAppID: Clarifai_Api_UserAppIDSet? = nil
}

/// Execute a new annotation search and optionally save it
/// annotation search over annotations using rank and filter proto
public struct Clarifai_Api_PostAnnotationsSearchesRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The user_id and app_id to query from.
  public var userAppID: Clarifai_Api_UserAppIDSet {
    get {return _userAppID ?? Clarifai_Api_UserAppIDSet()}
    set {_userAppID = newValue}
  }
  /// Returns true if `userAppID` has been explicitly set.
  public var hasUserAppID: Bool {return self._userAppID != nil}
  /// Clears the value of `userAppID`. Subsequent reads from it will return its default value.
  public mutating func clearUserAppID() {self._userAppID = nil}

  /// The searched to be executed or saved
  public var searches: [Clarifai_Api_Search] = []

  /// Pagination information to paginate through search result Hits.
  public var pagination: Clarifai_Api_Pagination {
    get {return _pagination ?? Clarifai_Api_Pagination()}
    set {_pagination = newValue}
  }
  /// Returns true if `pagination` has been explicitly set.
  public var hasPagination: Bool {return self._pagination != nil}
  /// Clears the value of `pagination`. Subsequent reads from it will return its default value.
  public mutating func clearPagination() {self._pagination = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _userAppID: Clarifai_Api_UserAppIDSet? = nil
  fileprivate var _pagination: Clarifai_Api_Pagination? = nil
}

/// DeleteAnnotationSearchMetricsRequest
public struct Clarifai_Api_DeleteAnnotationSearchMetricsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var userAppID: Clarifai_Api_UserAppIDSet {
    get {return _userAppID ?? Clarifai_Api_UserAppIDSet()}
    set {_userAppID = newValue}
  }
  /// Returns true if `userAppID` has been explicitly set.
  public var hasUserAppID: Bool {return self._userAppID != nil}
  /// Clears the value of `userAppID`. Subsequent reads from it will return its default value.
  public mutating func clearUserAppID() {self._userAppID = nil}

  public var id: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _userAppID: Clarifai_Api_UserAppIDSet? = nil
}

/// Execute a new input search and optionally save it
public struct Clarifai_Api_PostInputsSearchesRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The user_id and app_id to query from.
  public var userAppID: Clarifai_Api_UserAppIDSet {
    get {return _userAppID ?? Clarifai_Api_UserAppIDSet()}
    set {_userAppID = newValue}
  }
  /// Returns true if `userAppID` has been explicitly set.
  public var hasUserAppID: Bool {return self._userAppID != nil}
  /// Clears the value of `userAppID`. Subsequent reads from it will return its default value.
  public mutating func clearUserAppID() {self._userAppID = nil}

  /// The searched to be executed or saved
  public var searches: [Clarifai_Api_Search] = []

  /// Pagination information to paginate through search result Hits.
  public var pagination: Clarifai_Api_Pagination {
    get {return _pagination ?? Clarifai_Api_Pagination()}
    set {_pagination = newValue}
  }
  /// Returns true if `pagination` has been explicitly set.
  public var hasPagination: Bool {return self._pagination != nil}
  /// Clears the value of `pagination`. Subsequent reads from it will return its default value.
  public mutating func clearPagination() {self._pagination = nil}

  /// If only_count is set, then the response will not contain hits,
  /// but hit_counts instead.
  public var onlyCount: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _userAppID: Clarifai_Api_UserAppIDSet? = nil
  fileprivate var _pagination: Clarifai_Api_Pagination? = nil
}

/// SingleSearchResponse returns saved search in response to GetSearchRequest
public struct Clarifai_Api_SingleSearchResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Status of whether the search was successful.
  public var status: Clarifai_Api_Status_Status {
    get {return _status ?? Clarifai_Api_Status_Status()}
    set {_status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  public var hasStatus: Bool {return self._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  public mutating func clearStatus() {self._status = nil}

  public var search: Clarifai_Api_Search {
    get {return _search ?? Clarifai_Api_Search()}
    set {_search = newValue}
  }
  /// Returns true if `search` has been explicitly set.
  public var hasSearch: Bool {return self._search != nil}
  /// Clears the value of `search`. Subsequent reads from it will return its default value.
  public mutating func clearSearch() {self._search = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _status: Clarifai_Api_Status_Status? = nil
  fileprivate var _search: Clarifai_Api_Search? = nil
}

/// MultiSearchResponse
public struct Clarifai_Api_MultiSearchResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Status of whether the search was successful.
  public var status: Clarifai_Api_Status_Status {
    get {return _storage._status ?? Clarifai_Api_Status_Status()}
    set {_uniqueStorage()._status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  public var hasStatus: Bool {return _storage._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  public mutating func clearStatus() {_uniqueStorage()._status = nil}

  /// A unique id which uniquely identifies a search
  public var id: String {
    get {return _storage._id}
    set {_uniqueStorage()._id = newValue}
  }

  /// The list of search result Hits.
  public var hits: [Clarifai_Api_Hit] {
    get {return _storage._hits}
    set {_uniqueStorage()._hits = newValue}
  }

  /// The original query provided in the request.
  public var query: Clarifai_Api_Query {
    get {return _storage._query ?? Clarifai_Api_Query()}
    set {_uniqueStorage()._query = newValue}
  }
  /// Returns true if `query` has been explicitly set.
  public var hasQuery: Bool {return _storage._query != nil}
  /// Clears the value of `query`. Subsequent reads from it will return its default value.
  public mutating func clearQuery() {_uniqueStorage()._query = nil}

  /// The original Searches provided in the request.
  public var searches: [Clarifai_Api_Search] {
    get {return _storage._searches}
    set {_uniqueStorage()._searches = newValue}
  }

  /// The counts of hits for each search, in the same order as searches.
  /// Only returned if the request set only_count.
  public var hitCounts: [Clarifai_Api_HitCount] {
    get {return _storage._hitCounts}
    set {_uniqueStorage()._hitCounts = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// PostAnnotationSearchMetricsRequest
public struct Clarifai_Api_PostAnnotationSearchMetricsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var userAppID: Clarifai_Api_UserAppIDSet {
    get {return _userAppID ?? Clarifai_Api_UserAppIDSet()}
    set {_userAppID = newValue}
  }
  /// Returns true if `userAppID` has been explicitly set.
  public var hasUserAppID: Bool {return self._userAppID != nil}
  /// Clears the value of `userAppID`. Subsequent reads from it will return its default value.
  public mutating func clearUserAppID() {self._userAppID = nil}

  /// A unique customer facing id to identify this eval request
  public var id: String = String()

  /// The ground truth we are evaluating against
  public var groundTruth: Clarifai_Api_Search {
    get {return _groundTruth ?? Clarifai_Api_Search()}
    set {_groundTruth = newValue}
  }
  /// Returns true if `groundTruth` has been explicitly set.
  public var hasGroundTruth: Bool {return self._groundTruth != nil}
  /// Clears the value of `groundTruth`. Subsequent reads from it will return its default value.
  public mutating func clearGroundTruth() {self._groundTruth = nil}

  /// The set we are evaluating
  public var searchToEval: Clarifai_Api_Search {
    get {return _searchToEval ?? Clarifai_Api_Search()}
    set {_searchToEval = newValue}
  }
  /// Returns true if `searchToEval` has been explicitly set.
  public var hasSearchToEval: Bool {return self._searchToEval != nil}
  /// Clears the value of `searchToEval`. Subsequent reads from it will return its default value.
  public mutating func clearSearchToEval() {self._searchToEval = nil}

  /// List of concepts to evaluate are expected to be in data.concepts
  /// If nil, then all app concepts are used
  public var data: Clarifai_Api_Data {
    get {return _data ?? Clarifai_Api_Data()}
    set {_data = newValue}
  }
  /// Returns true if `data` has been explicitly set.
  public var hasData: Bool {return self._data != nil}
  /// Clears the value of `data`. Subsequent reads from it will return its default value.
  public mutating func clearData() {self._data = nil}

  /// The type of evaluation to use
  public var evaluationType: Clarifai_Api_EvaluationType = .undefined

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _userAppID: Clarifai_Api_UserAppIDSet? = nil
  fileprivate var _groundTruth: Clarifai_Api_Search? = nil
  fileprivate var _searchToEval: Clarifai_Api_Search? = nil
  fileprivate var _data: Clarifai_Api_Data? = nil
}

/// GetAnnotationSearchMetricsRequest
public struct Clarifai_Api_GetAnnotationSearchMetricsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var userAppID: Clarifai_Api_UserAppIDSet {
    get {return _userAppID ?? Clarifai_Api_UserAppIDSet()}
    set {_userAppID = newValue}
  }
  /// Returns true if `userAppID` has been explicitly set.
  public var hasUserAppID: Bool {return self._userAppID != nil}
  /// Clears the value of `userAppID`. Subsequent reads from it will return its default value.
  public mutating func clearUserAppID() {self._userAppID = nil}

  /// Unique custom facing id that identifies the eval to get
  public var id: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _userAppID: Clarifai_Api_UserAppIDSet? = nil
}

/// ListAnnotationSearchMetricsRequest
public struct Clarifai_Api_ListAnnotationSearchMetricsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var userAppID: Clarifai_Api_UserAppIDSet {
    get {return _userAppID ?? Clarifai_Api_UserAppIDSet()}
    set {_userAppID = newValue}
  }
  /// Returns true if `userAppID` has been explicitly set.
  public var hasUserAppID: Bool {return self._userAppID != nil}
  /// Clears the value of `userAppID`. Subsequent reads from it will return its default value.
  public mutating func clearUserAppID() {self._userAppID = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _userAppID: Clarifai_Api_UserAppIDSet? = nil
}

/// MultiAnnotationSearchMetricsResponse
public struct Clarifai_Api_MultiAnnotationSearchMetricsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Status of the request
  public var status: Clarifai_Api_Status_Status {
    get {return _status ?? Clarifai_Api_Status_Status()}
    set {_status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  public var hasStatus: Bool {return self._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  public mutating func clearStatus() {self._status = nil}

  public var annotationSearchMetrics: [Clarifai_Api_AnnotationSearchMetrics] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _status: Clarifai_Api_Status_Status? = nil
}

/// ListAnnotationFiltersRequest
public struct Clarifai_Api_ListAnnotationFiltersRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var userAppID: Clarifai_Api_UserAppIDSet {
    get {return _userAppID ?? Clarifai_Api_UserAppIDSet()}
    set {_userAppID = newValue}
  }
  /// Returns true if `userAppID` has been explicitly set.
  public var hasUserAppID: Bool {return self._userAppID != nil}
  /// Clears the value of `userAppID`. Subsequent reads from it will return its default value.
  public mutating func clearUserAppID() {self._userAppID = nil}

  /// (optional URL parameter) The page number. Pagination is used to split the results into chunks.
  /// Defaults to 1.
  public var page: UInt32 = 0

  /// (optional URL parameter) The number of results that will be contained in each page. Defaults
  /// to 128.
  public var perPage: UInt32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _userAppID: Clarifai_Api_UserAppIDSet? = nil
}

/// GetAnnotationFilterRequest
public struct Clarifai_Api_GetAnnotationFilterRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var userAppID: Clarifai_Api_UserAppIDSet {
    get {return _userAppID ?? Clarifai_Api_UserAppIDSet()}
    set {_userAppID = newValue}
  }
  /// Returns true if `userAppID` has been explicitly set.
  public var hasUserAppID: Bool {return self._userAppID != nil}
  /// Clears the value of `userAppID`. Subsequent reads from it will return its default value.
  public mutating func clearUserAppID() {self._userAppID = nil}

  /// Identify annotation filter by id.
  public var annotationFilterID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _userAppID: Clarifai_Api_UserAppIDSet? = nil
}

/// Request to add one or more annotation filters.
public struct Clarifai_Api_PostAnnotationFiltersRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var userAppID: Clarifai_Api_UserAppIDSet {
    get {return _userAppID ?? Clarifai_Api_UserAppIDSet()}
    set {_userAppID = newValue}
  }
  /// Returns true if `userAppID` has been explicitly set.
  public var hasUserAppID: Bool {return self._userAppID != nil}
  /// Clears the value of `userAppID`. Subsequent reads from it will return its default value.
  public mutating func clearUserAppID() {self._userAppID = nil}

  /// List of annotation filters that are requested to be added.
  public var annotationFilters: [Clarifai_Api_AnnotationFilter] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _userAppID: Clarifai_Api_UserAppIDSet? = nil
}

/// Request to patch several annotation filters.
public struct Clarifai_Api_PatchAnnotationFiltersRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var userAppID: Clarifai_Api_UserAppIDSet {
    get {return _userAppID ?? Clarifai_Api_UserAppIDSet()}
    set {_userAppID = newValue}
  }
  /// Returns true if `userAppID` has been explicitly set.
  public var hasUserAppID: Bool {return self._userAppID != nil}
  /// Clears the value of `userAppID`. Subsequent reads from it will return its default value.
  public mutating func clearUserAppID() {self._userAppID = nil}

  /// List of annotation filters that are requested to be updated.
  public var annotationFilters: [Clarifai_Api_AnnotationFilter] = []

  /// The action to perform on the patched objects
  /// For now, only 'overwrite' action is supported
  public var action: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _userAppID: Clarifai_Api_UserAppIDSet? = nil
}

/// Request to delete several annotation filters by list of ids.
public struct Clarifai_Api_DeleteAnnotationFiltersRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var userAppID: Clarifai_Api_UserAppIDSet {
    get {return _userAppID ?? Clarifai_Api_UserAppIDSet()}
    set {_userAppID = newValue}
  }
  /// Returns true if `userAppID` has been explicitly set.
  public var hasUserAppID: Bool {return self._userAppID != nil}
  /// Clears the value of `userAppID`. Subsequent reads from it will return its default value.
  public mutating func clearUserAppID() {self._userAppID = nil}

  /// Specify which filters to delete.
  public var annotationFilterIds: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _userAppID: Clarifai_Api_UserAppIDSet? = nil
}

/// MultiAnnotationFilterResponse
public struct Clarifai_Api_MultiAnnotationFilterResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var status: Clarifai_Api_Status_Status {
    get {return _status ?? Clarifai_Api_Status_Status()}
    set {_status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  public var hasStatus: Bool {return self._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  public mutating func clearStatus() {self._status = nil}

  public var annotationFilters: [Clarifai_Api_AnnotationFilter] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _status: Clarifai_Api_Status_Status? = nil
}

/// SingleAnnotationFilterResponse
public struct Clarifai_Api_SingleAnnotationFilterResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var status: Clarifai_Api_Status_Status {
    get {return _storage._status ?? Clarifai_Api_Status_Status()}
    set {_uniqueStorage()._status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  public var hasStatus: Bool {return _storage._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  public mutating func clearStatus() {_uniqueStorage()._status = nil}

  public var annotationFilter: Clarifai_Api_AnnotationFilter {
    get {return _storage._annotationFilter ?? Clarifai_Api_AnnotationFilter()}
    set {_uniqueStorage()._annotationFilter = newValue}
  }
  /// Returns true if `annotationFilter` has been explicitly set.
  public var hasAnnotationFilter: Bool {return _storage._annotationFilter != nil}
  /// Clears the value of `annotationFilter`. Subsequent reads from it will return its default value.
  public mutating func clearAnnotationFilter() {_uniqueStorage()._annotationFilter = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// GetUserRequest
public struct Clarifai_Api_GetUserRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// we used to have user_id but moved to the standard convention. Since this endpoint
  /// hasn't been exposed and only used by portal as a url this won't effect anything external.
  public var userAppID: Clarifai_Api_UserAppIDSet {
    get {return _userAppID ?? Clarifai_Api_UserAppIDSet()}
    set {_userAppID = newValue}
  }
  /// Returns true if `userAppID` has been explicitly set.
  public var hasUserAppID: Bool {return self._userAppID != nil}
  /// Clears the value of `userAppID`. Subsequent reads from it will return its default value.
  public mutating func clearUserAppID() {self._userAppID = nil}

  /// (optional URL parameter) List of additional fields to be included in the response. Currently supported: all, stars
  public var additionalFields: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _userAppID: Clarifai_Api_UserAppIDSet? = nil
}

/// SingleUserResponse
public struct Clarifai_Api_SingleUserResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var status: Clarifai_Api_Status_Status {
    get {return _status ?? Clarifai_Api_Status_Status()}
    set {_status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  public var hasStatus: Bool {return self._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  public mutating func clearStatus() {self._status = nil}

  public var user: Clarifai_Api_User {
    get {return _user ?? Clarifai_Api_User()}
    set {_user = newValue}
  }
  /// Returns true if `user` has been explicitly set.
  public var hasUser: Bool {return self._user != nil}
  /// Clears the value of `user`. Subsequent reads from it will return its default value.
  public mutating func clearUser() {self._user = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _status: Clarifai_Api_Status_Status? = nil
  fileprivate var _user: Clarifai_Api_User? = nil
}

/// PostValidatePasswordRequest
public struct Clarifai_Api_PostValidatePasswordRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var userAppID: Clarifai_Api_UserAppIDSet {
    get {return _userAppID ?? Clarifai_Api_UserAppIDSet()}
    set {_userAppID = newValue}
  }
  /// Returns true if `userAppID` has been explicitly set.
  public var hasUserAppID: Bool {return self._userAppID != nil}
  /// Clears the value of `userAppID`. Subsequent reads from it will return its default value.
  public mutating func clearUserAppID() {self._userAppID = nil}

  /// password to be validated
  public var password: Clarifai_Api_Password {
    get {return _password ?? Clarifai_Api_Password()}
    set {_password = newValue}
  }
  /// Returns true if `password` has been explicitly set.
  public var hasPassword: Bool {return self._password != nil}
  /// Clears the value of `password`. Subsequent reads from it will return its default value.
  public mutating func clearPassword() {self._password = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _userAppID: Clarifai_Api_UserAppIDSet? = nil
  fileprivate var _password: Clarifai_Api_Password? = nil
}

/// SinglePasswordValidationResponse
public struct Clarifai_Api_SinglePasswordValidationResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Standard clarifai status code
  public var status: Clarifai_Api_Status_Status {
    get {return _storage._status ?? Clarifai_Api_Status_Status()}
    set {_uniqueStorage()._status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  public var hasStatus: Bool {return _storage._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  public mutating func clearStatus() {_uniqueStorage()._status = nil}

  public var passwordViolations: Clarifai_Api_PasswordViolations {
    get {return _storage._passwordViolations ?? Clarifai_Api_PasswordViolations()}
    set {_uniqueStorage()._passwordViolations = newValue}
  }
  /// Returns true if `passwordViolations` has been explicitly set.
  public var hasPasswordViolations: Bool {return _storage._passwordViolations != nil}
  /// Clears the value of `passwordViolations`. Subsequent reads from it will return its default value.
  public mutating func clearPasswordViolations() {_uniqueStorage()._passwordViolations = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// GetWorkflowRequest
public struct Clarifai_Api_GetWorkflowRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var userAppID: Clarifai_Api_UserAppIDSet {
    get {return _userAppID ?? Clarifai_Api_UserAppIDSet()}
    set {_userAppID = newValue}
  }
  /// Returns true if `userAppID` has been explicitly set.
  public var hasUserAppID: Bool {return self._userAppID != nil}
  /// Clears the value of `userAppID`. Subsequent reads from it will return its default value.
  public mutating func clearUserAppID() {self._userAppID = nil}

  /// Workflow ID to retrieve
  /// If no ID is specified we return default workflow of the application
  /// If an ID is specified by default we first looks into Clarifai workflows for a Workflow ID
  public var workflowID: String = String()

  /// (optional URL parameter) List of additional fields to be included in the response. Currently supported: all, stars
  public var additionalFields: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _userAppID: Clarifai_Api_UserAppIDSet? = nil
}

/// ListWorkflowsRequest
public struct Clarifai_Api_ListWorkflowsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var userAppID: Clarifai_Api_UserAppIDSet {
    get {return _userAppID ?? Clarifai_Api_UserAppIDSet()}
    set {_userAppID = newValue}
  }
  /// Returns true if `userAppID` has been explicitly set.
  public var hasUserAppID: Bool {return self._userAppID != nil}
  /// Clears the value of `userAppID`. Subsequent reads from it will return its default value.
  public mutating func clearUserAppID() {self._userAppID = nil}

  /// (optional URL parameter) The page number. Pagination is used to split the results into chunks.
  /// Defaults to 1.
  public var page: UInt32 = 0

  /// (optional URL parameter) The number of results that will be contained in each page. Defaults
  /// to 128.
  public var perPage: UInt32 = 0

  /// (optional URL parameter) List of additional fields to be included in the response. Currently supported: all, stars
  public var additionalFields: [String] = []

  /// Sorting options:
  /// Whether to sort in ascending order. If false, will order in descending order.
  public var sortAscending: Bool = false

  public var sortBy: Clarifai_Api_ListWorkflowsRequest.OneOf_SortBy? = nil

  /// Whether to order by the name
  public var sortByID: Bool {
    get {
      if case .sortByID(let v)? = sortBy {return v}
      return false
    }
    set {sortBy = .sortByID(newValue)}
  }

  /// Whether to order by the modified_at time.
  /// If none of the sort options is set to true, will sort by modified_at.
  public var sortByModifiedAt: Bool {
    get {
      if case .sortByModifiedAt(let v)? = sortBy {return v}
      return false
    }
    set {sortBy = .sortByModifiedAt(newValue)}
  }

  /// Whether to order by the created_at time.
  public var sortByCreatedAt: Bool {
    get {
      if case .sortByCreatedAt(let v)? = sortBy {return v}
      return false
    }
    set {sortBy = .sortByCreatedAt(newValue)}
  }

  /// Whether to order by the number of users stared the workflow
  public var sortByStarCount: Bool {
    get {
      if case .sortByStarCount(let v)? = sortBy {return v}
      return false
    }
    set {sortBy = .sortByStarCount(newValue)}
  }

  /// Filtering options:
  /// If true, we only return workflows that are handpicked by clarifai staff
  public var featuredOnly: Bool = false

  /// If true, we only return workflows that are starred by the requesting user
  public var starredOnly: Bool = false

  /// Filter workflows by bookmark. If set, only return bookmarked workflows. Otherwise none bookmarked workflows only.
  public var bookmark: Bool = false

  /// Filter by visibility of the workflow. If set, only return workflows with the specified visibility.
  public var visibility: Clarifai_Api_Visibility {
    get {return _visibility ?? Clarifai_Api_Visibility()}
    set {_visibility = newValue}
  }
  /// Returns true if `visibility` has been explicitly set.
  public var hasVisibility: Bool {return self._visibility != nil}
  /// Clears the value of `visibility`. Subsequent reads from it will return its default value.
  public mutating func clearVisibility() {self._visibility = nil}

  /// Searching options:
  /// Specify a search parameter in order to perform keyword search on the
  /// following fields of the workflow:
  ///   - id
  ///   - description
  ///   - notes
  ///   - user_id (unless user_app_id.user_id is already set)
  ///
  /// Keywords are both normalized for search (so searching for "satisfy" matches "satisfied")
  /// and used for partial prefix-matching (so searching for "clari" matches "clarifai").
  ///
  /// NOTE: Both the list of fields searched and the exact keyword matching
  /// rules are subject to change and not guaranteed to be backwards-compatible.
  public var search: String = String()

  /// Query various text fields (id, description and notes) that can contain the words in the query string.
  /// Deprecated: use search instead.
  public var query: String = String()

  /// Filter by the id of the workflow. This supports wilcard queries like "gen*" to match "general" as an example.
  /// Deprecated: use search instead.
  public var id: String = String()

  /// Full text and prefix matching on id, owner id, description and notes. Searchable fields may be added
  /// Deprecated: use search instead.
  public var searchTerm: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_SortBy: Equatable {
    /// Whether to order by the name
    case sortByID(Bool)
    /// Whether to order by the modified_at time.
    /// If none of the sort options is set to true, will sort by modified_at.
    case sortByModifiedAt(Bool)
    /// Whether to order by the created_at time.
    case sortByCreatedAt(Bool)
    /// Whether to order by the number of users stared the workflow
    case sortByStarCount(Bool)

  #if !swift(>=4.1)
    public static func ==(lhs: Clarifai_Api_ListWorkflowsRequest.OneOf_SortBy, rhs: Clarifai_Api_ListWorkflowsRequest.OneOf_SortBy) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.sortByID, .sortByID): return {
        guard case .sortByID(let l) = lhs, case .sortByID(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.sortByModifiedAt, .sortByModifiedAt): return {
        guard case .sortByModifiedAt(let l) = lhs, case .sortByModifiedAt(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.sortByCreatedAt, .sortByCreatedAt): return {
        guard case .sortByCreatedAt(let l) = lhs, case .sortByCreatedAt(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.sortByStarCount, .sortByStarCount): return {
        guard case .sortByStarCount(let l) = lhs, case .sortByStarCount(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}

  fileprivate var _userAppID: Clarifai_Api_UserAppIDSet? = nil
  fileprivate var _visibility: Clarifai_Api_Visibility? = nil
}

/// PostWorkflowsRequest
public struct Clarifai_Api_PostWorkflowsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var userAppID: Clarifai_Api_UserAppIDSet {
    get {return _userAppID ?? Clarifai_Api_UserAppIDSet()}
    set {_userAppID = newValue}
  }
  /// Returns true if `userAppID` has been explicitly set.
  public var hasUserAppID: Bool {return self._userAppID != nil}
  /// Clears the value of `userAppID`. Subsequent reads from it will return its default value.
  public mutating func clearUserAppID() {self._userAppID = nil}

  public var workflows: [Clarifai_Api_Workflow] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _userAppID: Clarifai_Api_UserAppIDSet? = nil
}

/// PatchWorkflowsRequest
public struct Clarifai_Api_PatchWorkflowsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var userAppID: Clarifai_Api_UserAppIDSet {
    get {return _userAppID ?? Clarifai_Api_UserAppIDSet()}
    set {_userAppID = newValue}
  }
  /// Returns true if `userAppID` has been explicitly set.
  public var hasUserAppID: Bool {return self._userAppID != nil}
  /// Clears the value of `userAppID`. Subsequent reads from it will return its default value.
  public mutating func clearUserAppID() {self._userAppID = nil}

  public var workflows: [Clarifai_Api_Workflow] = []

  /// The action to perform on the patched objects
  /// For now actions 'merge', 'overwrite', and 'remove' are supported
  ///
  /// Note that 'remove' can be used to remove the workflow image by setting
  /// 'image.url' in the request to the current value returned for that workflow.
  /// This cannot be used in a request that is patching other fields as well.
  public var action: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _userAppID: Clarifai_Api_UserAppIDSet? = nil
}

/// PatchWorkflowIdsRequest
public struct Clarifai_Api_PatchWorkflowIdsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var userAppID: Clarifai_Api_UserAppIDSet {
    get {return _userAppID ?? Clarifai_Api_UserAppIDSet()}
    set {_userAppID = newValue}
  }
  /// Returns true if `userAppID` has been explicitly set.
  public var hasUserAppID: Bool {return self._userAppID != nil}
  /// Clears the value of `userAppID`. Subsequent reads from it will return its default value.
  public mutating func clearUserAppID() {self._userAppID = nil}

  /// Array containing 1 entry
  public var ids: [Clarifai_Api_IdUpdateSource] = []

  /// The action to perform on the patched objects
  /// Only 'overwrite' is supported
  public var action: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _userAppID: Clarifai_Api_UserAppIDSet? = nil
}

/// DeleteWorkflowRequest
public struct Clarifai_Api_DeleteWorkflowRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var userAppID: Clarifai_Api_UserAppIDSet {
    get {return _userAppID ?? Clarifai_Api_UserAppIDSet()}
    set {_userAppID = newValue}
  }
  /// Returns true if `userAppID` has been explicitly set.
  public var hasUserAppID: Bool {return self._userAppID != nil}
  /// Clears the value of `userAppID`. Subsequent reads from it will return its default value.
  public mutating func clearUserAppID() {self._userAppID = nil}

  public var workflowID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _userAppID: Clarifai_Api_UserAppIDSet? = nil
}

/// Request to delete several things by the list of ids.
public struct Clarifai_Api_DeleteWorkflowsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var userAppID: Clarifai_Api_UserAppIDSet {
    get {return _userAppID ?? Clarifai_Api_UserAppIDSet()}
    set {_userAppID = newValue}
  }
  /// Returns true if `userAppID` has been explicitly set.
  public var hasUserAppID: Bool {return self._userAppID != nil}
  /// Clears the value of `userAppID`. Subsequent reads from it will return its default value.
  public mutating func clearUserAppID() {self._userAppID = nil}

  public var ids: [String] = []

  public var deleteAll: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _userAppID: Clarifai_Api_UserAppIDSet? = nil
}

/// SingleWorkflowResponse
public struct Clarifai_Api_SingleWorkflowResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var status: Clarifai_Api_Status_Status {
    get {return _status ?? Clarifai_Api_Status_Status()}
    set {_status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  public var hasStatus: Bool {return self._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  public mutating func clearStatus() {self._status = nil}

  public var workflow: Clarifai_Api_Workflow {
    get {return _workflow ?? Clarifai_Api_Workflow()}
    set {_workflow = newValue}
  }
  /// Returns true if `workflow` has been explicitly set.
  public var hasWorkflow: Bool {return self._workflow != nil}
  /// Clears the value of `workflow`. Subsequent reads from it will return its default value.
  public mutating func clearWorkflow() {self._workflow = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _status: Clarifai_Api_Status_Status? = nil
  fileprivate var _workflow: Clarifai_Api_Workflow? = nil
}

/// MultiWorkflowResponse
public struct Clarifai_Api_MultiWorkflowResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var status: Clarifai_Api_Status_Status {
    get {return _status ?? Clarifai_Api_Status_Status()}
    set {_status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  public var hasStatus: Bool {return self._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  public mutating func clearStatus() {self._status = nil}

  public var workflows: [Clarifai_Api_Workflow] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _status: Clarifai_Api_Status_Status? = nil
}

/// PostWorkflowResultsRequest
public struct Clarifai_Api_PostWorkflowResultsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var userAppID: Clarifai_Api_UserAppIDSet {
    get {return _storage._userAppID ?? Clarifai_Api_UserAppIDSet()}
    set {_uniqueStorage()._userAppID = newValue}
  }
  /// Returns true if `userAppID` has been explicitly set.
  public var hasUserAppID: Bool {return _storage._userAppID != nil}
  /// Clears the value of `userAppID`. Subsequent reads from it will return its default value.
  public mutating func clearUserAppID() {_uniqueStorage()._userAppID = nil}

  /// Workflow ID to retrieve
  /// If no ID is specified we return default workflow of the application
  /// If an ID is specified by default we first looks into Clarifai workflows for a Workflow ID
  public var workflowID: String {
    get {return _storage._workflowID}
    set {_uniqueStorage()._workflowID = newValue}
  }

  /// Workflow version ID to retrieve
  /// If no ID is specified, latest workflow version is used
  public var versionID: String {
    get {return _storage._versionID}
    set {_uniqueStorage()._versionID = newValue}
  }

  public var inputs: [Clarifai_Api_Input] {
    get {return _storage._inputs}
    set {_uniqueStorage()._inputs = newValue}
  }

  /// FIXME(zeiler): the request for post workflows is using an outputconfig object that is supposed
  /// to be within models. This is not consistent with setting this on the request for post model
  /// outputs where it is inside a model object. To make this consistent we would send in the
  /// workflow object so that each model can have it's own output config. If nobody is setting
  /// this OutputConfig it would probably be easier to just remove it for now to keep things simpler
  /// and then it's more consistent we just don't support the OutputConfig on workflows.
  public var outputConfig: Clarifai_Api_OutputConfig {
    get {return _storage._outputConfig ?? Clarifai_Api_OutputConfig()}
    set {_uniqueStorage()._outputConfig = newValue}
  }
  /// Returns true if `outputConfig` has been explicitly set.
  public var hasOutputConfig: Bool {return _storage._outputConfig != nil}
  /// Clears the value of `outputConfig`. Subsequent reads from it will return its default value.
  public mutating func clearOutputConfig() {_uniqueStorage()._outputConfig = nil}

  /// Use this flag to look into clarifai published workflows first for a Workflow ID
  public var favorClarifaiWorkflows: Bool {
    get {return _storage._favorClarifaiWorkflows}
    set {_uniqueStorage()._favorClarifaiWorkflows = newValue}
  }

  /// A workflow state to be maintained across PostWorkflowResults requests/responses.
  /// If it is not sent in the initial request with workflow_state.id = "init" then no
  /// state will be saved or returned in PostWorkflowResultsResponse.
  public var workflowState: Clarifai_Api_WorkflowState {
    get {return _storage._workflowState ?? Clarifai_Api_WorkflowState()}
    set {_uniqueStorage()._workflowState = newValue}
  }
  /// Returns true if `workflowState` has been explicitly set.
  public var hasWorkflowState: Bool {return _storage._workflowState != nil}
  /// Clears the value of `workflowState`. Subsequent reads from it will return its default value.
  public mutating func clearWorkflowState() {_uniqueStorage()._workflowState = nil}

  /// Specify which compute to use for processing each node of the workflow:
  /// The key is the node.id from the loaded workflow.
  /// The value is a RunnerSelector in which you can specify the deployment or specific nodepool
  /// that you'd like that node to run on.
  /// This allows for use cases like some light models could run on a CPU-only nodepool
  /// while other models in the workflow require large GPUs.
  ///
  /// If node.id is not in the provided map, it will fall back to searching for
  /// an adequate deployment the model owner owns or fall back to
  /// the shared nodepools provided by Clarifai.
  /// We recommend you specify these RunnerSelectors so that you have better understanding of where
  /// processing occurs.
  public var nodeRunnerSelectors: Dictionary<String,Clarifai_Api_RunnerSelector> {
    get {return _storage._nodeRunnerSelectors}
    set {_uniqueStorage()._nodeRunnerSelectors = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// PostWorkflowResultsResponse
public struct Clarifai_Api_PostWorkflowResultsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The status of the request.
  public var status: Clarifai_Api_Status_Status {
    get {return _status ?? Clarifai_Api_Status_Status()}
    set {_status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  public var hasStatus: Bool {return self._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  public mutating func clearStatus() {self._status = nil}

  /// The workflow that was used in predictions with PostWorkflowResults
  public var workflow: Clarifai_Api_Workflow {
    get {return _workflow ?? Clarifai_Api_Workflow()}
    set {_workflow = newValue}
  }
  /// Returns true if `workflow` has been explicitly set.
  public var hasWorkflow: Bool {return self._workflow != nil}
  /// Clears the value of `workflow`. Subsequent reads from it will return its default value.
  public mutating func clearWorkflow() {self._workflow = nil}

  /// The resulting predictions of all models in the workflow.
  public var results: [Clarifai_Api_WorkflowResult] = []

  /// A workflow state to be maintained across PostWorkflowResults requests/responses.
  /// This WorkflowState should be passed in to subsequent PostWorkflowResults calls
  /// if you want to keep track of state across requests.
  /// If no WorkflowState was initialized in a request then no WorkflowState will be returned in this
  /// response.
  public var workflowState: Clarifai_Api_WorkflowState {
    get {return _workflowState ?? Clarifai_Api_WorkflowState()}
    set {_workflowState = newValue}
  }
  /// Returns true if `workflowState` has been explicitly set.
  public var hasWorkflowState: Bool {return self._workflowState != nil}
  /// Clears the value of `workflowState`. Subsequent reads from it will return its default value.
  public mutating func clearWorkflowState() {self._workflowState = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _status: Clarifai_Api_Status_Status? = nil
  fileprivate var _workflow: Clarifai_Api_Workflow? = nil
  fileprivate var _workflowState: Clarifai_Api_WorkflowState? = nil
}

/// ListWorkflowVersionsRequest
public struct Clarifai_Api_ListWorkflowVersionsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var userAppID: Clarifai_Api_UserAppIDSet {
    get {return _userAppID ?? Clarifai_Api_UserAppIDSet()}
    set {_userAppID = newValue}
  }
  /// Returns true if `userAppID` has been explicitly set.
  public var hasUserAppID: Bool {return self._userAppID != nil}
  /// Clears the value of `userAppID`. Subsequent reads from it will return its default value.
  public mutating func clearUserAppID() {self._userAppID = nil}

  /// List versions for the workflow identified by this id
  public var workflowID: String = String()

  /// (optional URL parameter) The page number. Pagination is used to split the results into chunks.
  /// Defaults to 1.
  public var page: UInt32 = 0

  /// (optional URL parameter) The number of results that will be contained in each page. Defaults
  /// to 128.
  public var perPage: UInt32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _userAppID: Clarifai_Api_UserAppIDSet? = nil
}

/// GetWorkflowVersionRequest
public struct Clarifai_Api_GetWorkflowVersionRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var userAppID: Clarifai_Api_UserAppIDSet {
    get {return _userAppID ?? Clarifai_Api_UserAppIDSet()}
    set {_userAppID = newValue}
  }
  /// Returns true if `userAppID` has been explicitly set.
  public var hasUserAppID: Bool {return self._userAppID != nil}
  /// Clears the value of `userAppID`. Subsequent reads from it will return its default value.
  public mutating func clearUserAppID() {self._userAppID = nil}

  /// The id of the workflow that has the requested version.
  public var workflowID: String = String()

  /// Get the identified by this id
  public var workflowVersionID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _userAppID: Clarifai_Api_UserAppIDSet? = nil
}

/// DeleteWorkflowVersionsRequest
public struct Clarifai_Api_DeleteWorkflowVersionsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var userAppID: Clarifai_Api_UserAppIDSet {
    get {return _userAppID ?? Clarifai_Api_UserAppIDSet()}
    set {_userAppID = newValue}
  }
  /// Returns true if `userAppID` has been explicitly set.
  public var hasUserAppID: Bool {return self._userAppID != nil}
  /// Clears the value of `userAppID`. Subsequent reads from it will return its default value.
  public mutating func clearUserAppID() {self._userAppID = nil}

  /// The id of the workflow that has the requested versions to delete.
  public var workflowID: String = String()

  /// Delete the versions identified by these ids
  public var workflowVersionIds: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _userAppID: Clarifai_Api_UserAppIDSet? = nil
}

/// PatchWorkflowVersionsRequest
public struct Clarifai_Api_PatchWorkflowVersionsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var userAppID: Clarifai_Api_UserAppIDSet {
    get {return _userAppID ?? Clarifai_Api_UserAppIDSet()}
    set {_userAppID = newValue}
  }
  /// Returns true if `userAppID` has been explicitly set.
  public var hasUserAppID: Bool {return self._userAppID != nil}
  /// Clears the value of `userAppID`. Subsequent reads from it will return its default value.
  public mutating func clearUserAppID() {self._userAppID = nil}

  /// The id of the workflow that has the requested versions to patch.
  public var workflowID: String = String()

  /// Patch these versions.
  public var workflowVersions: [Clarifai_Api_WorkflowVersion] = []

  /// The action to perform on the patched objects
  /// For now actions 'merge', 'overwrite', and 'remove' are supported
  public var action: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _userAppID: Clarifai_Api_UserAppIDSet? = nil
}

/// MultiWorkflowVersionResponse
public struct Clarifai_Api_MultiWorkflowVersionResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var status: Clarifai_Api_Status_Status {
    get {return _status ?? Clarifai_Api_Status_Status()}
    set {_status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  public var hasStatus: Bool {return self._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  public mutating func clearStatus() {self._status = nil}

  public var workflowVersions: [Clarifai_Api_WorkflowVersion] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _status: Clarifai_Api_Status_Status? = nil
}

/// SingleWorkflowVersionResponse
public struct Clarifai_Api_SingleWorkflowVersionResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var status: Clarifai_Api_Status_Status {
    get {return _storage._status ?? Clarifai_Api_Status_Status()}
    set {_uniqueStorage()._status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  public var hasStatus: Bool {return _storage._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  public mutating func clearStatus() {_uniqueStorage()._status = nil}

  public var workflowVersion: Clarifai_Api_WorkflowVersion {
    get {return _storage._workflowVersion ?? Clarifai_Api_WorkflowVersion()}
    set {_uniqueStorage()._workflowVersion = newValue}
  }
  /// Returns true if `workflowVersion` has been explicitly set.
  public var hasWorkflowVersion: Bool {return _storage._workflowVersion != nil}
  /// Clears the value of `workflowVersion`. Subsequent reads from it will return its default value.
  public mutating func clearWorkflowVersion() {_uniqueStorage()._workflowVersion = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Request to start app duplication jobs.
public struct Clarifai_Api_PostAppDuplicationsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The user and application ID of the source application to duplicate.
  public var userAppID: Clarifai_Api_UserAppIDSet {
    get {return _userAppID ?? Clarifai_Api_UserAppIDSet()}
    set {_userAppID = newValue}
  }
  /// Returns true if `userAppID` has been explicitly set.
  public var hasUserAppID: Bool {return self._userAppID != nil}
  /// Clears the value of `userAppID`. Subsequent reads from it will return its default value.
  public mutating func clearUserAppID() {self._userAppID = nil}

  public var appDuplications: [Clarifai_Api_AppDuplication] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _userAppID: Clarifai_Api_UserAppIDSet? = nil
}

/// Request to get an app duplication job.
public struct Clarifai_Api_GetAppDuplicationRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The ID of the user that created the app duplication job.
  public var userAppID: Clarifai_Api_UserAppIDSet {
    get {return _userAppID ?? Clarifai_Api_UserAppIDSet()}
    set {_userAppID = newValue}
  }
  /// Returns true if `userAppID` has been explicitly set.
  public var hasUserAppID: Bool {return self._userAppID != nil}
  /// Clears the value of `userAppID`. Subsequent reads from it will return its default value.
  public mutating func clearUserAppID() {self._userAppID = nil}

  public var appDuplicationID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _userAppID: Clarifai_Api_UserAppIDSet? = nil
}

/// Request to list all the app duplication jobs that a user created.
public struct Clarifai_Api_ListAppDuplicationsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The ID of the user whose app duplication jobs to list.
  public var userAppID: Clarifai_Api_UserAppIDSet {
    get {return _userAppID ?? Clarifai_Api_UserAppIDSet()}
    set {_userAppID = newValue}
  }
  /// Returns true if `userAppID` has been explicitly set.
  public var hasUserAppID: Bool {return self._userAppID != nil}
  /// Clears the value of `userAppID`. Subsequent reads from it will return its default value.
  public mutating func clearUserAppID() {self._userAppID = nil}

  /// (optional URL parameter) The page number. Pagination is used to split the results into chunks.
  /// Defaults to 1.
  public var page: UInt32 = 0

  /// (optional URL parameter) The number of results that will be contained in each page. Defaults
  /// to 128.
  public var perPage: UInt32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _userAppID: Clarifai_Api_UserAppIDSet? = nil
}

/// MultiAppDuplicationsResponse
public struct Clarifai_Api_MultiAppDuplicationsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var status: Clarifai_Api_Status_Status {
    get {return _status ?? Clarifai_Api_Status_Status()}
    set {_status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  public var hasStatus: Bool {return self._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  public mutating func clearStatus() {self._status = nil}

  public var appDuplications: [Clarifai_Api_AppDuplication] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _status: Clarifai_Api_Status_Status? = nil
}

/// SingleAppDuplicationResponse
public struct Clarifai_Api_SingleAppDuplicationResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var status: Clarifai_Api_Status_Status {
    get {return _status ?? Clarifai_Api_Status_Status()}
    set {_status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  public var hasStatus: Bool {return self._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  public mutating func clearStatus() {self._status = nil}

  public var appDuplication: Clarifai_Api_AppDuplication {
    get {return _appDuplication ?? Clarifai_Api_AppDuplication()}
    set {_appDuplication = newValue}
  }
  /// Returns true if `appDuplication` has been explicitly set.
  public var hasAppDuplication: Bool {return self._appDuplication != nil}
  /// Clears the value of `appDuplication`. Subsequent reads from it will return its default value.
  public mutating func clearAppDuplication() {self._appDuplication = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _status: Clarifai_Api_Status_Status? = nil
  fileprivate var _appDuplication: Clarifai_Api_AppDuplication? = nil
}

/// Request to create Tasks.
public struct Clarifai_Api_PostTasksRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var userAppID: Clarifai_Api_UserAppIDSet {
    get {return _userAppID ?? Clarifai_Api_UserAppIDSet()}
    set {_userAppID = newValue}
  }
  /// Returns true if `userAppID` has been explicitly set.
  public var hasUserAppID: Bool {return self._userAppID != nil}
  /// Clears the value of `userAppID`. Subsequent reads from it will return its default value.
  public mutating func clearUserAppID() {self._userAppID = nil}

  public var tasks: [Clarifai_Api_Task] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _userAppID: Clarifai_Api_UserAppIDSet? = nil
}

/// Request to get one task.
public struct Clarifai_Api_GetTaskRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var userAppID: Clarifai_Api_UserAppIDSet {
    get {return _userAppID ?? Clarifai_Api_UserAppIDSet()}
    set {_userAppID = newValue}
  }
  /// Returns true if `userAppID` has been explicitly set.
  public var hasUserAppID: Bool {return self._userAppID != nil}
  /// Clears the value of `userAppID`. Subsequent reads from it will return its default value.
  public mutating func clearUserAppID() {self._userAppID = nil}

  public var taskID: String = String()

  /// (optional URL parameter) List of additional fields to be included in the response.
  /// Currently supported additional fields:
  /// - all
  /// - worker.users
  /// - review.users
  /// - metrics.input_source.inputs_count_estimated
  /// - metrics.work.inputs_count_estimated
  /// - metrics.work.inputs_percent_estimated
  /// - metrics.review.inputs_count_estimated
  /// - metrics.review.inputs_count_estimated_per_reviewer
  /// - metrics.review.inputs_percent_estimated
  /// - metrics.review.inputs_percent_estimated_per_reviewer
  /// - metrics.review.inputs_reviewable_count_estimated_per_reviewer
  public var additionalFields: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _userAppID: Clarifai_Api_UserAppIDSet? = nil
}

/// Request to list multiple tasks.
public struct Clarifai_Api_ListTasksRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var userAppID: Clarifai_Api_UserAppIDSet {
    get {return _userAppID ?? Clarifai_Api_UserAppIDSet()}
    set {_userAppID = newValue}
  }
  /// Returns true if `userAppID` has been explicitly set.
  public var hasUserAppID: Bool {return self._userAppID != nil}
  /// Clears the value of `userAppID`. Subsequent reads from it will return its default value.
  public mutating func clearUserAppID() {self._userAppID = nil}

  /// (optional URL parameter) The page number. Pagination is used to split the results into chunks.
  /// Defaults to 1.
  public var page: UInt32 = 0

  /// (optional URL parameter) The number of results that will be contained in each page. Defaults
  /// to 128.
  public var perPage: UInt32 = 0

  /// Get tasks that have ANY user from this list assigned as worker.
  public var workerUserIds: [String] = []

  /// Get tasks that have ANY user from this list assigned as reviewer.
  public var reviewUserIds: [String] = []

  /// Get tasks that are associated to ANY label order from this list.
  public var labelOrderIds: [String] = []

  /// Get label order tasks as well
  /// It is automatically set to true if label_order_ids is set.
  public var includingLabelOrderTasks: Bool = false

  /// (optional URL parameter) List of additional fields to be included in the response.
  /// Currently supported additional fields:
  /// - all
  /// - worker.users
  /// - review.users
  /// - metrics.input_source.inputs_count_estimated
  /// - metrics.work.inputs_count_estimated
  /// - metrics.work.inputs_percent_estimated
  /// - metrics.review.inputs_count_estimated
  /// - metrics.review.inputs_count_estimated_per_reviewer
  /// - metrics.review.inputs_percent_estimated
  /// - metrics.review.inputs_percent_estimated_per_reviewer
  /// - metrics.review.inputs_reviewable_count_estimated_per_reviewer
  public var additionalFields: [String] = []

  /// (optional) task IDs to filter on
  public var ids: [String] = []

  /// (optional) input source type to filter
  public var inputSourceType: Clarifai_Api_TaskInputSource.TaskInputSourceType = .inputSourceTypeNotSet

  /// (optional) ids of input source to be filtered
  public var inputSourceIds: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _userAppID: Clarifai_Api_UserAppIDSet? = nil
}

/// Request to patch a list of tasks.
public struct Clarifai_Api_PatchTasksRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var userAppID: Clarifai_Api_UserAppIDSet {
    get {return _userAppID ?? Clarifai_Api_UserAppIDSet()}
    set {_userAppID = newValue}
  }
  /// Returns true if `userAppID` has been explicitly set.
  public var hasUserAppID: Bool {return self._userAppID != nil}
  /// Clears the value of `userAppID`. Subsequent reads from it will return its default value.
  public mutating func clearUserAppID() {self._userAppID = nil}

  public var tasks: [Clarifai_Api_Task] = []

  /// The action to perform on the patched objects
  /// For now, only 'overwrite' action is supported
  public var action: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _userAppID: Clarifai_Api_UserAppIDSet? = nil
}

/// Request to delete a list of tasks.
public struct Clarifai_Api_DeleteTasksRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var userAppID: Clarifai_Api_UserAppIDSet {
    get {return _userAppID ?? Clarifai_Api_UserAppIDSet()}
    set {_userAppID = newValue}
  }
  /// Returns true if `userAppID` has been explicitly set.
  public var hasUserAppID: Bool {return self._userAppID != nil}
  /// Clears the value of `userAppID`. Subsequent reads from it will return its default value.
  public mutating func clearUserAppID() {self._userAppID = nil}

  public var ids: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _userAppID: Clarifai_Api_UserAppIDSet? = nil
}

/// Response with multiple Tasks.
public struct Clarifai_Api_MultiTaskResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var status: Clarifai_Api_Status_Status {
    get {return _status ?? Clarifai_Api_Status_Status()}
    set {_status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  public var hasStatus: Bool {return self._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  public mutating func clearStatus() {self._status = nil}

  public var tasks: [Clarifai_Api_Task] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _status: Clarifai_Api_Status_Status? = nil
}

/// Response with a single Task.
public struct Clarifai_Api_SingleTaskResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var status: Clarifai_Api_Status_Status {
    get {return _status ?? Clarifai_Api_Status_Status()}
    set {_status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  public var hasStatus: Bool {return self._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  public mutating func clearStatus() {self._status = nil}

  public var task: Clarifai_Api_Task {
    get {return _task ?? Clarifai_Api_Task()}
    set {_task = newValue}
  }
  /// Returns true if `task` has been explicitly set.
  public var hasTask: Bool {return self._task != nil}
  /// Clears the value of `task`. Subsequent reads from it will return its default value.
  public mutating func clearTask() {self._task = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _status: Clarifai_Api_Status_Status? = nil
  fileprivate var _task: Clarifai_Api_Task? = nil
}

/// GetTaskCountRequest can be used for fetching -
/// 1. Task annotation count per user, per status
/// 1. Task input count per user (i.e. task assignment count), per status
public struct Clarifai_Api_GetTaskCountRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var userAppID: Clarifai_Api_UserAppIDSet {
    get {return _userAppID ?? Clarifai_Api_UserAppIDSet()}
    set {_userAppID = newValue}
  }
  /// Returns true if `userAppID` has been explicitly set.
  public var hasUserAppID: Bool {return self._userAppID != nil}
  /// Clears the value of `userAppID`. Subsequent reads from it will return its default value.
  public mutating func clearUserAppID() {self._userAppID = nil}

  /// task_id for which count per user per status is needed
  public var taskID: String = String()

  /// Only return counts for these user IDs, effectively operating as an
  /// OR among them to filter down the results.
  /// If model_version_ids or workflow_version_ids are also provided, these user_ids are OR'd with them as well because
  /// we want the union of all worker (user, model or workflow) counts in the results.
  public var userIds: [String] = []

  /// Only return counts for these model version IDs, effectively operating as an
  /// OR among them to filter down the results.
  /// If user_ids or workflow_version_ids are also provided, these model_version_ids are OR'd with them as well because
  /// we want the union of all worker (user, model or workflow) counts in the results.
  public var modelVersionIds: [String] = []

  /// Only return counts for these workflow version IDs, effectively operating as an
  /// OR among them to filter down the results.
  /// If user_ids or model_version_ids are also provided, these workflow_version_ids are OR'd with them as well because
  /// we want the union of all worker (user, model or workflow) counts in the results.
  public var workflowVersionIds: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _userAppID: Clarifai_Api_UserAppIDSet? = nil
}

/// SingleTaskCountResponse represents counts of task annotations or inputs (i.e. task assignments) for labelers in given task
public struct Clarifai_Api_SingleTaskCountResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var status: Clarifai_Api_Status_Status {
    get {return _status ?? Clarifai_Api_Status_Status()}
    set {_status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  public var hasStatus: Bool {return self._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  public mutating func clearStatus() {self._status = nil}

  public var appID: String = String()

  public var taskID: String = String()

  public var counts: [Clarifai_Api_TaskStatusCountPerUser] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _status: Clarifai_Api_Status_Status? = nil
}

/// Request to create label orders.
public struct Clarifai_Api_PostLabelOrdersRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var userAppID: Clarifai_Api_UserAppIDSet {
    get {return _userAppID ?? Clarifai_Api_UserAppIDSet()}
    set {_userAppID = newValue}
  }
  /// Returns true if `userAppID` has been explicitly set.
  public var hasUserAppID: Bool {return self._userAppID != nil}
  /// Clears the value of `userAppID`. Subsequent reads from it will return its default value.
  public mutating func clearUserAppID() {self._userAppID = nil}

  public var labelOrders: [Clarifai_Api_LabelOrder] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _userAppID: Clarifai_Api_UserAppIDSet? = nil
}

/// Request to get one label order.
public struct Clarifai_Api_GetLabelOrderRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var userAppID: Clarifai_Api_UserAppIDSet {
    get {return _userAppID ?? Clarifai_Api_UserAppIDSet()}
    set {_userAppID = newValue}
  }
  /// Returns true if `userAppID` has been explicitly set.
  public var hasUserAppID: Bool {return self._userAppID != nil}
  /// Clears the value of `userAppID`. Subsequent reads from it will return its default value.
  public mutating func clearUserAppID() {self._userAppID = nil}

  public var labelOrderID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _userAppID: Clarifai_Api_UserAppIDSet? = nil
}

/// Request to list multiple label orders.
public struct Clarifai_Api_ListLabelOrdersRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var userAppID: Clarifai_Api_UserAppIDSet {
    get {return _userAppID ?? Clarifai_Api_UserAppIDSet()}
    set {_userAppID = newValue}
  }
  /// Returns true if `userAppID` has been explicitly set.
  public var hasUserAppID: Bool {return self._userAppID != nil}
  /// Clears the value of `userAppID`. Subsequent reads from it will return its default value.
  public mutating func clearUserAppID() {self._userAppID = nil}

  /// (optional URL parameter) The page number. Pagination is used to split the results into chunks.
  /// Defaults to 1.
  public var page: UInt32 = 0

  /// (optional URL parameter) The number of results that will be contained in each page. Defaults
  /// to 128.
  public var perPage: UInt32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _userAppID: Clarifai_Api_UserAppIDSet? = nil
}

/// Request to patch a list of label orders.
public struct Clarifai_Api_PatchLabelOrdersRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var userAppID: Clarifai_Api_UserAppIDSet {
    get {return _userAppID ?? Clarifai_Api_UserAppIDSet()}
    set {_userAppID = newValue}
  }
  /// Returns true if `userAppID` has been explicitly set.
  public var hasUserAppID: Bool {return self._userAppID != nil}
  /// Clears the value of `userAppID`. Subsequent reads from it will return its default value.
  public mutating func clearUserAppID() {self._userAppID = nil}

  public var labelOrders: [Clarifai_Api_LabelOrder] = []

  /// The action to perform on the patched objects
  /// For now actions 'merge', 'overwrite', and 'remove' are supported
  public var action: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _userAppID: Clarifai_Api_UserAppIDSet? = nil
}

/// Request to delete a list of label orders.
public struct Clarifai_Api_DeleteLabelOrdersRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var userAppID: Clarifai_Api_UserAppIDSet {
    get {return _userAppID ?? Clarifai_Api_UserAppIDSet()}
    set {_userAppID = newValue}
  }
  /// Returns true if `userAppID` has been explicitly set.
  public var hasUserAppID: Bool {return self._userAppID != nil}
  /// Clears the value of `userAppID`. Subsequent reads from it will return its default value.
  public mutating func clearUserAppID() {self._userAppID = nil}

  public var ids: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _userAppID: Clarifai_Api_UserAppIDSet? = nil
}

/// Response with multiple label order.
public struct Clarifai_Api_MultiLabelOrderResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var status: Clarifai_Api_Status_Status {
    get {return _status ?? Clarifai_Api_Status_Status()}
    set {_status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  public var hasStatus: Bool {return self._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  public mutating func clearStatus() {self._status = nil}

  public var labelOrders: [Clarifai_Api_LabelOrder] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _status: Clarifai_Api_Status_Status? = nil
}

/// Response with a label order.
public struct Clarifai_Api_SingleLabelOrderResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var status: Clarifai_Api_Status_Status {
    get {return _status ?? Clarifai_Api_Status_Status()}
    set {_status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  public var hasStatus: Bool {return self._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  public mutating func clearStatus() {self._status = nil}

  public var labelOrder: Clarifai_Api_LabelOrder {
    get {return _labelOrder ?? Clarifai_Api_LabelOrder()}
    set {_labelOrder = newValue}
  }
  /// Returns true if `labelOrder` has been explicitly set.
  public var hasLabelOrder: Bool {return self._labelOrder != nil}
  /// Clears the value of `labelOrder`. Subsequent reads from it will return its default value.
  public mutating func clearLabelOrder() {self._labelOrder = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _status: Clarifai_Api_Status_Status? = nil
  fileprivate var _labelOrder: Clarifai_Api_LabelOrder? = nil
}

/// Request to create Collectors.
public struct Clarifai_Api_PostCollectorsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var userAppID: Clarifai_Api_UserAppIDSet {
    get {return _userAppID ?? Clarifai_Api_UserAppIDSet()}
    set {_userAppID = newValue}
  }
  /// Returns true if `userAppID` has been explicitly set.
  public var hasUserAppID: Bool {return self._userAppID != nil}
  /// Clears the value of `userAppID`. Subsequent reads from it will return its default value.
  public mutating func clearUserAppID() {self._userAppID = nil}

  public var collectors: [Clarifai_Api_Collector] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _userAppID: Clarifai_Api_UserAppIDSet? = nil
}

/// PatchCollectorsRequest
public struct Clarifai_Api_PatchCollectorsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var userAppID: Clarifai_Api_UserAppIDSet {
    get {return _userAppID ?? Clarifai_Api_UserAppIDSet()}
    set {_userAppID = newValue}
  }
  /// Returns true if `userAppID` has been explicitly set.
  public var hasUserAppID: Bool {return self._userAppID != nil}
  /// Clears the value of `userAppID`. Subsequent reads from it will return its default value.
  public mutating func clearUserAppID() {self._userAppID = nil}

  public var collectors: [Clarifai_Api_Collector] = []

  /// The action to perform on the patched objects
  /// Only 'overwrite' is supported
  public var action: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _userAppID: Clarifai_Api_UserAppIDSet? = nil
}

/// Request to delete several things by the list of ids.
public struct Clarifai_Api_DeleteCollectorsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var userAppID: Clarifai_Api_UserAppIDSet {
    get {return _userAppID ?? Clarifai_Api_UserAppIDSet()}
    set {_userAppID = newValue}
  }
  /// Returns true if `userAppID` has been explicitly set.
  public var hasUserAppID: Bool {return self._userAppID != nil}
  /// Clears the value of `userAppID`. Subsequent reads from it will return its default value.
  public mutating func clearUserAppID() {self._userAppID = nil}

  public var ids: [String] = []

  public var deleteAll: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _userAppID: Clarifai_Api_UserAppIDSet? = nil
}

/// Request to GET a single Collector.
public struct Clarifai_Api_GetCollectorRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var userAppID: Clarifai_Api_UserAppIDSet {
    get {return _userAppID ?? Clarifai_Api_UserAppIDSet()}
    set {_userAppID = newValue}
  }
  /// Returns true if `userAppID` has been explicitly set.
  public var hasUserAppID: Bool {return self._userAppID != nil}
  /// Clears the value of `userAppID`. Subsequent reads from it will return its default value.
  public mutating func clearUserAppID() {self._userAppID = nil}

  public var collectorID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _userAppID: Clarifai_Api_UserAppIDSet? = nil
}

/// Request to GET all the Collectors.
public struct Clarifai_Api_ListCollectorsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var userAppID: Clarifai_Api_UserAppIDSet {
    get {return _userAppID ?? Clarifai_Api_UserAppIDSet()}
    set {_userAppID = newValue}
  }
  /// Returns true if `userAppID` has been explicitly set.
  public var hasUserAppID: Bool {return self._userAppID != nil}
  /// Clears the value of `userAppID`. Subsequent reads from it will return its default value.
  public mutating func clearUserAppID() {self._userAppID = nil}

  /// (optional URL parameter) The page number. Pagination is used to split the results into chunks.
  /// Defaults to 1.
  public var page: UInt32 = 0

  /// (optional URL parameter) The number of results that will be contained in each page. Defaults
  /// to 128.
  public var perPage: UInt32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _userAppID: Clarifai_Api_UserAppIDSet? = nil
}

/// Response with multiple Collectors.
public struct Clarifai_Api_MultiCollectorResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var status: Clarifai_Api_Status_Status {
    get {return _status ?? Clarifai_Api_Status_Status()}
    set {_status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  public var hasStatus: Bool {return self._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  public mutating func clearStatus() {self._status = nil}

  public var collectors: [Clarifai_Api_Collector] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _status: Clarifai_Api_Status_Status? = nil
}

/// Response with a single Collector.
public struct Clarifai_Api_SingleCollectorResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var status: Clarifai_Api_Status_Status {
    get {return _status ?? Clarifai_Api_Status_Status()}
    set {_status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  public var hasStatus: Bool {return self._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  public mutating func clearStatus() {self._status = nil}

  public var collector: Clarifai_Api_Collector {
    get {return _collector ?? Clarifai_Api_Collector()}
    set {_collector = newValue}
  }
  /// Returns true if `collector` has been explicitly set.
  public var hasCollector: Bool {return self._collector != nil}
  /// Clears the value of `collector`. Subsequent reads from it will return its default value.
  public mutating func clearCollector() {self._collector = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _status: Clarifai_Api_Status_Status? = nil
  fileprivate var _collector: Clarifai_Api_Collector? = nil
}

/// PostStatValuesRequest
public struct Clarifai_Api_PostStatValuesRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The user and app information for the request.
  public var userAppID: Clarifai_Api_UserAppIDSet {
    get {return _userAppID ?? Clarifai_Api_UserAppIDSet()}
    set {_userAppID = newValue}
  }
  /// Returns true if `userAppID` has been explicitly set.
  public var hasUserAppID: Bool {return self._userAppID != nil}
  /// Clears the value of `userAppID`. Subsequent reads from it will return its default value.
  public mutating func clearUserAppID() {self._userAppID = nil}

  /// The stats to post, can post more than one at a time.
  public var statValues: [Clarifai_Api_StatValue] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _userAppID: Clarifai_Api_UserAppIDSet? = nil
}

/// MultiStatValueResponse
public struct Clarifai_Api_MultiStatValueResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The response status.
  public var status: Clarifai_Api_Status_Status {
    get {return _status ?? Clarifai_Api_Status_Status()}
    set {_status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  public var hasStatus: Bool {return self._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  public mutating func clearStatus() {self._status = nil}

  /// The returned stats values.
  public var statValues: [Clarifai_Api_StatValue] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _status: Clarifai_Api_Status_Status? = nil
}

/// PostStatValuesAggregateRequest
public struct Clarifai_Api_PostStatValuesAggregateRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Ids present in the url of the request.
  public var userAppID: Clarifai_Api_UserAppIDSet {
    get {return _userAppID ?? Clarifai_Api_UserAppIDSet()}
    set {_userAppID = newValue}
  }
  /// Returns true if `userAppID` has been explicitly set.
  public var hasUserAppID: Bool {return self._userAppID != nil}
  /// Clears the value of `userAppID`. Subsequent reads from it will return its default value.
  public mutating func clearUserAppID() {self._userAppID = nil}

  /// Query to retrieve aggregate values.
  public var statValueAggregateQueries: [Clarifai_Api_StatValueAggregateQuery] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _userAppID: Clarifai_Api_UserAppIDSet? = nil
}

/// MultiStatValueAggregateResponse
public struct Clarifai_Api_MultiStatValueAggregateResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The response status.
  public var status: Clarifai_Api_Status_Status {
    get {return _status ?? Clarifai_Api_Status_Status()}
    set {_status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  public var hasStatus: Bool {return self._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  public mutating func clearStatus() {self._status = nil}

  /// The aggregate results for each query passedin.
  public var statValueAggregateResults: [Clarifai_Api_StatValueAggregateResult] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _status: Clarifai_Api_Status_Status? = nil
}

/// GetModuleRequest
public struct Clarifai_Api_GetModuleRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var userAppID: Clarifai_Api_UserAppIDSet {
    get {return _userAppID ?? Clarifai_Api_UserAppIDSet()}
    set {_userAppID = newValue}
  }
  /// Returns true if `userAppID` has been explicitly set.
  public var hasUserAppID: Bool {return self._userAppID != nil}
  /// Clears the value of `userAppID`. Subsequent reads from it will return its default value.
  public mutating func clearUserAppID() {self._userAppID = nil}

  public var moduleID: String = String()

  public var additionalFields: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _userAppID: Clarifai_Api_UserAppIDSet? = nil
}

/// ListModulesRequest
public struct Clarifai_Api_ListModulesRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var userAppID: Clarifai_Api_UserAppIDSet {
    get {return _userAppID ?? Clarifai_Api_UserAppIDSet()}
    set {_userAppID = newValue}
  }
  /// Returns true if `userAppID` has been explicitly set.
  public var hasUserAppID: Bool {return self._userAppID != nil}
  /// Clears the value of `userAppID`. Subsequent reads from it will return its default value.
  public mutating func clearUserAppID() {self._userAppID = nil}

  /// (optional URL parameter) The page number. Pagination is used to split the results into chunks.
  /// Defaults to 1.
  public var page: UInt32 = 0

  /// (optional URL parameter) The number of results that will be contained in each page. Defaults
  /// to 128.
  public var perPage: UInt32 = 0

  public var additionalFields: [String] = []

  /// Sorting options:
  /// Whether to sort in ascending order. If false, will order in descending order.
  public var sortAscending: Bool = false

  public var sortBy: Clarifai_Api_ListModulesRequest.OneOf_SortBy? = nil

  /// Whether to order by the created_at time.
  public var sortByCreatedAt: Bool {
    get {
      if case .sortByCreatedAt(let v)? = sortBy {return v}
      return false
    }
    set {sortBy = .sortByCreatedAt(newValue)}
  }

  /// Whether to order by the number of users stared the app
  public var sortByStarCount: Bool {
    get {
      if case .sortByStarCount(let v)? = sortBy {return v}
      return false
    }
    set {sortBy = .sortByStarCount(newValue)}
  }

  /// If neither sort option is set to true, will sort by modified_at.
  public var sortByModifiedAt: Bool {
    get {
      if case .sortByModifiedAt(let v)? = sortBy {return v}
      return false
    }
    set {sortBy = .sortByModifiedAt(newValue)}
  }

  /// Whether to order by the external id
  public var sortByID: Bool {
    get {
      if case .sortByID(let v)? = sortBy {return v}
      return false
    }
    set {sortBy = .sortByID(newValue)}
  }

  /// Filtering options:
  public var starredOnly: Bool = false

  /// Filter modules by bookmark. If set, only return bookmarked modules. Otherwise none bookmarked modules only.
  public var bookmark: Bool = false

  /// Searching options:
  /// Specify a search parameter in order to perform keyword search on the
  /// following fields of the module:
  ///   - id
  ///   - description
  ///   - user_id (unless user_app_id.user_id is already set)
  ///
  /// Keywords are both normalized for search (so searching for "satisfy" matches "satisfied")
  /// and used for partial prefix-matching (so searching for "clari" matches "clarifai").
  ///
  /// NOTE: Both the list of fields searched and the exact keyword matching
  /// rules are subject to change and not guaranteed to be backwards-compatible.
  public var search: String = String()

  /// Filter by the id and description of the module. This supports wildcard queries like "gen*" to match "general" as an example.
  /// Deprecated: use search instead.
  public var name: String = String()

  /// Filter by the application owner whose this module belongs to
  /// Deprecated: use search instead of name.
  public var filterByUserID: Bool = false

  /// Filter by visibility of the modules. If set, only return modules with the specified visibility.
  public var visibility: Clarifai_Api_Visibility {
    get {return _visibility ?? Clarifai_Api_Visibility()}
    set {_visibility = newValue}
  }
  /// Returns true if `visibility` has been explicitly set.
  public var hasVisibility: Bool {return self._visibility != nil}
  /// Clears the value of `visibility`. Subsequent reads from it will return its default value.
  public mutating func clearVisibility() {self._visibility = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_SortBy: Equatable {
    /// Whether to order by the created_at time.
    case sortByCreatedAt(Bool)
    /// Whether to order by the number of users stared the app
    case sortByStarCount(Bool)
    /// If neither sort option is set to true, will sort by modified_at.
    case sortByModifiedAt(Bool)
    /// Whether to order by the external id
    case sortByID(Bool)

  #if !swift(>=4.1)
    public static func ==(lhs: Clarifai_Api_ListModulesRequest.OneOf_SortBy, rhs: Clarifai_Api_ListModulesRequest.OneOf_SortBy) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.sortByCreatedAt, .sortByCreatedAt): return {
        guard case .sortByCreatedAt(let l) = lhs, case .sortByCreatedAt(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.sortByStarCount, .sortByStarCount): return {
        guard case .sortByStarCount(let l) = lhs, case .sortByStarCount(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.sortByModifiedAt, .sortByModifiedAt): return {
        guard case .sortByModifiedAt(let l) = lhs, case .sortByModifiedAt(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.sortByID, .sortByID): return {
        guard case .sortByID(let l) = lhs, case .sortByID(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}

  fileprivate var _userAppID: Clarifai_Api_UserAppIDSet? = nil
  fileprivate var _visibility: Clarifai_Api_Visibility? = nil
}

/// PostModulesRequest
public struct Clarifai_Api_PostModulesRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var userAppID: Clarifai_Api_UserAppIDSet {
    get {return _userAppID ?? Clarifai_Api_UserAppIDSet()}
    set {_userAppID = newValue}
  }
  /// Returns true if `userAppID` has been explicitly set.
  public var hasUserAppID: Bool {return self._userAppID != nil}
  /// Clears the value of `userAppID`. Subsequent reads from it will return its default value.
  public mutating func clearUserAppID() {self._userAppID = nil}

  /// This allows you to create one or more module by posting it to the API.
  public var modules: [Clarifai_Api_Module] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _userAppID: Clarifai_Api_UserAppIDSet? = nil
}

/// PatchModulesRequest
public struct Clarifai_Api_PatchModulesRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var userAppID: Clarifai_Api_UserAppIDSet {
    get {return _userAppID ?? Clarifai_Api_UserAppIDSet()}
    set {_userAppID = newValue}
  }
  /// Returns true if `userAppID` has been explicitly set.
  public var hasUserAppID: Bool {return self._userAppID != nil}
  /// Clears the value of `userAppID`. Subsequent reads from it will return its default value.
  public mutating func clearUserAppID() {self._userAppID = nil}

  public var modules: [Clarifai_Api_Module] = []

  /// The action to perform on the patched objects
  /// Supported values: 'overwrite' and 'remove'.
  ///
  /// Note that 'remove' can only be used to remove the module image by setting
  /// 'image.url' in the request to the current value returned for that module.
  public var action: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _userAppID: Clarifai_Api_UserAppIDSet? = nil
}

/// Request to delete several things by the list of ids.
public struct Clarifai_Api_DeleteModulesRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var userAppID: Clarifai_Api_UserAppIDSet {
    get {return _userAppID ?? Clarifai_Api_UserAppIDSet()}
    set {_userAppID = newValue}
  }
  /// Returns true if `userAppID` has been explicitly set.
  public var hasUserAppID: Bool {return self._userAppID != nil}
  /// Clears the value of `userAppID`. Subsequent reads from it will return its default value.
  public mutating func clearUserAppID() {self._userAppID = nil}

  public var ids: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _userAppID: Clarifai_Api_UserAppIDSet? = nil
}

/// SingleModuleResponse
public struct Clarifai_Api_SingleModuleResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var status: Clarifai_Api_Status_Status {
    get {return _status ?? Clarifai_Api_Status_Status()}
    set {_status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  public var hasStatus: Bool {return self._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  public mutating func clearStatus() {self._status = nil}

  public var module: Clarifai_Api_Module {
    get {return _module ?? Clarifai_Api_Module()}
    set {_module = newValue}
  }
  /// Returns true if `module` has been explicitly set.
  public var hasModule: Bool {return self._module != nil}
  /// Clears the value of `module`. Subsequent reads from it will return its default value.
  public mutating func clearModule() {self._module = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _status: Clarifai_Api_Status_Status? = nil
  fileprivate var _module: Clarifai_Api_Module? = nil
}

/// MultiModuleResponse
public struct Clarifai_Api_MultiModuleResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var status: Clarifai_Api_Status_Status {
    get {return _status ?? Clarifai_Api_Status_Status()}
    set {_status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  public var hasStatus: Bool {return self._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  public mutating func clearStatus() {self._status = nil}

  public var modules: [Clarifai_Api_Module] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _status: Clarifai_Api_Status_Status? = nil
}

/// request for different endpoints currently.
public struct Clarifai_Api_GetModuleVersionRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var userAppID: Clarifai_Api_UserAppIDSet {
    get {return _userAppID ?? Clarifai_Api_UserAppIDSet()}
    set {_userAppID = newValue}
  }
  /// Returns true if `userAppID` has been explicitly set.
  public var hasUserAppID: Bool {return self._userAppID != nil}
  /// Clears the value of `userAppID`. Subsequent reads from it will return its default value.
  public mutating func clearUserAppID() {self._userAppID = nil}

  public var moduleID: String = String()

  public var moduleVersionID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _userAppID: Clarifai_Api_UserAppIDSet? = nil
}

/// ListModuleVersionsRequest
public struct Clarifai_Api_ListModuleVersionsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var userAppID: Clarifai_Api_UserAppIDSet {
    get {return _userAppID ?? Clarifai_Api_UserAppIDSet()}
    set {_userAppID = newValue}
  }
  /// Returns true if `userAppID` has been explicitly set.
  public var hasUserAppID: Bool {return self._userAppID != nil}
  /// Clears the value of `userAppID`. Subsequent reads from it will return its default value.
  public mutating func clearUserAppID() {self._userAppID = nil}

  public var moduleID: String = String()

  /// (optional URL parameter) The page number. Pagination is used to split the results into chunks.
  /// Defaults to 1.
  public var page: UInt32 = 0

  /// (optional URL parameter) The number of results that will be contained in each page. Defaults
  /// to 128.
  public var perPage: UInt32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _userAppID: Clarifai_Api_UserAppIDSet? = nil
}

/// PostModuleVersionsRequest
public struct Clarifai_Api_PostModuleVersionsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var userAppID: Clarifai_Api_UserAppIDSet {
    get {return _userAppID ?? Clarifai_Api_UserAppIDSet()}
    set {_userAppID = newValue}
  }
  /// Returns true if `userAppID` has been explicitly set.
  public var hasUserAppID: Bool {return self._userAppID != nil}
  /// Clears the value of `userAppID`. Subsequent reads from it will return its default value.
  public mutating func clearUserAppID() {self._userAppID = nil}

  public var moduleID: String = String()

  /// This allows you to create one or more module by posting it to the API.
  public var moduleVersions: [Clarifai_Api_ModuleVersion] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _userAppID: Clarifai_Api_UserAppIDSet? = nil
}

/// PatchModuleVersionsRequest
public struct Clarifai_Api_PatchModuleVersionsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var userAppID: Clarifai_Api_UserAppIDSet {
    get {return _userAppID ?? Clarifai_Api_UserAppIDSet()}
    set {_userAppID = newValue}
  }
  /// Returns true if `userAppID` has been explicitly set.
  public var hasUserAppID: Bool {return self._userAppID != nil}
  /// Clears the value of `userAppID`. Subsequent reads from it will return its default value.
  public mutating func clearUserAppID() {self._userAppID = nil}

  public var moduleID: String = String()

  /// This allows you to modify the module version details.
  /// ########## Supported fields ##########
  /// - description
  /// - id
  /// - metadata.fields
  /// - module_nav.module_sub_navs[].query_key
  /// - module_nav.module_sub_navs[].query_value
  /// - module_nav.module_sub_navs[].title
  /// - module_nav.title
  /// - notes
  /// - visibility.gettable
  public var moduleVersions: [Clarifai_Api_ModuleVersion] = []

  /// The action to perform on the patched objects
  /// For now only action 'merge' is supported
  public var action: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _userAppID: Clarifai_Api_UserAppIDSet? = nil
}

/// Request to delete several module versions by the list of ids.
public struct Clarifai_Api_DeleteModuleVersionsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var userAppID: Clarifai_Api_UserAppIDSet {
    get {return _userAppID ?? Clarifai_Api_UserAppIDSet()}
    set {_userAppID = newValue}
  }
  /// Returns true if `userAppID` has been explicitly set.
  public var hasUserAppID: Bool {return self._userAppID != nil}
  /// Clears the value of `userAppID`. Subsequent reads from it will return its default value.
  public mutating func clearUserAppID() {self._userAppID = nil}

  public var moduleID: String = String()

  public var ids: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _userAppID: Clarifai_Api_UserAppIDSet? = nil
}

/// Request to get the number of installations (by all users) for the module version
public struct Clarifai_Api_GetModuleVersionUsageCountRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var userAppID: Clarifai_Api_UserAppIDSet {
    get {return _userAppID ?? Clarifai_Api_UserAppIDSet()}
    set {_userAppID = newValue}
  }
  /// Returns true if `userAppID` has been explicitly set.
  public var hasUserAppID: Bool {return self._userAppID != nil}
  /// Clears the value of `userAppID`. Subsequent reads from it will return its default value.
  public mutating func clearUserAppID() {self._userAppID = nil}

  public var moduleID: String = String()

  public var moduleVersionID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _userAppID: Clarifai_Api_UserAppIDSet? = nil
}

/// SingleModuleVersionResponse
public struct Clarifai_Api_SingleModuleVersionResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var status: Clarifai_Api_Status_Status {
    get {return _storage._status ?? Clarifai_Api_Status_Status()}
    set {_uniqueStorage()._status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  public var hasStatus: Bool {return _storage._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  public mutating func clearStatus() {_uniqueStorage()._status = nil}

  public var moduleVersion: Clarifai_Api_ModuleVersion {
    get {return _storage._moduleVersion ?? Clarifai_Api_ModuleVersion()}
    set {_uniqueStorage()._moduleVersion = newValue}
  }
  /// Returns true if `moduleVersion` has been explicitly set.
  public var hasModuleVersion: Bool {return _storage._moduleVersion != nil}
  /// Clears the value of `moduleVersion`. Subsequent reads from it will return its default value.
  public mutating func clearModuleVersion() {_uniqueStorage()._moduleVersion = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// MultiModuleVersionResponse
public struct Clarifai_Api_MultiModuleVersionResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var status: Clarifai_Api_Status_Status {
    get {return _status ?? Clarifai_Api_Status_Status()}
    set {_status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  public var hasStatus: Bool {return self._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  public mutating func clearStatus() {self._status = nil}

  public var moduleVersions: [Clarifai_Api_ModuleVersion] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _status: Clarifai_Api_Status_Status? = nil
}

/// SingleModuleVersionUsageCountResponse
public struct Clarifai_Api_SingleModuleVersionUsageCountResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var status: Clarifai_Api_Status_Status {
    get {return _status ?? Clarifai_Api_Status_Status()}
    set {_status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  public var hasStatus: Bool {return self._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  public mutating func clearStatus() {self._status = nil}

  public var usageCount: UInt32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _status: Clarifai_Api_Status_Status? = nil
}

/// GetInstalledModuleVersionRequest
public struct Clarifai_Api_GetInstalledModuleVersionRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var userAppID: Clarifai_Api_UserAppIDSet {
    get {return _userAppID ?? Clarifai_Api_UserAppIDSet()}
    set {_userAppID = newValue}
  }
  /// Returns true if `userAppID` has been explicitly set.
  public var hasUserAppID: Bool {return self._userAppID != nil}
  /// Clears the value of `userAppID`. Subsequent reads from it will return its default value.
  public mutating func clearUserAppID() {self._userAppID = nil}

  /// the ID to get of the install module version.
  public var installedModuleVersionID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _userAppID: Clarifai_Api_UserAppIDSet? = nil
}

/// ListInstalledModuleVersionsRequest
public struct Clarifai_Api_ListInstalledModuleVersionsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var userAppID: Clarifai_Api_UserAppIDSet {
    get {return _userAppID ?? Clarifai_Api_UserAppIDSet()}
    set {_userAppID = newValue}
  }
  /// Returns true if `userAppID` has been explicitly set.
  public var hasUserAppID: Bool {return self._userAppID != nil}
  /// Clears the value of `userAppID`. Subsequent reads from it will return its default value.
  public mutating func clearUserAppID() {self._userAppID = nil}

  /// (optional URL parameter) The page number. Pagination is used to split the results into chunks.
  /// Defaults to 1.
  public var page: UInt32 = 0

  /// (optional URL parameter) The number of results that will be contained in each page. Defaults
  /// to 128.
  public var perPage: UInt32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _userAppID: Clarifai_Api_UserAppIDSet? = nil
}

/// PostInstalledModuleVersionsRequest to install a module version into the app in the URL
public struct Clarifai_Api_PostInstalledModuleVersionsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var userAppID: Clarifai_Api_UserAppIDSet {
    get {return _userAppID ?? Clarifai_Api_UserAppIDSet()}
    set {_userAppID = newValue}
  }
  /// Returns true if `userAppID` has been explicitly set.
  public var hasUserAppID: Bool {return self._userAppID != nil}
  /// Clears the value of `userAppID`. Subsequent reads from it will return its default value.
  public mutating func clearUserAppID() {self._userAppID = nil}

  /// This allows you to create one or more module by posting it to the API.
  public var installedModuleVersions: [Clarifai_Api_InstalledModuleVersion] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _userAppID: Clarifai_Api_UserAppIDSet? = nil
}

/// PostInstalledModuleVersionsKeyRequest to associate a key of the caller's to the installed module
/// version.
public struct Clarifai_Api_PostInstalledModuleVersionsKeyRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var userAppID: Clarifai_Api_UserAppIDSet {
    get {return _userAppID ?? Clarifai_Api_UserAppIDSet()}
    set {_userAppID = newValue}
  }
  /// Returns true if `userAppID` has been explicitly set.
  public var hasUserAppID: Bool {return self._userAppID != nil}
  /// Clears the value of `userAppID`. Subsequent reads from it will return its default value.
  public mutating func clearUserAppID() {self._userAppID = nil}

  /// the ID to get of the install module version.
  public var installedModuleVersionID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _userAppID: Clarifai_Api_UserAppIDSet? = nil
}

/// Request to delete several installed module versions by the list of ids.
public struct Clarifai_Api_DeleteInstalledModuleVersionsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var userAppID: Clarifai_Api_UserAppIDSet {
    get {return _userAppID ?? Clarifai_Api_UserAppIDSet()}
    set {_userAppID = newValue}
  }
  /// Returns true if `userAppID` has been explicitly set.
  public var hasUserAppID: Bool {return self._userAppID != nil}
  /// Clears the value of `userAppID`. Subsequent reads from it will return its default value.
  public mutating func clearUserAppID() {self._userAppID = nil}

  public var ids: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _userAppID: Clarifai_Api_UserAppIDSet? = nil
}

/// SingleInstalledModuleVersionResponse
public struct Clarifai_Api_SingleInstalledModuleVersionResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var status: Clarifai_Api_Status_Status {
    get {return _status ?? Clarifai_Api_Status_Status()}
    set {_status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  public var hasStatus: Bool {return self._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  public mutating func clearStatus() {self._status = nil}

  public var installedModuleVersion: Clarifai_Api_InstalledModuleVersion {
    get {return _installedModuleVersion ?? Clarifai_Api_InstalledModuleVersion()}
    set {_installedModuleVersion = newValue}
  }
  /// Returns true if `installedModuleVersion` has been explicitly set.
  public var hasInstalledModuleVersion: Bool {return self._installedModuleVersion != nil}
  /// Clears the value of `installedModuleVersion`. Subsequent reads from it will return its default value.
  public mutating func clearInstalledModuleVersion() {self._installedModuleVersion = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _status: Clarifai_Api_Status_Status? = nil
  fileprivate var _installedModuleVersion: Clarifai_Api_InstalledModuleVersion? = nil
}

/// MultiInstalledModuleVersionResponse
public struct Clarifai_Api_MultiInstalledModuleVersionResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var status: Clarifai_Api_Status_Status {
    get {return _status ?? Clarifai_Api_Status_Status()}
    set {_status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  public var hasStatus: Bool {return self._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  public mutating func clearStatus() {self._status = nil}

  public var installedModuleVersions: [Clarifai_Api_InstalledModuleVersion] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _status: Clarifai_Api_Status_Status? = nil
}

/// ListNextTaskAssignmentsRequest
public struct Clarifai_Api_ListNextTaskAssignmentsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var userAppID: Clarifai_Api_UserAppIDSet {
    get {return _userAppID ?? Clarifai_Api_UserAppIDSet()}
    set {_userAppID = newValue}
  }
  /// Returns true if `userAppID` has been explicitly set.
  public var hasUserAppID: Bool {return self._userAppID != nil}
  /// Clears the value of `userAppID`. Subsequent reads from it will return its default value.
  public mutating func clearUserAppID() {self._userAppID = nil}

  public var taskID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _userAppID: Clarifai_Api_UserAppIDSet? = nil
}

/// Request to perform bulk operations on a list of inputs based on input source.
public struct Clarifai_Api_PostBulkOperationsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var userAppID: Clarifai_Api_UserAppIDSet {
    get {return _userAppID ?? Clarifai_Api_UserAppIDSet()}
    set {_userAppID = newValue}
  }
  /// Returns true if `userAppID` has been explicitly set.
  public var hasUserAppID: Bool {return self._userAppID != nil}
  /// Clears the value of `userAppID`. Subsequent reads from it will return its default value.
  public mutating func clearUserAppID() {self._userAppID = nil}

  /// List of bulk operation(s) to be performed e.g bulk update metadata or tags or labels etc.
  public var bulkOperations: [Clarifai_Api_BulkOperation] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _userAppID: Clarifai_Api_UserAppIDSet? = nil
}

/// Request to list all the bulk operations.
public struct Clarifai_Api_ListBulkOperationsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var userAppID: Clarifai_Api_UserAppIDSet {
    get {return _userAppID ?? Clarifai_Api_UserAppIDSet()}
    set {_userAppID = newValue}
  }
  /// Returns true if `userAppID` has been explicitly set.
  public var hasUserAppID: Bool {return self._userAppID != nil}
  /// Clears the value of `userAppID`. Subsequent reads from it will return its default value.
  public mutating func clearUserAppID() {self._userAppID = nil}

  /// (optional URL parameter) The page number. Pagination is used to split the results into chunks.
  /// Defaults to 1.
  public var page: UInt32 = 0

  /// (optional URL parameter) The number of results that will be contained in each page. Defaults
  /// to 128.
  public var perPage: UInt32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _userAppID: Clarifai_Api_UserAppIDSet? = nil
}

/// Request to get the details of a bulk operation by ID.
public struct Clarifai_Api_GetBulkOperationRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var userAppID: Clarifai_Api_UserAppIDSet {
    get {return _userAppID ?? Clarifai_Api_UserAppIDSet()}
    set {_userAppID = newValue}
  }
  /// Returns true if `userAppID` has been explicitly set.
  public var hasUserAppID: Bool {return self._userAppID != nil}
  /// Clears the value of `userAppID`. Subsequent reads from it will return its default value.
  public mutating func clearUserAppID() {self._userAppID = nil}

  /// The bulk operation id
  public var id: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _userAppID: Clarifai_Api_UserAppIDSet? = nil
}

/// Cancel a list of bulk operation ids
public struct Clarifai_Api_CancelBulkOperationRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var userAppID: Clarifai_Api_UserAppIDSet {
    get {return _userAppID ?? Clarifai_Api_UserAppIDSet()}
    set {_userAppID = newValue}
  }
  /// Returns true if `userAppID` has been explicitly set.
  public var hasUserAppID: Bool {return self._userAppID != nil}
  /// Clears the value of `userAppID`. Subsequent reads from it will return its default value.
  public mutating func clearUserAppID() {self._userAppID = nil}

  /// List of bulk operation ids to be cancelled
  public var ids: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _userAppID: Clarifai_Api_UserAppIDSet? = nil
}

/// Request to delete the terminated bulk operations by ID
/// Only operations in terminated state can be deleted.
public struct Clarifai_Api_DeleteBulkOperationRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var userAppID: Clarifai_Api_UserAppIDSet {
    get {return _userAppID ?? Clarifai_Api_UserAppIDSet()}
    set {_userAppID = newValue}
  }
  /// Returns true if `userAppID` has been explicitly set.
  public var hasUserAppID: Bool {return self._userAppID != nil}
  /// Clears the value of `userAppID`. Subsequent reads from it will return its default value.
  public mutating func clearUserAppID() {self._userAppID = nil}

  /// List of bulk operation ids to be deleted
  public var ids: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _userAppID: Clarifai_Api_UserAppIDSet? = nil
}

/// SingleBulkOperationsResponse
public struct Clarifai_Api_SingleBulkOperationsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var status: Clarifai_Api_Status_Status {
    get {return _status ?? Clarifai_Api_Status_Status()}
    set {_status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  public var hasStatus: Bool {return self._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  public mutating func clearStatus() {self._status = nil}

  public var bulkOperation: Clarifai_Api_BulkOperation {
    get {return _bulkOperation ?? Clarifai_Api_BulkOperation()}
    set {_bulkOperation = newValue}
  }
  /// Returns true if `bulkOperation` has been explicitly set.
  public var hasBulkOperation: Bool {return self._bulkOperation != nil}
  /// Clears the value of `bulkOperation`. Subsequent reads from it will return its default value.
  public mutating func clearBulkOperation() {self._bulkOperation = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _status: Clarifai_Api_Status_Status? = nil
  fileprivate var _bulkOperation: Clarifai_Api_BulkOperation? = nil
}

/// MultiBulkOperationsResponse
public struct Clarifai_Api_MultiBulkOperationsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var status: Clarifai_Api_Status_Status {
    get {return _status ?? Clarifai_Api_Status_Status()}
    set {_status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  public var hasStatus: Bool {return self._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  public mutating func clearStatus() {self._status = nil}

  public var bulkOperation: [Clarifai_Api_BulkOperation] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _status: Clarifai_Api_Status_Status? = nil
}

/// PutTaskAssignmentsRequest
public struct Clarifai_Api_PutTaskAssignmentsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var userAppID: Clarifai_Api_UserAppIDSet {
    get {return _userAppID ?? Clarifai_Api_UserAppIDSet()}
    set {_userAppID = newValue}
  }
  /// Returns true if `userAppID` has been explicitly set.
  public var hasUserAppID: Bool {return self._userAppID != nil}
  /// Clears the value of `userAppID`. Subsequent reads from it will return its default value.
  public mutating func clearUserAppID() {self._userAppID = nil}

  public var taskID: String = String()

  /// Deprecated: use action and action_config instead.
  /// Supported for backwards compatibility: setting this field is equivalent with
  /// * action = LABEL_SUBMIT
  /// * label_submit_config = [{"task_assignments": {{"id": "<task-assignment-id-for-input-id>"}}]
  public var inputID: String = String()

  /// Action to perform on selected task.
  public var action: Clarifai_Api_PutTaskAssignmentsRequestAction = .notSet

  public var actionConfig: Clarifai_Api_PutTaskAssignmentsRequest.OneOf_ActionConfig? = nil

  ///    LabelStartConfig label_start_config = 5; // no config for label start action
  public var labelSubmitConfig: Clarifai_Api_LabelSubmitConfig {
    get {
      if case .labelSubmitConfig(let v)? = actionConfig {return v}
      return Clarifai_Api_LabelSubmitConfig()
    }
    set {actionConfig = .labelSubmitConfig(newValue)}
  }

  public var reviewStartConfig: Clarifai_Api_ReviewStartConfig {
    get {
      if case .reviewStartConfig(let v)? = actionConfig {return v}
      return Clarifai_Api_ReviewStartConfig()
    }
    set {actionConfig = .reviewStartConfig(newValue)}
  }

  public var reviewApproveConfig: Clarifai_Api_ReviewApproveConfig {
    get {
      if case .reviewApproveConfig(let v)? = actionConfig {return v}
      return Clarifai_Api_ReviewApproveConfig()
    }
    set {actionConfig = .reviewApproveConfig(newValue)}
  }

  public var reviewRequestChangesConfig: Clarifai_Api_ReviewRequestChangesConfig {
    get {
      if case .reviewRequestChangesConfig(let v)? = actionConfig {return v}
      return Clarifai_Api_ReviewRequestChangesConfig()
    }
    set {actionConfig = .reviewRequestChangesConfig(newValue)}
  }

  public var reviewRejectConfig: Clarifai_Api_ReviewRejectConfig {
    get {
      if case .reviewRejectConfig(let v)? = actionConfig {return v}
      return Clarifai_Api_ReviewRejectConfig()
    }
    set {actionConfig = .reviewRejectConfig(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_ActionConfig: Equatable {
    ///    LabelStartConfig label_start_config = 5; // no config for label start action
    case labelSubmitConfig(Clarifai_Api_LabelSubmitConfig)
    case reviewStartConfig(Clarifai_Api_ReviewStartConfig)
    case reviewApproveConfig(Clarifai_Api_ReviewApproveConfig)
    case reviewRequestChangesConfig(Clarifai_Api_ReviewRequestChangesConfig)
    case reviewRejectConfig(Clarifai_Api_ReviewRejectConfig)

  #if !swift(>=4.1)
    public static func ==(lhs: Clarifai_Api_PutTaskAssignmentsRequest.OneOf_ActionConfig, rhs: Clarifai_Api_PutTaskAssignmentsRequest.OneOf_ActionConfig) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.labelSubmitConfig, .labelSubmitConfig): return {
        guard case .labelSubmitConfig(let l) = lhs, case .labelSubmitConfig(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.reviewStartConfig, .reviewStartConfig): return {
        guard case .reviewStartConfig(let l) = lhs, case .reviewStartConfig(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.reviewApproveConfig, .reviewApproveConfig): return {
        guard case .reviewApproveConfig(let l) = lhs, case .reviewApproveConfig(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.reviewRequestChangesConfig, .reviewRequestChangesConfig): return {
        guard case .reviewRequestChangesConfig(let l) = lhs, case .reviewRequestChangesConfig(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.reviewRejectConfig, .reviewRejectConfig): return {
        guard case .reviewRejectConfig(let l) = lhs, case .reviewRejectConfig(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}

  fileprivate var _userAppID: Clarifai_Api_UserAppIDSet? = nil
}

public struct Clarifai_Api_LabelSubmitConfig {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var taskAssignments: [Clarifai_Api_TaskAssignment] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Clarifai_Api_ReviewStartConfig {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Review the work done by these workers.
  /// If empty, review the work for all workers.
  public var workers: [Clarifai_Api_Worker] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Clarifai_Api_ReviewApproveConfig {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var taskAssignments: [Clarifai_Api_TaskAssignment] = []

  public var workers: [Clarifai_Api_Worker] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Clarifai_Api_ReviewRequestChangesConfig {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var taskAssignments: [Clarifai_Api_TaskAssignment] = []

  public var workers: [Clarifai_Api_Worker] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Clarifai_Api_ReviewRejectConfig {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var taskAssignments: [Clarifai_Api_TaskAssignment] = []

  public var workers: [Clarifai_Api_Worker] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Clarifai_Api_MultiTaskAssignmentResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var status: Clarifai_Api_Status_Status {
    get {return _status ?? Clarifai_Api_Status_Status()}
    set {_status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  public var hasStatus: Bool {return self._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  public mutating func clearStatus() {self._status = nil}

  public var taskAssignments: [Clarifai_Api_TaskAssignment] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _status: Clarifai_Api_Status_Status? = nil
}

/// List all the input ingestion jobs
public struct Clarifai_Api_ListInputsAddJobsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var userAppID: Clarifai_Api_UserAppIDSet {
    get {return _userAppID ?? Clarifai_Api_UserAppIDSet()}
    set {_userAppID = newValue}
  }
  /// Returns true if `userAppID` has been explicitly set.
  public var hasUserAppID: Bool {return self._userAppID != nil}
  /// Clears the value of `userAppID`. Subsequent reads from it will return its default value.
  public mutating func clearUserAppID() {self._userAppID = nil}

  /// (optional URL parameter) The page number. Pagination is used to split the results into chunks.
  /// Defaults to 1.
  public var page: UInt32 = 0

  /// (optional URL parameter) The number of results that will be contained in each page. Defaults
  /// to 128.
  public var perPage: UInt32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _userAppID: Clarifai_Api_UserAppIDSet? = nil
}

public struct Clarifai_Api_GetInputsAddJobRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var userAppID: Clarifai_Api_UserAppIDSet {
    get {return _userAppID ?? Clarifai_Api_UserAppIDSet()}
    set {_userAppID = newValue}
  }
  /// Returns true if `userAppID` has been explicitly set.
  public var hasUserAppID: Bool {return self._userAppID != nil}
  /// Clears the value of `userAppID`. Subsequent reads from it will return its default value.
  public mutating func clearUserAppID() {self._userAppID = nil}

  /// id of add inputs job
  public var id: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _userAppID: Clarifai_Api_UserAppIDSet? = nil
}

public struct Clarifai_Api_CancelInputsAddJobRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var userAppID: Clarifai_Api_UserAppIDSet {
    get {return _userAppID ?? Clarifai_Api_UserAppIDSet()}
    set {_userAppID = newValue}
  }
  /// Returns true if `userAppID` has been explicitly set.
  public var hasUserAppID: Bool {return self._userAppID != nil}
  /// Clears the value of `userAppID`. Subsequent reads from it will return its default value.
  public mutating func clearUserAppID() {self._userAppID = nil}

  /// id of add inputs job to be cancelled
  public var id: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _userAppID: Clarifai_Api_UserAppIDSet? = nil
}

/// MultiInputsAddJobResponse
public struct Clarifai_Api_MultiInputsAddJobResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var status: Clarifai_Api_Status_Status {
    get {return _status ?? Clarifai_Api_Status_Status()}
    set {_status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  public var hasStatus: Bool {return self._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  public mutating func clearStatus() {self._status = nil}

  public var inputsAddJobs: [Clarifai_Api_InputsAddJob] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _status: Clarifai_Api_Status_Status? = nil
}

/// SingleInputsAddJobResponse
public struct Clarifai_Api_SingleInputsAddJobResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var status: Clarifai_Api_Status_Status {
    get {return _status ?? Clarifai_Api_Status_Status()}
    set {_status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  public var hasStatus: Bool {return self._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  public mutating func clearStatus() {self._status = nil}

  public var inputsAddJob: Clarifai_Api_InputsAddJob {
    get {return _inputsAddJob ?? Clarifai_Api_InputsAddJob()}
    set {_inputsAddJob = newValue}
  }
  /// Returns true if `inputsAddJob` has been explicitly set.
  public var hasInputsAddJob: Bool {return self._inputsAddJob != nil}
  /// Clears the value of `inputsAddJob`. Subsequent reads from it will return its default value.
  public mutating func clearInputsAddJob() {self._inputsAddJob = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _status: Clarifai_Api_Status_Status? = nil
  fileprivate var _inputsAddJob: Clarifai_Api_InputsAddJob? = nil
}

/// Start a multipart upload
public struct Clarifai_Api_PostUploadsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var userAppID: Clarifai_Api_UserAppIDSet {
    get {return _userAppID ?? Clarifai_Api_UserAppIDSet()}
    set {_userAppID = newValue}
  }
  /// Returns true if `userAppID` has been explicitly set.
  public var hasUserAppID: Bool {return self._userAppID != nil}
  /// Clears the value of `userAppID`. Subsequent reads from it will return its default value.
  public mutating func clearUserAppID() {self._userAppID = nil}

  public var uploads: [Clarifai_Api_Upload] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _userAppID: Clarifai_Api_UserAppIDSet? = nil
}

/// Stops or deletes multipart upload
public struct Clarifai_Api_DeleteUploadsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var userAppID: Clarifai_Api_UserAppIDSet {
    get {return _userAppID ?? Clarifai_Api_UserAppIDSet()}
    set {_userAppID = newValue}
  }
  /// Returns true if `userAppID` has been explicitly set.
  public var hasUserAppID: Bool {return self._userAppID != nil}
  /// Clears the value of `userAppID`. Subsequent reads from it will return its default value.
  public mutating func clearUserAppID() {self._userAppID = nil}

  public var ids: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _userAppID: Clarifai_Api_UserAppIDSet? = nil
}

public struct Clarifai_Api_ListUploadsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var userAppID: Clarifai_Api_UserAppIDSet {
    get {return _userAppID ?? Clarifai_Api_UserAppIDSet()}
    set {_userAppID = newValue}
  }
  /// Returns true if `userAppID` has been explicitly set.
  public var hasUserAppID: Bool {return self._userAppID != nil}
  /// Clears the value of `userAppID`. Subsequent reads from it will return its default value.
  public mutating func clearUserAppID() {self._userAppID = nil}

  /// (optional URL parameter) The page number. Pagination is used to split the results into chunks.
  /// Defaults to 1.
  public var page: UInt32 = 0

  /// (optional URL parameter) The number of results that will be contained in each page. Defaults
  /// to 128.
  public var perPage: UInt32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _userAppID: Clarifai_Api_UserAppIDSet? = nil
}

public struct Clarifai_Api_GetUploadRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var userAppID: Clarifai_Api_UserAppIDSet {
    get {return _userAppID ?? Clarifai_Api_UserAppIDSet()}
    set {_userAppID = newValue}
  }
  /// Returns true if `userAppID` has been explicitly set.
  public var hasUserAppID: Bool {return self._userAppID != nil}
  /// Clears the value of `userAppID`. Subsequent reads from it will return its default value.
  public mutating func clearUserAppID() {self._userAppID = nil}

  /// Upload ID
  public var uploadID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _userAppID: Clarifai_Api_UserAppIDSet? = nil
}

public struct Clarifai_Api_SingleUploadResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var status: Clarifai_Api_Status_Status {
    get {return _status ?? Clarifai_Api_Status_Status()}
    set {_status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  public var hasStatus: Bool {return self._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  public mutating func clearStatus() {self._status = nil}

  public var upload: Clarifai_Api_Upload {
    get {return _upload ?? Clarifai_Api_Upload()}
    set {_upload = newValue}
  }
  /// Returns true if `upload` has been explicitly set.
  public var hasUpload: Bool {return self._upload != nil}
  /// Clears the value of `upload`. Subsequent reads from it will return its default value.
  public mutating func clearUpload() {self._upload = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _status: Clarifai_Api_Status_Status? = nil
  fileprivate var _upload: Clarifai_Api_Upload? = nil
}

public struct Clarifai_Api_MultiUploadResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var status: Clarifai_Api_Status_Status {
    get {return _status ?? Clarifai_Api_Status_Status()}
    set {_status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  public var hasStatus: Bool {return self._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  public mutating func clearStatus() {self._status = nil}

  public var uploads: [Clarifai_Api_Upload] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _status: Clarifai_Api_Status_Status? = nil
}

/// Upload a part of a multipart upload.
/// Behaviour on completion depends on the endpoint that was used to initiate the upload.
public struct Clarifai_Api_PutUploadContentPartsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var userAppID: Clarifai_Api_UserAppIDSet {
    get {return _userAppID ?? Clarifai_Api_UserAppIDSet()}
    set {_userAppID = newValue}
  }
  /// Returns true if `userAppID` has been explicitly set.
  public var hasUserAppID: Bool {return self._userAppID != nil}
  /// Clears the value of `userAppID`. Subsequent reads from it will return its default value.
  public mutating func clearUserAppID() {self._userAppID = nil}

  public var uploadID: String = String()

  public var contentParts: [Clarifai_Api_UploadContentPart] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _userAppID: Clarifai_Api_UserAppIDSet? = nil
}

/// Initiates retrieval of inputs from cloud storage from a user provided data source.
/// Will create and return an inputs-add-job for tracking progress.
/// Archives will be extracted and their contents will be processed as inputs.
///
/// The cloud URL will be treated as a filter prefix. For example s3:/bucket/images_folder/abc will process
/// files in the images_folder beginning with abc or in a subfolder beginning with abc.
/// For example:
/// bucket/images_folder/abcImage.png
/// bucket/images_folder/abc-1/Data.zip
///
/// If given URL is for a private bucket or file, then credentials should be provided to access the bucket.
/// Credentials should include rights to list the objects in the bucket, except when pointed directly at a file archive,
/// in which case it only requires rights to access that particular file.
public struct Clarifai_Api_PostInputsDataSourcesRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var userAppID: Clarifai_Api_UserAppIDSet {
    get {return _userAppID ?? Clarifai_Api_UserAppIDSet()}
    set {_userAppID = newValue}
  }
  /// Returns true if `userAppID` has been explicitly set.
  public var hasUserAppID: Bool {return self._userAppID != nil}
  /// Clears the value of `userAppID`. Subsequent reads from it will return its default value.
  public mutating func clearUserAppID() {self._userAppID = nil}

  public var dataSources: [Clarifai_Api_InputsDataSource] = []

  /// If call back url is set, we will send a Post request to this endpoint with job status.
  public var callBackURL: String = String()

  /// Personal Access Token to the application to which inputs are added
  /// Deprecated: No need to send app_pat, it will be generated internally if not present
  public var appPat: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _userAppID: Clarifai_Api_UserAppIDSet? = nil
}

public struct Clarifai_Api_GetInputsExtractionJobRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var userAppID: Clarifai_Api_UserAppIDSet {
    get {return _userAppID ?? Clarifai_Api_UserAppIDSet()}
    set {_userAppID = newValue}
  }
  /// Returns true if `userAppID` has been explicitly set.
  public var hasUserAppID: Bool {return self._userAppID != nil}
  /// Clears the value of `userAppID`. Subsequent reads from it will return its default value.
  public mutating func clearUserAppID() {self._userAppID = nil}

  public var inputsExtractionJobID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _userAppID: Clarifai_Api_UserAppIDSet? = nil
}

public struct Clarifai_Api_ListInputsExtractionJobsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var userAppID: Clarifai_Api_UserAppIDSet {
    get {return _userAppID ?? Clarifai_Api_UserAppIDSet()}
    set {_userAppID = newValue}
  }
  /// Returns true if `userAppID` has been explicitly set.
  public var hasUserAppID: Bool {return self._userAppID != nil}
  /// Clears the value of `userAppID`. Subsequent reads from it will return its default value.
  public mutating func clearUserAppID() {self._userAppID = nil}

  /// (optional URL parameter) The page number. Pagination is used to split the results into chunks.
  /// Defaults to 1.
  public var page: UInt32 = 0

  /// (optional URL parameter) The number of results that will be contained in each page. Defaults
  /// to 128.
  public var perPage: UInt32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _userAppID: Clarifai_Api_UserAppIDSet? = nil
}

public struct Clarifai_Api_SingleInputsExtractionJobResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var status: Clarifai_Api_Status_Status {
    get {return _status ?? Clarifai_Api_Status_Status()}
    set {_status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  public var hasStatus: Bool {return self._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  public mutating func clearStatus() {self._status = nil}

  public var inputsExtractionJob: Clarifai_Api_InputsExtractionJob {
    get {return _inputsExtractionJob ?? Clarifai_Api_InputsExtractionJob()}
    set {_inputsExtractionJob = newValue}
  }
  /// Returns true if `inputsExtractionJob` has been explicitly set.
  public var hasInputsExtractionJob: Bool {return self._inputsExtractionJob != nil}
  /// Clears the value of `inputsExtractionJob`. Subsequent reads from it will return its default value.
  public mutating func clearInputsExtractionJob() {self._inputsExtractionJob = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _status: Clarifai_Api_Status_Status? = nil
  fileprivate var _inputsExtractionJob: Clarifai_Api_InputsExtractionJob? = nil
}

public struct Clarifai_Api_MultiInputsExtractionJobResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var status: Clarifai_Api_Status_Status {
    get {return _status ?? Clarifai_Api_Status_Status()}
    set {_status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  public var hasStatus: Bool {return self._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  public mutating func clearStatus() {self._status = nil}

  public var inputsExtractionJobs: [Clarifai_Api_InputsExtractionJob] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _status: Clarifai_Api_Status_Status? = nil
}

/// Cancel a list of extraction job ids
public struct Clarifai_Api_CancelInputsExtractionJobsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var userAppID: Clarifai_Api_UserAppIDSet {
    get {return _userAppID ?? Clarifai_Api_UserAppIDSet()}
    set {_userAppID = newValue}
  }
  /// Returns true if `userAppID` has been explicitly set.
  public var hasUserAppID: Bool {return self._userAppID != nil}
  /// Clears the value of `userAppID`. Subsequent reads from it will return its default value.
  public mutating func clearUserAppID() {self._userAppID = nil}

  /// List of extraction job ids to be cancelled
  public var ids: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _userAppID: Clarifai_Api_UserAppIDSet? = nil
}

/// Start uploading a file archive containing inputs.
/// Will create and return an inputs-add-job for tracking progress.
///
/// Associated inputs-add-job contains an upload id which should be completed through `PutUploadContentParts` endpoint.
/// Completing the upload will automatically begin unpacking the archive and uploading the contents as inputs.
public struct Clarifai_Api_PostInputsUploadsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var userAppID: Clarifai_Api_UserAppIDSet {
    get {return _userAppID ?? Clarifai_Api_UserAppIDSet()}
    set {_userAppID = newValue}
  }
  /// Returns true if `userAppID` has been explicitly set.
  public var hasUserAppID: Bool {return self._userAppID != nil}
  /// Clears the value of `userAppID`. Subsequent reads from it will return its default value.
  public mutating func clearUserAppID() {self._userAppID = nil}

  public var inputsUploads: [Clarifai_Api_InputsUpload] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _userAppID: Clarifai_Api_UserAppIDSet? = nil
}

/// GetRunnerRequest
public struct Clarifai_Api_GetRunnerRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var userAppID: Clarifai_Api_UserAppIDSet {
    get {return _userAppID ?? Clarifai_Api_UserAppIDSet()}
    set {_userAppID = newValue}
  }
  /// Returns true if `userAppID` has been explicitly set.
  public var hasUserAppID: Bool {return self._userAppID != nil}
  /// Clears the value of `userAppID`. Subsequent reads from it will return its default value.
  public mutating func clearUserAppID() {self._userAppID = nil}

  public var nodepoolID: String = String()

  public var runnerID: String = String()

  public var computeClusterID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _userAppID: Clarifai_Api_UserAppIDSet? = nil
}

/// ListRunnersRequest
public struct Clarifai_Api_ListRunnersRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var userAppID: Clarifai_Api_UserAppIDSet {
    get {return _userAppID ?? Clarifai_Api_UserAppIDSet()}
    set {_userAppID = newValue}
  }
  /// Returns true if `userAppID` has been explicitly set.
  public var hasUserAppID: Bool {return self._userAppID != nil}
  /// Clears the value of `userAppID`. Subsequent reads from it will return its default value.
  public mutating func clearUserAppID() {self._userAppID = nil}

  public var nodepoolID: String = String()

  /// (optional URL parameter) The page number. Pagination is used to split the results into chunks.
  /// Defaults to 1.
  public var page: UInt32 = 0

  /// (optional URL parameter) The number of results that will be contained in each page. Defaults
  /// to 128.
  public var perPage: UInt32 = 0

  public var computeClusterID: String = String()

  /// Only return runners whose replicas are >= min_replicas.
  public var minReplicas: UInt32 = 0

  /// (optional URL parameter) ModelVersion IDs. To list all runners for the model version
  public var modelVersionIds: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _userAppID: Clarifai_Api_UserAppIDSet? = nil
}

/// PostRunnersRequest
public struct Clarifai_Api_PostRunnersRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var userAppID: Clarifai_Api_UserAppIDSet {
    get {return _userAppID ?? Clarifai_Api_UserAppIDSet()}
    set {_userAppID = newValue}
  }
  /// Returns true if `userAppID` has been explicitly set.
  public var hasUserAppID: Bool {return self._userAppID != nil}
  /// Clears the value of `userAppID`. Subsequent reads from it will return its default value.
  public mutating func clearUserAppID() {self._userAppID = nil}

  public var nodepoolID: String = String()

  /// This allows you to create one or more runner by posting it to the API.
  public var runners: [Clarifai_Api_Runner] = []

  public var computeClusterID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _userAppID: Clarifai_Api_UserAppIDSet? = nil
}

/// PatchRunnersRequest
public struct Clarifai_Api_PatchRunnersRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var userAppID: Clarifai_Api_UserAppIDSet {
    get {return _userAppID ?? Clarifai_Api_UserAppIDSet()}
    set {_userAppID = newValue}
  }
  /// Returns true if `userAppID` has been explicitly set.
  public var hasUserAppID: Bool {return self._userAppID != nil}
  /// Clears the value of `userAppID`. Subsequent reads from it will return its default value.
  public mutating func clearUserAppID() {self._userAppID = nil}

  public var nodepoolID: String = String()

  /// This allows you to create one or more runner by posting it to the API.
  public var runners: [Clarifai_Api_Runner] = []

  public var computeClusterID: String = String()

  /// The action to perform on the patched objects
  /// For now actions 'merge', 'overwrite', and 'remove' are supported
  public var action: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _userAppID: Clarifai_Api_UserAppIDSet? = nil
}

/// Request to delete several things by the list of ids.
public struct Clarifai_Api_DeleteRunnersRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var userAppID: Clarifai_Api_UserAppIDSet {
    get {return _userAppID ?? Clarifai_Api_UserAppIDSet()}
    set {_userAppID = newValue}
  }
  /// Returns true if `userAppID` has been explicitly set.
  public var hasUserAppID: Bool {return self._userAppID != nil}
  /// Clears the value of `userAppID`. Subsequent reads from it will return its default value.
  public mutating func clearUserAppID() {self._userAppID = nil}

  public var nodepoolID: String = String()

  public var ids: [String] = []

  public var computeClusterID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _userAppID: Clarifai_Api_UserAppIDSet? = nil
}

/// SingleRunnerResponse
public struct Clarifai_Api_SingleRunnerResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var status: Clarifai_Api_Status_Status {
    get {return _status ?? Clarifai_Api_Status_Status()}
    set {_status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  public var hasStatus: Bool {return self._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  public mutating func clearStatus() {self._status = nil}

  public var runner: Clarifai_Api_Runner {
    get {return _runner ?? Clarifai_Api_Runner()}
    set {_runner = newValue}
  }
  /// Returns true if `runner` has been explicitly set.
  public var hasRunner: Bool {return self._runner != nil}
  /// Clears the value of `runner`. Subsequent reads from it will return its default value.
  public mutating func clearRunner() {self._runner = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _status: Clarifai_Api_Status_Status? = nil
  fileprivate var _runner: Clarifai_Api_Runner? = nil
}

/// MultiRunnerResponse
public struct Clarifai_Api_MultiRunnerResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var status: Clarifai_Api_Status_Status {
    get {return _status ?? Clarifai_Api_Status_Status()}
    set {_status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  public var hasStatus: Bool {return self._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  public mutating func clearStatus() {self._status = nil}

  public var runners: [Clarifai_Api_Runner] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _status: Clarifai_Api_Status_Status? = nil
}

public struct Clarifai_Api_ListRunnerItemsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var userAppID: Clarifai_Api_UserAppIDSet {
    get {return _userAppID ?? Clarifai_Api_UserAppIDSet()}
    set {_userAppID = newValue}
  }
  /// Returns true if `userAppID` has been explicitly set.
  public var hasUserAppID: Bool {return self._userAppID != nil}
  /// Clears the value of `userAppID`. Subsequent reads from it will return its default value.
  public mutating func clearUserAppID() {self._userAppID = nil}

  public var nodepoolID: String = String()

  public var runnerID: String = String()

  public var computeClusterID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _userAppID: Clarifai_Api_UserAppIDSet? = nil
}

/// PostRunnerItemOutputsRequest
/// This is the message that runners send to the API to communicate.
/// At the end of the request it will have the RunnerItemOutput filled in
/// with results of the workload the runner is processing. Other messages
/// from the runner use this same proto to communicate over to the API
/// and do handshakes.
public struct Clarifai_Api_PostRunnerItemOutputsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var userAppID: Clarifai_Api_UserAppIDSet {
    get {return _storage._userAppID ?? Clarifai_Api_UserAppIDSet()}
    set {_uniqueStorage()._userAppID = newValue}
  }
  /// Returns true if `userAppID` has been explicitly set.
  public var hasUserAppID: Bool {return _storage._userAppID != nil}
  /// Clears the value of `userAppID`. Subsequent reads from it will return its default value.
  public mutating func clearUserAppID() {_uniqueStorage()._userAppID = nil}

  /// The particular nodepool that runner belongs to
  public var nodepoolID: String {
    get {return _storage._nodepoolID}
    set {_uniqueStorage()._nodepoolID = newValue}
  }

  /// The particular runner that processed the work.
  public var runnerID: String {
    get {return _storage._runnerID}
    set {_uniqueStorage()._runnerID = newValue}
  }

  /// The particular item of work processed.
  public var runnerItemID: String {
    get {return _storage._runnerItemID}
    set {_uniqueStorage()._runnerItemID = newValue}
  }

  /// This allows you to create one or more runner by posting it to the API.
  public var runnerItemOutputs: [Clarifai_Api_RunnerItemOutput] {
    get {return _storage._runnerItemOutputs}
    set {_uniqueStorage()._runnerItemOutputs = newValue}
  }

  /// This request has a status so that it can communicate to the API from runners and
  /// communicate status, errors, etc. This is on the request since runners operate
  /// in a reverse protocol. This status is also used to initiate the
  /// ProcessRunnerItems request with RUNNER_STREAM_START code.
  public var status: Clarifai_Api_Status_Status {
    get {return _storage._status ?? Clarifai_Api_Status_Status()}
    set {_uniqueStorage()._status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  public var hasStatus: Bool {return _storage._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  public mutating func clearStatus() {_uniqueStorage()._status = nil}

  /// A unique ID to represent the runner. This may be tied to an underlying compute instance
  /// information or just an UUID.
  public var runnerReplicaID: String {
    get {return _storage._runnerReplicaID}
    set {_uniqueStorage()._runnerReplicaID = newValue}
  }

  public var computeClusterID: String {
    get {return _storage._computeClusterID}
    set {_uniqueStorage()._computeClusterID = newValue}
  }

  /// Used by agent runners to specify their cloud provider.
  public var cloudProviderID: String {
    get {return _storage._cloudProviderID}
    set {_uniqueStorage()._cloudProviderID = newValue}
  }

  /// Used by agent runners to specify their region.
  public var region: String {
    get {return _storage._region}
    set {_uniqueStorage()._region = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// SyncStateRequest is a message that the control plane sends to the agent runner to notify it of
/// changes to objects.
public struct Clarifai_Api_SyncStateRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The operation that was performed: create, update, delete.
  public var operationType: String = String()

  /// Objects that were affected.
  public var computeClusters: [Clarifai_Api_ComputeCluster] = []

  public var nodepools: [Clarifai_Api_Nodepool] = []

  public var runners: [Clarifai_Api_Runner] = []

  public var pipelineVersionRuns: [Clarifai_Api_PipelineVersionRun] = []

  public var secrets: [Clarifai_Api_Secret] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// MultiRunnerItemResponse
public struct Clarifai_Api_MultiRunnerItemResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var status: Clarifai_Api_Status_Status {
    get {return _status ?? Clarifai_Api_Status_Status()}
    set {_status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  public var hasStatus: Bool {return self._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  public mutating func clearStatus() {self._status = nil}

  public var runnerItems: [Clarifai_Api_RunnerItem] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _status: Clarifai_Api_Status_Status? = nil
}

/// This is a unit of work for a runner to process. This comes from the API
/// in the MultiRunnerItemResponse and contains the user's requests
/// to process.
public struct Clarifai_Api_RunnerItem {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// A UUID hash for this work item.
  public var id: String {
    get {return _storage._id}
    set {_uniqueStorage()._id = newValue}
  }

  /// A description of the work to be done in case needed for UIs.
  public var description_p: String {
    get {return _storage._description_p}
    set {_uniqueStorage()._description_p = newValue}
  }

  /// Information on how to process the given RunnerItem.
  public var processingInfo: Clarifai_Api_ProcessingInfo {
    get {return _storage._processingInfo ?? Clarifai_Api_ProcessingInfo()}
    set {_uniqueStorage()._processingInfo = newValue}
  }
  /// Returns true if `processingInfo` has been explicitly set.
  public var hasProcessingInfo: Bool {return _storage._processingInfo != nil}
  /// Clears the value of `processingInfo`. Subsequent reads from it will return its default value.
  public mutating func clearProcessingInfo() {_uniqueStorage()._processingInfo = nil}

  public var request: OneOf_Request? {
    get {return _storage._request}
    set {_uniqueStorage()._request = newValue}
  }

  /// Model prediction request from a user.
  public var postModelOutputsRequest: Clarifai_Api_PostModelOutputsRequest {
    get {
      if case .postModelOutputsRequest(let v)? = _storage._request {return v}
      return Clarifai_Api_PostModelOutputsRequest()
    }
    set {_uniqueStorage()._request = .postModelOutputsRequest(newValue)}
  }

  /// Agent sync request from control plane.
  public var syncStateRequest: Clarifai_Api_SyncStateRequest {
    get {
      if case .syncStateRequest(let v)? = _storage._request {return v}
      return Clarifai_Api_SyncStateRequest()
    }
    set {_uniqueStorage()._request = .syncStateRequest(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Request: Equatable {
    /// Model prediction request from a user.
    case postModelOutputsRequest(Clarifai_Api_PostModelOutputsRequest)
    /// Agent sync request from control plane.
    case syncStateRequest(Clarifai_Api_SyncStateRequest)

  #if !swift(>=4.1)
    public static func ==(lhs: Clarifai_Api_RunnerItem.OneOf_Request, rhs: Clarifai_Api_RunnerItem.OneOf_Request) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.postModelOutputsRequest, .postModelOutputsRequest): return {
        guard case .postModelOutputsRequest(let l) = lhs, case .postModelOutputsRequest(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.syncStateRequest, .syncStateRequest): return {
        guard case .syncStateRequest(let l) = lhs, case .syncStateRequest(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// This contains the response of the user's request once processing is done.
/// The runner should fill in the matching output to the RunnerItem.request
/// oneof field. This is sent to the API within PostRunnerItemOutputsRequest
public struct Clarifai_Api_RunnerItemOutput {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var response: Clarifai_Api_RunnerItemOutput.OneOf_Response? = nil

  /// The output of a model prediction request.
  public var multiOutputResponse: Clarifai_Api_MultiOutputResponse {
    get {
      if case .multiOutputResponse(let v)? = response {return v}
      return Clarifai_Api_MultiOutputResponse()
    }
    set {response = .multiOutputResponse(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Response: Equatable {
    /// The output of a model prediction request.
    case multiOutputResponse(Clarifai_Api_MultiOutputResponse)

  #if !swift(>=4.1)
    public static func ==(lhs: Clarifai_Api_RunnerItemOutput.OneOf_Response, rhs: Clarifai_Api_RunnerItemOutput.OneOf_Response) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.multiOutputResponse, .multiOutputResponse): return {
        guard case .multiOutputResponse(let l) = lhs, case .multiOutputResponse(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      }
    }
  #endif
  }

  public init() {}
}

public struct Clarifai_Api_MultiRunnerItemOutputResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var status: Clarifai_Api_Status_Status {
    get {return _status ?? Clarifai_Api_Status_Status()}
    set {_status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  public var hasStatus: Bool {return self._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  public mutating func clearStatus() {self._status = nil}

  public var runnerItemOutputs: [Clarifai_Api_RunnerItemOutput] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _status: Clarifai_Api_Status_Status? = nil
}

/// Get the estimated training time for a model version
public struct Clarifai_Api_PostModelVersionsTrainingTimeEstimateRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var userAppID: Clarifai_Api_UserAppIDSet {
    get {return _userAppID ?? Clarifai_Api_UserAppIDSet()}
    set {_userAppID = newValue}
  }
  /// Returns true if `userAppID` has been explicitly set.
  public var hasUserAppID: Bool {return self._userAppID != nil}
  /// Clears the value of `userAppID`. Subsequent reads from it will return its default value.
  public mutating func clearUserAppID() {self._userAppID = nil}

  public var modelID: String = String()

  public var modelVersions: [Clarifai_Api_ModelVersion] = []

  public var estimatedInputCount: UInt64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _userAppID: Clarifai_Api_UserAppIDSet? = nil
}

/// Estimated training time in seconds
public struct Clarifai_Api_MultiTrainingTimeEstimateResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var status: Clarifai_Api_Status_Status {
    get {return _status ?? Clarifai_Api_Status_Status()}
    set {_status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  public var hasStatus: Bool {return self._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  public mutating func clearStatus() {self._status = nil}

  public var trainingTimeEstimates: [SwiftProtobuf.Google_Protobuf_Duration] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _status: Clarifai_Api_Status_Status? = nil
}

/// List Cloud Providers
public struct Clarifai_Api_ListCloudProvidersRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Clarifai_Api_MultiCloudProviderResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var status: Clarifai_Api_Status_Status {
    get {return _status ?? Clarifai_Api_Status_Status()}
    set {_status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  public var hasStatus: Bool {return self._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  public mutating func clearStatus() {self._status = nil}

  public var cloudProviders: [Clarifai_Api_CloudProvider] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _status: Clarifai_Api_Status_Status? = nil
}

/// List CloudProvider Regions
public struct Clarifai_Api_ListCloudRegionsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The cloud provider to list compute clusters for.
  public var cloudProvider: Clarifai_Api_CloudProvider {
    get {return _cloudProvider ?? Clarifai_Api_CloudProvider()}
    set {_cloudProvider = newValue}
  }
  /// Returns true if `cloudProvider` has been explicitly set.
  public var hasCloudProvider: Bool {return self._cloudProvider != nil}
  /// Clears the value of `cloudProvider`. Subsequent reads from it will return its default value.
  public mutating func clearCloudProvider() {self._cloudProvider = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _cloudProvider: Clarifai_Api_CloudProvider? = nil
}

public struct Clarifai_Api_MultiCloudRegionResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var status: Clarifai_Api_Status_Status {
    get {return _status ?? Clarifai_Api_Status_Status()}
    set {_status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  public var hasStatus: Bool {return self._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  public mutating func clearStatus() {self._status = nil}

  public var regions: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _status: Clarifai_Api_Status_Status? = nil
}

/// List InstanceTypes
public struct Clarifai_Api_ListInstanceTypesRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The cloud provider to list compute clusters for.
  public var cloudProvider: Clarifai_Api_CloudProvider {
    get {return _cloudProvider ?? Clarifai_Api_CloudProvider()}
    set {_cloudProvider = newValue}
  }
  /// Returns true if `cloudProvider` has been explicitly set.
  public var hasCloudProvider: Bool {return self._cloudProvider != nil}
  /// Clears the value of `cloudProvider`. Subsequent reads from it will return its default value.
  public mutating func clearCloudProvider() {self._cloudProvider = nil}

  /// The region to list for so when there are multiple regions we get only the clusters
  /// that are supposed to be up in that region.
  public var region: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _cloudProvider: Clarifai_Api_CloudProvider? = nil
}

public struct Clarifai_Api_MultiInstanceTypeResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var status: Clarifai_Api_Status_Status {
    get {return _status ?? Clarifai_Api_Status_Status()}
    set {_status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  public var hasStatus: Bool {return self._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  public mutating func clearStatus() {self._status = nil}

  public var instanceTypes: [Clarifai_Api_InstanceType] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _status: Clarifai_Api_Status_Status? = nil
}

/// ComputeCLuster CRUD requests and responses
public struct Clarifai_Api_GetComputeClusterRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Only the user_id is used from this.
  public var userAppID: Clarifai_Api_UserAppIDSet {
    get {return _userAppID ?? Clarifai_Api_UserAppIDSet()}
    set {_userAppID = newValue}
  }
  /// Returns true if `userAppID` has been explicitly set.
  public var hasUserAppID: Bool {return self._userAppID != nil}
  /// Clears the value of `userAppID`. Subsequent reads from it will return its default value.
  public mutating func clearUserAppID() {self._userAppID = nil}

  public var computeClusterID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _userAppID: Clarifai_Api_UserAppIDSet? = nil
}

public struct Clarifai_Api_ListComputeClustersRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Only the user_id is used from this.
  public var userAppID: Clarifai_Api_UserAppIDSet {
    get {return _userAppID ?? Clarifai_Api_UserAppIDSet()}
    set {_userAppID = newValue}
  }
  /// Returns true if `userAppID` has been explicitly set.
  public var hasUserAppID: Bool {return self._userAppID != nil}
  /// Clears the value of `userAppID`. Subsequent reads from it will return its default value.
  public mutating func clearUserAppID() {self._userAppID = nil}

  /// (optional URL parameter) The page number. Pagination is used to split the results into chunks.
  /// Defaults to 1.
  public var page: UInt32 = 0

  /// (optional URL parameter) The number of results that will be contained in each page. Defaults
  /// to 128.
  public var perPage: UInt32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _userAppID: Clarifai_Api_UserAppIDSet? = nil
}

public struct Clarifai_Api_PostComputeClustersRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Only the user_id is used from this.
  public var userAppID: Clarifai_Api_UserAppIDSet {
    get {return _userAppID ?? Clarifai_Api_UserAppIDSet()}
    set {_userAppID = newValue}
  }
  /// Returns true if `userAppID` has been explicitly set.
  public var hasUserAppID: Bool {return self._userAppID != nil}
  /// Clears the value of `userAppID`. Subsequent reads from it will return its default value.
  public mutating func clearUserAppID() {self._userAppID = nil}

  /// This allows you to create one or more compute_clusters by posting it to the API.
  public var computeClusters: [Clarifai_Api_ComputeCluster] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _userAppID: Clarifai_Api_UserAppIDSet? = nil
}

public struct Clarifai_Api_DeleteComputeClustersRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Only the user_id is used from this.
  public var userAppID: Clarifai_Api_UserAppIDSet {
    get {return _userAppID ?? Clarifai_Api_UserAppIDSet()}
    set {_userAppID = newValue}
  }
  /// Returns true if `userAppID` has been explicitly set.
  public var hasUserAppID: Bool {return self._userAppID != nil}
  /// Clears the value of `userAppID`. Subsequent reads from it will return its default value.
  public mutating func clearUserAppID() {self._userAppID = nil}

  /// List of compute cluster ids to be deleted
  public var ids: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _userAppID: Clarifai_Api_UserAppIDSet? = nil
}

public struct Clarifai_Api_SingleComputeClusterResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var status: Clarifai_Api_Status_Status {
    get {return _status ?? Clarifai_Api_Status_Status()}
    set {_status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  public var hasStatus: Bool {return self._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  public mutating func clearStatus() {self._status = nil}

  public var computeCluster: Clarifai_Api_ComputeCluster {
    get {return _computeCluster ?? Clarifai_Api_ComputeCluster()}
    set {_computeCluster = newValue}
  }
  /// Returns true if `computeCluster` has been explicitly set.
  public var hasComputeCluster: Bool {return self._computeCluster != nil}
  /// Clears the value of `computeCluster`. Subsequent reads from it will return its default value.
  public mutating func clearComputeCluster() {self._computeCluster = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _status: Clarifai_Api_Status_Status? = nil
  fileprivate var _computeCluster: Clarifai_Api_ComputeCluster? = nil
}

public struct Clarifai_Api_MultiComputeClusterResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var status: Clarifai_Api_Status_Status {
    get {return _status ?? Clarifai_Api_Status_Status()}
    set {_status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  public var hasStatus: Bool {return self._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  public mutating func clearStatus() {self._status = nil}

  public var computeClusters: [Clarifai_Api_ComputeCluster] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _status: Clarifai_Api_Status_Status? = nil
}

/// TODO(zeiler): these might not be 100% correct and will be updated as we uncomment the endpoints.
/// Nodepool CRUD requests and responses
public struct Clarifai_Api_GetNodepoolRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var userAppID: Clarifai_Api_UserAppIDSet {
    get {return _userAppID ?? Clarifai_Api_UserAppIDSet()}
    set {_userAppID = newValue}
  }
  /// Returns true if `userAppID` has been explicitly set.
  public var hasUserAppID: Bool {return self._userAppID != nil}
  /// Clears the value of `userAppID`. Subsequent reads from it will return its default value.
  public mutating func clearUserAppID() {self._userAppID = nil}

  public var computeClusterID: String = String()

  public var nodepoolID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _userAppID: Clarifai_Api_UserAppIDSet? = nil
}

public struct Clarifai_Api_ListNodepoolsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var userAppID: Clarifai_Api_UserAppIDSet {
    get {return _userAppID ?? Clarifai_Api_UserAppIDSet()}
    set {_userAppID = newValue}
  }
  /// Returns true if `userAppID` has been explicitly set.
  public var hasUserAppID: Bool {return self._userAppID != nil}
  /// Clears the value of `userAppID`. Subsequent reads from it will return its default value.
  public mutating func clearUserAppID() {self._userAppID = nil}

  public var computeClusterID: String = String()

  /// (optional URL parameter) The page number. Pagination is used to split the results into chunks.
  /// Defaults to 1.
  public var page: UInt32 = 0

  /// (optional URL parameter) The number of results that will be contained in each page. Defaults
  /// to 128.
  public var perPage: UInt32 = 0

  /// Only return nodepools that are actively being used (having runners with
  /// replicas >= threshold and pipeline versions scheduled to run)
  public var activeUsage: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _userAppID: Clarifai_Api_UserAppIDSet? = nil
}

public struct Clarifai_Api_PostNodepoolsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Only the user_id is used from this.
  public var userAppID: Clarifai_Api_UserAppIDSet {
    get {return _userAppID ?? Clarifai_Api_UserAppIDSet()}
    set {_userAppID = newValue}
  }
  /// Returns true if `userAppID` has been explicitly set.
  public var hasUserAppID: Bool {return self._userAppID != nil}
  /// Clears the value of `userAppID`. Subsequent reads from it will return its default value.
  public mutating func clearUserAppID() {self._userAppID = nil}

  public var computeClusterID: String = String()

  /// This allows you to create one or more nodepools by posting it to the API.
  public var nodepools: [Clarifai_Api_Nodepool] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _userAppID: Clarifai_Api_UserAppIDSet? = nil
}

/// PatchNodepoolsRequest
public struct Clarifai_Api_PatchNodepoolsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var userAppID: Clarifai_Api_UserAppIDSet {
    get {return _userAppID ?? Clarifai_Api_UserAppIDSet()}
    set {_userAppID = newValue}
  }
  /// Returns true if `userAppID` has been explicitly set.
  public var hasUserAppID: Bool {return self._userAppID != nil}
  /// Clears the value of `userAppID`. Subsequent reads from it will return its default value.
  public mutating func clearUserAppID() {self._userAppID = nil}

  public var computeClusterID: String = String()

  public var nodepools: [Clarifai_Api_Nodepool] = []

  /// The action to perform on the patched objects
  /// For now actions 'merge', 'overwrite', and 'remove' are supported
  public var action: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _userAppID: Clarifai_Api_UserAppIDSet? = nil
}

public struct Clarifai_Api_DeleteNodepoolsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Only the user_id is used from this.
  public var userAppID: Clarifai_Api_UserAppIDSet {
    get {return _userAppID ?? Clarifai_Api_UserAppIDSet()}
    set {_userAppID = newValue}
  }
  /// Returns true if `userAppID` has been explicitly set.
  public var hasUserAppID: Bool {return self._userAppID != nil}
  /// Clears the value of `userAppID`. Subsequent reads from it will return its default value.
  public mutating func clearUserAppID() {self._userAppID = nil}

  public var computeClusterID: String = String()

  /// List of nodepool ids to be deleted
  public var ids: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _userAppID: Clarifai_Api_UserAppIDSet? = nil
}

public struct Clarifai_Api_SingleNodepoolResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var status: Clarifai_Api_Status_Status {
    get {return _storage._status ?? Clarifai_Api_Status_Status()}
    set {_uniqueStorage()._status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  public var hasStatus: Bool {return _storage._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  public mutating func clearStatus() {_uniqueStorage()._status = nil}

  public var nodepool: Clarifai_Api_Nodepool {
    get {return _storage._nodepool ?? Clarifai_Api_Nodepool()}
    set {_uniqueStorage()._nodepool = newValue}
  }
  /// Returns true if `nodepool` has been explicitly set.
  public var hasNodepool: Bool {return _storage._nodepool != nil}
  /// Clears the value of `nodepool`. Subsequent reads from it will return its default value.
  public mutating func clearNodepool() {_uniqueStorage()._nodepool = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Clarifai_Api_MultiNodepoolResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var status: Clarifai_Api_Status_Status {
    get {return _status ?? Clarifai_Api_Status_Status()}
    set {_status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  public var hasStatus: Bool {return self._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  public mutating func clearStatus() {self._status = nil}

  public var nodepools: [Clarifai_Api_Nodepool] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _status: Clarifai_Api_Status_Status? = nil
}

/// Deployments CRUD requests and responses
public struct Clarifai_Api_GetDeploymentRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var userAppID: Clarifai_Api_UserAppIDSet {
    get {return _userAppID ?? Clarifai_Api_UserAppIDSet()}
    set {_userAppID = newValue}
  }
  /// Returns true if `userAppID` has been explicitly set.
  public var hasUserAppID: Bool {return self._userAppID != nil}
  /// Clears the value of `userAppID`. Subsequent reads from it will return its default value.
  public mutating func clearUserAppID() {self._userAppID = nil}

  public var deploymentID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _userAppID: Clarifai_Api_UserAppIDSet? = nil
}

public struct Clarifai_Api_ListDeploymentsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var userAppID: Clarifai_Api_UserAppIDSet {
    get {return _userAppID ?? Clarifai_Api_UserAppIDSet()}
    set {_userAppID = newValue}
  }
  /// Returns true if `userAppID` has been explicitly set.
  public var hasUserAppID: Bool {return self._userAppID != nil}
  /// Clears the value of `userAppID`. Subsequent reads from it will return its default value.
  public mutating func clearUserAppID() {self._userAppID = nil}

  /// (optional URL parameter) Nodepool ID. To list all deployed workers in a Nodepool
  public var nodepoolID: String = String()

  /// (optional URL parameter) The page number. Pagination is used to split the results into chunks.
  /// Defaults to 1.
  public var page: UInt32 = 0

  /// (optional URL parameter) The number of results that will be contained in each page. Defaults
  /// to 128.
  public var perPage: UInt32 = 0

  /// (optional URL parameter) ModelVersion IDs. To list all deployments for the model version
  public var modelVersionIds: [String] = []

  /// (optional URL parameter) WorkflowVersion IDs. To list all deployments for the workflow version
  public var workflowVersionIds: [String] = []

  /// (optional URL parameter) ComputeCluster ID. To list all deployed workers in a ComputeCluster
  public var computeClusterID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _userAppID: Clarifai_Api_UserAppIDSet? = nil
}

public struct Clarifai_Api_PostDeploymentsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Only the user_id is used from this.
  public var userAppID: Clarifai_Api_UserAppIDSet {
    get {return _userAppID ?? Clarifai_Api_UserAppIDSet()}
    set {_userAppID = newValue}
  }
  /// Returns true if `userAppID` has been explicitly set.
  public var hasUserAppID: Bool {return self._userAppID != nil}
  /// Clears the value of `userAppID`. Subsequent reads from it will return its default value.
  public mutating func clearUserAppID() {self._userAppID = nil}

  /// This allows you to create one or more deployments by posting it to the API.
  public var deployments: [Clarifai_Api_Deployment] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _userAppID: Clarifai_Api_UserAppIDSet? = nil
}

public struct Clarifai_Api_DeleteDeploymentsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Only the user_id is used from this.
  public var userAppID: Clarifai_Api_UserAppIDSet {
    get {return _userAppID ?? Clarifai_Api_UserAppIDSet()}
    set {_userAppID = newValue}
  }
  /// Returns true if `userAppID` has been explicitly set.
  public var hasUserAppID: Bool {return self._userAppID != nil}
  /// Clears the value of `userAppID`. Subsequent reads from it will return its default value.
  public mutating func clearUserAppID() {self._userAppID = nil}

  /// List of deployment ids to be deleted
  public var ids: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _userAppID: Clarifai_Api_UserAppIDSet? = nil
}

public struct Clarifai_Api_PostAuditLogSearchesRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Only the user_id is used from this.
  public var userAppID: Clarifai_Api_UserAppIDSet {
    get {return _userAppID ?? Clarifai_Api_UserAppIDSet()}
    set {_userAppID = newValue}
  }
  /// Returns true if `userAppID` has been explicitly set.
  public var hasUserAppID: Bool {return self._userAppID != nil}
  /// Clears the value of `userAppID`. Subsequent reads from it will return its default value.
  public mutating func clearUserAppID() {self._userAppID = nil}

  public var query: Clarifai_Api_AuditLogQuery {
    get {return _query ?? Clarifai_Api_AuditLogQuery()}
    set {_query = newValue}
  }
  /// Returns true if `query` has been explicitly set.
  public var hasQuery: Bool {return self._query != nil}
  /// Clears the value of `query`. Subsequent reads from it will return its default value.
  public mutating func clearQuery() {self._query = nil}

  /// Sorting options:
  /// Whether to sort by timestamp in ascending order. If false, will order in descending order.
  public var sortAscending: Bool = false

  public var pagination: Clarifai_Api_Pagination {
    get {return _pagination ?? Clarifai_Api_Pagination()}
    set {_pagination = newValue}
  }
  /// Returns true if `pagination` has been explicitly set.
  public var hasPagination: Bool {return self._pagination != nil}
  /// Clears the value of `pagination`. Subsequent reads from it will return its default value.
  public mutating func clearPagination() {self._pagination = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _userAppID: Clarifai_Api_UserAppIDSet? = nil
  fileprivate var _query: Clarifai_Api_AuditLogQuery? = nil
  fileprivate var _pagination: Clarifai_Api_Pagination? = nil
}

public struct Clarifai_Api_MultiAuditLogEntryResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var status: Clarifai_Api_Status_Status {
    get {return _status ?? Clarifai_Api_Status_Status()}
    set {_status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  public var hasStatus: Bool {return self._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  public mutating func clearStatus() {self._status = nil}

  public var entries: [Clarifai_Api_AuditLogEntry] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _status: Clarifai_Api_Status_Status? = nil
}

public struct Clarifai_Api_PatchDeploymentsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Only the user_id is used from this.
  public var userAppID: Clarifai_Api_UserAppIDSet {
    get {return _userAppID ?? Clarifai_Api_UserAppIDSet()}
    set {_userAppID = newValue}
  }
  /// Returns true if `userAppID` has been explicitly set.
  public var hasUserAppID: Bool {return self._userAppID != nil}
  /// Clears the value of `userAppID`. Subsequent reads from it will return its default value.
  public mutating func clearUserAppID() {self._userAppID = nil}

  public var deployments: [Clarifai_Api_Deployment] = []

  /// The action to perform on the patched objects
  /// For now actions 'merge', 'overwrite', and 'remove' are supported
  public var action: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _userAppID: Clarifai_Api_UserAppIDSet? = nil
}

public struct Clarifai_Api_SingleDeploymentResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var status: Clarifai_Api_Status_Status {
    get {return _status ?? Clarifai_Api_Status_Status()}
    set {_status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  public var hasStatus: Bool {return self._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  public mutating func clearStatus() {self._status = nil}

  public var deployment: Clarifai_Api_Deployment {
    get {return _deployment ?? Clarifai_Api_Deployment()}
    set {_deployment = newValue}
  }
  /// Returns true if `deployment` has been explicitly set.
  public var hasDeployment: Bool {return self._deployment != nil}
  /// Clears the value of `deployment`. Subsequent reads from it will return its default value.
  public mutating func clearDeployment() {self._deployment = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _status: Clarifai_Api_Status_Status? = nil
  fileprivate var _deployment: Clarifai_Api_Deployment? = nil
}

public struct Clarifai_Api_MultiDeploymentResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var status: Clarifai_Api_Status_Status {
    get {return _status ?? Clarifai_Api_Status_Status()}
    set {_status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  public var hasStatus: Bool {return self._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  public mutating func clearStatus() {self._status = nil}

  public var deployments: [Clarifai_Api_Deployment] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _status: Clarifai_Api_Status_Status? = nil
}

public struct Clarifai_Api_ListWorkflowEvaluationTemplatesRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Clarifai_Api_MultiWorkflowEvaluationTemplateResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var status: Clarifai_Api_Status_Status {
    get {return _status ?? Clarifai_Api_Status_Status()}
    set {_status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  public var hasStatus: Bool {return self._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  public mutating func clearStatus() {self._status = nil}

  public var workflowVersionEvaluationTemplates: [Clarifai_Api_WorkflowVersionEvaluationTemplate] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _status: Clarifai_Api_Status_Status? = nil
}

public struct Clarifai_Api_PostWorkflowVersionEvaluationsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var userAppID: Clarifai_Api_UserAppIDSet {
    get {return _userAppID ?? Clarifai_Api_UserAppIDSet()}
    set {_userAppID = newValue}
  }
  /// Returns true if `userAppID` has been explicitly set.
  public var hasUserAppID: Bool {return self._userAppID != nil}
  /// Clears the value of `userAppID`. Subsequent reads from it will return its default value.
  public mutating func clearUserAppID() {self._userAppID = nil}

  public var workflowID: String = String()

  public var workflowVersionID: String = String()

  /// ########## Supported fields ##########
  /// - ground_truth_dataset_version.app_id
  /// - ground_truth_dataset_version.dataset_id
  /// - ground_truth_dataset_version.id
  /// - id
  /// - target_node_id
  /// - workflow_version_evaluation_template.id
  public var workflowVersionEvaluations: [Clarifai_Api_WorkflowVersionEvaluation] = []

  public var runnerSelectors: [Clarifai_Api_RunnerSelector] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _userAppID: Clarifai_Api_UserAppIDSet? = nil
}

public struct Clarifai_Api_PatchWorkflowVersionEvaluationsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var userAppID: Clarifai_Api_UserAppIDSet {
    get {return _userAppID ?? Clarifai_Api_UserAppIDSet()}
    set {_userAppID = newValue}
  }
  /// Returns true if `userAppID` has been explicitly set.
  public var hasUserAppID: Bool {return self._userAppID != nil}
  /// Clears the value of `userAppID`. Subsequent reads from it will return its default value.
  public mutating func clearUserAppID() {self._userAppID = nil}

  public var workflowID: String = String()

  public var workflowVersionID: String = String()

  /// ########## Supported fields ##########
  /// - id
  /// - predictions_dataset_version.dataset_id
  /// - predictions_dataset_version.id
  /// - status.code
  /// - status.details
  /// - workflow_evaluation_result.summary.evaluation_metric_values[].evaluation_metric_id
  /// - workflow_evaluation_result.summary.evaluation_metric_values[].explanation
  /// - workflow_evaluation_result.summary.evaluation_metric_values[].metric_value.float_value
  /// - workflow_evaluation_result.summary.evaluation_metric_values[].metric_value.int_value
  /// - workflow_evaluation_result.summary.evaluation_metric_values[].metric_value.string_value
  /// - workflow_evaluation_result.summary.evaluation_metric_values[].per_concept_values
  public var workflowVersionEvaluations: [Clarifai_Api_WorkflowVersionEvaluation] = []

  /// only overwrite supported
  public var action: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _userAppID: Clarifai_Api_UserAppIDSet? = nil
}

public struct Clarifai_Api_MultiWorkflowVersionEvaluationResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var status: Clarifai_Api_Status_Status {
    get {return _status ?? Clarifai_Api_Status_Status()}
    set {_status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  public var hasStatus: Bool {return self._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  public mutating func clearStatus() {self._status = nil}

  public var workflowVersionEvaluations: [Clarifai_Api_WorkflowVersionEvaluation] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _status: Clarifai_Api_Status_Status? = nil
}

public struct Clarifai_Api_SingleWorkflowVersionEvaluationResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var status: Clarifai_Api_Status_Status {
    get {return _status ?? Clarifai_Api_Status_Status()}
    set {_status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  public var hasStatus: Bool {return self._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  public mutating func clearStatus() {self._status = nil}

  public var workflowVersionEvaluation: Clarifai_Api_WorkflowVersionEvaluation {
    get {return _workflowVersionEvaluation ?? Clarifai_Api_WorkflowVersionEvaluation()}
    set {_workflowVersionEvaluation = newValue}
  }
  /// Returns true if `workflowVersionEvaluation` has been explicitly set.
  public var hasWorkflowVersionEvaluation: Bool {return self._workflowVersionEvaluation != nil}
  /// Clears the value of `workflowVersionEvaluation`. Subsequent reads from it will return its default value.
  public mutating func clearWorkflowVersionEvaluation() {self._workflowVersionEvaluation = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _status: Clarifai_Api_Status_Status? = nil
  fileprivate var _workflowVersionEvaluation: Clarifai_Api_WorkflowVersionEvaluation? = nil
}

public struct Clarifai_Api_GetWorkflowVersionEvaluationRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var userAppID: Clarifai_Api_UserAppIDSet {
    get {return _userAppID ?? Clarifai_Api_UserAppIDSet()}
    set {_userAppID = newValue}
  }
  /// Returns true if `userAppID` has been explicitly set.
  public var hasUserAppID: Bool {return self._userAppID != nil}
  /// Clears the value of `userAppID`. Subsequent reads from it will return its default value.
  public mutating func clearUserAppID() {self._userAppID = nil}

  public var workflowID: String = String()

  public var workflowVersionID: String = String()

  public var workflowVersionEvaluationID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _userAppID: Clarifai_Api_UserAppIDSet? = nil
}

public struct Clarifai_Api_ListWorkflowVersionEvaluationsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var userAppID: Clarifai_Api_UserAppIDSet {
    get {return _userAppID ?? Clarifai_Api_UserAppIDSet()}
    set {_userAppID = newValue}
  }
  /// Returns true if `userAppID` has been explicitly set.
  public var hasUserAppID: Bool {return self._userAppID != nil}
  /// Clears the value of `userAppID`. Subsequent reads from it will return its default value.
  public mutating func clearUserAppID() {self._userAppID = nil}

  public var workflowID: String = String()

  public var workflowVersionID: String = String()

  /// (optional URL parameter) The page number. Pagination is used to split the results into chunks.
  /// Defaults to 1.
  public var page: UInt32 = 0

  /// (optional URL parameter) The number of results that will be contained in each page. Defaults
  /// to 128.
  public var perPage: UInt32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _userAppID: Clarifai_Api_UserAppIDSet? = nil
}

public struct Clarifai_Api_PostModelMigrationRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var userAppID: Clarifai_Api_UserAppIDSet {
    get {return _userAppID ?? Clarifai_Api_UserAppIDSet()}
    set {_userAppID = newValue}
  }
  /// Returns true if `userAppID` has been explicitly set.
  public var hasUserAppID: Bool {return self._userAppID != nil}
  /// Clears the value of `userAppID`. Subsequent reads from it will return its default value.
  public mutating func clearUserAppID() {self._userAppID = nil}

  public var modelID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _userAppID: Clarifai_Api_UserAppIDSet? = nil
}

public struct Clarifai_Api_ListWorkflowVersionEvaluationDataRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var userAppID: Clarifai_Api_UserAppIDSet {
    get {return _userAppID ?? Clarifai_Api_UserAppIDSet()}
    set {_userAppID = newValue}
  }
  /// Returns true if `userAppID` has been explicitly set.
  public var hasUserAppID: Bool {return self._userAppID != nil}
  /// Clears the value of `userAppID`. Subsequent reads from it will return its default value.
  public mutating func clearUserAppID() {self._userAppID = nil}

  public var workflowID: String = String()

  public var workflowVersionID: String = String()

  public var workflowVersionEvaluationID: String = String()

  /// (optional URL parameter) The page number. Pagination is used to split the results into chunks.
  /// Defaults to 1.
  public var page: UInt32 = 0

  /// (optional URL parameter) The number of results that will be contained in each page. Defaults
  /// to 128.
  public var perPage: UInt32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _userAppID: Clarifai_Api_UserAppIDSet? = nil
}

public struct Clarifai_Api_PostWorkflowVersionEvaluationDataRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var userAppID: Clarifai_Api_UserAppIDSet {
    get {return _userAppID ?? Clarifai_Api_UserAppIDSet()}
    set {_userAppID = newValue}
  }
  /// Returns true if `userAppID` has been explicitly set.
  public var hasUserAppID: Bool {return self._userAppID != nil}
  /// Clears the value of `userAppID`. Subsequent reads from it will return its default value.
  public mutating func clearUserAppID() {self._userAppID = nil}

  public var workflowID: String = String()

  public var workflowVersionID: String = String()

  public var workflowVersionEvaluationID: String = String()

  /// ########## Supported fields ##########
  /// - id
  /// - workflow_evaluation_sample_result
  public var workflowVersionEvaluationData: [Clarifai_Api_WorkflowVersionEvaluationData] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _userAppID: Clarifai_Api_UserAppIDSet? = nil
}

public struct Clarifai_Api_MultiListWorkflowVersionEvaluationDataResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var status: Clarifai_Api_Status_Status {
    get {return _status ?? Clarifai_Api_Status_Status()}
    set {_status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  public var hasStatus: Bool {return self._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  public mutating func clearStatus() {self._status = nil}

  public var workflowVersionEvaluationData: [Clarifai_Api_WorkflowVersionEvaluationData] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _status: Clarifai_Api_Status_Status? = nil
}

public struct Clarifai_Api_GetPipelineRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var userAppID: Clarifai_Api_UserAppIDSet {
    get {return _userAppID ?? Clarifai_Api_UserAppIDSet()}
    set {_userAppID = newValue}
  }
  /// Returns true if `userAppID` has been explicitly set.
  public var hasUserAppID: Bool {return self._userAppID != nil}
  /// Clears the value of `userAppID`. Subsequent reads from it will return its default value.
  public mutating func clearUserAppID() {self._userAppID = nil}

  public var pipelineID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _userAppID: Clarifai_Api_UserAppIDSet? = nil
}

public struct Clarifai_Api_ListPipelinesRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var userAppID: Clarifai_Api_UserAppIDSet {
    get {return _userAppID ?? Clarifai_Api_UserAppIDSet()}
    set {_userAppID = newValue}
  }
  /// Returns true if `userAppID` has been explicitly set.
  public var hasUserAppID: Bool {return self._userAppID != nil}
  /// Clears the value of `userAppID`. Subsequent reads from it will return its default value.
  public mutating func clearUserAppID() {self._userAppID = nil}

  /// (optional URL parameter) The page number. Pagination is used to split the results into chunks.
  /// Defaults to 1.
  public var page: UInt32 = 0

  /// (optional URL parameter) The number of results that will be contained in each page. Defaults
  /// to 128.
  public var perPage: UInt32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _userAppID: Clarifai_Api_UserAppIDSet? = nil
}

public struct Clarifai_Api_PostPipelinesRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var userAppID: Clarifai_Api_UserAppIDSet {
    get {return _userAppID ?? Clarifai_Api_UserAppIDSet()}
    set {_userAppID = newValue}
  }
  /// Returns true if `userAppID` has been explicitly set.
  public var hasUserAppID: Bool {return self._userAppID != nil}
  /// Clears the value of `userAppID`. Subsequent reads from it will return its default value.
  public mutating func clearUserAppID() {self._userAppID = nil}

  public var pipelines: [Clarifai_Api_Pipeline] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _userAppID: Clarifai_Api_UserAppIDSet? = nil
}

public struct Clarifai_Api_PatchPipelinesRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var userAppID: Clarifai_Api_UserAppIDSet {
    get {return _userAppID ?? Clarifai_Api_UserAppIDSet()}
    set {_userAppID = newValue}
  }
  /// Returns true if `userAppID` has been explicitly set.
  public var hasUserAppID: Bool {return self._userAppID != nil}
  /// Clears the value of `userAppID`. Subsequent reads from it will return its default value.
  public mutating func clearUserAppID() {self._userAppID = nil}

  public var pipelines: [Clarifai_Api_Pipeline] = []

  /// The action to perform on the patched objects
  /// For now actions 'overwrite' are supported
  public var action: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _userAppID: Clarifai_Api_UserAppIDSet? = nil
}

public struct Clarifai_Api_DeletePipelinesRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var userAppID: Clarifai_Api_UserAppIDSet {
    get {return _userAppID ?? Clarifai_Api_UserAppIDSet()}
    set {_userAppID = newValue}
  }
  /// Returns true if `userAppID` has been explicitly set.
  public var hasUserAppID: Bool {return self._userAppID != nil}
  /// Clears the value of `userAppID`. Subsequent reads from it will return its default value.
  public mutating func clearUserAppID() {self._userAppID = nil}

  public var ids: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _userAppID: Clarifai_Api_UserAppIDSet? = nil
}

public struct Clarifai_Api_SinglePipelineResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var status: Clarifai_Api_Status_Status {
    get {return _status ?? Clarifai_Api_Status_Status()}
    set {_status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  public var hasStatus: Bool {return self._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  public mutating func clearStatus() {self._status = nil}

  public var pipeline: Clarifai_Api_Pipeline {
    get {return _pipeline ?? Clarifai_Api_Pipeline()}
    set {_pipeline = newValue}
  }
  /// Returns true if `pipeline` has been explicitly set.
  public var hasPipeline: Bool {return self._pipeline != nil}
  /// Clears the value of `pipeline`. Subsequent reads from it will return its default value.
  public mutating func clearPipeline() {self._pipeline = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _status: Clarifai_Api_Status_Status? = nil
  fileprivate var _pipeline: Clarifai_Api_Pipeline? = nil
}

public struct Clarifai_Api_MultiPipelineResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var status: Clarifai_Api_Status_Status {
    get {return _status ?? Clarifai_Api_Status_Status()}
    set {_status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  public var hasStatus: Bool {return self._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  public mutating func clearStatus() {self._status = nil}

  public var pipelines: [Clarifai_Api_Pipeline] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _status: Clarifai_Api_Status_Status? = nil
}

public struct Clarifai_Api_GetPipelineVersionRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var userAppID: Clarifai_Api_UserAppIDSet {
    get {return _userAppID ?? Clarifai_Api_UserAppIDSet()}
    set {_userAppID = newValue}
  }
  /// Returns true if `userAppID` has been explicitly set.
  public var hasUserAppID: Bool {return self._userAppID != nil}
  /// Clears the value of `userAppID`. Subsequent reads from it will return its default value.
  public mutating func clearUserAppID() {self._userAppID = nil}

  /// The id of the pipeline that has the requested version.
  public var pipelineID: String = String()

  /// Get the identified by this id
  public var pipelineVersionID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _userAppID: Clarifai_Api_UserAppIDSet? = nil
}

public struct Clarifai_Api_ListPipelineVersionsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var userAppID: Clarifai_Api_UserAppIDSet {
    get {return _userAppID ?? Clarifai_Api_UserAppIDSet()}
    set {_userAppID = newValue}
  }
  /// Returns true if `userAppID` has been explicitly set.
  public var hasUserAppID: Bool {return self._userAppID != nil}
  /// Clears the value of `userAppID`. Subsequent reads from it will return its default value.
  public mutating func clearUserAppID() {self._userAppID = nil}

  /// List versions for the pipeline identified by this id
  public var pipelineID: String = String()

  /// (optional URL parameter) The page number. Pagination is used to split the results into chunks.
  /// Defaults to 1.
  public var page: UInt32 = 0

  /// (optional URL parameter) The number of results that will be contained in each page. Defaults
  /// to 128.
  public var perPage: UInt32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _userAppID: Clarifai_Api_UserAppIDSet? = nil
}

public struct Clarifai_Api_PatchPipelineVersionsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var userAppID: Clarifai_Api_UserAppIDSet {
    get {return _userAppID ?? Clarifai_Api_UserAppIDSet()}
    set {_userAppID = newValue}
  }
  /// Returns true if `userAppID` has been explicitly set.
  public var hasUserAppID: Bool {return self._userAppID != nil}
  /// Clears the value of `userAppID`. Subsequent reads from it will return its default value.
  public mutating func clearUserAppID() {self._userAppID = nil}

  /// The id of the Pipeline that has the requested versions to patch.
  public var pipelineID: String = String()

  /// Patch these versions
  public var pipelineVersions: [Clarifai_Api_PipelineVersion] = []

  /// The action to perform on the patched objects
  /// For now actions 'merge', 'overwrite', and 'remove' are supported
  public var action: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _userAppID: Clarifai_Api_UserAppIDSet? = nil
}

public struct Clarifai_Api_DeletePipelineVersionsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var userAppID: Clarifai_Api_UserAppIDSet {
    get {return _userAppID ?? Clarifai_Api_UserAppIDSet()}
    set {_userAppID = newValue}
  }
  /// Returns true if `userAppID` has been explicitly set.
  public var hasUserAppID: Bool {return self._userAppID != nil}
  /// Clears the value of `userAppID`. Subsequent reads from it will return its default value.
  public mutating func clearUserAppID() {self._userAppID = nil}

  /// The id of the Pipeline for which versions are being deleted
  public var pipelineID: String = String()

  public var pipelineVersionIds: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _userAppID: Clarifai_Api_UserAppIDSet? = nil
}

public struct Clarifai_Api_SinglePipelineVersionResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var status: Clarifai_Api_Status_Status {
    get {return _storage._status ?? Clarifai_Api_Status_Status()}
    set {_uniqueStorage()._status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  public var hasStatus: Bool {return _storage._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  public mutating func clearStatus() {_uniqueStorage()._status = nil}

  public var pipelineVersion: Clarifai_Api_PipelineVersion {
    get {return _storage._pipelineVersion ?? Clarifai_Api_PipelineVersion()}
    set {_uniqueStorage()._pipelineVersion = newValue}
  }
  /// Returns true if `pipelineVersion` has been explicitly set.
  public var hasPipelineVersion: Bool {return _storage._pipelineVersion != nil}
  /// Clears the value of `pipelineVersion`. Subsequent reads from it will return its default value.
  public mutating func clearPipelineVersion() {_uniqueStorage()._pipelineVersion = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Clarifai_Api_MultiPipelineVersionResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var status: Clarifai_Api_Status_Status {
    get {return _status ?? Clarifai_Api_Status_Status()}
    set {_status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  public var hasStatus: Bool {return self._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  public mutating func clearStatus() {self._status = nil}

  public var pipelineVersions: [Clarifai_Api_PipelineVersion] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _status: Clarifai_Api_Status_Status? = nil
}

public struct Clarifai_Api_GetPipelineVersionRunRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var userAppID: Clarifai_Api_UserAppIDSet {
    get {return _userAppID ?? Clarifai_Api_UserAppIDSet()}
    set {_userAppID = newValue}
  }
  /// Returns true if `userAppID` has been explicitly set.
  public var hasUserAppID: Bool {return self._userAppID != nil}
  /// Clears the value of `userAppID`. Subsequent reads from it will return its default value.
  public mutating func clearUserAppID() {self._userAppID = nil}

  /// the ID of the pipeline
  public var pipelineID: String = String()

  /// The ID of the pipeline version
  public var pipelineVersionID: String = String()

  /// the ID of the pipeline version run
  public var pipelineVersionRunID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _userAppID: Clarifai_Api_UserAppIDSet? = nil
}

public struct Clarifai_Api_ListPipelineVersionRunsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var userAppID: Clarifai_Api_UserAppIDSet {
    get {return _userAppID ?? Clarifai_Api_UserAppIDSet()}
    set {_userAppID = newValue}
  }
  /// Returns true if `userAppID` has been explicitly set.
  public var hasUserAppID: Bool {return self._userAppID != nil}
  /// Clears the value of `userAppID`. Subsequent reads from it will return its default value.
  public mutating func clearUserAppID() {self._userAppID = nil}

  /// The ID of the pipeline
  public var pipelineID: String = String()

  /// The ID of the pipeline version
  public var pipelineVersionID: String = String()

  /// (optional URL parameter) The page number. Pagination is used to split the results into chunks.
  /// Defaults to 1.
  public var page: UInt32 = 0

  /// (optional URL parameter) The number of results that will be contained in each page. Defaults
  /// to 128.
  public var perPage: UInt32 = 0

  /// Filter based on status
  public var statusCodes: [Clarifai_Api_Status_StatusCode] = []

  /// compute cluster id
  public var computeClusterID: String = String()

  /// nodepool id
  public var nodepoolID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _userAppID: Clarifai_Api_UserAppIDSet? = nil
}

public struct Clarifai_Api_PostPipelineVersionRunsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var userAppID: Clarifai_Api_UserAppIDSet {
    get {return _userAppID ?? Clarifai_Api_UserAppIDSet()}
    set {_userAppID = newValue}
  }
  /// Returns true if `userAppID` has been explicitly set.
  public var hasUserAppID: Bool {return self._userAppID != nil}
  /// Clears the value of `userAppID`. Subsequent reads from it will return its default value.
  public mutating func clearUserAppID() {self._userAppID = nil}

  /// The ID of the pipeline
  public var pipelineID: String = String()

  /// The ID of the pipeline-version
  public var pipelineVersionID: String = String()

  public var pipelineVersionRuns: [Clarifai_Api_PipelineVersionRun] = []

  /// Allows using specific Nodepools for pipeline version runs
  public var runnerSelector: Clarifai_Api_RunnerSelector {
    get {return _runnerSelector ?? Clarifai_Api_RunnerSelector()}
    set {_runnerSelector = newValue}
  }
  /// Returns true if `runnerSelector` has been explicitly set.
  public var hasRunnerSelector: Bool {return self._runnerSelector != nil}
  /// Clears the value of `runnerSelector`. Subsequent reads from it will return its default value.
  public mutating func clearRunnerSelector() {self._runnerSelector = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _userAppID: Clarifai_Api_UserAppIDSet? = nil
  fileprivate var _runnerSelector: Clarifai_Api_RunnerSelector? = nil
}

public struct Clarifai_Api_PatchPipelineVersionRunsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var userAppID: Clarifai_Api_UserAppIDSet {
    get {return _userAppID ?? Clarifai_Api_UserAppIDSet()}
    set {_userAppID = newValue}
  }
  /// Returns true if `userAppID` has been explicitly set.
  public var hasUserAppID: Bool {return self._userAppID != nil}
  /// Clears the value of `userAppID`. Subsequent reads from it will return its default value.
  public mutating func clearUserAppID() {self._userAppID = nil}

  /// The ID of the pipeline
  public var pipelineID: String = String()

  /// The ID of the pipeline-version
  public var pipelineVersionID: String = String()

  /// ########## Supported fields ##########
  /// - app_id
  /// - id
  /// - orchestration_status
  /// - pipeline_version.id
  /// - pipeline_version.pipeline_id
  /// - user_id
  public var pipelineVersionRuns: [Clarifai_Api_PipelineVersionRun] = []

  /// Supported action: 'overwrite' -> allows to overwrite WorkflowStatus of PipelineVersionRun
  public var action: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _userAppID: Clarifai_Api_UserAppIDSet? = nil
}

public struct Clarifai_Api_SinglePipelineVersionRunResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var status: Clarifai_Api_Status_Status {
    get {return _status ?? Clarifai_Api_Status_Status()}
    set {_status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  public var hasStatus: Bool {return self._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  public mutating func clearStatus() {self._status = nil}

  public var pipelineVersionRun: Clarifai_Api_PipelineVersionRun {
    get {return _pipelineVersionRun ?? Clarifai_Api_PipelineVersionRun()}
    set {_pipelineVersionRun = newValue}
  }
  /// Returns true if `pipelineVersionRun` has been explicitly set.
  public var hasPipelineVersionRun: Bool {return self._pipelineVersionRun != nil}
  /// Clears the value of `pipelineVersionRun`. Subsequent reads from it will return its default value.
  public mutating func clearPipelineVersionRun() {self._pipelineVersionRun = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _status: Clarifai_Api_Status_Status? = nil
  fileprivate var _pipelineVersionRun: Clarifai_Api_PipelineVersionRun? = nil
}

public struct Clarifai_Api_MultiPipelineVersionRunResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var status: Clarifai_Api_Status_Status {
    get {return _status ?? Clarifai_Api_Status_Status()}
    set {_status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  public var hasStatus: Bool {return self._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  public mutating func clearStatus() {self._status = nil}

  public var pipelineVersionRuns: [Clarifai_Api_PipelineVersionRun] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _status: Clarifai_Api_Status_Status? = nil
}

public struct Clarifai_Api_PostPipelineStepsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var userAppID: Clarifai_Api_UserAppIDSet {
    get {return _userAppID ?? Clarifai_Api_UserAppIDSet()}
    set {_userAppID = newValue}
  }
  /// Returns true if `userAppID` has been explicitly set.
  public var hasUserAppID: Bool {return self._userAppID != nil}
  /// Clears the value of `userAppID`. Subsequent reads from it will return its default value.
  public mutating func clearUserAppID() {self._userAppID = nil}

  public var pipelineSteps: [Clarifai_Api_PipelineStep] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _userAppID: Clarifai_Api_UserAppIDSet? = nil
}

public struct Clarifai_Api_MultiPipelineStepResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var status: Clarifai_Api_Status_Status {
    get {return _status ?? Clarifai_Api_Status_Status()}
    set {_status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  public var hasStatus: Bool {return self._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  public mutating func clearStatus() {self._status = nil}

  public var pipelineSteps: [Clarifai_Api_PipelineStep] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _status: Clarifai_Api_Status_Status? = nil
}

public struct Clarifai_Api_ListPipelineStepsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var userAppID: Clarifai_Api_UserAppIDSet {
    get {return _userAppID ?? Clarifai_Api_UserAppIDSet()}
    set {_userAppID = newValue}
  }
  /// Returns true if `userAppID` has been explicitly set.
  public var hasUserAppID: Bool {return self._userAppID != nil}
  /// Clears the value of `userAppID`. Subsequent reads from it will return its default value.
  public mutating func clearUserAppID() {self._userAppID = nil}

  /// (optional URL parameter) The page number. Pagination is used to split the results into chunks.
  /// Defaults to 1.
  public var page: UInt32 = 0

  /// (optional URL parameter) The number of results that will be contained in each page. Defaults
  /// to 128.
  public var perPage: UInt32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _userAppID: Clarifai_Api_UserAppIDSet? = nil
}

public struct Clarifai_Api_ListPipelineStepVersionsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var userAppID: Clarifai_Api_UserAppIDSet {
    get {return _userAppID ?? Clarifai_Api_UserAppIDSet()}
    set {_userAppID = newValue}
  }
  /// Returns true if `userAppID` has been explicitly set.
  public var hasUserAppID: Bool {return self._userAppID != nil}
  /// Clears the value of `userAppID`. Subsequent reads from it will return its default value.
  public mutating func clearUserAppID() {self._userAppID = nil}

  /// List versions for the pipeline step identified by this id
  public var pipelineStepID: String = String()

  /// (optional URL parameter) The page number. Pagination is used to split the results into chunks.
  /// Defaults to 1.
  public var page: UInt32 = 0

  /// (optional URL parameter) The number of results that will be contained in each page. Defaults
  /// to 128.
  public var perPage: UInt32 = 0

  /// Filter based on status
  public var statusCodes: [Clarifai_Api_Status_StatusCode] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _userAppID: Clarifai_Api_UserAppIDSet? = nil
}

public struct Clarifai_Api_MultiPipelineStepVersionResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The status of the request
  public var status: Clarifai_Api_Status_Status {
    get {return _status ?? Clarifai_Api_Status_Status()}
    set {_status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  public var hasStatus: Bool {return self._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  public mutating func clearStatus() {self._status = nil}

  /// The pipeline step versions that were requested
  public var pipelineStepVersions: [Clarifai_Api_PipelineStepVersion] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _status: Clarifai_Api_Status_Status? = nil
}

public struct Clarifai_Api_PostPipelineStepVersionsUploadRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var uploadData: Clarifai_Api_PostPipelineStepVersionsUploadRequest.OneOf_UploadData? = nil

  /// Upload a new pipeline step version.
  public var uploadConfig: Clarifai_Api_PostPipelineStepVersionsUploadConfig {
    get {
      if case .uploadConfig(let v)? = uploadData {return v}
      return Clarifai_Api_PostPipelineStepVersionsUploadConfig()
    }
    set {uploadData = .uploadConfig(newValue)}
  }

  /// Upload a part of a multipart upload.
  public var contentPart: Clarifai_Api_UploadContentPart {
    get {
      if case .contentPart(let v)? = uploadData {return v}
      return Clarifai_Api_UploadContentPart()
    }
    set {uploadData = .contentPart(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_UploadData: Equatable {
    /// Upload a new pipeline step version.
    case uploadConfig(Clarifai_Api_PostPipelineStepVersionsUploadConfig)
    /// Upload a part of a multipart upload.
    case contentPart(Clarifai_Api_UploadContentPart)

  #if !swift(>=4.1)
    public static func ==(lhs: Clarifai_Api_PostPipelineStepVersionsUploadRequest.OneOf_UploadData, rhs: Clarifai_Api_PostPipelineStepVersionsUploadRequest.OneOf_UploadData) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.uploadConfig, .uploadConfig): return {
        guard case .uploadConfig(let l) = lhs, case .uploadConfig(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.contentPart, .contentPart): return {
        guard case .contentPart(let l) = lhs, case .contentPart(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

public struct Clarifai_Api_PostPipelineStepVersionsUploadResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Status of the upload
  public var status: Clarifai_Api_Status_Status {
    get {return _status ?? Clarifai_Api_Status_Status()}
    set {_status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  public var hasStatus: Bool {return self._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  public mutating func clearStatus() {self._status = nil}

  /// Bytes remaining to be uploaded - This is total_size - bytes_uploaded
  public var bytesRemaining: UInt64 = 0

  /// ID of the pipeline step version being uploaded
  public var pipelineStepVersionID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _status: Clarifai_Api_Status_Status? = nil
}

public struct Clarifai_Api_PostPipelineStepVersionsUploadConfig {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// User ID and App ID of the user uploading the pipeline step
  public var userAppID: Clarifai_Api_UserAppIDSet {
    get {return _userAppID ?? Clarifai_Api_UserAppIDSet()}
    set {_userAppID = newValue}
  }
  /// Returns true if `userAppID` has been explicitly set.
  public var hasUserAppID: Bool {return self._userAppID != nil}
  /// Clears the value of `userAppID`. Subsequent reads from it will return its default value.
  public mutating func clearUserAppID() {self._userAppID = nil}

  /// Pipeline Step to create version for
  public var pipelineStepID: String = String()

  /// Specification for the pipeline step version to be uploaded
  public var pipelineStepVersion: Clarifai_Api_PipelineStepVersion {
    get {return _pipelineStepVersion ?? Clarifai_Api_PipelineStepVersion()}
    set {_pipelineStepVersion = newValue}
  }
  /// Returns true if `pipelineStepVersion` has been explicitly set.
  public var hasPipelineStepVersion: Bool {return self._pipelineStepVersion != nil}
  /// Clears the value of `pipelineStepVersion`. Subsequent reads from it will return its default value.
  public mutating func clearPipelineStepVersion() {self._pipelineStepVersion = nil}

  /// Number of bytes in the pipeline step files to be uploaded
  public var totalSize: UInt64 = 0

  /// Number of bytes requested for the build process.
  public var storageRequestSize: UInt64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _userAppID: Clarifai_Api_UserAppIDSet? = nil
  fileprivate var _pipelineStepVersion: Clarifai_Api_PipelineStepVersion? = nil
}

public struct Clarifai_Api_GetPipelineStepRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var userAppID: Clarifai_Api_UserAppIDSet {
    get {return _userAppID ?? Clarifai_Api_UserAppIDSet()}
    set {_userAppID = newValue}
  }
  /// Returns true if `userAppID` has been explicitly set.
  public var hasUserAppID: Bool {return self._userAppID != nil}
  /// Clears the value of `userAppID`. Subsequent reads from it will return its default value.
  public mutating func clearUserAppID() {self._userAppID = nil}

  /// The id of the pipeline step that has the requested version.
  public var pipelineStepID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _userAppID: Clarifai_Api_UserAppIDSet? = nil
}

public struct Clarifai_Api_SinglePipelineStepResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The status of the request
  public var status: Clarifai_Api_Status_Status {
    get {return _status ?? Clarifai_Api_Status_Status()}
    set {_status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  public var hasStatus: Bool {return self._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  public mutating func clearStatus() {self._status = nil}

  /// The pipeline step that was requested
  public var pipelineStep: Clarifai_Api_PipelineStep {
    get {return _pipelineStep ?? Clarifai_Api_PipelineStep()}
    set {_pipelineStep = newValue}
  }
  /// Returns true if `pipelineStep` has been explicitly set.
  public var hasPipelineStep: Bool {return self._pipelineStep != nil}
  /// Clears the value of `pipelineStep`. Subsequent reads from it will return its default value.
  public mutating func clearPipelineStep() {self._pipelineStep = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _status: Clarifai_Api_Status_Status? = nil
  fileprivate var _pipelineStep: Clarifai_Api_PipelineStep? = nil
}

public struct Clarifai_Api_GetPipelineStepVersionRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var userAppID: Clarifai_Api_UserAppIDSet {
    get {return _userAppID ?? Clarifai_Api_UserAppIDSet()}
    set {_userAppID = newValue}
  }
  /// Returns true if `userAppID` has been explicitly set.
  public var hasUserAppID: Bool {return self._userAppID != nil}
  /// Clears the value of `userAppID`. Subsequent reads from it will return its default value.
  public mutating func clearUserAppID() {self._userAppID = nil}

  /// The id of the pipeline step that has the requested version.
  public var pipelineStepID: String = String()

  /// Get the identified by this id
  public var pipelineStepVersionID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _userAppID: Clarifai_Api_UserAppIDSet? = nil
}

public struct Clarifai_Api_SinglePipelineStepVersionResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The status of the request
  public var status: Clarifai_Api_Status_Status {
    get {return _status ?? Clarifai_Api_Status_Status()}
    set {_status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  public var hasStatus: Bool {return self._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  public mutating func clearStatus() {self._status = nil}

  /// The pipeline step version that was requested
  public var pipelineStepVersion: Clarifai_Api_PipelineStepVersion {
    get {return _pipelineStepVersion ?? Clarifai_Api_PipelineStepVersion()}
    set {_pipelineStepVersion = newValue}
  }
  /// Returns true if `pipelineStepVersion` has been explicitly set.
  public var hasPipelineStepVersion: Bool {return self._pipelineStepVersion != nil}
  /// Clears the value of `pipelineStepVersion`. Subsequent reads from it will return its default value.
  public mutating func clearPipelineStepVersion() {self._pipelineStepVersion = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _status: Clarifai_Api_Status_Status? = nil
  fileprivate var _pipelineStepVersion: Clarifai_Api_PipelineStepVersion? = nil
}

public struct Clarifai_Api_GetSecretRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var userAppID: Clarifai_Api_UserAppIDSet {
    get {return _userAppID ?? Clarifai_Api_UserAppIDSet()}
    set {_userAppID = newValue}
  }
  /// Returns true if `userAppID` has been explicitly set.
  public var hasUserAppID: Bool {return self._userAppID != nil}
  /// Clears the value of `userAppID`. Subsequent reads from it will return its default value.
  public mutating func clearUserAppID() {self._userAppID = nil}

  /// The id of the secret to get
  public var id: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _userAppID: Clarifai_Api_UserAppIDSet? = nil
}

public struct Clarifai_Api_ListSecretsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var userAppID: Clarifai_Api_UserAppIDSet {
    get {return _userAppID ?? Clarifai_Api_UserAppIDSet()}
    set {_userAppID = newValue}
  }
  /// Returns true if `userAppID` has been explicitly set.
  public var hasUserAppID: Bool {return self._userAppID != nil}
  /// Clears the value of `userAppID`. Subsequent reads from it will return its default value.
  public mutating func clearUserAppID() {self._userAppID = nil}

  /// (optional URL parameter) The page number. Pagination is used to split the results into chunks.
  /// Defaults to 1.
  public var page: UInt32 = 0

  /// (optional URL parameter) The number of results that will be contained in each page. Defaults
  /// to 128.
  public var perPage: UInt32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _userAppID: Clarifai_Api_UserAppIDSet? = nil
}

public struct Clarifai_Api_PostSecretsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var userAppID: Clarifai_Api_UserAppIDSet {
    get {return _userAppID ?? Clarifai_Api_UserAppIDSet()}
    set {_userAppID = newValue}
  }
  /// Returns true if `userAppID` has been explicitly set.
  public var hasUserAppID: Bool {return self._userAppID != nil}
  /// Clears the value of `userAppID`. Subsequent reads from it will return its default value.
  public mutating func clearUserAppID() {self._userAppID = nil}

  /// The secrets to create
  public var secrets: [Clarifai_Api_Secret] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _userAppID: Clarifai_Api_UserAppIDSet? = nil
}

public struct Clarifai_Api_PatchSecretsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var userAppID: Clarifai_Api_UserAppIDSet {
    get {return _userAppID ?? Clarifai_Api_UserAppIDSet()}
    set {_userAppID = newValue}
  }
  /// Returns true if `userAppID` has been explicitly set.
  public var hasUserAppID: Bool {return self._userAppID != nil}
  /// Clears the value of `userAppID`. Subsequent reads from it will return its default value.
  public mutating func clearUserAppID() {self._userAppID = nil}

  public var secret: [Clarifai_Api_Secret] = []

  public var action: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _userAppID: Clarifai_Api_UserAppIDSet? = nil
}

public struct Clarifai_Api_DeleteSecretsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var userAppID: Clarifai_Api_UserAppIDSet {
    get {return _userAppID ?? Clarifai_Api_UserAppIDSet()}
    set {_userAppID = newValue}
  }
  /// Returns true if `userAppID` has been explicitly set.
  public var hasUserAppID: Bool {return self._userAppID != nil}
  /// Clears the value of `userAppID`. Subsequent reads from it will return its default value.
  public mutating func clearUserAppID() {self._userAppID = nil}

  /// List of secret ids to be deleted
  public var ids: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _userAppID: Clarifai_Api_UserAppIDSet? = nil
}

public struct Clarifai_Api_SingleSecretResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var status: Clarifai_Api_Status_Status {
    get {return _storage._status ?? Clarifai_Api_Status_Status()}
    set {_uniqueStorage()._status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  public var hasStatus: Bool {return _storage._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  public mutating func clearStatus() {_uniqueStorage()._status = nil}

  public var secret: Clarifai_Api_Secret {
    get {return _storage._secret ?? Clarifai_Api_Secret()}
    set {_uniqueStorage()._secret = newValue}
  }
  /// Returns true if `secret` has been explicitly set.
  public var hasSecret: Bool {return _storage._secret != nil}
  /// Clears the value of `secret`. Subsequent reads from it will return its default value.
  public mutating func clearSecret() {_uniqueStorage()._secret = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Clarifai_Api_MultiSecretResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var status: Clarifai_Api_Status_Status {
    get {return _status ?? Clarifai_Api_Status_Status()}
    set {_status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  public var hasStatus: Bool {return self._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  public mutating func clearStatus() {self._status = nil}

  public var secrets: [Clarifai_Api_Secret] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _status: Clarifai_Api_Status_Status? = nil
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "clarifai.api"

extension Clarifai_Api_OrganizationInvitationStatus: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NOT_SET"),
    1: .same(proto: "PENDING"),
    2: .same(proto: "ACCEPTED"),
    3: .same(proto: "CANCELLED"),
    4: .same(proto: "DECLINED"),
    5: .same(proto: "EXPIRED"),
  ]
}

extension Clarifai_Api_PutTaskAssignmentsRequestAction: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "PUT_TASK_ASSIGNMENTS_REQUEST_ACTION_NOT_SET"),
    1: .same(proto: "LABEL_START"),
    2: .same(proto: "LABEL_SUBMIT"),
    10: .same(proto: "REVIEW_START"),
    11: .same(proto: "REVIEW_APPROVE"),
    12: .same(proto: "REVIEW_REQUEST_CHANGES"),
    13: .same(proto: "REVIEW_REJECT"),
  ]
}

extension Clarifai_Api_Pagination: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Pagination"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "page"),
    2: .standard(proto: "per_page"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.page) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.perPage) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.page != 0 {
      try visitor.visitSingularUInt32Field(value: self.page, fieldNumber: 1)
    }
    if self.perPage != 0 {
      try visitor.visitSingularUInt32Field(value: self.perPage, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_Pagination, rhs: Clarifai_Api_Pagination) -> Bool {
    if lhs.page != rhs.page {return false}
    if lhs.perPage != rhs.perPage {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_GetAnnotationRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetAnnotationRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_app_id"),
    2: .standard(proto: "annotation_id"),
    3: .standard(proto: "input_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._userAppID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.annotationID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.inputID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._userAppID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.annotationID.isEmpty {
      try visitor.visitSingularStringField(value: self.annotationID, fieldNumber: 2)
    }
    if !self.inputID.isEmpty {
      try visitor.visitSingularStringField(value: self.inputID, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_GetAnnotationRequest, rhs: Clarifai_Api_GetAnnotationRequest) -> Bool {
    if lhs._userAppID != rhs._userAppID {return false}
    if lhs.annotationID != rhs.annotationID {return false}
    if lhs.inputID != rhs.inputID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_ListAnnotationsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListAnnotationsRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_app_id"),
    2: .same(proto: "ids"),
    3: .standard(proto: "input_ids"),
    9: .standard(proto: "user_ids"),
    10: .standard(proto: "model_version_ids"),
    13: .standard(proto: "workflow_version_ids"),
    5: .same(proto: "statuses"),
    6: .standard(proto: "list_all_annotations"),
    12: .standard(proto: "return_model_output"),
    7: .same(proto: "page"),
    8: .standard(proto: "per_page"),
    11: .standard(proto: "task_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._userAppID) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.ids) }()
      case 3: try { try decoder.decodeRepeatedStringField(value: &self.inputIds) }()
      case 5: try { try decoder.decodeRepeatedMessageField(value: &self.statuses) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self.listAllAnnotations) }()
      case 7: try { try decoder.decodeSingularUInt32Field(value: &self.page) }()
      case 8: try { try decoder.decodeSingularUInt32Field(value: &self.perPage) }()
      case 9: try { try decoder.decodeRepeatedStringField(value: &self.userIds) }()
      case 10: try { try decoder.decodeRepeatedStringField(value: &self.modelVersionIds) }()
      case 11: try { try decoder.decodeSingularStringField(value: &self.taskID) }()
      case 12: try { try decoder.decodeSingularBoolField(value: &self.returnModelOutput) }()
      case 13: try { try decoder.decodeRepeatedStringField(value: &self.workflowVersionIds) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._userAppID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.ids.isEmpty {
      try visitor.visitRepeatedStringField(value: self.ids, fieldNumber: 2)
    }
    if !self.inputIds.isEmpty {
      try visitor.visitRepeatedStringField(value: self.inputIds, fieldNumber: 3)
    }
    if !self.statuses.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.statuses, fieldNumber: 5)
    }
    if self.listAllAnnotations != false {
      try visitor.visitSingularBoolField(value: self.listAllAnnotations, fieldNumber: 6)
    }
    if self.page != 0 {
      try visitor.visitSingularUInt32Field(value: self.page, fieldNumber: 7)
    }
    if self.perPage != 0 {
      try visitor.visitSingularUInt32Field(value: self.perPage, fieldNumber: 8)
    }
    if !self.userIds.isEmpty {
      try visitor.visitRepeatedStringField(value: self.userIds, fieldNumber: 9)
    }
    if !self.modelVersionIds.isEmpty {
      try visitor.visitRepeatedStringField(value: self.modelVersionIds, fieldNumber: 10)
    }
    if !self.taskID.isEmpty {
      try visitor.visitSingularStringField(value: self.taskID, fieldNumber: 11)
    }
    if self.returnModelOutput != false {
      try visitor.visitSingularBoolField(value: self.returnModelOutput, fieldNumber: 12)
    }
    if !self.workflowVersionIds.isEmpty {
      try visitor.visitRepeatedStringField(value: self.workflowVersionIds, fieldNumber: 13)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_ListAnnotationsRequest, rhs: Clarifai_Api_ListAnnotationsRequest) -> Bool {
    if lhs._userAppID != rhs._userAppID {return false}
    if lhs.ids != rhs.ids {return false}
    if lhs.inputIds != rhs.inputIds {return false}
    if lhs.userIds != rhs.userIds {return false}
    if lhs.modelVersionIds != rhs.modelVersionIds {return false}
    if lhs.workflowVersionIds != rhs.workflowVersionIds {return false}
    if lhs.statuses != rhs.statuses {return false}
    if lhs.listAllAnnotations != rhs.listAllAnnotations {return false}
    if lhs.returnModelOutput != rhs.returnModelOutput {return false}
    if lhs.page != rhs.page {return false}
    if lhs.perPage != rhs.perPage {return false}
    if lhs.taskID != rhs.taskID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_PostAnnotationsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PostAnnotationsRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_app_id"),
    2: .same(proto: "annotations"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._userAppID) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.annotations) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._userAppID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.annotations.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.annotations, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_PostAnnotationsRequest, rhs: Clarifai_Api_PostAnnotationsRequest) -> Bool {
    if lhs._userAppID != rhs._userAppID {return false}
    if lhs.annotations != rhs.annotations {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_PatchAnnotationsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PatchAnnotationsRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_app_id"),
    2: .same(proto: "annotations"),
    3: .same(proto: "action"),
    4: .standard(proto: "delete_if_empty_data"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._userAppID) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.annotations) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.action) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.deleteIfEmptyData) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._userAppID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.annotations.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.annotations, fieldNumber: 2)
    }
    if !self.action.isEmpty {
      try visitor.visitSingularStringField(value: self.action, fieldNumber: 3)
    }
    if self.deleteIfEmptyData != false {
      try visitor.visitSingularBoolField(value: self.deleteIfEmptyData, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_PatchAnnotationsRequest, rhs: Clarifai_Api_PatchAnnotationsRequest) -> Bool {
    if lhs._userAppID != rhs._userAppID {return false}
    if lhs.annotations != rhs.annotations {return false}
    if lhs.action != rhs.action {return false}
    if lhs.deleteIfEmptyData != rhs.deleteIfEmptyData {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_PatchAnnotationsStatusRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PatchAnnotationsStatusRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_app_id"),
    3: .standard(proto: "user_ids"),
    4: .standard(proto: "task_id"),
    6: .standard(proto: "status_codes"),
    5: .same(proto: "action"),
    2: .standard(proto: "status_code"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._userAppID) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.statusCode) }()
      case 3: try { try decoder.decodeRepeatedStringField(value: &self.userIds) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.taskID) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.action) }()
      case 6: try { try decoder.decodeRepeatedEnumField(value: &self.statusCodes) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._userAppID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.statusCode != .zero {
      try visitor.visitSingularEnumField(value: self.statusCode, fieldNumber: 2)
    }
    if !self.userIds.isEmpty {
      try visitor.visitRepeatedStringField(value: self.userIds, fieldNumber: 3)
    }
    if !self.taskID.isEmpty {
      try visitor.visitSingularStringField(value: self.taskID, fieldNumber: 4)
    }
    if !self.action.isEmpty {
      try visitor.visitSingularStringField(value: self.action, fieldNumber: 5)
    }
    if !self.statusCodes.isEmpty {
      try visitor.visitPackedEnumField(value: self.statusCodes, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_PatchAnnotationsStatusRequest, rhs: Clarifai_Api_PatchAnnotationsStatusRequest) -> Bool {
    if lhs._userAppID != rhs._userAppID {return false}
    if lhs.userIds != rhs.userIds {return false}
    if lhs.taskID != rhs.taskID {return false}
    if lhs.statusCodes != rhs.statusCodes {return false}
    if lhs.action != rhs.action {return false}
    if lhs.statusCode != rhs.statusCode {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_PatchAnnotationsStatusResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PatchAnnotationsStatusResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
    2: .standard(proto: "user_ids"),
    3: .standard(proto: "updated_count"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._status) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.userIds) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.updatedCount) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._status {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.userIds.isEmpty {
      try visitor.visitRepeatedStringField(value: self.userIds, fieldNumber: 2)
    }
    if self.updatedCount != 0 {
      try visitor.visitSingularUInt32Field(value: self.updatedCount, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_PatchAnnotationsStatusResponse, rhs: Clarifai_Api_PatchAnnotationsStatusResponse) -> Bool {
    if lhs._status != rhs._status {return false}
    if lhs.userIds != rhs.userIds {return false}
    if lhs.updatedCount != rhs.updatedCount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_DeleteAnnotationRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DeleteAnnotationRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_app_id"),
    2: .standard(proto: "input_id"),
    3: .standard(proto: "annotation_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._userAppID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.inputID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.annotationID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._userAppID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.inputID.isEmpty {
      try visitor.visitSingularStringField(value: self.inputID, fieldNumber: 2)
    }
    if !self.annotationID.isEmpty {
      try visitor.visitSingularStringField(value: self.annotationID, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_DeleteAnnotationRequest, rhs: Clarifai_Api_DeleteAnnotationRequest) -> Bool {
    if lhs._userAppID != rhs._userAppID {return false}
    if lhs.inputID != rhs.inputID {return false}
    if lhs.annotationID != rhs.annotationID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_DeleteAnnotationsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DeleteAnnotationsRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_app_id"),
    2: .same(proto: "ids"),
    3: .standard(proto: "input_ids"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._userAppID) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.ids) }()
      case 3: try { try decoder.decodeRepeatedStringField(value: &self.inputIds) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._userAppID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.ids.isEmpty {
      try visitor.visitRepeatedStringField(value: self.ids, fieldNumber: 2)
    }
    if !self.inputIds.isEmpty {
      try visitor.visitRepeatedStringField(value: self.inputIds, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_DeleteAnnotationsRequest, rhs: Clarifai_Api_DeleteAnnotationsRequest) -> Bool {
    if lhs._userAppID != rhs._userAppID {return false}
    if lhs.ids != rhs.ids {return false}
    if lhs.inputIds != rhs.inputIds {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_ListAnnotationTracksRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListAnnotationTracksRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_app_id"),
    2: .same(proto: "ids"),
    3: .standard(proto: "input_id"),
    4: .same(proto: "page"),
    5: .standard(proto: "per_page"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._userAppID) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.ids) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.inputID) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self.page) }()
      case 5: try { try decoder.decodeSingularUInt32Field(value: &self.perPage) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._userAppID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.ids.isEmpty {
      try visitor.visitRepeatedStringField(value: self.ids, fieldNumber: 2)
    }
    if !self.inputID.isEmpty {
      try visitor.visitSingularStringField(value: self.inputID, fieldNumber: 3)
    }
    if self.page != 0 {
      try visitor.visitSingularUInt32Field(value: self.page, fieldNumber: 4)
    }
    if self.perPage != 0 {
      try visitor.visitSingularUInt32Field(value: self.perPage, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_ListAnnotationTracksRequest, rhs: Clarifai_Api_ListAnnotationTracksRequest) -> Bool {
    if lhs._userAppID != rhs._userAppID {return false}
    if lhs.ids != rhs.ids {return false}
    if lhs.inputID != rhs.inputID {return false}
    if lhs.page != rhs.page {return false}
    if lhs.perPage != rhs.perPage {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_PostAnnotationTracksRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PostAnnotationTracksRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_app_id"),
    2: .standard(proto: "annotation_tracks"),
    3: .standard(proto: "input_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._userAppID) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.annotationTracks) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.inputID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._userAppID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.annotationTracks.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.annotationTracks, fieldNumber: 2)
    }
    if !self.inputID.isEmpty {
      try visitor.visitSingularStringField(value: self.inputID, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_PostAnnotationTracksRequest, rhs: Clarifai_Api_PostAnnotationTracksRequest) -> Bool {
    if lhs._userAppID != rhs._userAppID {return false}
    if lhs.annotationTracks != rhs.annotationTracks {return false}
    if lhs.inputID != rhs.inputID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_PatchAnnotationTracksRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PatchAnnotationTracksRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_app_id"),
    2: .standard(proto: "annotation_tracks"),
    3: .standard(proto: "input_id"),
    4: .same(proto: "action"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._userAppID) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.annotationTracks) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.inputID) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.action) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._userAppID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.annotationTracks.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.annotationTracks, fieldNumber: 2)
    }
    if !self.inputID.isEmpty {
      try visitor.visitSingularStringField(value: self.inputID, fieldNumber: 3)
    }
    if !self.action.isEmpty {
      try visitor.visitSingularStringField(value: self.action, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_PatchAnnotationTracksRequest, rhs: Clarifai_Api_PatchAnnotationTracksRequest) -> Bool {
    if lhs._userAppID != rhs._userAppID {return false}
    if lhs.annotationTracks != rhs.annotationTracks {return false}
    if lhs.inputID != rhs.inputID {return false}
    if lhs.action != rhs.action {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_DeleteAnnotationTracksRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DeleteAnnotationTracksRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_app_id"),
    2: .same(proto: "ids"),
    3: .standard(proto: "input_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._userAppID) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.ids) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.inputID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._userAppID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.ids.isEmpty {
      try visitor.visitRepeatedStringField(value: self.ids, fieldNumber: 2)
    }
    if !self.inputID.isEmpty {
      try visitor.visitSingularStringField(value: self.inputID, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_DeleteAnnotationTracksRequest, rhs: Clarifai_Api_DeleteAnnotationTracksRequest) -> Bool {
    if lhs._userAppID != rhs._userAppID {return false}
    if lhs.ids != rhs.ids {return false}
    if lhs.inputID != rhs.inputID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_MultiAnnotationTrackResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MultiAnnotationTrackResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
    2: .standard(proto: "annotation_tracks"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._status) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.annotationTracks) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._status {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.annotationTracks.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.annotationTracks, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_MultiAnnotationTrackResponse, rhs: Clarifai_Api_MultiAnnotationTrackResponse) -> Bool {
    if lhs._status != rhs._status {return false}
    if lhs.annotationTracks != rhs.annotationTracks {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_SingleAnnotationResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SingleAnnotationResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
    2: .same(proto: "annotation"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._status) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._annotation) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._status {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._annotation {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_SingleAnnotationResponse, rhs: Clarifai_Api_SingleAnnotationResponse) -> Bool {
    if lhs._status != rhs._status {return false}
    if lhs._annotation != rhs._annotation {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_MultiAnnotationResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MultiAnnotationResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
    2: .same(proto: "annotations"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._status) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.annotations) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._status {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.annotations.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.annotations, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_MultiAnnotationResponse, rhs: Clarifai_Api_MultiAnnotationResponse) -> Bool {
    if lhs._status != rhs._status {return false}
    if lhs.annotations != rhs.annotations {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_ListAnnotationWorkersRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListAnnotationWorkersRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_app_id"),
    2: .same(proto: "page"),
    3: .standard(proto: "per_page"),
    4: .standard(proto: "additional_fields"),
    5: .standard(proto: "trusted_only"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._userAppID) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.page) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.perPage) }()
      case 4: try { try decoder.decodeRepeatedStringField(value: &self.additionalFields) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.trustedOnly) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._userAppID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.page != 0 {
      try visitor.visitSingularUInt32Field(value: self.page, fieldNumber: 2)
    }
    if self.perPage != 0 {
      try visitor.visitSingularUInt32Field(value: self.perPage, fieldNumber: 3)
    }
    if !self.additionalFields.isEmpty {
      try visitor.visitRepeatedStringField(value: self.additionalFields, fieldNumber: 4)
    }
    if self.trustedOnly != false {
      try visitor.visitSingularBoolField(value: self.trustedOnly, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_ListAnnotationWorkersRequest, rhs: Clarifai_Api_ListAnnotationWorkersRequest) -> Bool {
    if lhs._userAppID != rhs._userAppID {return false}
    if lhs.page != rhs.page {return false}
    if lhs.perPage != rhs.perPage {return false}
    if lhs.additionalFields != rhs.additionalFields {return false}
    if lhs.trustedOnly != rhs.trustedOnly {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_MultiWorkerResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MultiWorkerResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
    2: .same(proto: "workers"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._status) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.workers) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._status {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.workers.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.workers, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_MultiWorkerResponse, rhs: Clarifai_Api_MultiWorkerResponse) -> Bool {
    if lhs._status != rhs._status {return false}
    if lhs.workers != rhs.workers {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_GetAppRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetAppRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_app_id"),
    2: .standard(proto: "additional_fields"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._userAppID) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.additionalFields) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._userAppID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.additionalFields.isEmpty {
      try visitor.visitRepeatedStringField(value: self.additionalFields, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_GetAppRequest, rhs: Clarifai_Api_GetAppRequest) -> Bool {
    if lhs._userAppID != rhs._userAppID {return false}
    if lhs.additionalFields != rhs.additionalFields {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_ListAppsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListAppsRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_app_id"),
    2: .same(proto: "page"),
    3: .standard(proto: "per_page"),
    10: .standard(proto: "additional_fields"),
    5: .standard(proto: "sort_ascending"),
    6: .standard(proto: "sort_by_name"),
    7: .standard(proto: "sort_by_modified_at"),
    12: .standard(proto: "sort_by_created_at"),
    13: .standard(proto: "sort_by_star_count"),
    17: .standard(proto: "sort_by_id"),
    9: .standard(proto: "featured_only"),
    11: .standard(proto: "starred_only"),
    16: .standard(proto: "template_only"),
    18: .same(proto: "visibility"),
    15: .same(proto: "search"),
    8: .same(proto: "query"),
    4: .same(proto: "name"),
    14: .same(proto: "id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._userAppID) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.page) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.perPage) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.sortAscending) }()
      case 6: try {
        var v: Bool?
        try decoder.decodeSingularBoolField(value: &v)
        if let v = v {
          if self.sortBy != nil {try decoder.handleConflictingOneOf()}
          self.sortBy = .sortByName(v)
        }
      }()
      case 7: try {
        var v: Bool?
        try decoder.decodeSingularBoolField(value: &v)
        if let v = v {
          if self.sortBy != nil {try decoder.handleConflictingOneOf()}
          self.sortBy = .sortByModifiedAt(v)
        }
      }()
      case 8: try { try decoder.decodeSingularStringField(value: &self.query) }()
      case 9: try { try decoder.decodeSingularBoolField(value: &self.featuredOnly) }()
      case 10: try { try decoder.decodeRepeatedStringField(value: &self.additionalFields) }()
      case 11: try { try decoder.decodeSingularBoolField(value: &self.starredOnly) }()
      case 12: try {
        var v: Bool?
        try decoder.decodeSingularBoolField(value: &v)
        if let v = v {
          if self.sortBy != nil {try decoder.handleConflictingOneOf()}
          self.sortBy = .sortByCreatedAt(v)
        }
      }()
      case 13: try {
        var v: Bool?
        try decoder.decodeSingularBoolField(value: &v)
        if let v = v {
          if self.sortBy != nil {try decoder.handleConflictingOneOf()}
          self.sortBy = .sortByStarCount(v)
        }
      }()
      case 14: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 15: try { try decoder.decodeSingularStringField(value: &self.search) }()
      case 16: try { try decoder.decodeSingularBoolField(value: &self.templateOnly) }()
      case 17: try {
        var v: Bool?
        try decoder.decodeSingularBoolField(value: &v)
        if let v = v {
          if self.sortBy != nil {try decoder.handleConflictingOneOf()}
          self.sortBy = .sortByID(v)
        }
      }()
      case 18: try { try decoder.decodeSingularMessageField(value: &self._visibility) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._userAppID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.page != 0 {
      try visitor.visitSingularUInt32Field(value: self.page, fieldNumber: 2)
    }
    if self.perPage != 0 {
      try visitor.visitSingularUInt32Field(value: self.perPage, fieldNumber: 3)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 4)
    }
    if self.sortAscending != false {
      try visitor.visitSingularBoolField(value: self.sortAscending, fieldNumber: 5)
    }
    switch self.sortBy {
    case .sortByName?: try {
      guard case .sortByName(let v)? = self.sortBy else { preconditionFailure() }
      try visitor.visitSingularBoolField(value: v, fieldNumber: 6)
    }()
    case .sortByModifiedAt?: try {
      guard case .sortByModifiedAt(let v)? = self.sortBy else { preconditionFailure() }
      try visitor.visitSingularBoolField(value: v, fieldNumber: 7)
    }()
    default: break
    }
    if !self.query.isEmpty {
      try visitor.visitSingularStringField(value: self.query, fieldNumber: 8)
    }
    if self.featuredOnly != false {
      try visitor.visitSingularBoolField(value: self.featuredOnly, fieldNumber: 9)
    }
    if !self.additionalFields.isEmpty {
      try visitor.visitRepeatedStringField(value: self.additionalFields, fieldNumber: 10)
    }
    if self.starredOnly != false {
      try visitor.visitSingularBoolField(value: self.starredOnly, fieldNumber: 11)
    }
    switch self.sortBy {
    case .sortByCreatedAt?: try {
      guard case .sortByCreatedAt(let v)? = self.sortBy else { preconditionFailure() }
      try visitor.visitSingularBoolField(value: v, fieldNumber: 12)
    }()
    case .sortByStarCount?: try {
      guard case .sortByStarCount(let v)? = self.sortBy else { preconditionFailure() }
      try visitor.visitSingularBoolField(value: v, fieldNumber: 13)
    }()
    default: break
    }
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 14)
    }
    if !self.search.isEmpty {
      try visitor.visitSingularStringField(value: self.search, fieldNumber: 15)
    }
    if self.templateOnly != false {
      try visitor.visitSingularBoolField(value: self.templateOnly, fieldNumber: 16)
    }
    try { if case .sortByID(let v)? = self.sortBy {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 17)
    } }()
    try { if let v = self._visibility {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 18)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_ListAppsRequest, rhs: Clarifai_Api_ListAppsRequest) -> Bool {
    if lhs._userAppID != rhs._userAppID {return false}
    if lhs.page != rhs.page {return false}
    if lhs.perPage != rhs.perPage {return false}
    if lhs.additionalFields != rhs.additionalFields {return false}
    if lhs.sortAscending != rhs.sortAscending {return false}
    if lhs.sortBy != rhs.sortBy {return false}
    if lhs.featuredOnly != rhs.featuredOnly {return false}
    if lhs.starredOnly != rhs.starredOnly {return false}
    if lhs.templateOnly != rhs.templateOnly {return false}
    if lhs._visibility != rhs._visibility {return false}
    if lhs.search != rhs.search {return false}
    if lhs.query != rhs.query {return false}
    if lhs.name != rhs.name {return false}
    if lhs.id != rhs.id {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_PostAppsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PostAppsRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_app_id"),
    2: .same(proto: "apps"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._userAppID) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.apps) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._userAppID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.apps.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.apps, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_PostAppsRequest, rhs: Clarifai_Api_PostAppsRequest) -> Bool {
    if lhs._userAppID != rhs._userAppID {return false}
    if lhs.apps != rhs.apps {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_DeleteAppRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DeleteAppRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_app_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._userAppID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._userAppID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_DeleteAppRequest, rhs: Clarifai_Api_DeleteAppRequest) -> Bool {
    if lhs._userAppID != rhs._userAppID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_PatchAppsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PatchAppsRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_app_id"),
    2: .same(proto: "apps"),
    3: .same(proto: "action"),
    4: .standard(proto: "metadata_action"),
    5: .same(proto: "reindex"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._userAppID) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.apps) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.action) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._metadataAction) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.reindex) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._userAppID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.apps.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.apps, fieldNumber: 2)
    }
    if !self.action.isEmpty {
      try visitor.visitSingularStringField(value: self.action, fieldNumber: 3)
    }
    try { if let v = self._metadataAction {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    if self.reindex != false {
      try visitor.visitSingularBoolField(value: self.reindex, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_PatchAppsRequest, rhs: Clarifai_Api_PatchAppsRequest) -> Bool {
    if lhs._userAppID != rhs._userAppID {return false}
    if lhs.apps != rhs.apps {return false}
    if lhs.action != rhs.action {return false}
    if lhs._metadataAction != rhs._metadataAction {return false}
    if lhs.reindex != rhs.reindex {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_PatchAppsDetailsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PatchAppsDetailsRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_app_id"),
    2: .same(proto: "apps"),
    3: .same(proto: "action"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._userAppID) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.apps) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.action) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._userAppID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.apps.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.apps, fieldNumber: 2)
    }
    if !self.action.isEmpty {
      try visitor.visitSingularStringField(value: self.action, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_PatchAppsDetailsRequest, rhs: Clarifai_Api_PatchAppsDetailsRequest) -> Bool {
    if lhs._userAppID != rhs._userAppID {return false}
    if lhs.apps != rhs.apps {return false}
    if lhs.action != rhs.action {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_PatchAppRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PatchAppRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_app_id"),
    2: .same(proto: "app"),
    3: .same(proto: "action"),
    4: .standard(proto: "metadata_action"),
    5: .same(proto: "reindex"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._userAppID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._app) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.action) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._metadataAction) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.reindex) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._userAppID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._app {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.action.isEmpty {
      try visitor.visitSingularStringField(value: self.action, fieldNumber: 3)
    }
    try { if let v = self._metadataAction {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    if self.reindex != false {
      try visitor.visitSingularBoolField(value: self.reindex, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_PatchAppRequest, rhs: Clarifai_Api_PatchAppRequest) -> Bool {
    if lhs._userAppID != rhs._userAppID {return false}
    if lhs._app != rhs._app {return false}
    if lhs.action != rhs.action {return false}
    if lhs._metadataAction != rhs._metadataAction {return false}
    if lhs.reindex != rhs.reindex {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_PatchAppsIdsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PatchAppsIdsRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_app_id"),
    3: .same(proto: "ids"),
    4: .same(proto: "action"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._userAppID) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.ids) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.action) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._userAppID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.ids.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.ids, fieldNumber: 3)
    }
    if !self.action.isEmpty {
      try visitor.visitSingularStringField(value: self.action, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_PatchAppsIdsRequest, rhs: Clarifai_Api_PatchAppsIdsRequest) -> Bool {
    if lhs._userAppID != rhs._userAppID {return false}
    if lhs.ids != rhs.ids {return false}
    if lhs.action != rhs.action {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_PostAppsSearchesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PostAppsSearchesRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_app_id"),
    2: .standard(proto: "app_query"),
    3: .same(proto: "pagination"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._userAppID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._appQuery) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._pagination) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._userAppID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._appQuery {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._pagination {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_PostAppsSearchesRequest, rhs: Clarifai_Api_PostAppsSearchesRequest) -> Bool {
    if lhs._userAppID != rhs._userAppID {return false}
    if lhs._appQuery != rhs._appQuery {return false}
    if lhs._pagination != rhs._pagination {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_SingleAppResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SingleAppResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
    2: .same(proto: "app"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._status) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._app) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._status {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._app {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_SingleAppResponse, rhs: Clarifai_Api_SingleAppResponse) -> Bool {
    if lhs._status != rhs._status {return false}
    if lhs._app != rhs._app {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_MultiAppResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MultiAppResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
    2: .same(proto: "apps"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._status) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.apps) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._status {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.apps.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.apps, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_MultiAppResponse, rhs: Clarifai_Api_MultiAppResponse) -> Bool {
    if lhs._status != rhs._status {return false}
    if lhs.apps != rhs.apps {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_ListCollaboratorsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListCollaboratorsRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_app_id"),
    2: .standard(proto: "list_all_collaborators"),
    3: .same(proto: "page"),
    4: .standard(proto: "per_page"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._userAppID) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.listAllCollaborators) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.page) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self.perPage) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._userAppID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.listAllCollaborators != false {
      try visitor.visitSingularBoolField(value: self.listAllCollaborators, fieldNumber: 2)
    }
    if self.page != 0 {
      try visitor.visitSingularUInt32Field(value: self.page, fieldNumber: 3)
    }
    if self.perPage != 0 {
      try visitor.visitSingularUInt32Field(value: self.perPage, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_ListCollaboratorsRequest, rhs: Clarifai_Api_ListCollaboratorsRequest) -> Bool {
    if lhs._userAppID != rhs._userAppID {return false}
    if lhs.listAllCollaborators != rhs.listAllCollaborators {return false}
    if lhs.page != rhs.page {return false}
    if lhs.perPage != rhs.perPage {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_PostCollaboratorsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PostCollaboratorsRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_app_id"),
    2: .same(proto: "collaborators"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._userAppID) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.collaborators) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._userAppID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.collaborators.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.collaborators, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_PostCollaboratorsRequest, rhs: Clarifai_Api_PostCollaboratorsRequest) -> Bool {
    if lhs._userAppID != rhs._userAppID {return false}
    if lhs.collaborators != rhs.collaborators {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_PatchCollaboratorsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PatchCollaboratorsRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_app_id"),
    2: .same(proto: "collaborators"),
    3: .same(proto: "action"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._userAppID) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.collaborators) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.action) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._userAppID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.collaborators.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.collaborators, fieldNumber: 2)
    }
    if !self.action.isEmpty {
      try visitor.visitSingularStringField(value: self.action, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_PatchCollaboratorsRequest, rhs: Clarifai_Api_PatchCollaboratorsRequest) -> Bool {
    if lhs._userAppID != rhs._userAppID {return false}
    if lhs.collaborators != rhs.collaborators {return false}
    if lhs.action != rhs.action {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_DeleteCollaboratorsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DeleteCollaboratorsRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_app_id"),
    2: .standard(proto: "collaborator_ids"),
    3: .standard(proto: "user_emails"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._userAppID) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.collaboratorIds) }()
      case 3: try { try decoder.decodeRepeatedStringField(value: &self.userEmails) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._userAppID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.collaboratorIds.isEmpty {
      try visitor.visitRepeatedStringField(value: self.collaboratorIds, fieldNumber: 2)
    }
    if !self.userEmails.isEmpty {
      try visitor.visitRepeatedStringField(value: self.userEmails, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_DeleteCollaboratorsRequest, rhs: Clarifai_Api_DeleteCollaboratorsRequest) -> Bool {
    if lhs._userAppID != rhs._userAppID {return false}
    if lhs.collaboratorIds != rhs.collaboratorIds {return false}
    if lhs.userEmails != rhs.userEmails {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_MultiCollaboratorsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MultiCollaboratorsResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
    2: .same(proto: "collaborators"),
    3: .standard(proto: "app_owner"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._status) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.collaborators) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._appOwner) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._status {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.collaborators.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.collaborators, fieldNumber: 2)
    }
    try { if let v = self._appOwner {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_MultiCollaboratorsResponse, rhs: Clarifai_Api_MultiCollaboratorsResponse) -> Bool {
    if lhs._status != rhs._status {return false}
    if lhs.collaborators != rhs.collaborators {return false}
    if lhs._appOwner != rhs._appOwner {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_ListCollaborationsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListCollaborationsRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_app_id"),
    2: .same(proto: "page"),
    3: .standard(proto: "per_page"),
    4: .standard(proto: "template_only"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._userAppID) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.page) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.perPage) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.templateOnly) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._userAppID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.page != 0 {
      try visitor.visitSingularUInt32Field(value: self.page, fieldNumber: 2)
    }
    if self.perPage != 0 {
      try visitor.visitSingularUInt32Field(value: self.perPage, fieldNumber: 3)
    }
    if self.templateOnly != false {
      try visitor.visitSingularBoolField(value: self.templateOnly, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_ListCollaborationsRequest, rhs: Clarifai_Api_ListCollaborationsRequest) -> Bool {
    if lhs._userAppID != rhs._userAppID {return false}
    if lhs.page != rhs.page {return false}
    if lhs.perPage != rhs.perPage {return false}
    if lhs.templateOnly != rhs.templateOnly {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_MultiCollaborationsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MultiCollaborationsResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
    2: .same(proto: "collaborations"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._status) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.collaborations) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._status {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.collaborations.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.collaborations, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_MultiCollaborationsResponse, rhs: Clarifai_Api_MultiCollaborationsResponse) -> Bool {
    if lhs._status != rhs._status {return false}
    if lhs.collaborations != rhs.collaborations {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_GetStatusCodeRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetStatusCodeRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "status_code_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.statusCodeID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.statusCodeID.isEmpty {
      try visitor.visitSingularStringField(value: self.statusCodeID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_GetStatusCodeRequest, rhs: Clarifai_Api_GetStatusCodeRequest) -> Bool {
    if lhs.statusCodeID != rhs.statusCodeID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_ListStatusCodesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListStatusCodesRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_ListStatusCodesRequest, rhs: Clarifai_Api_ListStatusCodesRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_SingleStatusCodeResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SingleStatusCodeResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._status) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._status {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_SingleStatusCodeResponse, rhs: Clarifai_Api_SingleStatusCodeResponse) -> Bool {
    if lhs._status != rhs._status {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_MultiStatusCodeResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MultiStatusCodeResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
    2: .same(proto: "statuses"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._status) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.statuses) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._status {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.statuses.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.statuses, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_MultiStatusCodeResponse, rhs: Clarifai_Api_MultiStatusCodeResponse) -> Bool {
    if lhs._status != rhs._status {return false}
    if lhs.statuses != rhs.statuses {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_GetConceptRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetConceptRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_app_id"),
    2: .standard(proto: "concept_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._userAppID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.conceptID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._userAppID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.conceptID.isEmpty {
      try visitor.visitSingularStringField(value: self.conceptID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_GetConceptRequest, rhs: Clarifai_Api_GetConceptRequest) -> Bool {
    if lhs._userAppID != rhs._userAppID {return false}
    if lhs.conceptID != rhs.conceptID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_ListConceptsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListConceptsRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_app_id"),
    2: .same(proto: "page"),
    3: .standard(proto: "per_page"),
    4: .same(proto: "id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._userAppID) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.page) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.perPage) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.id) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._userAppID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.page != 0 {
      try visitor.visitSingularUInt32Field(value: self.page, fieldNumber: 2)
    }
    if self.perPage != 0 {
      try visitor.visitSingularUInt32Field(value: self.perPage, fieldNumber: 3)
    }
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_ListConceptsRequest, rhs: Clarifai_Api_ListConceptsRequest) -> Bool {
    if lhs._userAppID != rhs._userAppID {return false}
    if lhs.page != rhs.page {return false}
    if lhs.perPage != rhs.perPage {return false}
    if lhs.id != rhs.id {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_ListModelConceptsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListModelConceptsRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_app_id"),
    2: .standard(proto: "model_id"),
    3: .standard(proto: "version_id"),
    4: .same(proto: "page"),
    5: .standard(proto: "per_page"),
    6: .same(proto: "search"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._userAppID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.modelID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.versionID) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self.page) }()
      case 5: try { try decoder.decodeSingularUInt32Field(value: &self.perPage) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.search) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._userAppID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.modelID.isEmpty {
      try visitor.visitSingularStringField(value: self.modelID, fieldNumber: 2)
    }
    if !self.versionID.isEmpty {
      try visitor.visitSingularStringField(value: self.versionID, fieldNumber: 3)
    }
    if self.page != 0 {
      try visitor.visitSingularUInt32Field(value: self.page, fieldNumber: 4)
    }
    if self.perPage != 0 {
      try visitor.visitSingularUInt32Field(value: self.perPage, fieldNumber: 5)
    }
    if !self.search.isEmpty {
      try visitor.visitSingularStringField(value: self.search, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_ListModelConceptsRequest, rhs: Clarifai_Api_ListModelConceptsRequest) -> Bool {
    if lhs._userAppID != rhs._userAppID {return false}
    if lhs.modelID != rhs.modelID {return false}
    if lhs.versionID != rhs.versionID {return false}
    if lhs.page != rhs.page {return false}
    if lhs.perPage != rhs.perPage {return false}
    if lhs.search != rhs.search {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_PostConceptsSearchesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PostConceptsSearchesRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_app_id"),
    2: .standard(proto: "concept_query"),
    4: .standard(proto: "extra_info"),
    3: .same(proto: "pagination"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._userAppID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._conceptQuery) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._pagination) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._extraInfo) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._userAppID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._conceptQuery {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._pagination {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._extraInfo {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_PostConceptsSearchesRequest, rhs: Clarifai_Api_PostConceptsSearchesRequest) -> Bool {
    if lhs._userAppID != rhs._userAppID {return false}
    if lhs._conceptQuery != rhs._conceptQuery {return false}
    if lhs._extraInfo != rhs._extraInfo {return false}
    if lhs._pagination != rhs._pagination {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_ConceptExtraInfoRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ConceptExtraInfoRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "rankable_model"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._rankableModel) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._rankableModel {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_ConceptExtraInfoRequest, rhs: Clarifai_Api_ConceptExtraInfoRequest) -> Bool {
    if lhs._rankableModel != rhs._rankableModel {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_PostConceptsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PostConceptsRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_app_id"),
    2: .same(proto: "concepts"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._userAppID) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.concepts) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._userAppID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.concepts.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.concepts, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_PostConceptsRequest, rhs: Clarifai_Api_PostConceptsRequest) -> Bool {
    if lhs._userAppID != rhs._userAppID {return false}
    if lhs.concepts != rhs.concepts {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_PatchConceptsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PatchConceptsRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_app_id"),
    2: .same(proto: "concepts"),
    3: .same(proto: "action"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._userAppID) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.concepts) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.action) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._userAppID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.concepts.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.concepts, fieldNumber: 2)
    }
    if !self.action.isEmpty {
      try visitor.visitSingularStringField(value: self.action, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_PatchConceptsRequest, rhs: Clarifai_Api_PatchConceptsRequest) -> Bool {
    if lhs._userAppID != rhs._userAppID {return false}
    if lhs.concepts != rhs.concepts {return false}
    if lhs.action != rhs.action {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_GetConceptCountsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetConceptCountsRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_app_id"),
    2: .same(proto: "page"),
    3: .standard(proto: "per_page"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._userAppID) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.page) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.perPage) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._userAppID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.page != 0 {
      try visitor.visitSingularUInt32Field(value: self.page, fieldNumber: 2)
    }
    if self.perPage != 0 {
      try visitor.visitSingularUInt32Field(value: self.perPage, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_GetConceptCountsRequest, rhs: Clarifai_Api_GetConceptCountsRequest) -> Bool {
    if lhs._userAppID != rhs._userAppID {return false}
    if lhs.page != rhs.page {return false}
    if lhs.perPage != rhs.perPage {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_SingleConceptResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SingleConceptResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
    2: .same(proto: "concept"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._status) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._concept) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._status {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._concept {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_SingleConceptResponse, rhs: Clarifai_Api_SingleConceptResponse) -> Bool {
    if lhs._status != rhs._status {return false}
    if lhs._concept != rhs._concept {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_MultiConceptResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MultiConceptResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
    2: .same(proto: "concepts"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._status) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.concepts) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._status {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.concepts.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.concepts, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_MultiConceptResponse, rhs: Clarifai_Api_MultiConceptResponse) -> Bool {
    if lhs._status != rhs._status {return false}
    if lhs.concepts != rhs.concepts {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_MultiConceptCountResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MultiConceptCountResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
    2: .standard(proto: "concept_counts"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._status) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.conceptCounts) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._status {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.conceptCounts.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.conceptCounts, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_MultiConceptCountResponse, rhs: Clarifai_Api_MultiConceptCountResponse) -> Bool {
    if lhs._status != rhs._status {return false}
    if lhs.conceptCounts != rhs.conceptCounts {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_ListConceptRelationsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListConceptRelationsRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_app_id"),
    2: .standard(proto: "concept_id"),
    3: .same(proto: "predicate"),
    4: .standard(proto: "knowledge_graph_id"),
    5: .same(proto: "page"),
    6: .standard(proto: "per_page"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._userAppID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.conceptID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.predicate) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.knowledgeGraphID) }()
      case 5: try { try decoder.decodeSingularUInt32Field(value: &self.page) }()
      case 6: try { try decoder.decodeSingularUInt32Field(value: &self.perPage) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._userAppID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.conceptID.isEmpty {
      try visitor.visitSingularStringField(value: self.conceptID, fieldNumber: 2)
    }
    if !self.predicate.isEmpty {
      try visitor.visitSingularStringField(value: self.predicate, fieldNumber: 3)
    }
    if !self.knowledgeGraphID.isEmpty {
      try visitor.visitSingularStringField(value: self.knowledgeGraphID, fieldNumber: 4)
    }
    if self.page != 0 {
      try visitor.visitSingularUInt32Field(value: self.page, fieldNumber: 5)
    }
    if self.perPage != 0 {
      try visitor.visitSingularUInt32Field(value: self.perPage, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_ListConceptRelationsRequest, rhs: Clarifai_Api_ListConceptRelationsRequest) -> Bool {
    if lhs._userAppID != rhs._userAppID {return false}
    if lhs.conceptID != rhs.conceptID {return false}
    if lhs.predicate != rhs.predicate {return false}
    if lhs.knowledgeGraphID != rhs.knowledgeGraphID {return false}
    if lhs.page != rhs.page {return false}
    if lhs.perPage != rhs.perPage {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_PostConceptRelationsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PostConceptRelationsRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_app_id"),
    2: .standard(proto: "concept_id"),
    3: .standard(proto: "concept_relations"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._userAppID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.conceptID) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.conceptRelations) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._userAppID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.conceptID.isEmpty {
      try visitor.visitSingularStringField(value: self.conceptID, fieldNumber: 2)
    }
    if !self.conceptRelations.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.conceptRelations, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_PostConceptRelationsRequest, rhs: Clarifai_Api_PostConceptRelationsRequest) -> Bool {
    if lhs._userAppID != rhs._userAppID {return false}
    if lhs.conceptID != rhs.conceptID {return false}
    if lhs.conceptRelations != rhs.conceptRelations {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_DeleteConceptRelationsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DeleteConceptRelationsRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_app_id"),
    2: .standard(proto: "concept_id"),
    3: .same(proto: "ids"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._userAppID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.conceptID) }()
      case 3: try { try decoder.decodeRepeatedStringField(value: &self.ids) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._userAppID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.conceptID.isEmpty {
      try visitor.visitSingularStringField(value: self.conceptID, fieldNumber: 2)
    }
    if !self.ids.isEmpty {
      try visitor.visitRepeatedStringField(value: self.ids, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_DeleteConceptRelationsRequest, rhs: Clarifai_Api_DeleteConceptRelationsRequest) -> Bool {
    if lhs._userAppID != rhs._userAppID {return false}
    if lhs.conceptID != rhs.conceptID {return false}
    if lhs.ids != rhs.ids {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_ListKnowledgeGraphsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListKnowledgeGraphsRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_app_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._userAppID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._userAppID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_ListKnowledgeGraphsRequest, rhs: Clarifai_Api_ListKnowledgeGraphsRequest) -> Bool {
    if lhs._userAppID != rhs._userAppID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_PostKnowledgeGraphsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PostKnowledgeGraphsRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_app_id"),
    2: .standard(proto: "knowledge_graphs"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._userAppID) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.knowledgeGraphs) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._userAppID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.knowledgeGraphs.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.knowledgeGraphs, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_PostKnowledgeGraphsRequest, rhs: Clarifai_Api_PostKnowledgeGraphsRequest) -> Bool {
    if lhs._userAppID != rhs._userAppID {return false}
    if lhs.knowledgeGraphs != rhs.knowledgeGraphs {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_MultiConceptRelationResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MultiConceptRelationResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
    2: .standard(proto: "concept_relations"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._status) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.conceptRelations) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._status {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.conceptRelations.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.conceptRelations, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_MultiConceptRelationResponse, rhs: Clarifai_Api_MultiConceptRelationResponse) -> Bool {
    if lhs._status != rhs._status {return false}
    if lhs.conceptRelations != rhs.conceptRelations {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_MultiKnowledgeGraphResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MultiKnowledgeGraphResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
    2: .standard(proto: "knowledge_graphs"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._status) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.knowledgeGraphs) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._status {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.knowledgeGraphs.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.knowledgeGraphs, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_MultiKnowledgeGraphResponse, rhs: Clarifai_Api_MultiKnowledgeGraphResponse) -> Bool {
    if lhs._status != rhs._status {return false}
    if lhs.knowledgeGraphs != rhs.knowledgeGraphs {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_GetConceptLanguageRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetConceptLanguageRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_app_id"),
    2: .standard(proto: "concept_id"),
    3: .same(proto: "language"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._userAppID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.conceptID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.language) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._userAppID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.conceptID.isEmpty {
      try visitor.visitSingularStringField(value: self.conceptID, fieldNumber: 2)
    }
    if !self.language.isEmpty {
      try visitor.visitSingularStringField(value: self.language, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_GetConceptLanguageRequest, rhs: Clarifai_Api_GetConceptLanguageRequest) -> Bool {
    if lhs._userAppID != rhs._userAppID {return false}
    if lhs.conceptID != rhs.conceptID {return false}
    if lhs.language != rhs.language {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_ListConceptLanguagesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListConceptLanguagesRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_app_id"),
    2: .standard(proto: "concept_id"),
    3: .same(proto: "page"),
    4: .standard(proto: "per_page"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._userAppID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.conceptID) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.page) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self.perPage) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._userAppID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.conceptID.isEmpty {
      try visitor.visitSingularStringField(value: self.conceptID, fieldNumber: 2)
    }
    if self.page != 0 {
      try visitor.visitSingularUInt32Field(value: self.page, fieldNumber: 3)
    }
    if self.perPage != 0 {
      try visitor.visitSingularUInt32Field(value: self.perPage, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_ListConceptLanguagesRequest, rhs: Clarifai_Api_ListConceptLanguagesRequest) -> Bool {
    if lhs._userAppID != rhs._userAppID {return false}
    if lhs.conceptID != rhs.conceptID {return false}
    if lhs.page != rhs.page {return false}
    if lhs.perPage != rhs.perPage {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_PatchConceptLanguagesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PatchConceptLanguagesRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_app_id"),
    2: .standard(proto: "concept_id"),
    3: .standard(proto: "concept_languages"),
    4: .same(proto: "action"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._userAppID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.conceptID) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.conceptLanguages) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.action) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._userAppID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.conceptID.isEmpty {
      try visitor.visitSingularStringField(value: self.conceptID, fieldNumber: 2)
    }
    if !self.conceptLanguages.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.conceptLanguages, fieldNumber: 3)
    }
    if !self.action.isEmpty {
      try visitor.visitSingularStringField(value: self.action, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_PatchConceptLanguagesRequest, rhs: Clarifai_Api_PatchConceptLanguagesRequest) -> Bool {
    if lhs._userAppID != rhs._userAppID {return false}
    if lhs.conceptID != rhs.conceptID {return false}
    if lhs.conceptLanguages != rhs.conceptLanguages {return false}
    if lhs.action != rhs.action {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_PostConceptLanguagesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PostConceptLanguagesRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_app_id"),
    2: .standard(proto: "concept_id"),
    3: .standard(proto: "concept_languages"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._userAppID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.conceptID) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.conceptLanguages) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._userAppID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.conceptID.isEmpty {
      try visitor.visitSingularStringField(value: self.conceptID, fieldNumber: 2)
    }
    if !self.conceptLanguages.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.conceptLanguages, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_PostConceptLanguagesRequest, rhs: Clarifai_Api_PostConceptLanguagesRequest) -> Bool {
    if lhs._userAppID != rhs._userAppID {return false}
    if lhs.conceptID != rhs.conceptID {return false}
    if lhs.conceptLanguages != rhs.conceptLanguages {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_SingleConceptLanguageResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SingleConceptLanguageResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
    2: .standard(proto: "concept_language"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._status) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._conceptLanguage) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._status {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._conceptLanguage {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_SingleConceptLanguageResponse, rhs: Clarifai_Api_SingleConceptLanguageResponse) -> Bool {
    if lhs._status != rhs._status {return false}
    if lhs._conceptLanguage != rhs._conceptLanguage {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_MultiConceptLanguageResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MultiConceptLanguageResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
    2: .standard(proto: "concept_languages"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._status) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.conceptLanguages) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._status {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.conceptLanguages.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.conceptLanguages, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_MultiConceptLanguageResponse, rhs: Clarifai_Api_MultiConceptLanguageResponse) -> Bool {
    if lhs._status != rhs._status {return false}
    if lhs.conceptLanguages != rhs.conceptLanguages {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_GetInputRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetInputRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_app_id"),
    2: .standard(proto: "input_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._userAppID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.inputID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._userAppID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.inputID.isEmpty {
      try visitor.visitSingularStringField(value: self.inputID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_GetInputRequest, rhs: Clarifai_Api_GetInputRequest) -> Bool {
    if lhs._userAppID != rhs._userAppID {return false}
    if lhs.inputID != rhs.inputID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_GetVideoManifestRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetVideoManifestRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_app_id"),
    2: .standard(proto: "input_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._userAppID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.inputID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._userAppID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.inputID.isEmpty {
      try visitor.visitSingularStringField(value: self.inputID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_GetVideoManifestRequest, rhs: Clarifai_Api_GetVideoManifestRequest) -> Bool {
    if lhs._userAppID != rhs._userAppID {return false}
    if lhs.inputID != rhs.inputID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_GetInputSamplesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetInputSamplesRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_app_id"),
    2: .standard(proto: "task_id"),
    3: .standard(proto: "user_ids"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._userAppID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.taskID) }()
      case 3: try { try decoder.decodeRepeatedStringField(value: &self.userIds) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._userAppID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.taskID.isEmpty {
      try visitor.visitSingularStringField(value: self.taskID, fieldNumber: 2)
    }
    if !self.userIds.isEmpty {
      try visitor.visitRepeatedStringField(value: self.userIds, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_GetInputSamplesRequest, rhs: Clarifai_Api_GetInputSamplesRequest) -> Bool {
    if lhs._userAppID != rhs._userAppID {return false}
    if lhs.taskID != rhs.taskID {return false}
    if lhs.userIds != rhs.userIds {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_ListInputsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListInputsRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_app_id"),
    2: .same(proto: "page"),
    3: .standard(proto: "per_page"),
    5: .same(proto: "status"),
    4: .same(proto: "ids"),
  ]

  fileprivate class _StorageClass {
    var _userAppID: Clarifai_Api_UserAppIDSet? = nil
    var _page: UInt32 = 0
    var _perPage: UInt32 = 0
    var _status: Clarifai_Api_Status_Status? = nil
    var _ids: [String] = []

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _userAppID = source._userAppID
      _page = source._page
      _perPage = source._perPage
      _status = source._status
      _ids = source._ids
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._userAppID) }()
        case 2: try { try decoder.decodeSingularUInt32Field(value: &_storage._page) }()
        case 3: try { try decoder.decodeSingularUInt32Field(value: &_storage._perPage) }()
        case 4: try { try decoder.decodeRepeatedStringField(value: &_storage._ids) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._status) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._userAppID {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      if _storage._page != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._page, fieldNumber: 2)
      }
      if _storage._perPage != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._perPage, fieldNumber: 3)
      }
      if !_storage._ids.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._ids, fieldNumber: 4)
      }
      try { if let v = _storage._status {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_ListInputsRequest, rhs: Clarifai_Api_ListInputsRequest) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._userAppID != rhs_storage._userAppID {return false}
        if _storage._page != rhs_storage._page {return false}
        if _storage._perPage != rhs_storage._perPage {return false}
        if _storage._status != rhs_storage._status {return false}
        if _storage._ids != rhs_storage._ids {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_StreamInputsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".StreamInputsRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_app_id"),
    2: .standard(proto: "per_page"),
    3: .standard(proto: "last_id"),
    5: .standard(proto: "order_by_id"),
    4: .same(proto: "descending"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._userAppID) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.perPage) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.lastID) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.descending) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.orderByID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._userAppID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.perPage != 0 {
      try visitor.visitSingularUInt32Field(value: self.perPage, fieldNumber: 2)
    }
    if !self.lastID.isEmpty {
      try visitor.visitSingularStringField(value: self.lastID, fieldNumber: 3)
    }
    if self.descending != false {
      try visitor.visitSingularBoolField(value: self.descending, fieldNumber: 4)
    }
    if self.orderByID != false {
      try visitor.visitSingularBoolField(value: self.orderByID, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_StreamInputsRequest, rhs: Clarifai_Api_StreamInputsRequest) -> Bool {
    if lhs._userAppID != rhs._userAppID {return false}
    if lhs.perPage != rhs.perPage {return false}
    if lhs.lastID != rhs.lastID {return false}
    if lhs.orderByID != rhs.orderByID {return false}
    if lhs.descending != rhs.descending {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_PostInputsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PostInputsRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_app_id"),
    2: .same(proto: "inputs"),
    3: .standard(proto: "inputs_add_job_id"),
    4: .standard(proto: "input_id_conflict_resolution"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._userAppID) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.inputs) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.inputsAddJobID) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self.inputIDConflictResolution) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._userAppID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.inputs.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.inputs, fieldNumber: 2)
    }
    if !self.inputsAddJobID.isEmpty {
      try visitor.visitSingularStringField(value: self.inputsAddJobID, fieldNumber: 3)
    }
    if self.inputIDConflictResolution != .notSet {
      try visitor.visitSingularEnumField(value: self.inputIDConflictResolution, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_PostInputsRequest, rhs: Clarifai_Api_PostInputsRequest) -> Bool {
    if lhs._userAppID != rhs._userAppID {return false}
    if lhs.inputs != rhs.inputs {return false}
    if lhs.inputsAddJobID != rhs.inputsAddJobID {return false}
    if lhs.inputIDConflictResolution != rhs.inputIDConflictResolution {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_PatchInputsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PatchInputsRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_app_id"),
    2: .same(proto: "inputs"),
    3: .same(proto: "action"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._userAppID) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.inputs) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.action) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._userAppID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.inputs.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.inputs, fieldNumber: 2)
    }
    if !self.action.isEmpty {
      try visitor.visitSingularStringField(value: self.action, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_PatchInputsRequest, rhs: Clarifai_Api_PatchInputsRequest) -> Bool {
    if lhs._userAppID != rhs._userAppID {return false}
    if lhs.inputs != rhs.inputs {return false}
    if lhs.action != rhs.action {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_DeleteInputRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DeleteInputRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_app_id"),
    2: .standard(proto: "input_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._userAppID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.inputID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._userAppID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.inputID.isEmpty {
      try visitor.visitSingularStringField(value: self.inputID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_DeleteInputRequest, rhs: Clarifai_Api_DeleteInputRequest) -> Bool {
    if lhs._userAppID != rhs._userAppID {return false}
    if lhs.inputID != rhs.inputID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_DeleteInputsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DeleteInputsRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_app_id"),
    2: .same(proto: "ids"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._userAppID) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.ids) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._userAppID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.ids.isEmpty {
      try visitor.visitRepeatedStringField(value: self.ids, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_DeleteInputsRequest, rhs: Clarifai_Api_DeleteInputsRequest) -> Bool {
    if lhs._userAppID != rhs._userAppID {return false}
    if lhs.ids != rhs.ids {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_SingleInputResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SingleInputResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
    2: .same(proto: "input"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._status) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._input) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._status {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._input {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_SingleInputResponse, rhs: Clarifai_Api_SingleInputResponse) -> Bool {
    if lhs._status != rhs._status {return false}
    if lhs._input != rhs._input {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_GetVideoManifestResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetVideoManifestResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
    2: .standard(proto: "manifest_url"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._status) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.manifestURL) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._status {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.manifestURL.isEmpty {
      try visitor.visitSingularStringField(value: self.manifestURL, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_GetVideoManifestResponse, rhs: Clarifai_Api_GetVideoManifestResponse) -> Bool {
    if lhs._status != rhs._status {return false}
    if lhs.manifestURL != rhs.manifestURL {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_MultiInputResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MultiInputResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
    2: .same(proto: "inputs"),
    3: .standard(proto: "inputs_add_job"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._status) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.inputs) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._inputsAddJob) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._status {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.inputs.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.inputs, fieldNumber: 2)
    }
    try { if let v = self._inputsAddJob {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_MultiInputResponse, rhs: Clarifai_Api_MultiInputResponse) -> Bool {
    if lhs._status != rhs._status {return false}
    if lhs.inputs != rhs.inputs {return false}
    if lhs._inputsAddJob != rhs._inputsAddJob {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_MultiInputAnnotationResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MultiInputAnnotationResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
    3: .same(proto: "hits"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._status) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.hits) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._status {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.hits.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.hits, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_MultiInputAnnotationResponse, rhs: Clarifai_Api_MultiInputAnnotationResponse) -> Bool {
    if lhs._status != rhs._status {return false}
    if lhs.hits != rhs.hits {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_SingleInputCountResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SingleInputCountResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
    2: .same(proto: "counts"),
  ]

  fileprivate class _StorageClass {
    var _status: Clarifai_Api_Status_Status? = nil
    var _counts: Clarifai_Api_InputCount? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _status = source._status
      _counts = source._counts
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._status) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._counts) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._status {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._counts {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_SingleInputCountResponse, rhs: Clarifai_Api_SingleInputCountResponse) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._status != rhs_storage._status {return false}
        if _storage._counts != rhs_storage._counts {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_GetInputCountRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetInputCountRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_app_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._userAppID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._userAppID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_GetInputCountRequest, rhs: Clarifai_Api_GetInputCountRequest) -> Bool {
    if lhs._userAppID != rhs._userAppID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_ListDatasetsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListDatasetsRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_app_id"),
    2: .same(proto: "page"),
    3: .standard(proto: "per_page"),
    5: .standard(proto: "additional_fields"),
    6: .standard(proto: "sort_ascending"),
    7: .standard(proto: "sort_by_created_at"),
    8: .standard(proto: "sort_by_star_count"),
    9: .standard(proto: "sort_by_modified_at"),
    11: .standard(proto: "sort_by_id"),
    4: .standard(proto: "starred_only"),
    10: .same(proto: "bookmark"),
    13: .same(proto: "search"),
    12: .same(proto: "id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._userAppID) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.page) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.perPage) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.starredOnly) }()
      case 5: try { try decoder.decodeRepeatedStringField(value: &self.additionalFields) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self.sortAscending) }()
      case 7: try {
        var v: Bool?
        try decoder.decodeSingularBoolField(value: &v)
        if let v = v {
          if self.sortBy != nil {try decoder.handleConflictingOneOf()}
          self.sortBy = .sortByCreatedAt(v)
        }
      }()
      case 8: try {
        var v: Bool?
        try decoder.decodeSingularBoolField(value: &v)
        if let v = v {
          if self.sortBy != nil {try decoder.handleConflictingOneOf()}
          self.sortBy = .sortByStarCount(v)
        }
      }()
      case 9: try {
        var v: Bool?
        try decoder.decodeSingularBoolField(value: &v)
        if let v = v {
          if self.sortBy != nil {try decoder.handleConflictingOneOf()}
          self.sortBy = .sortByModifiedAt(v)
        }
      }()
      case 10: try { try decoder.decodeSingularBoolField(value: &self.bookmark) }()
      case 11: try {
        var v: Bool?
        try decoder.decodeSingularBoolField(value: &v)
        if let v = v {
          if self.sortBy != nil {try decoder.handleConflictingOneOf()}
          self.sortBy = .sortByID(v)
        }
      }()
      case 12: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 13: try { try decoder.decodeSingularStringField(value: &self.search) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._userAppID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.page != 0 {
      try visitor.visitSingularUInt32Field(value: self.page, fieldNumber: 2)
    }
    if self.perPage != 0 {
      try visitor.visitSingularUInt32Field(value: self.perPage, fieldNumber: 3)
    }
    if self.starredOnly != false {
      try visitor.visitSingularBoolField(value: self.starredOnly, fieldNumber: 4)
    }
    if !self.additionalFields.isEmpty {
      try visitor.visitRepeatedStringField(value: self.additionalFields, fieldNumber: 5)
    }
    if self.sortAscending != false {
      try visitor.visitSingularBoolField(value: self.sortAscending, fieldNumber: 6)
    }
    switch self.sortBy {
    case .sortByCreatedAt?: try {
      guard case .sortByCreatedAt(let v)? = self.sortBy else { preconditionFailure() }
      try visitor.visitSingularBoolField(value: v, fieldNumber: 7)
    }()
    case .sortByStarCount?: try {
      guard case .sortByStarCount(let v)? = self.sortBy else { preconditionFailure() }
      try visitor.visitSingularBoolField(value: v, fieldNumber: 8)
    }()
    case .sortByModifiedAt?: try {
      guard case .sortByModifiedAt(let v)? = self.sortBy else { preconditionFailure() }
      try visitor.visitSingularBoolField(value: v, fieldNumber: 9)
    }()
    default: break
    }
    if self.bookmark != false {
      try visitor.visitSingularBoolField(value: self.bookmark, fieldNumber: 10)
    }
    try { if case .sortByID(let v)? = self.sortBy {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 11)
    } }()
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 12)
    }
    if !self.search.isEmpty {
      try visitor.visitSingularStringField(value: self.search, fieldNumber: 13)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_ListDatasetsRequest, rhs: Clarifai_Api_ListDatasetsRequest) -> Bool {
    if lhs._userAppID != rhs._userAppID {return false}
    if lhs.page != rhs.page {return false}
    if lhs.perPage != rhs.perPage {return false}
    if lhs.additionalFields != rhs.additionalFields {return false}
    if lhs.sortAscending != rhs.sortAscending {return false}
    if lhs.sortBy != rhs.sortBy {return false}
    if lhs.starredOnly != rhs.starredOnly {return false}
    if lhs.bookmark != rhs.bookmark {return false}
    if lhs.search != rhs.search {return false}
    if lhs.id != rhs.id {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_GetDatasetRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetDatasetRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_app_id"),
    2: .standard(proto: "dataset_id"),
    3: .standard(proto: "additional_fields"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._userAppID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.datasetID) }()
      case 3: try { try decoder.decodeRepeatedStringField(value: &self.additionalFields) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._userAppID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.datasetID.isEmpty {
      try visitor.visitSingularStringField(value: self.datasetID, fieldNumber: 2)
    }
    if !self.additionalFields.isEmpty {
      try visitor.visitRepeatedStringField(value: self.additionalFields, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_GetDatasetRequest, rhs: Clarifai_Api_GetDatasetRequest) -> Bool {
    if lhs._userAppID != rhs._userAppID {return false}
    if lhs.datasetID != rhs.datasetID {return false}
    if lhs.additionalFields != rhs.additionalFields {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_PostDatasetsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PostDatasetsRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_app_id"),
    2: .same(proto: "datasets"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._userAppID) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.datasets) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._userAppID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.datasets.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.datasets, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_PostDatasetsRequest, rhs: Clarifai_Api_PostDatasetsRequest) -> Bool {
    if lhs._userAppID != rhs._userAppID {return false}
    if lhs.datasets != rhs.datasets {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_PatchDatasetsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PatchDatasetsRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_app_id"),
    2: .same(proto: "datasets"),
    3: .same(proto: "action"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._userAppID) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.datasets) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.action) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._userAppID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.datasets.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.datasets, fieldNumber: 2)
    }
    if !self.action.isEmpty {
      try visitor.visitSingularStringField(value: self.action, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_PatchDatasetsRequest, rhs: Clarifai_Api_PatchDatasetsRequest) -> Bool {
    if lhs._userAppID != rhs._userAppID {return false}
    if lhs.datasets != rhs.datasets {return false}
    if lhs.action != rhs.action {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_DeleteDatasetsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DeleteDatasetsRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_app_id"),
    2: .standard(proto: "dataset_ids"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._userAppID) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.datasetIds) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._userAppID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.datasetIds.isEmpty {
      try visitor.visitRepeatedStringField(value: self.datasetIds, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_DeleteDatasetsRequest, rhs: Clarifai_Api_DeleteDatasetsRequest) -> Bool {
    if lhs._userAppID != rhs._userAppID {return false}
    if lhs.datasetIds != rhs.datasetIds {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_MultiDatasetResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MultiDatasetResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
    2: .same(proto: "datasets"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._status) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.datasets) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._status {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.datasets.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.datasets, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_MultiDatasetResponse, rhs: Clarifai_Api_MultiDatasetResponse) -> Bool {
    if lhs._status != rhs._status {return false}
    if lhs.datasets != rhs.datasets {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_SingleDatasetResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SingleDatasetResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
    2: .same(proto: "dataset"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._status) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._dataset) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._status {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._dataset {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_SingleDatasetResponse, rhs: Clarifai_Api_SingleDatasetResponse) -> Bool {
    if lhs._status != rhs._status {return false}
    if lhs._dataset != rhs._dataset {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_ListDatasetInputsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListDatasetInputsRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_app_id"),
    2: .standard(proto: "dataset_id"),
    3: .same(proto: "page"),
    4: .standard(proto: "per_page"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._userAppID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.datasetID) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.page) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self.perPage) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._userAppID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.datasetID.isEmpty {
      try visitor.visitSingularStringField(value: self.datasetID, fieldNumber: 2)
    }
    if self.page != 0 {
      try visitor.visitSingularUInt32Field(value: self.page, fieldNumber: 3)
    }
    if self.perPage != 0 {
      try visitor.visitSingularUInt32Field(value: self.perPage, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_ListDatasetInputsRequest, rhs: Clarifai_Api_ListDatasetInputsRequest) -> Bool {
    if lhs._userAppID != rhs._userAppID {return false}
    if lhs.datasetID != rhs.datasetID {return false}
    if lhs.page != rhs.page {return false}
    if lhs.perPage != rhs.perPage {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_GetDatasetInputRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetDatasetInputRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_app_id"),
    2: .standard(proto: "dataset_id"),
    3: .standard(proto: "input_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._userAppID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.datasetID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.inputID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._userAppID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.datasetID.isEmpty {
      try visitor.visitSingularStringField(value: self.datasetID, fieldNumber: 2)
    }
    if !self.inputID.isEmpty {
      try visitor.visitSingularStringField(value: self.inputID, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_GetDatasetInputRequest, rhs: Clarifai_Api_GetDatasetInputRequest) -> Bool {
    if lhs._userAppID != rhs._userAppID {return false}
    if lhs.datasetID != rhs.datasetID {return false}
    if lhs.inputID != rhs.inputID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_PostDatasetInputsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PostDatasetInputsRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_app_id"),
    2: .standard(proto: "dataset_id"),
    3: .standard(proto: "dataset_inputs"),
    4: .same(proto: "search"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._userAppID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.datasetID) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.datasetInputs) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._search) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._userAppID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.datasetID.isEmpty {
      try visitor.visitSingularStringField(value: self.datasetID, fieldNumber: 2)
    }
    if !self.datasetInputs.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.datasetInputs, fieldNumber: 3)
    }
    try { if let v = self._search {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_PostDatasetInputsRequest, rhs: Clarifai_Api_PostDatasetInputsRequest) -> Bool {
    if lhs._userAppID != rhs._userAppID {return false}
    if lhs.datasetID != rhs.datasetID {return false}
    if lhs.datasetInputs != rhs.datasetInputs {return false}
    if lhs._search != rhs._search {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_DeleteDatasetInputsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DeleteDatasetInputsRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_app_id"),
    2: .standard(proto: "dataset_id"),
    3: .standard(proto: "input_ids"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._userAppID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.datasetID) }()
      case 3: try { try decoder.decodeRepeatedStringField(value: &self.inputIds) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._userAppID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.datasetID.isEmpty {
      try visitor.visitSingularStringField(value: self.datasetID, fieldNumber: 2)
    }
    if !self.inputIds.isEmpty {
      try visitor.visitRepeatedStringField(value: self.inputIds, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_DeleteDatasetInputsRequest, rhs: Clarifai_Api_DeleteDatasetInputsRequest) -> Bool {
    if lhs._userAppID != rhs._userAppID {return false}
    if lhs.datasetID != rhs.datasetID {return false}
    if lhs.inputIds != rhs.inputIds {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_MultiDatasetInputResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MultiDatasetInputResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
    2: .standard(proto: "dataset_inputs"),
    4: .standard(proto: "bulk_operation"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._status) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.datasetInputs) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._bulkOperation) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._status {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.datasetInputs.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.datasetInputs, fieldNumber: 2)
    }
    try { if let v = self._bulkOperation {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_MultiDatasetInputResponse, rhs: Clarifai_Api_MultiDatasetInputResponse) -> Bool {
    if lhs._status != rhs._status {return false}
    if lhs.datasetInputs != rhs.datasetInputs {return false}
    if lhs._bulkOperation != rhs._bulkOperation {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_SingleDatasetInputResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SingleDatasetInputResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
    2: .standard(proto: "dataset_input"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._status) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._datasetInput) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._status {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._datasetInput {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_SingleDatasetInputResponse, rhs: Clarifai_Api_SingleDatasetInputResponse) -> Bool {
    if lhs._status != rhs._status {return false}
    if lhs._datasetInput != rhs._datasetInput {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_ListDatasetVersionsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListDatasetVersionsRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_app_id"),
    2: .standard(proto: "dataset_id"),
    3: .same(proto: "page"),
    4: .standard(proto: "per_page"),
    5: .standard(proto: "request_origins"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._userAppID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.datasetID) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.page) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self.perPage) }()
      case 5: try { try decoder.decodeRepeatedEnumField(value: &self.requestOrigins) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._userAppID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.datasetID.isEmpty {
      try visitor.visitSingularStringField(value: self.datasetID, fieldNumber: 2)
    }
    if self.page != 0 {
      try visitor.visitSingularUInt32Field(value: self.page, fieldNumber: 3)
    }
    if self.perPage != 0 {
      try visitor.visitSingularUInt32Field(value: self.perPage, fieldNumber: 4)
    }
    if !self.requestOrigins.isEmpty {
      try visitor.visitPackedEnumField(value: self.requestOrigins, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_ListDatasetVersionsRequest, rhs: Clarifai_Api_ListDatasetVersionsRequest) -> Bool {
    if lhs._userAppID != rhs._userAppID {return false}
    if lhs.datasetID != rhs.datasetID {return false}
    if lhs.page != rhs.page {return false}
    if lhs.perPage != rhs.perPage {return false}
    if lhs.requestOrigins != rhs.requestOrigins {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_GetDatasetVersionRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetDatasetVersionRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_app_id"),
    2: .standard(proto: "dataset_id"),
    3: .standard(proto: "dataset_version_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._userAppID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.datasetID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.datasetVersionID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._userAppID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.datasetID.isEmpty {
      try visitor.visitSingularStringField(value: self.datasetID, fieldNumber: 2)
    }
    if !self.datasetVersionID.isEmpty {
      try visitor.visitSingularStringField(value: self.datasetVersionID, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_GetDatasetVersionRequest, rhs: Clarifai_Api_GetDatasetVersionRequest) -> Bool {
    if lhs._userAppID != rhs._userAppID {return false}
    if lhs.datasetID != rhs.datasetID {return false}
    if lhs.datasetVersionID != rhs.datasetVersionID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_ListDatasetVersionMetricsGroupsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListDatasetVersionMetricsGroupsRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_app_id"),
    2: .standard(proto: "dataset_id"),
    3: .standard(proto: "dataset_version_id"),
    4: .same(proto: "page"),
    5: .standard(proto: "per_page"),
    6: .standard(proto: "parent_paths"),
    7: .same(proto: "types"),
    8: .same(proto: "values"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._userAppID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.datasetID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.datasetVersionID) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self.page) }()
      case 5: try { try decoder.decodeSingularUInt32Field(value: &self.perPage) }()
      case 6: try { try decoder.decodeRepeatedStringField(value: &self.parentPaths) }()
      case 7: try { try decoder.decodeRepeatedEnumField(value: &self.types) }()
      case 8: try { try decoder.decodeRepeatedMessageField(value: &self.values) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._userAppID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.datasetID.isEmpty {
      try visitor.visitSingularStringField(value: self.datasetID, fieldNumber: 2)
    }
    if !self.datasetVersionID.isEmpty {
      try visitor.visitSingularStringField(value: self.datasetVersionID, fieldNumber: 3)
    }
    if self.page != 0 {
      try visitor.visitSingularUInt32Field(value: self.page, fieldNumber: 4)
    }
    if self.perPage != 0 {
      try visitor.visitSingularUInt32Field(value: self.perPage, fieldNumber: 5)
    }
    if !self.parentPaths.isEmpty {
      try visitor.visitRepeatedStringField(value: self.parentPaths, fieldNumber: 6)
    }
    if !self.types.isEmpty {
      try visitor.visitPackedEnumField(value: self.types, fieldNumber: 7)
    }
    if !self.values.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.values, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_ListDatasetVersionMetricsGroupsRequest, rhs: Clarifai_Api_ListDatasetVersionMetricsGroupsRequest) -> Bool {
    if lhs._userAppID != rhs._userAppID {return false}
    if lhs.datasetID != rhs.datasetID {return false}
    if lhs.datasetVersionID != rhs.datasetVersionID {return false}
    if lhs.page != rhs.page {return false}
    if lhs.perPage != rhs.perPage {return false}
    if lhs.parentPaths != rhs.parentPaths {return false}
    if lhs.types != rhs.types {return false}
    if lhs.values != rhs.values {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_PostDatasetVersionsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PostDatasetVersionsRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_app_id"),
    2: .standard(proto: "dataset_id"),
    3: .standard(proto: "dataset_versions"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._userAppID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.datasetID) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.datasetVersions) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._userAppID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.datasetID.isEmpty {
      try visitor.visitSingularStringField(value: self.datasetID, fieldNumber: 2)
    }
    if !self.datasetVersions.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.datasetVersions, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_PostDatasetVersionsRequest, rhs: Clarifai_Api_PostDatasetVersionsRequest) -> Bool {
    if lhs._userAppID != rhs._userAppID {return false}
    if lhs.datasetID != rhs.datasetID {return false}
    if lhs.datasetVersions != rhs.datasetVersions {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_PatchDatasetVersionsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PatchDatasetVersionsRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_app_id"),
    2: .standard(proto: "dataset_id"),
    3: .standard(proto: "dataset_versions"),
    4: .same(proto: "action"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._userAppID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.datasetID) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.datasetVersions) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.action) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._userAppID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.datasetID.isEmpty {
      try visitor.visitSingularStringField(value: self.datasetID, fieldNumber: 2)
    }
    if !self.datasetVersions.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.datasetVersions, fieldNumber: 3)
    }
    if !self.action.isEmpty {
      try visitor.visitSingularStringField(value: self.action, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_PatchDatasetVersionsRequest, rhs: Clarifai_Api_PatchDatasetVersionsRequest) -> Bool {
    if lhs._userAppID != rhs._userAppID {return false}
    if lhs.datasetID != rhs.datasetID {return false}
    if lhs.datasetVersions != rhs.datasetVersions {return false}
    if lhs.action != rhs.action {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_DeleteDatasetVersionsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DeleteDatasetVersionsRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_app_id"),
    2: .standard(proto: "dataset_id"),
    3: .standard(proto: "dataset_version_ids"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._userAppID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.datasetID) }()
      case 3: try { try decoder.decodeRepeatedStringField(value: &self.datasetVersionIds) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._userAppID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.datasetID.isEmpty {
      try visitor.visitSingularStringField(value: self.datasetID, fieldNumber: 2)
    }
    if !self.datasetVersionIds.isEmpty {
      try visitor.visitRepeatedStringField(value: self.datasetVersionIds, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_DeleteDatasetVersionsRequest, rhs: Clarifai_Api_DeleteDatasetVersionsRequest) -> Bool {
    if lhs._userAppID != rhs._userAppID {return false}
    if lhs.datasetID != rhs.datasetID {return false}
    if lhs.datasetVersionIds != rhs.datasetVersionIds {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_PutDatasetVersionExportsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PutDatasetVersionExportsRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_app_id"),
    2: .standard(proto: "dataset_id"),
    3: .standard(proto: "dataset_version_id"),
    4: .same(proto: "exports"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._userAppID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.datasetID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.datasetVersionID) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.exports) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._userAppID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.datasetID.isEmpty {
      try visitor.visitSingularStringField(value: self.datasetID, fieldNumber: 2)
    }
    if !self.datasetVersionID.isEmpty {
      try visitor.visitSingularStringField(value: self.datasetVersionID, fieldNumber: 3)
    }
    if !self.exports.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.exports, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_PutDatasetVersionExportsRequest, rhs: Clarifai_Api_PutDatasetVersionExportsRequest) -> Bool {
    if lhs._userAppID != rhs._userAppID {return false}
    if lhs.datasetID != rhs.datasetID {return false}
    if lhs.datasetVersionID != rhs.datasetVersionID {return false}
    if lhs.exports != rhs.exports {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_MultiDatasetVersionResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MultiDatasetVersionResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
    2: .standard(proto: "dataset_versions"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._status) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.datasetVersions) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._status {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.datasetVersions.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.datasetVersions, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_MultiDatasetVersionResponse, rhs: Clarifai_Api_MultiDatasetVersionResponse) -> Bool {
    if lhs._status != rhs._status {return false}
    if lhs.datasetVersions != rhs.datasetVersions {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_MultiDatasetVersionExportResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MultiDatasetVersionExportResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
    2: .same(proto: "exports"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._status) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.exports) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._status {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.exports.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.exports, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_MultiDatasetVersionExportResponse, rhs: Clarifai_Api_MultiDatasetVersionExportResponse) -> Bool {
    if lhs._status != rhs._status {return false}
    if lhs.exports != rhs.exports {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_MultiDatasetVersionMetricsGroupResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MultiDatasetVersionMetricsGroupResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
    2: .standard(proto: "dataset_version_metrics_groups"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._status) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.datasetVersionMetricsGroups) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._status {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.datasetVersionMetricsGroups.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.datasetVersionMetricsGroups, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_MultiDatasetVersionMetricsGroupResponse, rhs: Clarifai_Api_MultiDatasetVersionMetricsGroupResponse) -> Bool {
    if lhs._status != rhs._status {return false}
    if lhs.datasetVersionMetricsGroups != rhs.datasetVersionMetricsGroups {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_SingleDatasetVersionResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SingleDatasetVersionResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
    2: .standard(proto: "dataset_version"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._status) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._datasetVersion) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._status {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._datasetVersion {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_SingleDatasetVersionResponse, rhs: Clarifai_Api_SingleDatasetVersionResponse) -> Bool {
    if lhs._status != rhs._status {return false}
    if lhs._datasetVersion != rhs._datasetVersion {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_PostModelOutputsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PostModelOutputsRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_app_id"),
    2: .standard(proto: "model_id"),
    3: .standard(proto: "version_id"),
    4: .same(proto: "inputs"),
    5: .same(proto: "model"),
    6: .standard(proto: "runner_selector"),
    7: .standard(proto: "use_predict_cache"),
    8: .standard(proto: "enable_log_summary_on_error"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._userAppID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.modelID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.versionID) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.inputs) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._model) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._runnerSelector) }()
      case 7: try { try decoder.decodeSingularBoolField(value: &self.usePredictCache) }()
      case 8: try { try decoder.decodeSingularBoolField(value: &self.enableLogSummaryOnError) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._userAppID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.modelID.isEmpty {
      try visitor.visitSingularStringField(value: self.modelID, fieldNumber: 2)
    }
    if !self.versionID.isEmpty {
      try visitor.visitSingularStringField(value: self.versionID, fieldNumber: 3)
    }
    if !self.inputs.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.inputs, fieldNumber: 4)
    }
    try { if let v = self._model {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._runnerSelector {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    if self.usePredictCache != false {
      try visitor.visitSingularBoolField(value: self.usePredictCache, fieldNumber: 7)
    }
    if self.enableLogSummaryOnError != false {
      try visitor.visitSingularBoolField(value: self.enableLogSummaryOnError, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_PostModelOutputsRequest, rhs: Clarifai_Api_PostModelOutputsRequest) -> Bool {
    if lhs._userAppID != rhs._userAppID {return false}
    if lhs.modelID != rhs.modelID {return false}
    if lhs.versionID != rhs.versionID {return false}
    if lhs.inputs != rhs.inputs {return false}
    if lhs._model != rhs._model {return false}
    if lhs._runnerSelector != rhs._runnerSelector {return false}
    if lhs.usePredictCache != rhs.usePredictCache {return false}
    if lhs.enableLogSummaryOnError != rhs.enableLogSummaryOnError {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_ListModelInputsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListModelInputsRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_app_id"),
    2: .standard(proto: "model_id"),
    3: .standard(proto: "version_id"),
    4: .same(proto: "page"),
    5: .standard(proto: "per_page"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._userAppID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.modelID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.versionID) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self.page) }()
      case 5: try { try decoder.decodeSingularUInt32Field(value: &self.perPage) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._userAppID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.modelID.isEmpty {
      try visitor.visitSingularStringField(value: self.modelID, fieldNumber: 2)
    }
    if !self.versionID.isEmpty {
      try visitor.visitSingularStringField(value: self.versionID, fieldNumber: 3)
    }
    if self.page != 0 {
      try visitor.visitSingularUInt32Field(value: self.page, fieldNumber: 4)
    }
    if self.perPage != 0 {
      try visitor.visitSingularUInt32Field(value: self.perPage, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_ListModelInputsRequest, rhs: Clarifai_Api_ListModelInputsRequest) -> Bool {
    if lhs._userAppID != rhs._userAppID {return false}
    if lhs.modelID != rhs.modelID {return false}
    if lhs.versionID != rhs.versionID {return false}
    if lhs.page != rhs.page {return false}
    if lhs.perPage != rhs.perPage {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_PostComputePlaneMetricsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PostComputePlaneMetricsRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "compute_plane_metrics"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.computePlaneMetrics) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.computePlaneMetrics.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.computePlaneMetrics, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_PostComputePlaneMetricsRequest, rhs: Clarifai_Api_PostComputePlaneMetricsRequest) -> Bool {
    if lhs.computePlaneMetrics != rhs.computePlaneMetrics {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_PostLogEntriesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PostLogEntriesRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "log_entries"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.logEntries) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.logEntries.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.logEntries, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_PostLogEntriesRequest, rhs: Clarifai_Api_PostLogEntriesRequest) -> Bool {
    if lhs.logEntries != rhs.logEntries {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_ListLogEntriesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListLogEntriesRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "page"),
    2: .standard(proto: "per_page"),
    3: .standard(proto: "log_type"),
    4: .standard(proto: "user_app_id"),
    5: .standard(proto: "model_id"),
    6: .standard(proto: "model_version_id"),
    7: .standard(proto: "workflow_id"),
    17: .standard(proto: "compute_cluster_user_id"),
    9: .standard(proto: "compute_cluster_id"),
    10: .standard(proto: "nodepool_id"),
    11: .standard(proto: "runner_id"),
    12: .standard(proto: "pipeline_id"),
    13: .standard(proto: "pipeline_version_id"),
    14: .standard(proto: "pipeline_version_run_id"),
    15: .standard(proto: "pipeline_step_id"),
    16: .standard(proto: "pipeline_step_version_id"),
  ]

  fileprivate class _StorageClass {
    var _page: UInt32 = 0
    var _perPage: UInt32 = 0
    var _logType: String = String()
    var _userAppID: Clarifai_Api_UserAppIDSet? = nil
    var _modelID: String = String()
    var _modelVersionID: String = String()
    var _workflowID: String = String()
    var _computeClusterUserID: String = String()
    var _computeClusterID: String = String()
    var _nodepoolID: String = String()
    var _runnerID: String = String()
    var _pipelineID: String = String()
    var _pipelineVersionID: String = String()
    var _pipelineVersionRunID: String = String()
    var _pipelineStepID: String = String()
    var _pipelineStepVersionID: String = String()

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _page = source._page
      _perPage = source._perPage
      _logType = source._logType
      _userAppID = source._userAppID
      _modelID = source._modelID
      _modelVersionID = source._modelVersionID
      _workflowID = source._workflowID
      _computeClusterUserID = source._computeClusterUserID
      _computeClusterID = source._computeClusterID
      _nodepoolID = source._nodepoolID
      _runnerID = source._runnerID
      _pipelineID = source._pipelineID
      _pipelineVersionID = source._pipelineVersionID
      _pipelineVersionRunID = source._pipelineVersionRunID
      _pipelineStepID = source._pipelineStepID
      _pipelineStepVersionID = source._pipelineStepVersionID
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularUInt32Field(value: &_storage._page) }()
        case 2: try { try decoder.decodeSingularUInt32Field(value: &_storage._perPage) }()
        case 3: try { try decoder.decodeSingularStringField(value: &_storage._logType) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._userAppID) }()
        case 5: try { try decoder.decodeSingularStringField(value: &_storage._modelID) }()
        case 6: try { try decoder.decodeSingularStringField(value: &_storage._modelVersionID) }()
        case 7: try { try decoder.decodeSingularStringField(value: &_storage._workflowID) }()
        case 9: try { try decoder.decodeSingularStringField(value: &_storage._computeClusterID) }()
        case 10: try { try decoder.decodeSingularStringField(value: &_storage._nodepoolID) }()
        case 11: try { try decoder.decodeSingularStringField(value: &_storage._runnerID) }()
        case 12: try { try decoder.decodeSingularStringField(value: &_storage._pipelineID) }()
        case 13: try { try decoder.decodeSingularStringField(value: &_storage._pipelineVersionID) }()
        case 14: try { try decoder.decodeSingularStringField(value: &_storage._pipelineVersionRunID) }()
        case 15: try { try decoder.decodeSingularStringField(value: &_storage._pipelineStepID) }()
        case 16: try { try decoder.decodeSingularStringField(value: &_storage._pipelineStepVersionID) }()
        case 17: try { try decoder.decodeSingularStringField(value: &_storage._computeClusterUserID) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if _storage._page != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._page, fieldNumber: 1)
      }
      if _storage._perPage != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._perPage, fieldNumber: 2)
      }
      if !_storage._logType.isEmpty {
        try visitor.visitSingularStringField(value: _storage._logType, fieldNumber: 3)
      }
      try { if let v = _storage._userAppID {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      if !_storage._modelID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._modelID, fieldNumber: 5)
      }
      if !_storage._modelVersionID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._modelVersionID, fieldNumber: 6)
      }
      if !_storage._workflowID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._workflowID, fieldNumber: 7)
      }
      if !_storage._computeClusterID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._computeClusterID, fieldNumber: 9)
      }
      if !_storage._nodepoolID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._nodepoolID, fieldNumber: 10)
      }
      if !_storage._runnerID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._runnerID, fieldNumber: 11)
      }
      if !_storage._pipelineID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._pipelineID, fieldNumber: 12)
      }
      if !_storage._pipelineVersionID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._pipelineVersionID, fieldNumber: 13)
      }
      if !_storage._pipelineVersionRunID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._pipelineVersionRunID, fieldNumber: 14)
      }
      if !_storage._pipelineStepID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._pipelineStepID, fieldNumber: 15)
      }
      if !_storage._pipelineStepVersionID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._pipelineStepVersionID, fieldNumber: 16)
      }
      if !_storage._computeClusterUserID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._computeClusterUserID, fieldNumber: 17)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_ListLogEntriesRequest, rhs: Clarifai_Api_ListLogEntriesRequest) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._page != rhs_storage._page {return false}
        if _storage._perPage != rhs_storage._perPage {return false}
        if _storage._logType != rhs_storage._logType {return false}
        if _storage._userAppID != rhs_storage._userAppID {return false}
        if _storage._modelID != rhs_storage._modelID {return false}
        if _storage._modelVersionID != rhs_storage._modelVersionID {return false}
        if _storage._workflowID != rhs_storage._workflowID {return false}
        if _storage._computeClusterUserID != rhs_storage._computeClusterUserID {return false}
        if _storage._computeClusterID != rhs_storage._computeClusterID {return false}
        if _storage._nodepoolID != rhs_storage._nodepoolID {return false}
        if _storage._runnerID != rhs_storage._runnerID {return false}
        if _storage._pipelineID != rhs_storage._pipelineID {return false}
        if _storage._pipelineVersionID != rhs_storage._pipelineVersionID {return false}
        if _storage._pipelineVersionRunID != rhs_storage._pipelineVersionRunID {return false}
        if _storage._pipelineStepID != rhs_storage._pipelineStepID {return false}
        if _storage._pipelineStepVersionID != rhs_storage._pipelineStepVersionID {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_StreamLogEntriesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".StreamLogEntriesRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "log_type"),
    2: .standard(proto: "user_app_id"),
    3: .standard(proto: "model_id"),
    4: .standard(proto: "model_version_id"),
    5: .standard(proto: "workflow_id"),
    17: .standard(proto: "compute_cluster_user_id"),
    6: .standard(proto: "compute_cluster_id"),
    7: .standard(proto: "nodepool_id"),
    8: .standard(proto: "runner_id"),
    12: .standard(proto: "pipeline_id"),
    13: .standard(proto: "pipeline_version_id"),
    14: .standard(proto: "pipeline_version_run_id"),
    15: .standard(proto: "pipeline_step_id"),
    16: .standard(proto: "pipeline_step_version_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.logType) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._userAppID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.modelID) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.modelVersionID) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.workflowID) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.computeClusterID) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.nodepoolID) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self.runnerID) }()
      case 12: try { try decoder.decodeSingularStringField(value: &self.pipelineID) }()
      case 13: try { try decoder.decodeSingularStringField(value: &self.pipelineVersionID) }()
      case 14: try { try decoder.decodeSingularStringField(value: &self.pipelineVersionRunID) }()
      case 15: try { try decoder.decodeSingularStringField(value: &self.pipelineStepID) }()
      case 16: try { try decoder.decodeSingularStringField(value: &self.pipelineStepVersionID) }()
      case 17: try { try decoder.decodeSingularStringField(value: &self.computeClusterUserID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.logType.isEmpty {
      try visitor.visitSingularStringField(value: self.logType, fieldNumber: 1)
    }
    try { if let v = self._userAppID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.modelID.isEmpty {
      try visitor.visitSingularStringField(value: self.modelID, fieldNumber: 3)
    }
    if !self.modelVersionID.isEmpty {
      try visitor.visitSingularStringField(value: self.modelVersionID, fieldNumber: 4)
    }
    if !self.workflowID.isEmpty {
      try visitor.visitSingularStringField(value: self.workflowID, fieldNumber: 5)
    }
    if !self.computeClusterID.isEmpty {
      try visitor.visitSingularStringField(value: self.computeClusterID, fieldNumber: 6)
    }
    if !self.nodepoolID.isEmpty {
      try visitor.visitSingularStringField(value: self.nodepoolID, fieldNumber: 7)
    }
    if !self.runnerID.isEmpty {
      try visitor.visitSingularStringField(value: self.runnerID, fieldNumber: 8)
    }
    if !self.pipelineID.isEmpty {
      try visitor.visitSingularStringField(value: self.pipelineID, fieldNumber: 12)
    }
    if !self.pipelineVersionID.isEmpty {
      try visitor.visitSingularStringField(value: self.pipelineVersionID, fieldNumber: 13)
    }
    if !self.pipelineVersionRunID.isEmpty {
      try visitor.visitSingularStringField(value: self.pipelineVersionRunID, fieldNumber: 14)
    }
    if !self.pipelineStepID.isEmpty {
      try visitor.visitSingularStringField(value: self.pipelineStepID, fieldNumber: 15)
    }
    if !self.pipelineStepVersionID.isEmpty {
      try visitor.visitSingularStringField(value: self.pipelineStepVersionID, fieldNumber: 16)
    }
    if !self.computeClusterUserID.isEmpty {
      try visitor.visitSingularStringField(value: self.computeClusterUserID, fieldNumber: 17)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_StreamLogEntriesRequest, rhs: Clarifai_Api_StreamLogEntriesRequest) -> Bool {
    if lhs.logType != rhs.logType {return false}
    if lhs._userAppID != rhs._userAppID {return false}
    if lhs.modelID != rhs.modelID {return false}
    if lhs.modelVersionID != rhs.modelVersionID {return false}
    if lhs.workflowID != rhs.workflowID {return false}
    if lhs.computeClusterUserID != rhs.computeClusterUserID {return false}
    if lhs.computeClusterID != rhs.computeClusterID {return false}
    if lhs.nodepoolID != rhs.nodepoolID {return false}
    if lhs.runnerID != rhs.runnerID {return false}
    if lhs.pipelineID != rhs.pipelineID {return false}
    if lhs.pipelineVersionID != rhs.pipelineVersionID {return false}
    if lhs.pipelineVersionRunID != rhs.pipelineVersionRunID {return false}
    if lhs.pipelineStepID != rhs.pipelineStepID {return false}
    if lhs.pipelineStepVersionID != rhs.pipelineStepVersionID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_GetKeyRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetKeyRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_app_id"),
    2: .standard(proto: "key_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._userAppID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.keyID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._userAppID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.keyID.isEmpty {
      try visitor.visitSingularStringField(value: self.keyID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_GetKeyRequest, rhs: Clarifai_Api_GetKeyRequest) -> Bool {
    if lhs._userAppID != rhs._userAppID {return false}
    if lhs.keyID != rhs.keyID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_ListKeysRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListKeysRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_app_id"),
    2: .same(proto: "page"),
    3: .standard(proto: "per_page"),
    4: .standard(proto: "not_expired"),
    5: .same(proto: "scopes"),
    6: .same(proto: "endpoints"),
    7: .same(proto: "type"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._userAppID) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.page) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.perPage) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.notExpired) }()
      case 5: try { try decoder.decodeRepeatedStringField(value: &self.scopes) }()
      case 6: try { try decoder.decodeRepeatedStringField(value: &self.endpoints) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.type) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._userAppID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.page != 0 {
      try visitor.visitSingularUInt32Field(value: self.page, fieldNumber: 2)
    }
    if self.perPage != 0 {
      try visitor.visitSingularUInt32Field(value: self.perPage, fieldNumber: 3)
    }
    if self.notExpired != false {
      try visitor.visitSingularBoolField(value: self.notExpired, fieldNumber: 4)
    }
    if !self.scopes.isEmpty {
      try visitor.visitRepeatedStringField(value: self.scopes, fieldNumber: 5)
    }
    if !self.endpoints.isEmpty {
      try visitor.visitRepeatedStringField(value: self.endpoints, fieldNumber: 6)
    }
    if !self.type.isEmpty {
      try visitor.visitSingularStringField(value: self.type, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_ListKeysRequest, rhs: Clarifai_Api_ListKeysRequest) -> Bool {
    if lhs._userAppID != rhs._userAppID {return false}
    if lhs.page != rhs.page {return false}
    if lhs.perPage != rhs.perPage {return false}
    if lhs.notExpired != rhs.notExpired {return false}
    if lhs.scopes != rhs.scopes {return false}
    if lhs.endpoints != rhs.endpoints {return false}
    if lhs.type != rhs.type {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_ListAppKeysRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListAppKeysRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_app_id"),
    2: .same(proto: "page"),
    3: .standard(proto: "per_page"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._userAppID) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.page) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.perPage) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._userAppID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.page != 0 {
      try visitor.visitSingularUInt32Field(value: self.page, fieldNumber: 2)
    }
    if self.perPage != 0 {
      try visitor.visitSingularUInt32Field(value: self.perPage, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_ListAppKeysRequest, rhs: Clarifai_Api_ListAppKeysRequest) -> Bool {
    if lhs._userAppID != rhs._userAppID {return false}
    if lhs.page != rhs.page {return false}
    if lhs.perPage != rhs.perPage {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_PostKeysRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PostKeysRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_app_id"),
    2: .same(proto: "keys"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._userAppID) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.keys) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._userAppID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.keys.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.keys, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_PostKeysRequest, rhs: Clarifai_Api_PostKeysRequest) -> Bool {
    if lhs._userAppID != rhs._userAppID {return false}
    if lhs.keys != rhs.keys {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_DeleteKeyRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DeleteKeyRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_app_id"),
    2: .standard(proto: "key_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._userAppID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.keyID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._userAppID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.keyID.isEmpty {
      try visitor.visitSingularStringField(value: self.keyID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_DeleteKeyRequest, rhs: Clarifai_Api_DeleteKeyRequest) -> Bool {
    if lhs._userAppID != rhs._userAppID {return false}
    if lhs.keyID != rhs.keyID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_PatchKeysRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PatchKeysRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_app_id"),
    2: .same(proto: "keys"),
    3: .same(proto: "action"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._userAppID) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.keys) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.action) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._userAppID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.keys.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.keys, fieldNumber: 2)
    }
    if !self.action.isEmpty {
      try visitor.visitSingularStringField(value: self.action, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_PatchKeysRequest, rhs: Clarifai_Api_PatchKeysRequest) -> Bool {
    if lhs._userAppID != rhs._userAppID {return false}
    if lhs.keys != rhs.keys {return false}
    if lhs.action != rhs.action {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_SingleKeyResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SingleKeyResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
    2: .same(proto: "key"),
  ]

  fileprivate class _StorageClass {
    var _status: Clarifai_Api_Status_Status? = nil
    var _key: Clarifai_Api_Key? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _status = source._status
      _key = source._key
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._status) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._key) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._status {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._key {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_SingleKeyResponse, rhs: Clarifai_Api_SingleKeyResponse) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._status != rhs_storage._status {return false}
        if _storage._key != rhs_storage._key {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_MultiKeyResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MultiKeyResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
    2: .same(proto: "keys"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._status) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.keys) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._status {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.keys.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.keys, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_MultiKeyResponse, rhs: Clarifai_Api_MultiKeyResponse) -> Bool {
    if lhs._status != rhs._status {return false}
    if lhs.keys != rhs.keys {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_GetModelRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetModelRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_app_id"),
    2: .standard(proto: "model_id"),
    3: .standard(proto: "version_id"),
    4: .same(proto: "language"),
    5: .standard(proto: "trained_before"),
    19: .standard(proto: "additional_fields"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._userAppID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.modelID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.versionID) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.language) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.trainedBefore) }()
      case 19: try { try decoder.decodeRepeatedStringField(value: &self.additionalFields) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._userAppID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.modelID.isEmpty {
      try visitor.visitSingularStringField(value: self.modelID, fieldNumber: 2)
    }
    if !self.versionID.isEmpty {
      try visitor.visitSingularStringField(value: self.versionID, fieldNumber: 3)
    }
    if !self.language.isEmpty {
      try visitor.visitSingularStringField(value: self.language, fieldNumber: 4)
    }
    if self.trainedBefore != false {
      try visitor.visitSingularBoolField(value: self.trainedBefore, fieldNumber: 5)
    }
    if !self.additionalFields.isEmpty {
      try visitor.visitRepeatedStringField(value: self.additionalFields, fieldNumber: 19)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_GetModelRequest, rhs: Clarifai_Api_GetModelRequest) -> Bool {
    if lhs._userAppID != rhs._userAppID {return false}
    if lhs.modelID != rhs.modelID {return false}
    if lhs.versionID != rhs.versionID {return false}
    if lhs.language != rhs.language {return false}
    if lhs.trainedBefore != rhs.trainedBefore {return false}
    if lhs.additionalFields != rhs.additionalFields {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_ListModelsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListModelsRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_app_id"),
    2: .same(proto: "page"),
    3: .standard(proto: "per_page"),
    19: .standard(proto: "additional_fields"),
    10: .standard(proto: "sort_ascending"),
    11: .standard(proto: "sort_by_name"),
    12: .standard(proto: "sort_by_num_inputs"),
    13: .standard(proto: "sort_by_modified_at"),
    24: .standard(proto: "sort_by_created_at"),
    25: .standard(proto: "sort_by_star_count"),
    6: .standard(proto: "model_type_id"),
    7: .standard(proto: "trained_only"),
    8: .standard(proto: "input_fields"),
    9: .standard(proto: "output_fields"),
    15: .same(proto: "license"),
    16: .standard(proto: "featured_only"),
    20: .standard(proto: "starred_only"),
    17: .same(proto: "toolkits"),
    18: .standard(proto: "use_cases"),
    21: .same(proto: "languages"),
    23: .standard(proto: "dont_fetch_from_main"),
    26: .same(proto: "bookmark"),
    27: .same(proto: "search"),
    14: .same(proto: "query"),
    5: .same(proto: "name"),
    22: .standard(proto: "filter_by_user_id"),
    28: .standard(proto: "model_version_ids"),
    29: .standard(proto: "license_type"),
    30: .same(proto: "source"),
    31: .same(proto: "creator"),
    33: .standard(proto: "min_replicas"),
    34: .standard(proto: "show_replicas"),
    35: .same(proto: "visibility"),
  ]

  fileprivate class _StorageClass {
    var _userAppID: Clarifai_Api_UserAppIDSet? = nil
    var _page: UInt32 = 0
    var _perPage: UInt32 = 0
    var _additionalFields: [String] = []
    var _sortAscending: Bool = false
    var _sortBy: Clarifai_Api_ListModelsRequest.OneOf_SortBy?
    var _modelTypeID: String = String()
    var _trainedOnly: Bool = false
    var _inputFields: [String] = []
    var _outputFields: [String] = []
    var _license: String = String()
    var _featuredOnly: Bool = false
    var _starredOnly: Bool = false
    var _toolkits: [String] = []
    var _useCases: [String] = []
    var _languages: [String] = []
    var _dontFetchFromMain: Bool = false
    var _bookmark: Bool = false
    var _search: String = String()
    var _query: String = String()
    var _name: String = String()
    var _filterByUserID: Bool = false
    var _modelVersionIds: [String] = []
    var _licenseType: Clarifai_Api_LicenseType = .unknownLicenseType
    var _source: UInt32 = 0
    var _creator: String = String()
    var _minReplicas: UInt32 = 0
    var _showReplicas: Bool = false
    var _visibility: Clarifai_Api_Visibility? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _userAppID = source._userAppID
      _page = source._page
      _perPage = source._perPage
      _additionalFields = source._additionalFields
      _sortAscending = source._sortAscending
      _sortBy = source._sortBy
      _modelTypeID = source._modelTypeID
      _trainedOnly = source._trainedOnly
      _inputFields = source._inputFields
      _outputFields = source._outputFields
      _license = source._license
      _featuredOnly = source._featuredOnly
      _starredOnly = source._starredOnly
      _toolkits = source._toolkits
      _useCases = source._useCases
      _languages = source._languages
      _dontFetchFromMain = source._dontFetchFromMain
      _bookmark = source._bookmark
      _search = source._search
      _query = source._query
      _name = source._name
      _filterByUserID = source._filterByUserID
      _modelVersionIds = source._modelVersionIds
      _licenseType = source._licenseType
      _source = source._source
      _creator = source._creator
      _minReplicas = source._minReplicas
      _showReplicas = source._showReplicas
      _visibility = source._visibility
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._userAppID) }()
        case 2: try { try decoder.decodeSingularUInt32Field(value: &_storage._page) }()
        case 3: try { try decoder.decodeSingularUInt32Field(value: &_storage._perPage) }()
        case 5: try { try decoder.decodeSingularStringField(value: &_storage._name) }()
        case 6: try { try decoder.decodeSingularStringField(value: &_storage._modelTypeID) }()
        case 7: try { try decoder.decodeSingularBoolField(value: &_storage._trainedOnly) }()
        case 8: try { try decoder.decodeRepeatedStringField(value: &_storage._inputFields) }()
        case 9: try { try decoder.decodeRepeatedStringField(value: &_storage._outputFields) }()
        case 10: try { try decoder.decodeSingularBoolField(value: &_storage._sortAscending) }()
        case 11: try {
          var v: Bool?
          try decoder.decodeSingularBoolField(value: &v)
          if let v = v {
            if _storage._sortBy != nil {try decoder.handleConflictingOneOf()}
            _storage._sortBy = .sortByName(v)
          }
        }()
        case 12: try {
          var v: Bool?
          try decoder.decodeSingularBoolField(value: &v)
          if let v = v {
            if _storage._sortBy != nil {try decoder.handleConflictingOneOf()}
            _storage._sortBy = .sortByNumInputs(v)
          }
        }()
        case 13: try {
          var v: Bool?
          try decoder.decodeSingularBoolField(value: &v)
          if let v = v {
            if _storage._sortBy != nil {try decoder.handleConflictingOneOf()}
            _storage._sortBy = .sortByModifiedAt(v)
          }
        }()
        case 14: try { try decoder.decodeSingularStringField(value: &_storage._query) }()
        case 15: try { try decoder.decodeSingularStringField(value: &_storage._license) }()
        case 16: try { try decoder.decodeSingularBoolField(value: &_storage._featuredOnly) }()
        case 17: try { try decoder.decodeRepeatedStringField(value: &_storage._toolkits) }()
        case 18: try { try decoder.decodeRepeatedStringField(value: &_storage._useCases) }()
        case 19: try { try decoder.decodeRepeatedStringField(value: &_storage._additionalFields) }()
        case 20: try { try decoder.decodeSingularBoolField(value: &_storage._starredOnly) }()
        case 21: try { try decoder.decodeRepeatedStringField(value: &_storage._languages) }()
        case 22: try { try decoder.decodeSingularBoolField(value: &_storage._filterByUserID) }()
        case 23: try { try decoder.decodeSingularBoolField(value: &_storage._dontFetchFromMain) }()
        case 24: try {
          var v: Bool?
          try decoder.decodeSingularBoolField(value: &v)
          if let v = v {
            if _storage._sortBy != nil {try decoder.handleConflictingOneOf()}
            _storage._sortBy = .sortByCreatedAt(v)
          }
        }()
        case 25: try {
          var v: Bool?
          try decoder.decodeSingularBoolField(value: &v)
          if let v = v {
            if _storage._sortBy != nil {try decoder.handleConflictingOneOf()}
            _storage._sortBy = .sortByStarCount(v)
          }
        }()
        case 26: try { try decoder.decodeSingularBoolField(value: &_storage._bookmark) }()
        case 27: try { try decoder.decodeSingularStringField(value: &_storage._search) }()
        case 28: try { try decoder.decodeRepeatedStringField(value: &_storage._modelVersionIds) }()
        case 29: try { try decoder.decodeSingularEnumField(value: &_storage._licenseType) }()
        case 30: try { try decoder.decodeSingularUInt32Field(value: &_storage._source) }()
        case 31: try { try decoder.decodeSingularStringField(value: &_storage._creator) }()
        case 33: try { try decoder.decodeSingularUInt32Field(value: &_storage._minReplicas) }()
        case 34: try { try decoder.decodeSingularBoolField(value: &_storage._showReplicas) }()
        case 35: try { try decoder.decodeSingularMessageField(value: &_storage._visibility) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._userAppID {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      if _storage._page != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._page, fieldNumber: 2)
      }
      if _storage._perPage != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._perPage, fieldNumber: 3)
      }
      if !_storage._name.isEmpty {
        try visitor.visitSingularStringField(value: _storage._name, fieldNumber: 5)
      }
      if !_storage._modelTypeID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._modelTypeID, fieldNumber: 6)
      }
      if _storage._trainedOnly != false {
        try visitor.visitSingularBoolField(value: _storage._trainedOnly, fieldNumber: 7)
      }
      if !_storage._inputFields.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._inputFields, fieldNumber: 8)
      }
      if !_storage._outputFields.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._outputFields, fieldNumber: 9)
      }
      if _storage._sortAscending != false {
        try visitor.visitSingularBoolField(value: _storage._sortAscending, fieldNumber: 10)
      }
      switch _storage._sortBy {
      case .sortByName?: try {
        guard case .sortByName(let v)? = _storage._sortBy else { preconditionFailure() }
        try visitor.visitSingularBoolField(value: v, fieldNumber: 11)
      }()
      case .sortByNumInputs?: try {
        guard case .sortByNumInputs(let v)? = _storage._sortBy else { preconditionFailure() }
        try visitor.visitSingularBoolField(value: v, fieldNumber: 12)
      }()
      case .sortByModifiedAt?: try {
        guard case .sortByModifiedAt(let v)? = _storage._sortBy else { preconditionFailure() }
        try visitor.visitSingularBoolField(value: v, fieldNumber: 13)
      }()
      default: break
      }
      if !_storage._query.isEmpty {
        try visitor.visitSingularStringField(value: _storage._query, fieldNumber: 14)
      }
      if !_storage._license.isEmpty {
        try visitor.visitSingularStringField(value: _storage._license, fieldNumber: 15)
      }
      if _storage._featuredOnly != false {
        try visitor.visitSingularBoolField(value: _storage._featuredOnly, fieldNumber: 16)
      }
      if !_storage._toolkits.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._toolkits, fieldNumber: 17)
      }
      if !_storage._useCases.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._useCases, fieldNumber: 18)
      }
      if !_storage._additionalFields.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._additionalFields, fieldNumber: 19)
      }
      if _storage._starredOnly != false {
        try visitor.visitSingularBoolField(value: _storage._starredOnly, fieldNumber: 20)
      }
      if !_storage._languages.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._languages, fieldNumber: 21)
      }
      if _storage._filterByUserID != false {
        try visitor.visitSingularBoolField(value: _storage._filterByUserID, fieldNumber: 22)
      }
      if _storage._dontFetchFromMain != false {
        try visitor.visitSingularBoolField(value: _storage._dontFetchFromMain, fieldNumber: 23)
      }
      switch _storage._sortBy {
      case .sortByCreatedAt?: try {
        guard case .sortByCreatedAt(let v)? = _storage._sortBy else { preconditionFailure() }
        try visitor.visitSingularBoolField(value: v, fieldNumber: 24)
      }()
      case .sortByStarCount?: try {
        guard case .sortByStarCount(let v)? = _storage._sortBy else { preconditionFailure() }
        try visitor.visitSingularBoolField(value: v, fieldNumber: 25)
      }()
      default: break
      }
      if _storage._bookmark != false {
        try visitor.visitSingularBoolField(value: _storage._bookmark, fieldNumber: 26)
      }
      if !_storage._search.isEmpty {
        try visitor.visitSingularStringField(value: _storage._search, fieldNumber: 27)
      }
      if !_storage._modelVersionIds.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._modelVersionIds, fieldNumber: 28)
      }
      if _storage._licenseType != .unknownLicenseType {
        try visitor.visitSingularEnumField(value: _storage._licenseType, fieldNumber: 29)
      }
      if _storage._source != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._source, fieldNumber: 30)
      }
      if !_storage._creator.isEmpty {
        try visitor.visitSingularStringField(value: _storage._creator, fieldNumber: 31)
      }
      if _storage._minReplicas != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._minReplicas, fieldNumber: 33)
      }
      if _storage._showReplicas != false {
        try visitor.visitSingularBoolField(value: _storage._showReplicas, fieldNumber: 34)
      }
      try { if let v = _storage._visibility {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 35)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_ListModelsRequest, rhs: Clarifai_Api_ListModelsRequest) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._userAppID != rhs_storage._userAppID {return false}
        if _storage._page != rhs_storage._page {return false}
        if _storage._perPage != rhs_storage._perPage {return false}
        if _storage._additionalFields != rhs_storage._additionalFields {return false}
        if _storage._sortAscending != rhs_storage._sortAscending {return false}
        if _storage._sortBy != rhs_storage._sortBy {return false}
        if _storage._modelTypeID != rhs_storage._modelTypeID {return false}
        if _storage._trainedOnly != rhs_storage._trainedOnly {return false}
        if _storage._inputFields != rhs_storage._inputFields {return false}
        if _storage._outputFields != rhs_storage._outputFields {return false}
        if _storage._license != rhs_storage._license {return false}
        if _storage._featuredOnly != rhs_storage._featuredOnly {return false}
        if _storage._starredOnly != rhs_storage._starredOnly {return false}
        if _storage._toolkits != rhs_storage._toolkits {return false}
        if _storage._useCases != rhs_storage._useCases {return false}
        if _storage._languages != rhs_storage._languages {return false}
        if _storage._dontFetchFromMain != rhs_storage._dontFetchFromMain {return false}
        if _storage._bookmark != rhs_storage._bookmark {return false}
        if _storage._search != rhs_storage._search {return false}
        if _storage._query != rhs_storage._query {return false}
        if _storage._name != rhs_storage._name {return false}
        if _storage._filterByUserID != rhs_storage._filterByUserID {return false}
        if _storage._modelVersionIds != rhs_storage._modelVersionIds {return false}
        if _storage._licenseType != rhs_storage._licenseType {return false}
        if _storage._source != rhs_storage._source {return false}
        if _storage._creator != rhs_storage._creator {return false}
        if _storage._minReplicas != rhs_storage._minReplicas {return false}
        if _storage._showReplicas != rhs_storage._showReplicas {return false}
        if _storage._visibility != rhs_storage._visibility {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_GetResourceCountsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetResourceCountsRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_app_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._userAppID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._userAppID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_GetResourceCountsRequest, rhs: Clarifai_Api_GetResourceCountsRequest) -> Bool {
    if lhs._userAppID != rhs._userAppID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_GetResourceCountsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetResourceCountsResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
    2: .same(proto: "datasets"),
    3: .same(proto: "models"),
    4: .same(proto: "workflows"),
    5: .same(proto: "modules"),
    6: .same(proto: "inputs"),
  ]

  fileprivate class _StorageClass {
    var _status: Clarifai_Api_Status_Status? = nil
    var _datasets: Int64 = 0
    var _models: Int64 = 0
    var _workflows: Int64 = 0
    var _modules: Int64 = 0
    var _inputs: Int64 = 0

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _status = source._status
      _datasets = source._datasets
      _models = source._models
      _workflows = source._workflows
      _modules = source._modules
      _inputs = source._inputs
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._status) }()
        case 2: try { try decoder.decodeSingularInt64Field(value: &_storage._datasets) }()
        case 3: try { try decoder.decodeSingularInt64Field(value: &_storage._models) }()
        case 4: try { try decoder.decodeSingularInt64Field(value: &_storage._workflows) }()
        case 5: try { try decoder.decodeSingularInt64Field(value: &_storage._modules) }()
        case 6: try { try decoder.decodeSingularInt64Field(value: &_storage._inputs) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._status {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      if _storage._datasets != 0 {
        try visitor.visitSingularInt64Field(value: _storage._datasets, fieldNumber: 2)
      }
      if _storage._models != 0 {
        try visitor.visitSingularInt64Field(value: _storage._models, fieldNumber: 3)
      }
      if _storage._workflows != 0 {
        try visitor.visitSingularInt64Field(value: _storage._workflows, fieldNumber: 4)
      }
      if _storage._modules != 0 {
        try visitor.visitSingularInt64Field(value: _storage._modules, fieldNumber: 5)
      }
      if _storage._inputs != 0 {
        try visitor.visitSingularInt64Field(value: _storage._inputs, fieldNumber: 6)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_GetResourceCountsResponse, rhs: Clarifai_Api_GetResourceCountsResponse) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._status != rhs_storage._status {return false}
        if _storage._datasets != rhs_storage._datasets {return false}
        if _storage._models != rhs_storage._models {return false}
        if _storage._workflows != rhs_storage._workflows {return false}
        if _storage._modules != rhs_storage._modules {return false}
        if _storage._inputs != rhs_storage._inputs {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_PatchModelToolkitsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PatchModelToolkitsRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_app_id"),
    2: .standard(proto: "model_id"),
    3: .same(proto: "toolkits"),
    4: .same(proto: "action"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._userAppID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.modelID) }()
      case 3: try { try decoder.decodeRepeatedStringField(value: &self.toolkits) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.action) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._userAppID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.modelID.isEmpty {
      try visitor.visitSingularStringField(value: self.modelID, fieldNumber: 2)
    }
    if !self.toolkits.isEmpty {
      try visitor.visitRepeatedStringField(value: self.toolkits, fieldNumber: 3)
    }
    if !self.action.isEmpty {
      try visitor.visitSingularStringField(value: self.action, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_PatchModelToolkitsRequest, rhs: Clarifai_Api_PatchModelToolkitsRequest) -> Bool {
    if lhs._userAppID != rhs._userAppID {return false}
    if lhs.modelID != rhs.modelID {return false}
    if lhs.toolkits != rhs.toolkits {return false}
    if lhs.action != rhs.action {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_PatchModelCheckConsentsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PatchModelCheckConsentsRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_app_id"),
    2: .standard(proto: "model_id"),
    3: .standard(proto: "check_consents"),
    4: .same(proto: "action"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._userAppID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.modelID) }()
      case 3: try { try decoder.decodeRepeatedStringField(value: &self.checkConsents) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.action) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._userAppID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.modelID.isEmpty {
      try visitor.visitSingularStringField(value: self.modelID, fieldNumber: 2)
    }
    if !self.checkConsents.isEmpty {
      try visitor.visitRepeatedStringField(value: self.checkConsents, fieldNumber: 3)
    }
    if !self.action.isEmpty {
      try visitor.visitSingularStringField(value: self.action, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_PatchModelCheckConsentsRequest, rhs: Clarifai_Api_PatchModelCheckConsentsRequest) -> Bool {
    if lhs._userAppID != rhs._userAppID {return false}
    if lhs.modelID != rhs.modelID {return false}
    if lhs.checkConsents != rhs.checkConsents {return false}
    if lhs.action != rhs.action {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_PatchModelUseCasesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PatchModelUseCasesRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_app_id"),
    2: .standard(proto: "model_id"),
    3: .same(proto: "usecases"),
    4: .same(proto: "action"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._userAppID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.modelID) }()
      case 3: try { try decoder.decodeRepeatedStringField(value: &self.usecases) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.action) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._userAppID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.modelID.isEmpty {
      try visitor.visitSingularStringField(value: self.modelID, fieldNumber: 2)
    }
    if !self.usecases.isEmpty {
      try visitor.visitRepeatedStringField(value: self.usecases, fieldNumber: 3)
    }
    if !self.action.isEmpty {
      try visitor.visitSingularStringField(value: self.action, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_PatchModelUseCasesRequest, rhs: Clarifai_Api_PatchModelUseCasesRequest) -> Bool {
    if lhs._userAppID != rhs._userAppID {return false}
    if lhs.modelID != rhs.modelID {return false}
    if lhs.usecases != rhs.usecases {return false}
    if lhs.action != rhs.action {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_PatchModelLanguagesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PatchModelLanguagesRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_app_id"),
    2: .standard(proto: "model_id"),
    3: .same(proto: "languages"),
    4: .same(proto: "action"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._userAppID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.modelID) }()
      case 3: try { try decoder.decodeRepeatedStringField(value: &self.languages) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.action) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._userAppID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.modelID.isEmpty {
      try visitor.visitSingularStringField(value: self.modelID, fieldNumber: 2)
    }
    if !self.languages.isEmpty {
      try visitor.visitRepeatedStringField(value: self.languages, fieldNumber: 3)
    }
    if !self.action.isEmpty {
      try visitor.visitSingularStringField(value: self.action, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_PatchModelLanguagesRequest, rhs: Clarifai_Api_PatchModelLanguagesRequest) -> Bool {
    if lhs._userAppID != rhs._userAppID {return false}
    if lhs.modelID != rhs.modelID {return false}
    if lhs.languages != rhs.languages {return false}
    if lhs.action != rhs.action {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_MultiModelToolkitResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MultiModelToolkitResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
    2: .same(proto: "toolkits"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._status) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.toolkits) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._status {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.toolkits.isEmpty {
      try visitor.visitRepeatedStringField(value: self.toolkits, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_MultiModelToolkitResponse, rhs: Clarifai_Api_MultiModelToolkitResponse) -> Bool {
    if lhs._status != rhs._status {return false}
    if lhs.toolkits != rhs.toolkits {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_MultiModelCheckConsentResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MultiModelCheckConsentResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
    2: .standard(proto: "check_consents"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._status) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.checkConsents) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._status {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.checkConsents.isEmpty {
      try visitor.visitRepeatedStringField(value: self.checkConsents, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_MultiModelCheckConsentResponse, rhs: Clarifai_Api_MultiModelCheckConsentResponse) -> Bool {
    if lhs._status != rhs._status {return false}
    if lhs.checkConsents != rhs.checkConsents {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_MultiModelUseCaseResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MultiModelUseCaseResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
    2: .same(proto: "usecases"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._status) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.usecases) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._status {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.usecases.isEmpty {
      try visitor.visitRepeatedStringField(value: self.usecases, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_MultiModelUseCaseResponse, rhs: Clarifai_Api_MultiModelUseCaseResponse) -> Bool {
    if lhs._status != rhs._status {return false}
    if lhs.usecases != rhs.usecases {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_MultiModelLanguageResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MultiModelLanguageResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
    2: .same(proto: "languages"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._status) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.languages) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._status {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.languages.isEmpty {
      try visitor.visitRepeatedStringField(value: self.languages, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_MultiModelLanguageResponse, rhs: Clarifai_Api_MultiModelLanguageResponse) -> Bool {
    if lhs._status != rhs._status {return false}
    if lhs.languages != rhs.languages {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_PostModelsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PostModelsRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_app_id"),
    2: .same(proto: "model"),
    3: .same(proto: "models"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._userAppID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._model) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.models) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._userAppID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._model {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.models.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.models, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_PostModelsRequest, rhs: Clarifai_Api_PostModelsRequest) -> Bool {
    if lhs._userAppID != rhs._userAppID {return false}
    if lhs._model != rhs._model {return false}
    if lhs.models != rhs.models {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_PatchModelsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PatchModelsRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_app_id"),
    2: .same(proto: "models"),
    3: .same(proto: "action"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._userAppID) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.models) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.action) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._userAppID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.models.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.models, fieldNumber: 2)
    }
    if !self.action.isEmpty {
      try visitor.visitSingularStringField(value: self.action, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_PatchModelsRequest, rhs: Clarifai_Api_PatchModelsRequest) -> Bool {
    if lhs._userAppID != rhs._userAppID {return false}
    if lhs.models != rhs.models {return false}
    if lhs.action != rhs.action {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_IdUpdateSource: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".IdUpdateSource"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .standard(proto: "new_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.newID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if !self.newID.isEmpty {
      try visitor.visitSingularStringField(value: self.newID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_IdUpdateSource, rhs: Clarifai_Api_IdUpdateSource) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.newID != rhs.newID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_PatchModelIdsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PatchModelIdsRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_app_id"),
    3: .same(proto: "ids"),
    4: .same(proto: "action"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._userAppID) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.ids) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.action) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._userAppID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.ids.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.ids, fieldNumber: 3)
    }
    if !self.action.isEmpty {
      try visitor.visitSingularStringField(value: self.action, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_PatchModelIdsRequest, rhs: Clarifai_Api_PatchModelIdsRequest) -> Bool {
    if lhs._userAppID != rhs._userAppID {return false}
    if lhs.ids != rhs.ids {return false}
    if lhs.action != rhs.action {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_DeleteModelRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DeleteModelRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_app_id"),
    2: .standard(proto: "model_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._userAppID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.modelID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._userAppID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.modelID.isEmpty {
      try visitor.visitSingularStringField(value: self.modelID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_DeleteModelRequest, rhs: Clarifai_Api_DeleteModelRequest) -> Bool {
    if lhs._userAppID != rhs._userAppID {return false}
    if lhs.modelID != rhs.modelID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_DeleteModelsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DeleteModelsRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_app_id"),
    2: .same(proto: "ids"),
    3: .standard(proto: "delete_all"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._userAppID) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.ids) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.deleteAll) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._userAppID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.ids.isEmpty {
      try visitor.visitRepeatedStringField(value: self.ids, fieldNumber: 2)
    }
    if self.deleteAll != false {
      try visitor.visitSingularBoolField(value: self.deleteAll, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_DeleteModelsRequest, rhs: Clarifai_Api_DeleteModelsRequest) -> Bool {
    if lhs._userAppID != rhs._userAppID {return false}
    if lhs.ids != rhs.ids {return false}
    if lhs.deleteAll != rhs.deleteAll {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_PostModelsSearchesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PostModelsSearchesRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_app_id"),
    2: .standard(proto: "model_query"),
    3: .same(proto: "pagination"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._userAppID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._modelQuery) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._pagination) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._userAppID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._modelQuery {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._pagination {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_PostModelsSearchesRequest, rhs: Clarifai_Api_PostModelsSearchesRequest) -> Bool {
    if lhs._userAppID != rhs._userAppID {return false}
    if lhs._modelQuery != rhs._modelQuery {return false}
    if lhs._pagination != rhs._pagination {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_SingleModelResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SingleModelResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
    2: .same(proto: "model"),
    4: .standard(proto: "workflow_count"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._status) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._model) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.workflowCount) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._status {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._model {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if self.workflowCount != 0 {
      try visitor.visitSingularInt32Field(value: self.workflowCount, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_SingleModelResponse, rhs: Clarifai_Api_SingleModelResponse) -> Bool {
    if lhs._status != rhs._status {return false}
    if lhs._model != rhs._model {return false}
    if lhs.workflowCount != rhs.workflowCount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_MultiModelResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MultiModelResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
    2: .same(proto: "models"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._status) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.models) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._status {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.models.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.models, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_MultiModelResponse, rhs: Clarifai_Api_MultiModelResponse) -> Bool {
    if lhs._status != rhs._status {return false}
    if lhs.models != rhs.models {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_PatchModelVersionsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PatchModelVersionsRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_app_id"),
    2: .standard(proto: "model_id"),
    3: .standard(proto: "model_versions"),
    4: .same(proto: "action"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._userAppID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.modelID) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.modelVersions) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.action) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._userAppID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.modelID.isEmpty {
      try visitor.visitSingularStringField(value: self.modelID, fieldNumber: 2)
    }
    if !self.modelVersions.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.modelVersions, fieldNumber: 3)
    }
    if !self.action.isEmpty {
      try visitor.visitSingularStringField(value: self.action, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_PatchModelVersionsRequest, rhs: Clarifai_Api_PatchModelVersionsRequest) -> Bool {
    if lhs._userAppID != rhs._userAppID {return false}
    if lhs.modelID != rhs.modelID {return false}
    if lhs.modelVersions != rhs.modelVersions {return false}
    if lhs.action != rhs.action {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_GetModelVersionRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetModelVersionRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_app_id"),
    2: .standard(proto: "model_id"),
    3: .standard(proto: "version_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._userAppID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.modelID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.versionID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._userAppID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.modelID.isEmpty {
      try visitor.visitSingularStringField(value: self.modelID, fieldNumber: 2)
    }
    if !self.versionID.isEmpty {
      try visitor.visitSingularStringField(value: self.versionID, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_GetModelVersionRequest, rhs: Clarifai_Api_GetModelVersionRequest) -> Bool {
    if lhs._userAppID != rhs._userAppID {return false}
    if lhs.modelID != rhs.modelID {return false}
    if lhs.versionID != rhs.versionID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_ListModelVersionsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListModelVersionsRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_app_id"),
    2: .standard(proto: "model_id"),
    3: .same(proto: "page"),
    4: .standard(proto: "per_page"),
    5: .standard(proto: "concept_ids"),
    6: .standard(proto: "trained_only"),
    7: .standard(proto: "sort_ascending"),
    8: .standard(proto: "sort_by_status_code"),
    9: .standard(proto: "sort_by_num_inputs"),
    10: .standard(proto: "sort_by_description"),
    11: .standard(proto: "sort_by_created_at"),
    12: .standard(proto: "min_replicas"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._userAppID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.modelID) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.page) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self.perPage) }()
      case 5: try { try decoder.decodeRepeatedStringField(value: &self.conceptIds) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self.trainedOnly) }()
      case 7: try { try decoder.decodeSingularBoolField(value: &self.sortAscending) }()
      case 8: try {
        var v: Bool?
        try decoder.decodeSingularBoolField(value: &v)
        if let v = v {
          if self.sortBy != nil {try decoder.handleConflictingOneOf()}
          self.sortBy = .sortByStatusCode(v)
        }
      }()
      case 9: try {
        var v: Bool?
        try decoder.decodeSingularBoolField(value: &v)
        if let v = v {
          if self.sortBy != nil {try decoder.handleConflictingOneOf()}
          self.sortBy = .sortByNumInputs(v)
        }
      }()
      case 10: try {
        var v: Bool?
        try decoder.decodeSingularBoolField(value: &v)
        if let v = v {
          if self.sortBy != nil {try decoder.handleConflictingOneOf()}
          self.sortBy = .sortByDescription(v)
        }
      }()
      case 11: try {
        var v: Bool?
        try decoder.decodeSingularBoolField(value: &v)
        if let v = v {
          if self.sortBy != nil {try decoder.handleConflictingOneOf()}
          self.sortBy = .sortByCreatedAt(v)
        }
      }()
      case 12: try { try decoder.decodeSingularUInt32Field(value: &self.minReplicas) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._userAppID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.modelID.isEmpty {
      try visitor.visitSingularStringField(value: self.modelID, fieldNumber: 2)
    }
    if self.page != 0 {
      try visitor.visitSingularUInt32Field(value: self.page, fieldNumber: 3)
    }
    if self.perPage != 0 {
      try visitor.visitSingularUInt32Field(value: self.perPage, fieldNumber: 4)
    }
    if !self.conceptIds.isEmpty {
      try visitor.visitRepeatedStringField(value: self.conceptIds, fieldNumber: 5)
    }
    if self.trainedOnly != false {
      try visitor.visitSingularBoolField(value: self.trainedOnly, fieldNumber: 6)
    }
    if self.sortAscending != false {
      try visitor.visitSingularBoolField(value: self.sortAscending, fieldNumber: 7)
    }
    switch self.sortBy {
    case .sortByStatusCode?: try {
      guard case .sortByStatusCode(let v)? = self.sortBy else { preconditionFailure() }
      try visitor.visitSingularBoolField(value: v, fieldNumber: 8)
    }()
    case .sortByNumInputs?: try {
      guard case .sortByNumInputs(let v)? = self.sortBy else { preconditionFailure() }
      try visitor.visitSingularBoolField(value: v, fieldNumber: 9)
    }()
    case .sortByDescription?: try {
      guard case .sortByDescription(let v)? = self.sortBy else { preconditionFailure() }
      try visitor.visitSingularBoolField(value: v, fieldNumber: 10)
    }()
    case .sortByCreatedAt?: try {
      guard case .sortByCreatedAt(let v)? = self.sortBy else { preconditionFailure() }
      try visitor.visitSingularBoolField(value: v, fieldNumber: 11)
    }()
    case nil: break
    }
    if self.minReplicas != 0 {
      try visitor.visitSingularUInt32Field(value: self.minReplicas, fieldNumber: 12)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_ListModelVersionsRequest, rhs: Clarifai_Api_ListModelVersionsRequest) -> Bool {
    if lhs._userAppID != rhs._userAppID {return false}
    if lhs.modelID != rhs.modelID {return false}
    if lhs.page != rhs.page {return false}
    if lhs.perPage != rhs.perPage {return false}
    if lhs.conceptIds != rhs.conceptIds {return false}
    if lhs.trainedOnly != rhs.trainedOnly {return false}
    if lhs.sortAscending != rhs.sortAscending {return false}
    if lhs.sortBy != rhs.sortBy {return false}
    if lhs.minReplicas != rhs.minReplicas {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_DeleteModelVersionRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DeleteModelVersionRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_app_id"),
    3: .standard(proto: "model_id"),
    4: .standard(proto: "version_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._userAppID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.modelID) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.versionID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._userAppID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.modelID.isEmpty {
      try visitor.visitSingularStringField(value: self.modelID, fieldNumber: 3)
    }
    if !self.versionID.isEmpty {
      try visitor.visitSingularStringField(value: self.versionID, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_DeleteModelVersionRequest, rhs: Clarifai_Api_DeleteModelVersionRequest) -> Bool {
    if lhs._userAppID != rhs._userAppID {return false}
    if lhs.modelID != rhs.modelID {return false}
    if lhs.versionID != rhs.versionID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_SingleModelVersionResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SingleModelVersionResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
    2: .standard(proto: "model_version"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._status) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._modelVersion) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._status {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._modelVersion {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_SingleModelVersionResponse, rhs: Clarifai_Api_SingleModelVersionResponse) -> Bool {
    if lhs._status != rhs._status {return false}
    if lhs._modelVersion != rhs._modelVersion {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_MultiModelVersionResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MultiModelVersionResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
    2: .standard(proto: "model_versions"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._status) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.modelVersions) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._status {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.modelVersions.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.modelVersions, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_MultiModelVersionResponse, rhs: Clarifai_Api_MultiModelVersionResponse) -> Bool {
    if lhs._status != rhs._status {return false}
    if lhs.modelVersions != rhs.modelVersions {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_PostModelVersionsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PostModelVersionsRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_app_id"),
    2: .standard(proto: "model_id"),
    3: .standard(proto: "model_versions"),
    8: .same(proto: "description"),
    10: .standard(proto: "eval_info"),
    11: .standard(proto: "do_migration"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._userAppID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.modelID) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.modelVersions) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      case 10: try { try decoder.decodeSingularMessageField(value: &self._evalInfo) }()
      case 11: try { try decoder.decodeSingularBoolField(value: &self.doMigration) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._userAppID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.modelID.isEmpty {
      try visitor.visitSingularStringField(value: self.modelID, fieldNumber: 2)
    }
    if !self.modelVersions.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.modelVersions, fieldNumber: 3)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 8)
    }
    try { if let v = self._evalInfo {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
    } }()
    if self.doMigration != false {
      try visitor.visitSingularBoolField(value: self.doMigration, fieldNumber: 11)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_PostModelVersionsRequest, rhs: Clarifai_Api_PostModelVersionsRequest) -> Bool {
    if lhs._userAppID != rhs._userAppID {return false}
    if lhs.modelID != rhs.modelID {return false}
    if lhs.modelVersions != rhs.modelVersions {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs._evalInfo != rhs._evalInfo {return false}
    if lhs.doMigration != rhs.doMigration {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_PostModelVersionsUploadRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PostModelVersionsUploadRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "upload_config"),
    2: .standard(proto: "content_part"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Clarifai_Api_PostModelVersionsUploadConfig?
        var hadOneofValue = false
        if let current = self.uploadData {
          hadOneofValue = true
          if case .uploadConfig(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.uploadData = .uploadConfig(v)
        }
      }()
      case 2: try {
        var v: Clarifai_Api_UploadContentPart?
        var hadOneofValue = false
        if let current = self.uploadData {
          hadOneofValue = true
          if case .contentPart(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.uploadData = .contentPart(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.uploadData {
    case .uploadConfig?: try {
      guard case .uploadConfig(let v)? = self.uploadData else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .contentPart?: try {
      guard case .contentPart(let v)? = self.uploadData else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_PostModelVersionsUploadRequest, rhs: Clarifai_Api_PostModelVersionsUploadRequest) -> Bool {
    if lhs.uploadData != rhs.uploadData {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_PostModelVersionsUploadResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PostModelVersionsUploadResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
    2: .standard(proto: "bytes_remaining"),
    3: .standard(proto: "model_version_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._status) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.bytesRemaining) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.modelVersionID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._status {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.bytesRemaining != 0 {
      try visitor.visitSingularUInt64Field(value: self.bytesRemaining, fieldNumber: 2)
    }
    if !self.modelVersionID.isEmpty {
      try visitor.visitSingularStringField(value: self.modelVersionID, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_PostModelVersionsUploadResponse, rhs: Clarifai_Api_PostModelVersionsUploadResponse) -> Bool {
    if lhs._status != rhs._status {return false}
    if lhs.bytesRemaining != rhs.bytesRemaining {return false}
    if lhs.modelVersionID != rhs.modelVersionID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_PostModelVersionsUploadConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PostModelVersionsUploadConfig"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_app_id"),
    2: .standard(proto: "model_id"),
    3: .standard(proto: "model_version"),
    4: .standard(proto: "total_size"),
    5: .standard(proto: "is_v3"),
    6: .standard(proto: "storage_request_size"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._userAppID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.modelID) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._modelVersion) }()
      case 4: try { try decoder.decodeSingularUInt64Field(value: &self.totalSize) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.isV3) }()
      case 6: try { try decoder.decodeSingularUInt64Field(value: &self.storageRequestSize) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._userAppID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.modelID.isEmpty {
      try visitor.visitSingularStringField(value: self.modelID, fieldNumber: 2)
    }
    try { if let v = self._modelVersion {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if self.totalSize != 0 {
      try visitor.visitSingularUInt64Field(value: self.totalSize, fieldNumber: 4)
    }
    if self.isV3 != false {
      try visitor.visitSingularBoolField(value: self.isV3, fieldNumber: 5)
    }
    if self.storageRequestSize != 0 {
      try visitor.visitSingularUInt64Field(value: self.storageRequestSize, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_PostModelVersionsUploadConfig, rhs: Clarifai_Api_PostModelVersionsUploadConfig) -> Bool {
    if lhs._userAppID != rhs._userAppID {return false}
    if lhs.modelID != rhs.modelID {return false}
    if lhs._modelVersion != rhs._modelVersion {return false}
    if lhs.totalSize != rhs.totalSize {return false}
    if lhs.isV3 != rhs.isV3 {return false}
    if lhs.storageRequestSize != rhs.storageRequestSize {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_PutModelVersionExportsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PutModelVersionExportsRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_app_id"),
    2: .standard(proto: "model_id"),
    3: .standard(proto: "version_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._userAppID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.modelID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.versionID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._userAppID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.modelID.isEmpty {
      try visitor.visitSingularStringField(value: self.modelID, fieldNumber: 2)
    }
    if !self.versionID.isEmpty {
      try visitor.visitSingularStringField(value: self.versionID, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_PutModelVersionExportsRequest, rhs: Clarifai_Api_PutModelVersionExportsRequest) -> Bool {
    if lhs._userAppID != rhs._userAppID {return false}
    if lhs.modelID != rhs.modelID {return false}
    if lhs.versionID != rhs.versionID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_GetModelVersionExportRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetModelVersionExportRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_app_id"),
    2: .standard(proto: "model_id"),
    3: .standard(proto: "version_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._userAppID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.modelID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.versionID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._userAppID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.modelID.isEmpty {
      try visitor.visitSingularStringField(value: self.modelID, fieldNumber: 2)
    }
    if !self.versionID.isEmpty {
      try visitor.visitSingularStringField(value: self.versionID, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_GetModelVersionExportRequest, rhs: Clarifai_Api_GetModelVersionExportRequest) -> Bool {
    if lhs._userAppID != rhs._userAppID {return false}
    if lhs.modelID != rhs.modelID {return false}
    if lhs.versionID != rhs.versionID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_SingleModelVersionExportResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SingleModelVersionExportResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
    2: .same(proto: "export"),
  ]

  fileprivate class _StorageClass {
    var _status: Clarifai_Api_Status_Status? = nil
    var _export: Clarifai_Api_ModelVersionExport? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _status = source._status
      _export = source._export
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._status) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._export) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._status {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._export {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_SingleModelVersionExportResponse, rhs: Clarifai_Api_SingleModelVersionExportResponse) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._status != rhs_storage._status {return false}
        if _storage._export != rhs_storage._export {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_PostWorkflowVersionsUnPublishRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PostWorkflowVersionsUnPublishRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_app_id"),
    2: .standard(proto: "workflow_id"),
    3: .same(proto: "publications"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._userAppID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.workflowID) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.publications) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._userAppID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.workflowID.isEmpty {
      try visitor.visitSingularStringField(value: self.workflowID, fieldNumber: 2)
    }
    if !self.publications.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.publications, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_PostWorkflowVersionsUnPublishRequest, rhs: Clarifai_Api_PostWorkflowVersionsUnPublishRequest) -> Bool {
    if lhs._userAppID != rhs._userAppID {return false}
    if lhs.workflowID != rhs.workflowID {return false}
    if lhs.publications != rhs.publications {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_PostWorkflowVersionsPublishRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PostWorkflowVersionsPublishRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_app_id"),
    2: .standard(proto: "workflow_id"),
    3: .same(proto: "publications"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._userAppID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.workflowID) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.publications) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._userAppID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.workflowID.isEmpty {
      try visitor.visitSingularStringField(value: self.workflowID, fieldNumber: 2)
    }
    if !self.publications.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.publications, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_PostWorkflowVersionsPublishRequest, rhs: Clarifai_Api_PostWorkflowVersionsPublishRequest) -> Bool {
    if lhs._userAppID != rhs._userAppID {return false}
    if lhs.workflowID != rhs.workflowID {return false}
    if lhs.publications != rhs.publications {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_WorkflowVersionPublishRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".WorkflowVersionPublishRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "version_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.versionID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.versionID.isEmpty {
      try visitor.visitSingularStringField(value: self.versionID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_WorkflowVersionPublishRequest, rhs: Clarifai_Api_WorkflowVersionPublishRequest) -> Bool {
    if lhs.versionID != rhs.versionID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_WorkflowVersionUnPublishRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".WorkflowVersionUnPublishRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "version_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.versionID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.versionID.isEmpty {
      try visitor.visitSingularStringField(value: self.versionID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_WorkflowVersionUnPublishRequest, rhs: Clarifai_Api_WorkflowVersionUnPublishRequest) -> Bool {
    if lhs.versionID != rhs.versionID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_ModelVersionPublishRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ModelVersionPublishRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "version_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.versionID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.versionID.isEmpty {
      try visitor.visitSingularStringField(value: self.versionID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_ModelVersionPublishRequest, rhs: Clarifai_Api_ModelVersionPublishRequest) -> Bool {
    if lhs.versionID != rhs.versionID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_PostModelVersionsPublishRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PostModelVersionsPublishRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_app_id"),
    2: .standard(proto: "model_id"),
    3: .same(proto: "publications"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._userAppID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.modelID) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.publications) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._userAppID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.modelID.isEmpty {
      try visitor.visitSingularStringField(value: self.modelID, fieldNumber: 2)
    }
    if !self.publications.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.publications, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_PostModelVersionsPublishRequest, rhs: Clarifai_Api_PostModelVersionsPublishRequest) -> Bool {
    if lhs._userAppID != rhs._userAppID {return false}
    if lhs.modelID != rhs.modelID {return false}
    if lhs.publications != rhs.publications {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_ModelVersionUnpublishRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ModelVersionUnpublishRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "version_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.versionID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.versionID.isEmpty {
      try visitor.visitSingularStringField(value: self.versionID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_ModelVersionUnpublishRequest, rhs: Clarifai_Api_ModelVersionUnpublishRequest) -> Bool {
    if lhs.versionID != rhs.versionID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_PostModelVersionsUnPublishRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PostModelVersionsUnPublishRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_app_id"),
    2: .standard(proto: "model_id"),
    3: .same(proto: "publications"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._userAppID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.modelID) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.publications) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._userAppID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.modelID.isEmpty {
      try visitor.visitSingularStringField(value: self.modelID, fieldNumber: 2)
    }
    if !self.publications.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.publications, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_PostModelVersionsUnPublishRequest, rhs: Clarifai_Api_PostModelVersionsUnPublishRequest) -> Bool {
    if lhs._userAppID != rhs._userAppID {return false}
    if lhs.modelID != rhs.modelID {return false}
    if lhs.publications != rhs.publications {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_PostEvaluationsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PostEvaluationsRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_app_id"),
    2: .standard(proto: "eval_metrics"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._userAppID) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.evalMetrics) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._userAppID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.evalMetrics.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.evalMetrics, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_PostEvaluationsRequest, rhs: Clarifai_Api_PostEvaluationsRequest) -> Bool {
    if lhs._userAppID != rhs._userAppID {return false}
    if lhs.evalMetrics != rhs.evalMetrics {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_ListEvaluationsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListEvaluationsRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_app_id"),
    2: .same(proto: "page"),
    3: .standard(proto: "per_page"),
    4: .standard(proto: "sort_ascending"),
    5: .standard(proto: "sort_by_app_id"),
    6: .standard(proto: "sort_by_roc_auc"),
    7: .standard(proto: "sort_by_f1"),
    8: .standard(proto: "sort_by_created_at"),
    9: .standard(proto: "sort_by_mean_avg_precision"),
    10: .standard(proto: "sort_by_precision"),
    11: .standard(proto: "sort_by_recall"),
    16: .standard(proto: "sort_by_model_id"),
    17: .standard(proto: "sort_by_eval_dataset_id"),
    18: .standard(proto: "sort_by_train_dataset_id"),
    12: .standard(proto: "model_type_id"),
    13: .standard(proto: "eval_dataset_ids"),
    14: .standard(proto: "train_dataset_ids"),
    15: .standard(proto: "concept_ids"),
    19: .standard(proto: "show_failed_metrics"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._userAppID) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.page) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.perPage) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.sortAscending) }()
      case 5: try {
        var v: Bool?
        try decoder.decodeSingularBoolField(value: &v)
        if let v = v {
          if self.sortBy != nil {try decoder.handleConflictingOneOf()}
          self.sortBy = .sortByAppID(v)
        }
      }()
      case 6: try {
        var v: Bool?
        try decoder.decodeSingularBoolField(value: &v)
        if let v = v {
          if self.sortBy != nil {try decoder.handleConflictingOneOf()}
          self.sortBy = .sortByRocAuc(v)
        }
      }()
      case 7: try {
        var v: Bool?
        try decoder.decodeSingularBoolField(value: &v)
        if let v = v {
          if self.sortBy != nil {try decoder.handleConflictingOneOf()}
          self.sortBy = .sortByF1(v)
        }
      }()
      case 8: try {
        var v: Bool?
        try decoder.decodeSingularBoolField(value: &v)
        if let v = v {
          if self.sortBy != nil {try decoder.handleConflictingOneOf()}
          self.sortBy = .sortByCreatedAt(v)
        }
      }()
      case 9: try {
        var v: Bool?
        try decoder.decodeSingularBoolField(value: &v)
        if let v = v {
          if self.sortBy != nil {try decoder.handleConflictingOneOf()}
          self.sortBy = .sortByMeanAvgPrecision(v)
        }
      }()
      case 10: try {
        var v: Bool?
        try decoder.decodeSingularBoolField(value: &v)
        if let v = v {
          if self.sortBy != nil {try decoder.handleConflictingOneOf()}
          self.sortBy = .sortByPrecision(v)
        }
      }()
      case 11: try {
        var v: Bool?
        try decoder.decodeSingularBoolField(value: &v)
        if let v = v {
          if self.sortBy != nil {try decoder.handleConflictingOneOf()}
          self.sortBy = .sortByRecall(v)
        }
      }()
      case 12: try { try decoder.decodeSingularStringField(value: &self.modelTypeID) }()
      case 13: try { try decoder.decodeRepeatedStringField(value: &self.evalDatasetIds) }()
      case 14: try { try decoder.decodeRepeatedStringField(value: &self.trainDatasetIds) }()
      case 15: try { try decoder.decodeRepeatedStringField(value: &self.conceptIds) }()
      case 16: try {
        var v: Bool?
        try decoder.decodeSingularBoolField(value: &v)
        if let v = v {
          if self.sortBy != nil {try decoder.handleConflictingOneOf()}
          self.sortBy = .sortByModelID(v)
        }
      }()
      case 17: try {
        var v: Bool?
        try decoder.decodeSingularBoolField(value: &v)
        if let v = v {
          if self.sortBy != nil {try decoder.handleConflictingOneOf()}
          self.sortBy = .sortByEvalDatasetID(v)
        }
      }()
      case 18: try {
        var v: Bool?
        try decoder.decodeSingularBoolField(value: &v)
        if let v = v {
          if self.sortBy != nil {try decoder.handleConflictingOneOf()}
          self.sortBy = .sortByTrainDatasetID(v)
        }
      }()
      case 19: try { try decoder.decodeSingularBoolField(value: &self.showFailedMetrics) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._userAppID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.page != 0 {
      try visitor.visitSingularUInt32Field(value: self.page, fieldNumber: 2)
    }
    if self.perPage != 0 {
      try visitor.visitSingularUInt32Field(value: self.perPage, fieldNumber: 3)
    }
    if self.sortAscending != false {
      try visitor.visitSingularBoolField(value: self.sortAscending, fieldNumber: 4)
    }
    switch self.sortBy {
    case .sortByAppID?: try {
      guard case .sortByAppID(let v)? = self.sortBy else { preconditionFailure() }
      try visitor.visitSingularBoolField(value: v, fieldNumber: 5)
    }()
    case .sortByRocAuc?: try {
      guard case .sortByRocAuc(let v)? = self.sortBy else { preconditionFailure() }
      try visitor.visitSingularBoolField(value: v, fieldNumber: 6)
    }()
    case .sortByF1?: try {
      guard case .sortByF1(let v)? = self.sortBy else { preconditionFailure() }
      try visitor.visitSingularBoolField(value: v, fieldNumber: 7)
    }()
    case .sortByCreatedAt?: try {
      guard case .sortByCreatedAt(let v)? = self.sortBy else { preconditionFailure() }
      try visitor.visitSingularBoolField(value: v, fieldNumber: 8)
    }()
    case .sortByMeanAvgPrecision?: try {
      guard case .sortByMeanAvgPrecision(let v)? = self.sortBy else { preconditionFailure() }
      try visitor.visitSingularBoolField(value: v, fieldNumber: 9)
    }()
    case .sortByPrecision?: try {
      guard case .sortByPrecision(let v)? = self.sortBy else { preconditionFailure() }
      try visitor.visitSingularBoolField(value: v, fieldNumber: 10)
    }()
    case .sortByRecall?: try {
      guard case .sortByRecall(let v)? = self.sortBy else { preconditionFailure() }
      try visitor.visitSingularBoolField(value: v, fieldNumber: 11)
    }()
    default: break
    }
    if !self.modelTypeID.isEmpty {
      try visitor.visitSingularStringField(value: self.modelTypeID, fieldNumber: 12)
    }
    if !self.evalDatasetIds.isEmpty {
      try visitor.visitRepeatedStringField(value: self.evalDatasetIds, fieldNumber: 13)
    }
    if !self.trainDatasetIds.isEmpty {
      try visitor.visitRepeatedStringField(value: self.trainDatasetIds, fieldNumber: 14)
    }
    if !self.conceptIds.isEmpty {
      try visitor.visitRepeatedStringField(value: self.conceptIds, fieldNumber: 15)
    }
    switch self.sortBy {
    case .sortByModelID?: try {
      guard case .sortByModelID(let v)? = self.sortBy else { preconditionFailure() }
      try visitor.visitSingularBoolField(value: v, fieldNumber: 16)
    }()
    case .sortByEvalDatasetID?: try {
      guard case .sortByEvalDatasetID(let v)? = self.sortBy else { preconditionFailure() }
      try visitor.visitSingularBoolField(value: v, fieldNumber: 17)
    }()
    case .sortByTrainDatasetID?: try {
      guard case .sortByTrainDatasetID(let v)? = self.sortBy else { preconditionFailure() }
      try visitor.visitSingularBoolField(value: v, fieldNumber: 18)
    }()
    default: break
    }
    if self.showFailedMetrics != false {
      try visitor.visitSingularBoolField(value: self.showFailedMetrics, fieldNumber: 19)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_ListEvaluationsRequest, rhs: Clarifai_Api_ListEvaluationsRequest) -> Bool {
    if lhs._userAppID != rhs._userAppID {return false}
    if lhs.page != rhs.page {return false}
    if lhs.perPage != rhs.perPage {return false}
    if lhs.sortAscending != rhs.sortAscending {return false}
    if lhs.sortBy != rhs.sortBy {return false}
    if lhs.modelTypeID != rhs.modelTypeID {return false}
    if lhs.evalDatasetIds != rhs.evalDatasetIds {return false}
    if lhs.trainDatasetIds != rhs.trainDatasetIds {return false}
    if lhs.conceptIds != rhs.conceptIds {return false}
    if lhs.showFailedMetrics != rhs.showFailedMetrics {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_GetEvaluationRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetEvaluationRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_app_id"),
    2: .standard(proto: "evaluation_id"),
    3: .same(proto: "fields"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._userAppID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.evaluationID) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._fields) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._userAppID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.evaluationID.isEmpty {
      try visitor.visitSingularStringField(value: self.evaluationID, fieldNumber: 2)
    }
    try { if let v = self._fields {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_GetEvaluationRequest, rhs: Clarifai_Api_GetEvaluationRequest) -> Bool {
    if lhs._userAppID != rhs._userAppID {return false}
    if lhs.evaluationID != rhs.evaluationID {return false}
    if lhs._fields != rhs._fields {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_PostModelVersionEvaluationsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PostModelVersionEvaluationsRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_app_id"),
    2: .standard(proto: "model_id"),
    3: .standard(proto: "model_version_id"),
    4: .standard(proto: "eval_metrics"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._userAppID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.modelID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.modelVersionID) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.evalMetrics) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._userAppID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.modelID.isEmpty {
      try visitor.visitSingularStringField(value: self.modelID, fieldNumber: 2)
    }
    if !self.modelVersionID.isEmpty {
      try visitor.visitSingularStringField(value: self.modelVersionID, fieldNumber: 3)
    }
    if !self.evalMetrics.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.evalMetrics, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_PostModelVersionEvaluationsRequest, rhs: Clarifai_Api_PostModelVersionEvaluationsRequest) -> Bool {
    if lhs._userAppID != rhs._userAppID {return false}
    if lhs.modelID != rhs.modelID {return false}
    if lhs.modelVersionID != rhs.modelVersionID {return false}
    if lhs.evalMetrics != rhs.evalMetrics {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_ListModelVersionEvaluationsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListModelVersionEvaluationsRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_app_id"),
    2: .standard(proto: "model_id"),
    3: .standard(proto: "model_version_id"),
    4: .same(proto: "page"),
    5: .standard(proto: "per_page"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._userAppID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.modelID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.modelVersionID) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self.page) }()
      case 5: try { try decoder.decodeSingularUInt32Field(value: &self.perPage) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._userAppID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.modelID.isEmpty {
      try visitor.visitSingularStringField(value: self.modelID, fieldNumber: 2)
    }
    if !self.modelVersionID.isEmpty {
      try visitor.visitSingularStringField(value: self.modelVersionID, fieldNumber: 3)
    }
    if self.page != 0 {
      try visitor.visitSingularUInt32Field(value: self.page, fieldNumber: 4)
    }
    if self.perPage != 0 {
      try visitor.visitSingularUInt32Field(value: self.perPage, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_ListModelVersionEvaluationsRequest, rhs: Clarifai_Api_ListModelVersionEvaluationsRequest) -> Bool {
    if lhs._userAppID != rhs._userAppID {return false}
    if lhs.modelID != rhs.modelID {return false}
    if lhs.modelVersionID != rhs.modelVersionID {return false}
    if lhs.page != rhs.page {return false}
    if lhs.perPage != rhs.perPage {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_GetModelVersionEvaluationRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetModelVersionEvaluationRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_app_id"),
    2: .standard(proto: "model_id"),
    3: .standard(proto: "model_version_id"),
    4: .standard(proto: "evaluation_id"),
    5: .same(proto: "fields"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._userAppID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.modelID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.modelVersionID) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.evaluationID) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._fields) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._userAppID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.modelID.isEmpty {
      try visitor.visitSingularStringField(value: self.modelID, fieldNumber: 2)
    }
    if !self.modelVersionID.isEmpty {
      try visitor.visitSingularStringField(value: self.modelVersionID, fieldNumber: 3)
    }
    if !self.evaluationID.isEmpty {
      try visitor.visitSingularStringField(value: self.evaluationID, fieldNumber: 4)
    }
    try { if let v = self._fields {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_GetModelVersionEvaluationRequest, rhs: Clarifai_Api_GetModelVersionEvaluationRequest) -> Bool {
    if lhs._userAppID != rhs._userAppID {return false}
    if lhs.modelID != rhs.modelID {return false}
    if lhs.modelVersionID != rhs.modelVersionID {return false}
    if lhs.evaluationID != rhs.evaluationID {return false}
    if lhs._fields != rhs._fields {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_SingleEvalMetricsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SingleEvalMetricsResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
    2: .standard(proto: "eval_metrics"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._status) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._evalMetrics) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._status {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._evalMetrics {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_SingleEvalMetricsResponse, rhs: Clarifai_Api_SingleEvalMetricsResponse) -> Bool {
    if lhs._status != rhs._status {return false}
    if lhs._evalMetrics != rhs._evalMetrics {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_MultiEvalMetricsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MultiEvalMetricsResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
    2: .standard(proto: "eval_metrics"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._status) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.evalMetrics) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._status {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.evalMetrics.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.evalMetrics, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_MultiEvalMetricsResponse, rhs: Clarifai_Api_MultiEvalMetricsResponse) -> Bool {
    if lhs._status != rhs._status {return false}
    if lhs.evalMetrics != rhs.evalMetrics {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_PostModelVersionMetricsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PostModelVersionMetricsRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_app_id"),
    2: .standard(proto: "model_id"),
    3: .standard(proto: "version_id"),
    5: .standard(proto: "test_search"),
    10: .standard(proto: "eval_info"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._userAppID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.modelID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.versionID) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._testSearch) }()
      case 10: try { try decoder.decodeSingularMessageField(value: &self._evalInfo) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._userAppID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.modelID.isEmpty {
      try visitor.visitSingularStringField(value: self.modelID, fieldNumber: 2)
    }
    if !self.versionID.isEmpty {
      try visitor.visitSingularStringField(value: self.versionID, fieldNumber: 3)
    }
    try { if let v = self._testSearch {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._evalInfo {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_PostModelVersionMetricsRequest, rhs: Clarifai_Api_PostModelVersionMetricsRequest) -> Bool {
    if lhs._userAppID != rhs._userAppID {return false}
    if lhs.modelID != rhs.modelID {return false}
    if lhs.versionID != rhs.versionID {return false}
    if lhs._testSearch != rhs._testSearch {return false}
    if lhs._evalInfo != rhs._evalInfo {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_GetModelVersionMetricsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetModelVersionMetricsRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_app_id"),
    2: .standard(proto: "model_id"),
    3: .standard(proto: "version_id"),
    4: .same(proto: "fields"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._userAppID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.modelID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.versionID) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._fields) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._userAppID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.modelID.isEmpty {
      try visitor.visitSingularStringField(value: self.modelID, fieldNumber: 2)
    }
    if !self.versionID.isEmpty {
      try visitor.visitSingularStringField(value: self.versionID, fieldNumber: 3)
    }
    try { if let v = self._fields {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_GetModelVersionMetricsRequest, rhs: Clarifai_Api_GetModelVersionMetricsRequest) -> Bool {
    if lhs._userAppID != rhs._userAppID {return false}
    if lhs.modelID != rhs.modelID {return false}
    if lhs.versionID != rhs.versionID {return false}
    if lhs._fields != rhs._fields {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_GetModelTypeRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetModelTypeRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_app_id"),
    2: .standard(proto: "model_type_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._userAppID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.modelTypeID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._userAppID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.modelTypeID.isEmpty {
      try visitor.visitSingularStringField(value: self.modelTypeID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_GetModelTypeRequest, rhs: Clarifai_Api_GetModelTypeRequest) -> Bool {
    if lhs._userAppID != rhs._userAppID {return false}
    if lhs.modelTypeID != rhs.modelTypeID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_ListModelTypesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListModelTypesRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_app_id"),
    2: .same(proto: "page"),
    3: .standard(proto: "per_page"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._userAppID) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.page) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.perPage) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._userAppID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.page != 0 {
      try visitor.visitSingularUInt32Field(value: self.page, fieldNumber: 2)
    }
    if self.perPage != 0 {
      try visitor.visitSingularUInt32Field(value: self.perPage, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_ListModelTypesRequest, rhs: Clarifai_Api_ListModelTypesRequest) -> Bool {
    if lhs._userAppID != rhs._userAppID {return false}
    if lhs.page != rhs.page {return false}
    if lhs.perPage != rhs.perPage {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_ListOpenSourceLicensesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListOpenSourceLicensesRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_ListOpenSourceLicensesRequest, rhs: Clarifai_Api_ListOpenSourceLicensesRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_ListOpenSourceLicensesResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListOpenSourceLicensesResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
    2: .same(proto: "licenses"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._status) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.licenses) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._status {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.licenses.isEmpty {
      try visitor.visitRepeatedStringField(value: self.licenses, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_ListOpenSourceLicensesResponse, rhs: Clarifai_Api_ListOpenSourceLicensesResponse) -> Bool {
    if lhs._status != rhs._status {return false}
    if lhs.licenses != rhs.licenses {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_SingleModelTypeResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SingleModelTypeResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
    2: .standard(proto: "model_type"),
  ]

  fileprivate class _StorageClass {
    var _status: Clarifai_Api_Status_Status? = nil
    var _modelType: Clarifai_Api_ModelType? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _status = source._status
      _modelType = source._modelType
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._status) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._modelType) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._status {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._modelType {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_SingleModelTypeResponse, rhs: Clarifai_Api_SingleModelTypeResponse) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._status != rhs_storage._status {return false}
        if _storage._modelType != rhs_storage._modelType {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_MultiModelTypeResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MultiModelTypeResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
    2: .standard(proto: "model_types"),
    3: .standard(proto: "model_importers"),
    4: .standard(proto: "triton_conda_envs_info"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._status) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.modelTypes) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._modelImporters) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.tritonCondaEnvsInfo) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._status {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.modelTypes.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.modelTypes, fieldNumber: 2)
    }
    try { if let v = self._modelImporters {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if !self.tritonCondaEnvsInfo.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.tritonCondaEnvsInfo, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_MultiModelTypeResponse, rhs: Clarifai_Api_MultiModelTypeResponse) -> Bool {
    if lhs._status != rhs._status {return false}
    if lhs.modelTypes != rhs.modelTypes {return false}
    if lhs._modelImporters != rhs._modelImporters {return false}
    if lhs.tritonCondaEnvsInfo != rhs.tritonCondaEnvsInfo {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_GetModelVersionInputExampleRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetModelVersionInputExampleRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_app_id"),
    2: .standard(proto: "model_id"),
    3: .standard(proto: "model_version_id"),
    4: .standard(proto: "example_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._userAppID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.modelID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.modelVersionID) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.exampleID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._userAppID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.modelID.isEmpty {
      try visitor.visitSingularStringField(value: self.modelID, fieldNumber: 2)
    }
    if !self.modelVersionID.isEmpty {
      try visitor.visitSingularStringField(value: self.modelVersionID, fieldNumber: 3)
    }
    if !self.exampleID.isEmpty {
      try visitor.visitSingularStringField(value: self.exampleID, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_GetModelVersionInputExampleRequest, rhs: Clarifai_Api_GetModelVersionInputExampleRequest) -> Bool {
    if lhs._userAppID != rhs._userAppID {return false}
    if lhs.modelID != rhs.modelID {return false}
    if lhs.modelVersionID != rhs.modelVersionID {return false}
    if lhs.exampleID != rhs.exampleID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_ListModelVersionInputExamplesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListModelVersionInputExamplesRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_app_id"),
    2: .standard(proto: "model_id"),
    3: .standard(proto: "model_version_id"),
    4: .same(proto: "page"),
    5: .standard(proto: "per_page"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._userAppID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.modelID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.modelVersionID) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self.page) }()
      case 5: try { try decoder.decodeSingularUInt32Field(value: &self.perPage) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._userAppID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.modelID.isEmpty {
      try visitor.visitSingularStringField(value: self.modelID, fieldNumber: 2)
    }
    if !self.modelVersionID.isEmpty {
      try visitor.visitSingularStringField(value: self.modelVersionID, fieldNumber: 3)
    }
    if self.page != 0 {
      try visitor.visitSingularUInt32Field(value: self.page, fieldNumber: 4)
    }
    if self.perPage != 0 {
      try visitor.visitSingularUInt32Field(value: self.perPage, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_ListModelVersionInputExamplesRequest, rhs: Clarifai_Api_ListModelVersionInputExamplesRequest) -> Bool {
    if lhs._userAppID != rhs._userAppID {return false}
    if lhs.modelID != rhs.modelID {return false}
    if lhs.modelVersionID != rhs.modelVersionID {return false}
    if lhs.page != rhs.page {return false}
    if lhs.perPage != rhs.perPage {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_SingleModelVersionInputExampleResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SingleModelVersionInputExampleResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
    2: .standard(proto: "model_version_input_example"),
  ]

  fileprivate class _StorageClass {
    var _status: Clarifai_Api_Status_Status? = nil
    var _modelVersionInputExample: Clarifai_Api_ModelVersionInputExample? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _status = source._status
      _modelVersionInputExample = source._modelVersionInputExample
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._status) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._modelVersionInputExample) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._status {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._modelVersionInputExample {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_SingleModelVersionInputExampleResponse, rhs: Clarifai_Api_SingleModelVersionInputExampleResponse) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._status != rhs_storage._status {return false}
        if _storage._modelVersionInputExample != rhs_storage._modelVersionInputExample {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_MultiModelVersionInputExampleResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MultiModelVersionInputExampleResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
    2: .standard(proto: "model_version_input_examples"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._status) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.modelVersionInputExamples) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._status {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.modelVersionInputExamples.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.modelVersionInputExamples, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_MultiModelVersionInputExampleResponse, rhs: Clarifai_Api_MultiModelVersionInputExampleResponse) -> Bool {
    if lhs._status != rhs._status {return false}
    if lhs.modelVersionInputExamples != rhs.modelVersionInputExamples {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_ListModelReferencesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListModelReferencesRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_app_id"),
    2: .standard(proto: "model_id"),
    3: .same(proto: "page"),
    4: .standard(proto: "per_page"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._userAppID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.modelID) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.page) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self.perPage) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._userAppID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.modelID.isEmpty {
      try visitor.visitSingularStringField(value: self.modelID, fieldNumber: 2)
    }
    if self.page != 0 {
      try visitor.visitSingularUInt32Field(value: self.page, fieldNumber: 3)
    }
    if self.perPage != 0 {
      try visitor.visitSingularUInt32Field(value: self.perPage, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_ListModelReferencesRequest, rhs: Clarifai_Api_ListModelReferencesRequest) -> Bool {
    if lhs._userAppID != rhs._userAppID {return false}
    if lhs.modelID != rhs.modelID {return false}
    if lhs.page != rhs.page {return false}
    if lhs.perPage != rhs.perPage {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_MultiModelReferenceResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MultiModelReferenceResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
    2: .standard(proto: "model_references"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._status) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.modelReferences) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._status {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.modelReferences.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.modelReferences, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_MultiModelReferenceResponse, rhs: Clarifai_Api_MultiModelReferenceResponse) -> Bool {
    if lhs._status != rhs._status {return false}
    if lhs.modelReferences != rhs.modelReferences {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_MultiOutputResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MultiOutputResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
    2: .same(proto: "outputs"),
    3: .standard(proto: "runner_selector"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._status) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.outputs) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._runnerSelector) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._status {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.outputs.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.outputs, fieldNumber: 2)
    }
    try { if let v = self._runnerSelector {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_MultiOutputResponse, rhs: Clarifai_Api_MultiOutputResponse) -> Bool {
    if lhs._status != rhs._status {return false}
    if lhs.outputs != rhs.outputs {return false}
    if lhs._runnerSelector != rhs._runnerSelector {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_MultiLogEntryResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MultiLogEntryResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
    2: .standard(proto: "log_entries"),
    4: .same(proto: "page"),
    5: .standard(proto: "per_page"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._status) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.logEntries) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self.page) }()
      case 5: try { try decoder.decodeSingularUInt32Field(value: &self.perPage) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._status {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.logEntries.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.logEntries, fieldNumber: 2)
    }
    if self.page != 0 {
      try visitor.visitSingularUInt32Field(value: self.page, fieldNumber: 4)
    }
    if self.perPage != 0 {
      try visitor.visitSingularUInt32Field(value: self.perPage, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_MultiLogEntryResponse, rhs: Clarifai_Api_MultiLogEntryResponse) -> Bool {
    if lhs._status != rhs._status {return false}
    if lhs.logEntries != rhs.logEntries {return false}
    if lhs.page != rhs.page {return false}
    if lhs.perPage != rhs.perPage {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_ListScopesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListScopesRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "key_type"),
    2: .standard(proto: "user_app_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.keyType) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._userAppID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.keyType.isEmpty {
      try visitor.visitSingularStringField(value: self.keyType, fieldNumber: 1)
    }
    try { if let v = self._userAppID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_ListScopesRequest, rhs: Clarifai_Api_ListScopesRequest) -> Bool {
    if lhs.keyType != rhs.keyType {return false}
    if lhs._userAppID != rhs._userAppID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_MyScopesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MyScopesRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_app_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._userAppID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._userAppID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_MyScopesRequest, rhs: Clarifai_Api_MyScopesRequest) -> Bool {
    if lhs._userAppID != rhs._userAppID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_MyScopesUserRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MyScopesUserRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_app_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._userAppID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._userAppID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_MyScopesUserRequest, rhs: Clarifai_Api_MyScopesUserRequest) -> Bool {
    if lhs._userAppID != rhs._userAppID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_MyScopesRootRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MyScopesRootRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_MyScopesRootRequest, rhs: Clarifai_Api_MyScopesRootRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_MultiScopeDepsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MultiScopeDepsResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
    2: .standard(proto: "scope_deps"),
    3: .standard(proto: "endpoint_deps"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._status) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.scopeDeps) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.endpointDeps) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._status {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.scopeDeps.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.scopeDeps, fieldNumber: 2)
    }
    if !self.endpointDeps.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.endpointDeps, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_MultiScopeDepsResponse, rhs: Clarifai_Api_MultiScopeDepsResponse) -> Bool {
    if lhs._status != rhs._status {return false}
    if lhs.scopeDeps != rhs.scopeDeps {return false}
    if lhs.endpointDeps != rhs.endpointDeps {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_MultiScopeResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MultiScopeResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
    2: .same(proto: "scopes"),
    3: .same(proto: "app"),
    4: .same(proto: "endpoints"),
    5: .standard(proto: "user_feature_flags"),
  ]

  fileprivate class _StorageClass {
    var _status: Clarifai_Api_Status_Status? = nil
    var _scopes: [String] = []
    var _app: Clarifai_Api_App? = nil
    var _endpoints: [String] = []
    var _userFeatureFlags: String = String()

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _status = source._status
      _scopes = source._scopes
      _app = source._app
      _endpoints = source._endpoints
      _userFeatureFlags = source._userFeatureFlags
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._status) }()
        case 2: try { try decoder.decodeRepeatedStringField(value: &_storage._scopes) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._app) }()
        case 4: try { try decoder.decodeRepeatedStringField(value: &_storage._endpoints) }()
        case 5: try { try decoder.decodeSingularStringField(value: &_storage._userFeatureFlags) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._status {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      if !_storage._scopes.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._scopes, fieldNumber: 2)
      }
      try { if let v = _storage._app {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      if !_storage._endpoints.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._endpoints, fieldNumber: 4)
      }
      if !_storage._userFeatureFlags.isEmpty {
        try visitor.visitSingularStringField(value: _storage._userFeatureFlags, fieldNumber: 5)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_MultiScopeResponse, rhs: Clarifai_Api_MultiScopeResponse) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._status != rhs_storage._status {return false}
        if _storage._scopes != rhs_storage._scopes {return false}
        if _storage._app != rhs_storage._app {return false}
        if _storage._endpoints != rhs_storage._endpoints {return false}
        if _storage._userFeatureFlags != rhs_storage._userFeatureFlags {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_MultiScopeUserResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MultiScopeUserResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
    2: .same(proto: "scopes"),
    4: .same(proto: "endpoints"),
    5: .standard(proto: "user_feature_flags"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._status) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.scopes) }()
      case 4: try { try decoder.decodeRepeatedStringField(value: &self.endpoints) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.userFeatureFlags) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._status {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.scopes.isEmpty {
      try visitor.visitRepeatedStringField(value: self.scopes, fieldNumber: 2)
    }
    if !self.endpoints.isEmpty {
      try visitor.visitRepeatedStringField(value: self.endpoints, fieldNumber: 4)
    }
    if !self.userFeatureFlags.isEmpty {
      try visitor.visitSingularStringField(value: self.userFeatureFlags, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_MultiScopeUserResponse, rhs: Clarifai_Api_MultiScopeUserResponse) -> Bool {
    if lhs._status != rhs._status {return false}
    if lhs.scopes != rhs.scopes {return false}
    if lhs.endpoints != rhs.endpoints {return false}
    if lhs.userFeatureFlags != rhs.userFeatureFlags {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_MultiScopeRootResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MultiScopeRootResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
    2: .same(proto: "scopes"),
    4: .same(proto: "endpoints"),
    5: .standard(proto: "user_feature_flags"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._status) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.scopes) }()
      case 4: try { try decoder.decodeRepeatedStringField(value: &self.endpoints) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.userFeatureFlags) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._status {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.scopes.isEmpty {
      try visitor.visitRepeatedStringField(value: self.scopes, fieldNumber: 2)
    }
    if !self.endpoints.isEmpty {
      try visitor.visitRepeatedStringField(value: self.endpoints, fieldNumber: 4)
    }
    if !self.userFeatureFlags.isEmpty {
      try visitor.visitSingularStringField(value: self.userFeatureFlags, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_MultiScopeRootResponse, rhs: Clarifai_Api_MultiScopeRootResponse) -> Bool {
    if lhs._status != rhs._status {return false}
    if lhs.scopes != rhs.scopes {return false}
    if lhs.endpoints != rhs.endpoints {return false}
    if lhs.userFeatureFlags != rhs.userFeatureFlags {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_GetSearchRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetSearchRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_app_id"),
    2: .same(proto: "id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._userAppID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.id) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._userAppID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_GetSearchRequest, rhs: Clarifai_Api_GetSearchRequest) -> Bool {
    if lhs._userAppID != rhs._userAppID {return false}
    if lhs.id != rhs.id {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_ListSearchesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListSearchesRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_app_id"),
    2: .same(proto: "page"),
    3: .standard(proto: "per_page"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._userAppID) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.page) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.perPage) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._userAppID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.page != 0 {
      try visitor.visitSingularUInt32Field(value: self.page, fieldNumber: 2)
    }
    if self.perPage != 0 {
      try visitor.visitSingularUInt32Field(value: self.perPage, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_ListSearchesRequest, rhs: Clarifai_Api_ListSearchesRequest) -> Bool {
    if lhs._userAppID != rhs._userAppID {return false}
    if lhs.page != rhs.page {return false}
    if lhs.perPage != rhs.perPage {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_PostSearchesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PostSearchesRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_app_id"),
    2: .same(proto: "query"),
    3: .same(proto: "searches"),
    4: .same(proto: "pagination"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._userAppID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._query) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.searches) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._pagination) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._userAppID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._query {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.searches.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.searches, fieldNumber: 3)
    }
    try { if let v = self._pagination {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_PostSearchesRequest, rhs: Clarifai_Api_PostSearchesRequest) -> Bool {
    if lhs._userAppID != rhs._userAppID {return false}
    if lhs._query != rhs._query {return false}
    if lhs.searches != rhs.searches {return false}
    if lhs._pagination != rhs._pagination {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_PatchInputsSearchesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PatchInputsSearchesRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_app_id"),
    2: .same(proto: "searches"),
    3: .same(proto: "action"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._userAppID) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.searches) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.action) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._userAppID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.searches.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.searches, fieldNumber: 2)
    }
    if !self.action.isEmpty {
      try visitor.visitSingularStringField(value: self.action, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_PatchInputsSearchesRequest, rhs: Clarifai_Api_PatchInputsSearchesRequest) -> Bool {
    if lhs._userAppID != rhs._userAppID {return false}
    if lhs.searches != rhs.searches {return false}
    if lhs.action != rhs.action {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_PatchAnnotationsSearchesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PatchAnnotationsSearchesRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_app_id"),
    2: .same(proto: "searches"),
    3: .same(proto: "action"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._userAppID) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.searches) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.action) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._userAppID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.searches.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.searches, fieldNumber: 2)
    }
    if !self.action.isEmpty {
      try visitor.visitSingularStringField(value: self.action, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_PatchAnnotationsSearchesRequest, rhs: Clarifai_Api_PatchAnnotationsSearchesRequest) -> Bool {
    if lhs._userAppID != rhs._userAppID {return false}
    if lhs.searches != rhs.searches {return false}
    if lhs.action != rhs.action {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_PatchSearchesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PatchSearchesRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_app_id"),
    2: .same(proto: "searches"),
    3: .same(proto: "action"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._userAppID) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.searches) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.action) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._userAppID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.searches.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.searches, fieldNumber: 2)
    }
    if !self.action.isEmpty {
      try visitor.visitSingularStringField(value: self.action, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_PatchSearchesRequest, rhs: Clarifai_Api_PatchSearchesRequest) -> Bool {
    if lhs._userAppID != rhs._userAppID {return false}
    if lhs.searches != rhs.searches {return false}
    if lhs.action != rhs.action {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_PostSearchesByIDRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PostSearchesByIDRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_app_id"),
    2: .same(proto: "id"),
    3: .same(proto: "pagination"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._userAppID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._pagination) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._userAppID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 2)
    }
    try { if let v = self._pagination {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_PostSearchesByIDRequest, rhs: Clarifai_Api_PostSearchesByIDRequest) -> Bool {
    if lhs._userAppID != rhs._userAppID {return false}
    if lhs.id != rhs.id {return false}
    if lhs._pagination != rhs._pagination {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_DeleteSearchRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DeleteSearchRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_app_id"),
    2: .same(proto: "id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._userAppID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.id) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._userAppID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_DeleteSearchRequest, rhs: Clarifai_Api_DeleteSearchRequest) -> Bool {
    if lhs._userAppID != rhs._userAppID {return false}
    if lhs.id != rhs.id {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_PostAnnotationsSearchesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PostAnnotationsSearchesRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_app_id"),
    2: .same(proto: "searches"),
    3: .same(proto: "pagination"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._userAppID) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.searches) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._pagination) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._userAppID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.searches.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.searches, fieldNumber: 2)
    }
    try { if let v = self._pagination {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_PostAnnotationsSearchesRequest, rhs: Clarifai_Api_PostAnnotationsSearchesRequest) -> Bool {
    if lhs._userAppID != rhs._userAppID {return false}
    if lhs.searches != rhs.searches {return false}
    if lhs._pagination != rhs._pagination {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_DeleteAnnotationSearchMetricsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DeleteAnnotationSearchMetricsRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_app_id"),
    2: .same(proto: "id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._userAppID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.id) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._userAppID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_DeleteAnnotationSearchMetricsRequest, rhs: Clarifai_Api_DeleteAnnotationSearchMetricsRequest) -> Bool {
    if lhs._userAppID != rhs._userAppID {return false}
    if lhs.id != rhs.id {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_PostInputsSearchesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PostInputsSearchesRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_app_id"),
    2: .same(proto: "searches"),
    3: .same(proto: "pagination"),
    4: .standard(proto: "only_count"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._userAppID) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.searches) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._pagination) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.onlyCount) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._userAppID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.searches.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.searches, fieldNumber: 2)
    }
    try { if let v = self._pagination {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if self.onlyCount != false {
      try visitor.visitSingularBoolField(value: self.onlyCount, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_PostInputsSearchesRequest, rhs: Clarifai_Api_PostInputsSearchesRequest) -> Bool {
    if lhs._userAppID != rhs._userAppID {return false}
    if lhs.searches != rhs.searches {return false}
    if lhs._pagination != rhs._pagination {return false}
    if lhs.onlyCount != rhs.onlyCount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_SingleSearchResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SingleSearchResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
    5: .same(proto: "search"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._status) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._search) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._status {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._search {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_SingleSearchResponse, rhs: Clarifai_Api_SingleSearchResponse) -> Bool {
    if lhs._status != rhs._status {return false}
    if lhs._search != rhs._search {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_MultiSearchResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MultiSearchResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
    2: .same(proto: "id"),
    3: .same(proto: "hits"),
    4: .same(proto: "query"),
    5: .same(proto: "searches"),
    6: .standard(proto: "hit_counts"),
  ]

  fileprivate class _StorageClass {
    var _status: Clarifai_Api_Status_Status? = nil
    var _id: String = String()
    var _hits: [Clarifai_Api_Hit] = []
    var _query: Clarifai_Api_Query? = nil
    var _searches: [Clarifai_Api_Search] = []
    var _hitCounts: [Clarifai_Api_HitCount] = []

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _status = source._status
      _id = source._id
      _hits = source._hits
      _query = source._query
      _searches = source._searches
      _hitCounts = source._hitCounts
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._status) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._id) }()
        case 3: try { try decoder.decodeRepeatedMessageField(value: &_storage._hits) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._query) }()
        case 5: try { try decoder.decodeRepeatedMessageField(value: &_storage._searches) }()
        case 6: try { try decoder.decodeRepeatedMessageField(value: &_storage._hitCounts) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._status {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      if !_storage._id.isEmpty {
        try visitor.visitSingularStringField(value: _storage._id, fieldNumber: 2)
      }
      if !_storage._hits.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._hits, fieldNumber: 3)
      }
      try { if let v = _storage._query {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      if !_storage._searches.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._searches, fieldNumber: 5)
      }
      if !_storage._hitCounts.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._hitCounts, fieldNumber: 6)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_MultiSearchResponse, rhs: Clarifai_Api_MultiSearchResponse) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._status != rhs_storage._status {return false}
        if _storage._id != rhs_storage._id {return false}
        if _storage._hits != rhs_storage._hits {return false}
        if _storage._query != rhs_storage._query {return false}
        if _storage._searches != rhs_storage._searches {return false}
        if _storage._hitCounts != rhs_storage._hitCounts {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_PostAnnotationSearchMetricsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PostAnnotationSearchMetricsRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_app_id"),
    2: .same(proto: "id"),
    3: .standard(proto: "ground_truth"),
    4: .standard(proto: "search_to_eval"),
    5: .same(proto: "data"),
    6: .standard(proto: "evaluation_type"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._userAppID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._groundTruth) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._searchToEval) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._data) }()
      case 6: try { try decoder.decodeSingularEnumField(value: &self.evaluationType) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._userAppID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 2)
    }
    try { if let v = self._groundTruth {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._searchToEval {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._data {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    if self.evaluationType != .undefined {
      try visitor.visitSingularEnumField(value: self.evaluationType, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_PostAnnotationSearchMetricsRequest, rhs: Clarifai_Api_PostAnnotationSearchMetricsRequest) -> Bool {
    if lhs._userAppID != rhs._userAppID {return false}
    if lhs.id != rhs.id {return false}
    if lhs._groundTruth != rhs._groundTruth {return false}
    if lhs._searchToEval != rhs._searchToEval {return false}
    if lhs._data != rhs._data {return false}
    if lhs.evaluationType != rhs.evaluationType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_GetAnnotationSearchMetricsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetAnnotationSearchMetricsRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_app_id"),
    2: .same(proto: "id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._userAppID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.id) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._userAppID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_GetAnnotationSearchMetricsRequest, rhs: Clarifai_Api_GetAnnotationSearchMetricsRequest) -> Bool {
    if lhs._userAppID != rhs._userAppID {return false}
    if lhs.id != rhs.id {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_ListAnnotationSearchMetricsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListAnnotationSearchMetricsRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_app_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._userAppID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._userAppID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_ListAnnotationSearchMetricsRequest, rhs: Clarifai_Api_ListAnnotationSearchMetricsRequest) -> Bool {
    if lhs._userAppID != rhs._userAppID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_MultiAnnotationSearchMetricsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MultiAnnotationSearchMetricsResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
    2: .standard(proto: "annotation_search_metrics"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._status) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.annotationSearchMetrics) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._status {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.annotationSearchMetrics.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.annotationSearchMetrics, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_MultiAnnotationSearchMetricsResponse, rhs: Clarifai_Api_MultiAnnotationSearchMetricsResponse) -> Bool {
    if lhs._status != rhs._status {return false}
    if lhs.annotationSearchMetrics != rhs.annotationSearchMetrics {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_ListAnnotationFiltersRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListAnnotationFiltersRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_app_id"),
    2: .same(proto: "page"),
    3: .standard(proto: "per_page"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._userAppID) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.page) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.perPage) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._userAppID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.page != 0 {
      try visitor.visitSingularUInt32Field(value: self.page, fieldNumber: 2)
    }
    if self.perPage != 0 {
      try visitor.visitSingularUInt32Field(value: self.perPage, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_ListAnnotationFiltersRequest, rhs: Clarifai_Api_ListAnnotationFiltersRequest) -> Bool {
    if lhs._userAppID != rhs._userAppID {return false}
    if lhs.page != rhs.page {return false}
    if lhs.perPage != rhs.perPage {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_GetAnnotationFilterRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetAnnotationFilterRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_app_id"),
    2: .standard(proto: "annotation_filter_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._userAppID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.annotationFilterID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._userAppID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.annotationFilterID.isEmpty {
      try visitor.visitSingularStringField(value: self.annotationFilterID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_GetAnnotationFilterRequest, rhs: Clarifai_Api_GetAnnotationFilterRequest) -> Bool {
    if lhs._userAppID != rhs._userAppID {return false}
    if lhs.annotationFilterID != rhs.annotationFilterID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_PostAnnotationFiltersRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PostAnnotationFiltersRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_app_id"),
    2: .standard(proto: "annotation_filters"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._userAppID) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.annotationFilters) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._userAppID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.annotationFilters.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.annotationFilters, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_PostAnnotationFiltersRequest, rhs: Clarifai_Api_PostAnnotationFiltersRequest) -> Bool {
    if lhs._userAppID != rhs._userAppID {return false}
    if lhs.annotationFilters != rhs.annotationFilters {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_PatchAnnotationFiltersRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PatchAnnotationFiltersRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_app_id"),
    2: .standard(proto: "annotation_filters"),
    3: .same(proto: "action"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._userAppID) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.annotationFilters) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.action) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._userAppID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.annotationFilters.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.annotationFilters, fieldNumber: 2)
    }
    if !self.action.isEmpty {
      try visitor.visitSingularStringField(value: self.action, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_PatchAnnotationFiltersRequest, rhs: Clarifai_Api_PatchAnnotationFiltersRequest) -> Bool {
    if lhs._userAppID != rhs._userAppID {return false}
    if lhs.annotationFilters != rhs.annotationFilters {return false}
    if lhs.action != rhs.action {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_DeleteAnnotationFiltersRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DeleteAnnotationFiltersRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_app_id"),
    2: .standard(proto: "annotation_filter_ids"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._userAppID) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.annotationFilterIds) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._userAppID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.annotationFilterIds.isEmpty {
      try visitor.visitRepeatedStringField(value: self.annotationFilterIds, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_DeleteAnnotationFiltersRequest, rhs: Clarifai_Api_DeleteAnnotationFiltersRequest) -> Bool {
    if lhs._userAppID != rhs._userAppID {return false}
    if lhs.annotationFilterIds != rhs.annotationFilterIds {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_MultiAnnotationFilterResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MultiAnnotationFilterResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
    2: .standard(proto: "annotation_filters"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._status) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.annotationFilters) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._status {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.annotationFilters.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.annotationFilters, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_MultiAnnotationFilterResponse, rhs: Clarifai_Api_MultiAnnotationFilterResponse) -> Bool {
    if lhs._status != rhs._status {return false}
    if lhs.annotationFilters != rhs.annotationFilters {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_SingleAnnotationFilterResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SingleAnnotationFilterResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
    2: .standard(proto: "annotation_filter"),
  ]

  fileprivate class _StorageClass {
    var _status: Clarifai_Api_Status_Status? = nil
    var _annotationFilter: Clarifai_Api_AnnotationFilter? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _status = source._status
      _annotationFilter = source._annotationFilter
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._status) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._annotationFilter) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._status {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._annotationFilter {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_SingleAnnotationFilterResponse, rhs: Clarifai_Api_SingleAnnotationFilterResponse) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._status != rhs_storage._status {return false}
        if _storage._annotationFilter != rhs_storage._annotationFilter {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_GetUserRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetUserRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_app_id"),
    2: .standard(proto: "additional_fields"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._userAppID) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.additionalFields) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._userAppID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.additionalFields.isEmpty {
      try visitor.visitRepeatedStringField(value: self.additionalFields, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_GetUserRequest, rhs: Clarifai_Api_GetUserRequest) -> Bool {
    if lhs._userAppID != rhs._userAppID {return false}
    if lhs.additionalFields != rhs.additionalFields {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_SingleUserResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SingleUserResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
    2: .same(proto: "user"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._status) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._user) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._status {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._user {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_SingleUserResponse, rhs: Clarifai_Api_SingleUserResponse) -> Bool {
    if lhs._status != rhs._status {return false}
    if lhs._user != rhs._user {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_PostValidatePasswordRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PostValidatePasswordRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_app_id"),
    2: .same(proto: "password"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._userAppID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._password) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._userAppID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._password {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_PostValidatePasswordRequest, rhs: Clarifai_Api_PostValidatePasswordRequest) -> Bool {
    if lhs._userAppID != rhs._userAppID {return false}
    if lhs._password != rhs._password {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_SinglePasswordValidationResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SinglePasswordValidationResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
    2: .standard(proto: "password_violations"),
  ]

  fileprivate class _StorageClass {
    var _status: Clarifai_Api_Status_Status? = nil
    var _passwordViolations: Clarifai_Api_PasswordViolations? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _status = source._status
      _passwordViolations = source._passwordViolations
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._status) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._passwordViolations) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._status {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._passwordViolations {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_SinglePasswordValidationResponse, rhs: Clarifai_Api_SinglePasswordValidationResponse) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._status != rhs_storage._status {return false}
        if _storage._passwordViolations != rhs_storage._passwordViolations {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_GetWorkflowRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetWorkflowRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_app_id"),
    2: .standard(proto: "workflow_id"),
    4: .standard(proto: "additional_fields"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._userAppID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.workflowID) }()
      case 4: try { try decoder.decodeRepeatedStringField(value: &self.additionalFields) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._userAppID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.workflowID.isEmpty {
      try visitor.visitSingularStringField(value: self.workflowID, fieldNumber: 2)
    }
    if !self.additionalFields.isEmpty {
      try visitor.visitRepeatedStringField(value: self.additionalFields, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_GetWorkflowRequest, rhs: Clarifai_Api_GetWorkflowRequest) -> Bool {
    if lhs._userAppID != rhs._userAppID {return false}
    if lhs.workflowID != rhs.workflowID {return false}
    if lhs.additionalFields != rhs.additionalFields {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_ListWorkflowsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListWorkflowsRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_app_id"),
    2: .same(proto: "page"),
    3: .standard(proto: "per_page"),
    10: .standard(proto: "additional_fields"),
    5: .standard(proto: "sort_ascending"),
    6: .standard(proto: "sort_by_id"),
    7: .standard(proto: "sort_by_modified_at"),
    13: .standard(proto: "sort_by_created_at"),
    14: .standard(proto: "sort_by_star_count"),
    9: .standard(proto: "featured_only"),
    11: .standard(proto: "starred_only"),
    15: .same(proto: "bookmark"),
    17: .same(proto: "visibility"),
    16: .same(proto: "search"),
    8: .same(proto: "query"),
    4: .same(proto: "id"),
    12: .standard(proto: "search_term"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._userAppID) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.page) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.perPage) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.sortAscending) }()
      case 6: try {
        var v: Bool?
        try decoder.decodeSingularBoolField(value: &v)
        if let v = v {
          if self.sortBy != nil {try decoder.handleConflictingOneOf()}
          self.sortBy = .sortByID(v)
        }
      }()
      case 7: try {
        var v: Bool?
        try decoder.decodeSingularBoolField(value: &v)
        if let v = v {
          if self.sortBy != nil {try decoder.handleConflictingOneOf()}
          self.sortBy = .sortByModifiedAt(v)
        }
      }()
      case 8: try { try decoder.decodeSingularStringField(value: &self.query) }()
      case 9: try { try decoder.decodeSingularBoolField(value: &self.featuredOnly) }()
      case 10: try { try decoder.decodeRepeatedStringField(value: &self.additionalFields) }()
      case 11: try { try decoder.decodeSingularBoolField(value: &self.starredOnly) }()
      case 12: try { try decoder.decodeSingularStringField(value: &self.searchTerm) }()
      case 13: try {
        var v: Bool?
        try decoder.decodeSingularBoolField(value: &v)
        if let v = v {
          if self.sortBy != nil {try decoder.handleConflictingOneOf()}
          self.sortBy = .sortByCreatedAt(v)
        }
      }()
      case 14: try {
        var v: Bool?
        try decoder.decodeSingularBoolField(value: &v)
        if let v = v {
          if self.sortBy != nil {try decoder.handleConflictingOneOf()}
          self.sortBy = .sortByStarCount(v)
        }
      }()
      case 15: try { try decoder.decodeSingularBoolField(value: &self.bookmark) }()
      case 16: try { try decoder.decodeSingularStringField(value: &self.search) }()
      case 17: try { try decoder.decodeSingularMessageField(value: &self._visibility) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._userAppID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.page != 0 {
      try visitor.visitSingularUInt32Field(value: self.page, fieldNumber: 2)
    }
    if self.perPage != 0 {
      try visitor.visitSingularUInt32Field(value: self.perPage, fieldNumber: 3)
    }
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 4)
    }
    if self.sortAscending != false {
      try visitor.visitSingularBoolField(value: self.sortAscending, fieldNumber: 5)
    }
    switch self.sortBy {
    case .sortByID?: try {
      guard case .sortByID(let v)? = self.sortBy else { preconditionFailure() }
      try visitor.visitSingularBoolField(value: v, fieldNumber: 6)
    }()
    case .sortByModifiedAt?: try {
      guard case .sortByModifiedAt(let v)? = self.sortBy else { preconditionFailure() }
      try visitor.visitSingularBoolField(value: v, fieldNumber: 7)
    }()
    default: break
    }
    if !self.query.isEmpty {
      try visitor.visitSingularStringField(value: self.query, fieldNumber: 8)
    }
    if self.featuredOnly != false {
      try visitor.visitSingularBoolField(value: self.featuredOnly, fieldNumber: 9)
    }
    if !self.additionalFields.isEmpty {
      try visitor.visitRepeatedStringField(value: self.additionalFields, fieldNumber: 10)
    }
    if self.starredOnly != false {
      try visitor.visitSingularBoolField(value: self.starredOnly, fieldNumber: 11)
    }
    if !self.searchTerm.isEmpty {
      try visitor.visitSingularStringField(value: self.searchTerm, fieldNumber: 12)
    }
    switch self.sortBy {
    case .sortByCreatedAt?: try {
      guard case .sortByCreatedAt(let v)? = self.sortBy else { preconditionFailure() }
      try visitor.visitSingularBoolField(value: v, fieldNumber: 13)
    }()
    case .sortByStarCount?: try {
      guard case .sortByStarCount(let v)? = self.sortBy else { preconditionFailure() }
      try visitor.visitSingularBoolField(value: v, fieldNumber: 14)
    }()
    default: break
    }
    if self.bookmark != false {
      try visitor.visitSingularBoolField(value: self.bookmark, fieldNumber: 15)
    }
    if !self.search.isEmpty {
      try visitor.visitSingularStringField(value: self.search, fieldNumber: 16)
    }
    try { if let v = self._visibility {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 17)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_ListWorkflowsRequest, rhs: Clarifai_Api_ListWorkflowsRequest) -> Bool {
    if lhs._userAppID != rhs._userAppID {return false}
    if lhs.page != rhs.page {return false}
    if lhs.perPage != rhs.perPage {return false}
    if lhs.additionalFields != rhs.additionalFields {return false}
    if lhs.sortAscending != rhs.sortAscending {return false}
    if lhs.sortBy != rhs.sortBy {return false}
    if lhs.featuredOnly != rhs.featuredOnly {return false}
    if lhs.starredOnly != rhs.starredOnly {return false}
    if lhs.bookmark != rhs.bookmark {return false}
    if lhs._visibility != rhs._visibility {return false}
    if lhs.search != rhs.search {return false}
    if lhs.query != rhs.query {return false}
    if lhs.id != rhs.id {return false}
    if lhs.searchTerm != rhs.searchTerm {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_PostWorkflowsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PostWorkflowsRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_app_id"),
    2: .same(proto: "workflows"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._userAppID) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.workflows) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._userAppID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.workflows.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.workflows, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_PostWorkflowsRequest, rhs: Clarifai_Api_PostWorkflowsRequest) -> Bool {
    if lhs._userAppID != rhs._userAppID {return false}
    if lhs.workflows != rhs.workflows {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_PatchWorkflowsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PatchWorkflowsRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_app_id"),
    2: .same(proto: "workflows"),
    3: .same(proto: "action"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._userAppID) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.workflows) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.action) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._userAppID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.workflows.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.workflows, fieldNumber: 2)
    }
    if !self.action.isEmpty {
      try visitor.visitSingularStringField(value: self.action, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_PatchWorkflowsRequest, rhs: Clarifai_Api_PatchWorkflowsRequest) -> Bool {
    if lhs._userAppID != rhs._userAppID {return false}
    if lhs.workflows != rhs.workflows {return false}
    if lhs.action != rhs.action {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_PatchWorkflowIdsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PatchWorkflowIdsRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_app_id"),
    3: .same(proto: "ids"),
    4: .same(proto: "action"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._userAppID) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.ids) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.action) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._userAppID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.ids.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.ids, fieldNumber: 3)
    }
    if !self.action.isEmpty {
      try visitor.visitSingularStringField(value: self.action, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_PatchWorkflowIdsRequest, rhs: Clarifai_Api_PatchWorkflowIdsRequest) -> Bool {
    if lhs._userAppID != rhs._userAppID {return false}
    if lhs.ids != rhs.ids {return false}
    if lhs.action != rhs.action {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_DeleteWorkflowRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DeleteWorkflowRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_app_id"),
    2: .standard(proto: "workflow_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._userAppID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.workflowID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._userAppID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.workflowID.isEmpty {
      try visitor.visitSingularStringField(value: self.workflowID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_DeleteWorkflowRequest, rhs: Clarifai_Api_DeleteWorkflowRequest) -> Bool {
    if lhs._userAppID != rhs._userAppID {return false}
    if lhs.workflowID != rhs.workflowID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_DeleteWorkflowsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DeleteWorkflowsRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_app_id"),
    2: .same(proto: "ids"),
    3: .standard(proto: "delete_all"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._userAppID) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.ids) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.deleteAll) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._userAppID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.ids.isEmpty {
      try visitor.visitRepeatedStringField(value: self.ids, fieldNumber: 2)
    }
    if self.deleteAll != false {
      try visitor.visitSingularBoolField(value: self.deleteAll, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_DeleteWorkflowsRequest, rhs: Clarifai_Api_DeleteWorkflowsRequest) -> Bool {
    if lhs._userAppID != rhs._userAppID {return false}
    if lhs.ids != rhs.ids {return false}
    if lhs.deleteAll != rhs.deleteAll {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_SingleWorkflowResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SingleWorkflowResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
    2: .same(proto: "workflow"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._status) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._workflow) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._status {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._workflow {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_SingleWorkflowResponse, rhs: Clarifai_Api_SingleWorkflowResponse) -> Bool {
    if lhs._status != rhs._status {return false}
    if lhs._workflow != rhs._workflow {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_MultiWorkflowResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MultiWorkflowResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
    2: .same(proto: "workflows"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._status) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.workflows) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._status {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.workflows.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.workflows, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_MultiWorkflowResponse, rhs: Clarifai_Api_MultiWorkflowResponse) -> Bool {
    if lhs._status != rhs._status {return false}
    if lhs.workflows != rhs.workflows {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_PostWorkflowResultsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PostWorkflowResultsRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_app_id"),
    2: .standard(proto: "workflow_id"),
    7: .standard(proto: "version_id"),
    3: .same(proto: "inputs"),
    4: .standard(proto: "output_config"),
    5: .standard(proto: "favor_clarifai_workflows"),
    6: .standard(proto: "workflow_state"),
    8: .standard(proto: "node_runner_selectors"),
  ]

  fileprivate class _StorageClass {
    var _userAppID: Clarifai_Api_UserAppIDSet? = nil
    var _workflowID: String = String()
    var _versionID: String = String()
    var _inputs: [Clarifai_Api_Input] = []
    var _outputConfig: Clarifai_Api_OutputConfig? = nil
    var _favorClarifaiWorkflows: Bool = false
    var _workflowState: Clarifai_Api_WorkflowState? = nil
    var _nodeRunnerSelectors: Dictionary<String,Clarifai_Api_RunnerSelector> = [:]

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _userAppID = source._userAppID
      _workflowID = source._workflowID
      _versionID = source._versionID
      _inputs = source._inputs
      _outputConfig = source._outputConfig
      _favorClarifaiWorkflows = source._favorClarifaiWorkflows
      _workflowState = source._workflowState
      _nodeRunnerSelectors = source._nodeRunnerSelectors
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._userAppID) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._workflowID) }()
        case 3: try { try decoder.decodeRepeatedMessageField(value: &_storage._inputs) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._outputConfig) }()
        case 5: try { try decoder.decodeSingularBoolField(value: &_storage._favorClarifaiWorkflows) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._workflowState) }()
        case 7: try { try decoder.decodeSingularStringField(value: &_storage._versionID) }()
        case 8: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Clarifai_Api_RunnerSelector>.self, value: &_storage._nodeRunnerSelectors) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._userAppID {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      if !_storage._workflowID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._workflowID, fieldNumber: 2)
      }
      if !_storage._inputs.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._inputs, fieldNumber: 3)
      }
      try { if let v = _storage._outputConfig {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      if _storage._favorClarifaiWorkflows != false {
        try visitor.visitSingularBoolField(value: _storage._favorClarifaiWorkflows, fieldNumber: 5)
      }
      try { if let v = _storage._workflowState {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
      if !_storage._versionID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._versionID, fieldNumber: 7)
      }
      if !_storage._nodeRunnerSelectors.isEmpty {
        try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Clarifai_Api_RunnerSelector>.self, value: _storage._nodeRunnerSelectors, fieldNumber: 8)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_PostWorkflowResultsRequest, rhs: Clarifai_Api_PostWorkflowResultsRequest) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._userAppID != rhs_storage._userAppID {return false}
        if _storage._workflowID != rhs_storage._workflowID {return false}
        if _storage._versionID != rhs_storage._versionID {return false}
        if _storage._inputs != rhs_storage._inputs {return false}
        if _storage._outputConfig != rhs_storage._outputConfig {return false}
        if _storage._favorClarifaiWorkflows != rhs_storage._favorClarifaiWorkflows {return false}
        if _storage._workflowState != rhs_storage._workflowState {return false}
        if _storage._nodeRunnerSelectors != rhs_storage._nodeRunnerSelectors {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_PostWorkflowResultsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PostWorkflowResultsResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
    2: .same(proto: "workflow"),
    3: .same(proto: "results"),
    4: .standard(proto: "workflow_state"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._status) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._workflow) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.results) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._workflowState) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._status {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._workflow {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.results.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.results, fieldNumber: 3)
    }
    try { if let v = self._workflowState {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_PostWorkflowResultsResponse, rhs: Clarifai_Api_PostWorkflowResultsResponse) -> Bool {
    if lhs._status != rhs._status {return false}
    if lhs._workflow != rhs._workflow {return false}
    if lhs.results != rhs.results {return false}
    if lhs._workflowState != rhs._workflowState {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_ListWorkflowVersionsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListWorkflowVersionsRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_app_id"),
    2: .standard(proto: "workflow_id"),
    3: .same(proto: "page"),
    4: .standard(proto: "per_page"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._userAppID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.workflowID) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.page) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self.perPage) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._userAppID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.workflowID.isEmpty {
      try visitor.visitSingularStringField(value: self.workflowID, fieldNumber: 2)
    }
    if self.page != 0 {
      try visitor.visitSingularUInt32Field(value: self.page, fieldNumber: 3)
    }
    if self.perPage != 0 {
      try visitor.visitSingularUInt32Field(value: self.perPage, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_ListWorkflowVersionsRequest, rhs: Clarifai_Api_ListWorkflowVersionsRequest) -> Bool {
    if lhs._userAppID != rhs._userAppID {return false}
    if lhs.workflowID != rhs.workflowID {return false}
    if lhs.page != rhs.page {return false}
    if lhs.perPage != rhs.perPage {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_GetWorkflowVersionRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetWorkflowVersionRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_app_id"),
    2: .standard(proto: "workflow_id"),
    3: .standard(proto: "workflow_version_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._userAppID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.workflowID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.workflowVersionID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._userAppID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.workflowID.isEmpty {
      try visitor.visitSingularStringField(value: self.workflowID, fieldNumber: 2)
    }
    if !self.workflowVersionID.isEmpty {
      try visitor.visitSingularStringField(value: self.workflowVersionID, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_GetWorkflowVersionRequest, rhs: Clarifai_Api_GetWorkflowVersionRequest) -> Bool {
    if lhs._userAppID != rhs._userAppID {return false}
    if lhs.workflowID != rhs.workflowID {return false}
    if lhs.workflowVersionID != rhs.workflowVersionID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_DeleteWorkflowVersionsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DeleteWorkflowVersionsRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_app_id"),
    2: .standard(proto: "workflow_id"),
    3: .standard(proto: "workflow_version_ids"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._userAppID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.workflowID) }()
      case 3: try { try decoder.decodeRepeatedStringField(value: &self.workflowVersionIds) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._userAppID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.workflowID.isEmpty {
      try visitor.visitSingularStringField(value: self.workflowID, fieldNumber: 2)
    }
    if !self.workflowVersionIds.isEmpty {
      try visitor.visitRepeatedStringField(value: self.workflowVersionIds, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_DeleteWorkflowVersionsRequest, rhs: Clarifai_Api_DeleteWorkflowVersionsRequest) -> Bool {
    if lhs._userAppID != rhs._userAppID {return false}
    if lhs.workflowID != rhs.workflowID {return false}
    if lhs.workflowVersionIds != rhs.workflowVersionIds {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_PatchWorkflowVersionsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PatchWorkflowVersionsRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_app_id"),
    2: .standard(proto: "workflow_id"),
    3: .standard(proto: "workflow_versions"),
    4: .same(proto: "action"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._userAppID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.workflowID) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.workflowVersions) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.action) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._userAppID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.workflowID.isEmpty {
      try visitor.visitSingularStringField(value: self.workflowID, fieldNumber: 2)
    }
    if !self.workflowVersions.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.workflowVersions, fieldNumber: 3)
    }
    if !self.action.isEmpty {
      try visitor.visitSingularStringField(value: self.action, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_PatchWorkflowVersionsRequest, rhs: Clarifai_Api_PatchWorkflowVersionsRequest) -> Bool {
    if lhs._userAppID != rhs._userAppID {return false}
    if lhs.workflowID != rhs.workflowID {return false}
    if lhs.workflowVersions != rhs.workflowVersions {return false}
    if lhs.action != rhs.action {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_MultiWorkflowVersionResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MultiWorkflowVersionResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
    2: .standard(proto: "workflow_versions"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._status) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.workflowVersions) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._status {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.workflowVersions.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.workflowVersions, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_MultiWorkflowVersionResponse, rhs: Clarifai_Api_MultiWorkflowVersionResponse) -> Bool {
    if lhs._status != rhs._status {return false}
    if lhs.workflowVersions != rhs.workflowVersions {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_SingleWorkflowVersionResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SingleWorkflowVersionResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
    2: .standard(proto: "workflow_version"),
  ]

  fileprivate class _StorageClass {
    var _status: Clarifai_Api_Status_Status? = nil
    var _workflowVersion: Clarifai_Api_WorkflowVersion? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _status = source._status
      _workflowVersion = source._workflowVersion
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._status) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._workflowVersion) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._status {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._workflowVersion {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_SingleWorkflowVersionResponse, rhs: Clarifai_Api_SingleWorkflowVersionResponse) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._status != rhs_storage._status {return false}
        if _storage._workflowVersion != rhs_storage._workflowVersion {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_PostAppDuplicationsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PostAppDuplicationsRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_app_id"),
    2: .standard(proto: "app_duplications"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._userAppID) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.appDuplications) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._userAppID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.appDuplications.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.appDuplications, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_PostAppDuplicationsRequest, rhs: Clarifai_Api_PostAppDuplicationsRequest) -> Bool {
    if lhs._userAppID != rhs._userAppID {return false}
    if lhs.appDuplications != rhs.appDuplications {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_GetAppDuplicationRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetAppDuplicationRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_app_id"),
    2: .standard(proto: "app_duplication_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._userAppID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.appDuplicationID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._userAppID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.appDuplicationID.isEmpty {
      try visitor.visitSingularStringField(value: self.appDuplicationID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_GetAppDuplicationRequest, rhs: Clarifai_Api_GetAppDuplicationRequest) -> Bool {
    if lhs._userAppID != rhs._userAppID {return false}
    if lhs.appDuplicationID != rhs.appDuplicationID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_ListAppDuplicationsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListAppDuplicationsRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_app_id"),
    2: .same(proto: "page"),
    3: .standard(proto: "per_page"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._userAppID) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.page) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.perPage) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._userAppID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.page != 0 {
      try visitor.visitSingularUInt32Field(value: self.page, fieldNumber: 2)
    }
    if self.perPage != 0 {
      try visitor.visitSingularUInt32Field(value: self.perPage, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_ListAppDuplicationsRequest, rhs: Clarifai_Api_ListAppDuplicationsRequest) -> Bool {
    if lhs._userAppID != rhs._userAppID {return false}
    if lhs.page != rhs.page {return false}
    if lhs.perPage != rhs.perPage {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_MultiAppDuplicationsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MultiAppDuplicationsResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
    2: .standard(proto: "app_duplications"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._status) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.appDuplications) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._status {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.appDuplications.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.appDuplications, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_MultiAppDuplicationsResponse, rhs: Clarifai_Api_MultiAppDuplicationsResponse) -> Bool {
    if lhs._status != rhs._status {return false}
    if lhs.appDuplications != rhs.appDuplications {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_SingleAppDuplicationResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SingleAppDuplicationResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
    2: .standard(proto: "app_duplication"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._status) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._appDuplication) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._status {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._appDuplication {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_SingleAppDuplicationResponse, rhs: Clarifai_Api_SingleAppDuplicationResponse) -> Bool {
    if lhs._status != rhs._status {return false}
    if lhs._appDuplication != rhs._appDuplication {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_PostTasksRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PostTasksRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_app_id"),
    2: .same(proto: "tasks"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._userAppID) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.tasks) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._userAppID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.tasks.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.tasks, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_PostTasksRequest, rhs: Clarifai_Api_PostTasksRequest) -> Bool {
    if lhs._userAppID != rhs._userAppID {return false}
    if lhs.tasks != rhs.tasks {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_GetTaskRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetTaskRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_app_id"),
    2: .standard(proto: "task_id"),
    3: .standard(proto: "additional_fields"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._userAppID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.taskID) }()
      case 3: try { try decoder.decodeRepeatedStringField(value: &self.additionalFields) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._userAppID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.taskID.isEmpty {
      try visitor.visitSingularStringField(value: self.taskID, fieldNumber: 2)
    }
    if !self.additionalFields.isEmpty {
      try visitor.visitRepeatedStringField(value: self.additionalFields, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_GetTaskRequest, rhs: Clarifai_Api_GetTaskRequest) -> Bool {
    if lhs._userAppID != rhs._userAppID {return false}
    if lhs.taskID != rhs.taskID {return false}
    if lhs.additionalFields != rhs.additionalFields {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_ListTasksRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListTasksRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_app_id"),
    2: .same(proto: "page"),
    3: .standard(proto: "per_page"),
    4: .standard(proto: "worker_user_ids"),
    5: .standard(proto: "review_user_ids"),
    8: .standard(proto: "label_order_ids"),
    6: .standard(proto: "including_label_order_tasks"),
    7: .standard(proto: "additional_fields"),
    9: .same(proto: "ids"),
    10: .standard(proto: "input_source_type"),
    11: .standard(proto: "input_source_ids"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._userAppID) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.page) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.perPage) }()
      case 4: try { try decoder.decodeRepeatedStringField(value: &self.workerUserIds) }()
      case 5: try { try decoder.decodeRepeatedStringField(value: &self.reviewUserIds) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self.includingLabelOrderTasks) }()
      case 7: try { try decoder.decodeRepeatedStringField(value: &self.additionalFields) }()
      case 8: try { try decoder.decodeRepeatedStringField(value: &self.labelOrderIds) }()
      case 9: try { try decoder.decodeRepeatedStringField(value: &self.ids) }()
      case 10: try { try decoder.decodeSingularEnumField(value: &self.inputSourceType) }()
      case 11: try { try decoder.decodeRepeatedStringField(value: &self.inputSourceIds) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._userAppID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.page != 0 {
      try visitor.visitSingularUInt32Field(value: self.page, fieldNumber: 2)
    }
    if self.perPage != 0 {
      try visitor.visitSingularUInt32Field(value: self.perPage, fieldNumber: 3)
    }
    if !self.workerUserIds.isEmpty {
      try visitor.visitRepeatedStringField(value: self.workerUserIds, fieldNumber: 4)
    }
    if !self.reviewUserIds.isEmpty {
      try visitor.visitRepeatedStringField(value: self.reviewUserIds, fieldNumber: 5)
    }
    if self.includingLabelOrderTasks != false {
      try visitor.visitSingularBoolField(value: self.includingLabelOrderTasks, fieldNumber: 6)
    }
    if !self.additionalFields.isEmpty {
      try visitor.visitRepeatedStringField(value: self.additionalFields, fieldNumber: 7)
    }
    if !self.labelOrderIds.isEmpty {
      try visitor.visitRepeatedStringField(value: self.labelOrderIds, fieldNumber: 8)
    }
    if !self.ids.isEmpty {
      try visitor.visitRepeatedStringField(value: self.ids, fieldNumber: 9)
    }
    if self.inputSourceType != .inputSourceTypeNotSet {
      try visitor.visitSingularEnumField(value: self.inputSourceType, fieldNumber: 10)
    }
    if !self.inputSourceIds.isEmpty {
      try visitor.visitRepeatedStringField(value: self.inputSourceIds, fieldNumber: 11)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_ListTasksRequest, rhs: Clarifai_Api_ListTasksRequest) -> Bool {
    if lhs._userAppID != rhs._userAppID {return false}
    if lhs.page != rhs.page {return false}
    if lhs.perPage != rhs.perPage {return false}
    if lhs.workerUserIds != rhs.workerUserIds {return false}
    if lhs.reviewUserIds != rhs.reviewUserIds {return false}
    if lhs.labelOrderIds != rhs.labelOrderIds {return false}
    if lhs.includingLabelOrderTasks != rhs.includingLabelOrderTasks {return false}
    if lhs.additionalFields != rhs.additionalFields {return false}
    if lhs.ids != rhs.ids {return false}
    if lhs.inputSourceType != rhs.inputSourceType {return false}
    if lhs.inputSourceIds != rhs.inputSourceIds {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_PatchTasksRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PatchTasksRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_app_id"),
    2: .same(proto: "tasks"),
    3: .same(proto: "action"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._userAppID) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.tasks) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.action) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._userAppID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.tasks.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.tasks, fieldNumber: 2)
    }
    if !self.action.isEmpty {
      try visitor.visitSingularStringField(value: self.action, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_PatchTasksRequest, rhs: Clarifai_Api_PatchTasksRequest) -> Bool {
    if lhs._userAppID != rhs._userAppID {return false}
    if lhs.tasks != rhs.tasks {return false}
    if lhs.action != rhs.action {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_DeleteTasksRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DeleteTasksRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_app_id"),
    2: .same(proto: "ids"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._userAppID) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.ids) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._userAppID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.ids.isEmpty {
      try visitor.visitRepeatedStringField(value: self.ids, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_DeleteTasksRequest, rhs: Clarifai_Api_DeleteTasksRequest) -> Bool {
    if lhs._userAppID != rhs._userAppID {return false}
    if lhs.ids != rhs.ids {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_MultiTaskResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MultiTaskResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
    2: .same(proto: "tasks"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._status) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.tasks) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._status {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.tasks.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.tasks, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_MultiTaskResponse, rhs: Clarifai_Api_MultiTaskResponse) -> Bool {
    if lhs._status != rhs._status {return false}
    if lhs.tasks != rhs.tasks {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_SingleTaskResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SingleTaskResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
    2: .same(proto: "task"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._status) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._task) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._status {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._task {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_SingleTaskResponse, rhs: Clarifai_Api_SingleTaskResponse) -> Bool {
    if lhs._status != rhs._status {return false}
    if lhs._task != rhs._task {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_GetTaskCountRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetTaskCountRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_app_id"),
    2: .standard(proto: "task_id"),
    3: .standard(proto: "user_ids"),
    4: .standard(proto: "model_version_ids"),
    5: .standard(proto: "workflow_version_ids"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._userAppID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.taskID) }()
      case 3: try { try decoder.decodeRepeatedStringField(value: &self.userIds) }()
      case 4: try { try decoder.decodeRepeatedStringField(value: &self.modelVersionIds) }()
      case 5: try { try decoder.decodeRepeatedStringField(value: &self.workflowVersionIds) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._userAppID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.taskID.isEmpty {
      try visitor.visitSingularStringField(value: self.taskID, fieldNumber: 2)
    }
    if !self.userIds.isEmpty {
      try visitor.visitRepeatedStringField(value: self.userIds, fieldNumber: 3)
    }
    if !self.modelVersionIds.isEmpty {
      try visitor.visitRepeatedStringField(value: self.modelVersionIds, fieldNumber: 4)
    }
    if !self.workflowVersionIds.isEmpty {
      try visitor.visitRepeatedStringField(value: self.workflowVersionIds, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_GetTaskCountRequest, rhs: Clarifai_Api_GetTaskCountRequest) -> Bool {
    if lhs._userAppID != rhs._userAppID {return false}
    if lhs.taskID != rhs.taskID {return false}
    if lhs.userIds != rhs.userIds {return false}
    if lhs.modelVersionIds != rhs.modelVersionIds {return false}
    if lhs.workflowVersionIds != rhs.workflowVersionIds {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_SingleTaskCountResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SingleTaskCountResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
    2: .standard(proto: "app_id"),
    3: .standard(proto: "task_id"),
    4: .same(proto: "counts"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._status) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.appID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.taskID) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.counts) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._status {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.appID.isEmpty {
      try visitor.visitSingularStringField(value: self.appID, fieldNumber: 2)
    }
    if !self.taskID.isEmpty {
      try visitor.visitSingularStringField(value: self.taskID, fieldNumber: 3)
    }
    if !self.counts.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.counts, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_SingleTaskCountResponse, rhs: Clarifai_Api_SingleTaskCountResponse) -> Bool {
    if lhs._status != rhs._status {return false}
    if lhs.appID != rhs.appID {return false}
    if lhs.taskID != rhs.taskID {return false}
    if lhs.counts != rhs.counts {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_PostLabelOrdersRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PostLabelOrdersRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_app_id"),
    2: .standard(proto: "label_orders"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._userAppID) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.labelOrders) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._userAppID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.labelOrders.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.labelOrders, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_PostLabelOrdersRequest, rhs: Clarifai_Api_PostLabelOrdersRequest) -> Bool {
    if lhs._userAppID != rhs._userAppID {return false}
    if lhs.labelOrders != rhs.labelOrders {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_GetLabelOrderRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetLabelOrderRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_app_id"),
    2: .standard(proto: "label_order_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._userAppID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.labelOrderID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._userAppID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.labelOrderID.isEmpty {
      try visitor.visitSingularStringField(value: self.labelOrderID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_GetLabelOrderRequest, rhs: Clarifai_Api_GetLabelOrderRequest) -> Bool {
    if lhs._userAppID != rhs._userAppID {return false}
    if lhs.labelOrderID != rhs.labelOrderID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_ListLabelOrdersRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListLabelOrdersRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_app_id"),
    2: .same(proto: "page"),
    3: .standard(proto: "per_page"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._userAppID) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.page) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.perPage) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._userAppID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.page != 0 {
      try visitor.visitSingularUInt32Field(value: self.page, fieldNumber: 2)
    }
    if self.perPage != 0 {
      try visitor.visitSingularUInt32Field(value: self.perPage, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_ListLabelOrdersRequest, rhs: Clarifai_Api_ListLabelOrdersRequest) -> Bool {
    if lhs._userAppID != rhs._userAppID {return false}
    if lhs.page != rhs.page {return false}
    if lhs.perPage != rhs.perPage {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_PatchLabelOrdersRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PatchLabelOrdersRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_app_id"),
    2: .standard(proto: "label_orders"),
    3: .same(proto: "action"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._userAppID) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.labelOrders) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.action) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._userAppID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.labelOrders.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.labelOrders, fieldNumber: 2)
    }
    if !self.action.isEmpty {
      try visitor.visitSingularStringField(value: self.action, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_PatchLabelOrdersRequest, rhs: Clarifai_Api_PatchLabelOrdersRequest) -> Bool {
    if lhs._userAppID != rhs._userAppID {return false}
    if lhs.labelOrders != rhs.labelOrders {return false}
    if lhs.action != rhs.action {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_DeleteLabelOrdersRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DeleteLabelOrdersRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_app_id"),
    2: .same(proto: "ids"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._userAppID) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.ids) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._userAppID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.ids.isEmpty {
      try visitor.visitRepeatedStringField(value: self.ids, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_DeleteLabelOrdersRequest, rhs: Clarifai_Api_DeleteLabelOrdersRequest) -> Bool {
    if lhs._userAppID != rhs._userAppID {return false}
    if lhs.ids != rhs.ids {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_MultiLabelOrderResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MultiLabelOrderResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
    2: .standard(proto: "label_orders"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._status) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.labelOrders) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._status {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.labelOrders.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.labelOrders, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_MultiLabelOrderResponse, rhs: Clarifai_Api_MultiLabelOrderResponse) -> Bool {
    if lhs._status != rhs._status {return false}
    if lhs.labelOrders != rhs.labelOrders {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_SingleLabelOrderResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SingleLabelOrderResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
    2: .standard(proto: "label_order"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._status) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._labelOrder) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._status {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._labelOrder {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_SingleLabelOrderResponse, rhs: Clarifai_Api_SingleLabelOrderResponse) -> Bool {
    if lhs._status != rhs._status {return false}
    if lhs._labelOrder != rhs._labelOrder {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_PostCollectorsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PostCollectorsRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_app_id"),
    2: .same(proto: "collectors"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._userAppID) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.collectors) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._userAppID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.collectors.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.collectors, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_PostCollectorsRequest, rhs: Clarifai_Api_PostCollectorsRequest) -> Bool {
    if lhs._userAppID != rhs._userAppID {return false}
    if lhs.collectors != rhs.collectors {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_PatchCollectorsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PatchCollectorsRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_app_id"),
    2: .same(proto: "collectors"),
    3: .same(proto: "action"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._userAppID) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.collectors) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.action) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._userAppID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.collectors.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.collectors, fieldNumber: 2)
    }
    if !self.action.isEmpty {
      try visitor.visitSingularStringField(value: self.action, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_PatchCollectorsRequest, rhs: Clarifai_Api_PatchCollectorsRequest) -> Bool {
    if lhs._userAppID != rhs._userAppID {return false}
    if lhs.collectors != rhs.collectors {return false}
    if lhs.action != rhs.action {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_DeleteCollectorsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DeleteCollectorsRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_app_id"),
    2: .same(proto: "ids"),
    3: .standard(proto: "delete_all"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._userAppID) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.ids) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.deleteAll) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._userAppID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.ids.isEmpty {
      try visitor.visitRepeatedStringField(value: self.ids, fieldNumber: 2)
    }
    if self.deleteAll != false {
      try visitor.visitSingularBoolField(value: self.deleteAll, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_DeleteCollectorsRequest, rhs: Clarifai_Api_DeleteCollectorsRequest) -> Bool {
    if lhs._userAppID != rhs._userAppID {return false}
    if lhs.ids != rhs.ids {return false}
    if lhs.deleteAll != rhs.deleteAll {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_GetCollectorRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetCollectorRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_app_id"),
    2: .standard(proto: "collector_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._userAppID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.collectorID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._userAppID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.collectorID.isEmpty {
      try visitor.visitSingularStringField(value: self.collectorID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_GetCollectorRequest, rhs: Clarifai_Api_GetCollectorRequest) -> Bool {
    if lhs._userAppID != rhs._userAppID {return false}
    if lhs.collectorID != rhs.collectorID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_ListCollectorsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListCollectorsRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_app_id"),
    2: .same(proto: "page"),
    3: .standard(proto: "per_page"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._userAppID) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.page) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.perPage) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._userAppID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.page != 0 {
      try visitor.visitSingularUInt32Field(value: self.page, fieldNumber: 2)
    }
    if self.perPage != 0 {
      try visitor.visitSingularUInt32Field(value: self.perPage, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_ListCollectorsRequest, rhs: Clarifai_Api_ListCollectorsRequest) -> Bool {
    if lhs._userAppID != rhs._userAppID {return false}
    if lhs.page != rhs.page {return false}
    if lhs.perPage != rhs.perPage {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_MultiCollectorResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MultiCollectorResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
    2: .same(proto: "collectors"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._status) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.collectors) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._status {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.collectors.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.collectors, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_MultiCollectorResponse, rhs: Clarifai_Api_MultiCollectorResponse) -> Bool {
    if lhs._status != rhs._status {return false}
    if lhs.collectors != rhs.collectors {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_SingleCollectorResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SingleCollectorResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
    2: .same(proto: "collector"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._status) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._collector) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._status {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._collector {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_SingleCollectorResponse, rhs: Clarifai_Api_SingleCollectorResponse) -> Bool {
    if lhs._status != rhs._status {return false}
    if lhs._collector != rhs._collector {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_PostStatValuesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PostStatValuesRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_app_id"),
    2: .standard(proto: "stat_values"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._userAppID) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.statValues) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._userAppID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.statValues.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.statValues, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_PostStatValuesRequest, rhs: Clarifai_Api_PostStatValuesRequest) -> Bool {
    if lhs._userAppID != rhs._userAppID {return false}
    if lhs.statValues != rhs.statValues {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_MultiStatValueResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MultiStatValueResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
    2: .standard(proto: "stat_values"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._status) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.statValues) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._status {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.statValues.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.statValues, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_MultiStatValueResponse, rhs: Clarifai_Api_MultiStatValueResponse) -> Bool {
    if lhs._status != rhs._status {return false}
    if lhs.statValues != rhs.statValues {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_PostStatValuesAggregateRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PostStatValuesAggregateRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_app_id"),
    2: .standard(proto: "stat_value_aggregate_queries"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._userAppID) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.statValueAggregateQueries) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._userAppID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.statValueAggregateQueries.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.statValueAggregateQueries, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_PostStatValuesAggregateRequest, rhs: Clarifai_Api_PostStatValuesAggregateRequest) -> Bool {
    if lhs._userAppID != rhs._userAppID {return false}
    if lhs.statValueAggregateQueries != rhs.statValueAggregateQueries {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_MultiStatValueAggregateResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MultiStatValueAggregateResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
    2: .standard(proto: "stat_value_aggregate_results"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._status) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.statValueAggregateResults) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._status {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.statValueAggregateResults.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.statValueAggregateResults, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_MultiStatValueAggregateResponse, rhs: Clarifai_Api_MultiStatValueAggregateResponse) -> Bool {
    if lhs._status != rhs._status {return false}
    if lhs.statValueAggregateResults != rhs.statValueAggregateResults {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_GetModuleRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetModuleRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_app_id"),
    2: .standard(proto: "module_id"),
    3: .standard(proto: "additional_fields"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._userAppID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.moduleID) }()
      case 3: try { try decoder.decodeRepeatedStringField(value: &self.additionalFields) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._userAppID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.moduleID.isEmpty {
      try visitor.visitSingularStringField(value: self.moduleID, fieldNumber: 2)
    }
    if !self.additionalFields.isEmpty {
      try visitor.visitRepeatedStringField(value: self.additionalFields, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_GetModuleRequest, rhs: Clarifai_Api_GetModuleRequest) -> Bool {
    if lhs._userAppID != rhs._userAppID {return false}
    if lhs.moduleID != rhs.moduleID {return false}
    if lhs.additionalFields != rhs.additionalFields {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_ListModulesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListModulesRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_app_id"),
    2: .same(proto: "page"),
    3: .standard(proto: "per_page"),
    5: .standard(proto: "additional_fields"),
    6: .standard(proto: "sort_ascending"),
    7: .standard(proto: "sort_by_created_at"),
    8: .standard(proto: "sort_by_star_count"),
    9: .standard(proto: "sort_by_modified_at"),
    11: .standard(proto: "sort_by_id"),
    4: .standard(proto: "starred_only"),
    10: .same(proto: "bookmark"),
    14: .same(proto: "search"),
    12: .same(proto: "name"),
    13: .standard(proto: "filter_by_user_id"),
    15: .same(proto: "visibility"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._userAppID) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.page) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.perPage) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.starredOnly) }()
      case 5: try { try decoder.decodeRepeatedStringField(value: &self.additionalFields) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self.sortAscending) }()
      case 7: try {
        var v: Bool?
        try decoder.decodeSingularBoolField(value: &v)
        if let v = v {
          if self.sortBy != nil {try decoder.handleConflictingOneOf()}
          self.sortBy = .sortByCreatedAt(v)
        }
      }()
      case 8: try {
        var v: Bool?
        try decoder.decodeSingularBoolField(value: &v)
        if let v = v {
          if self.sortBy != nil {try decoder.handleConflictingOneOf()}
          self.sortBy = .sortByStarCount(v)
        }
      }()
      case 9: try {
        var v: Bool?
        try decoder.decodeSingularBoolField(value: &v)
        if let v = v {
          if self.sortBy != nil {try decoder.handleConflictingOneOf()}
          self.sortBy = .sortByModifiedAt(v)
        }
      }()
      case 10: try { try decoder.decodeSingularBoolField(value: &self.bookmark) }()
      case 11: try {
        var v: Bool?
        try decoder.decodeSingularBoolField(value: &v)
        if let v = v {
          if self.sortBy != nil {try decoder.handleConflictingOneOf()}
          self.sortBy = .sortByID(v)
        }
      }()
      case 12: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 13: try { try decoder.decodeSingularBoolField(value: &self.filterByUserID) }()
      case 14: try { try decoder.decodeSingularStringField(value: &self.search) }()
      case 15: try { try decoder.decodeSingularMessageField(value: &self._visibility) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._userAppID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.page != 0 {
      try visitor.visitSingularUInt32Field(value: self.page, fieldNumber: 2)
    }
    if self.perPage != 0 {
      try visitor.visitSingularUInt32Field(value: self.perPage, fieldNumber: 3)
    }
    if self.starredOnly != false {
      try visitor.visitSingularBoolField(value: self.starredOnly, fieldNumber: 4)
    }
    if !self.additionalFields.isEmpty {
      try visitor.visitRepeatedStringField(value: self.additionalFields, fieldNumber: 5)
    }
    if self.sortAscending != false {
      try visitor.visitSingularBoolField(value: self.sortAscending, fieldNumber: 6)
    }
    switch self.sortBy {
    case .sortByCreatedAt?: try {
      guard case .sortByCreatedAt(let v)? = self.sortBy else { preconditionFailure() }
      try visitor.visitSingularBoolField(value: v, fieldNumber: 7)
    }()
    case .sortByStarCount?: try {
      guard case .sortByStarCount(let v)? = self.sortBy else { preconditionFailure() }
      try visitor.visitSingularBoolField(value: v, fieldNumber: 8)
    }()
    case .sortByModifiedAt?: try {
      guard case .sortByModifiedAt(let v)? = self.sortBy else { preconditionFailure() }
      try visitor.visitSingularBoolField(value: v, fieldNumber: 9)
    }()
    default: break
    }
    if self.bookmark != false {
      try visitor.visitSingularBoolField(value: self.bookmark, fieldNumber: 10)
    }
    try { if case .sortByID(let v)? = self.sortBy {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 11)
    } }()
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 12)
    }
    if self.filterByUserID != false {
      try visitor.visitSingularBoolField(value: self.filterByUserID, fieldNumber: 13)
    }
    if !self.search.isEmpty {
      try visitor.visitSingularStringField(value: self.search, fieldNumber: 14)
    }
    try { if let v = self._visibility {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_ListModulesRequest, rhs: Clarifai_Api_ListModulesRequest) -> Bool {
    if lhs._userAppID != rhs._userAppID {return false}
    if lhs.page != rhs.page {return false}
    if lhs.perPage != rhs.perPage {return false}
    if lhs.additionalFields != rhs.additionalFields {return false}
    if lhs.sortAscending != rhs.sortAscending {return false}
    if lhs.sortBy != rhs.sortBy {return false}
    if lhs.starredOnly != rhs.starredOnly {return false}
    if lhs.bookmark != rhs.bookmark {return false}
    if lhs.search != rhs.search {return false}
    if lhs.name != rhs.name {return false}
    if lhs.filterByUserID != rhs.filterByUserID {return false}
    if lhs._visibility != rhs._visibility {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_PostModulesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PostModulesRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_app_id"),
    3: .same(proto: "modules"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._userAppID) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.modules) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._userAppID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.modules.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.modules, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_PostModulesRequest, rhs: Clarifai_Api_PostModulesRequest) -> Bool {
    if lhs._userAppID != rhs._userAppID {return false}
    if lhs.modules != rhs.modules {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_PatchModulesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PatchModulesRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_app_id"),
    2: .same(proto: "modules"),
    3: .same(proto: "action"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._userAppID) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.modules) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.action) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._userAppID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.modules.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.modules, fieldNumber: 2)
    }
    if !self.action.isEmpty {
      try visitor.visitSingularStringField(value: self.action, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_PatchModulesRequest, rhs: Clarifai_Api_PatchModulesRequest) -> Bool {
    if lhs._userAppID != rhs._userAppID {return false}
    if lhs.modules != rhs.modules {return false}
    if lhs.action != rhs.action {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_DeleteModulesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DeleteModulesRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_app_id"),
    2: .same(proto: "ids"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._userAppID) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.ids) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._userAppID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.ids.isEmpty {
      try visitor.visitRepeatedStringField(value: self.ids, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_DeleteModulesRequest, rhs: Clarifai_Api_DeleteModulesRequest) -> Bool {
    if lhs._userAppID != rhs._userAppID {return false}
    if lhs.ids != rhs.ids {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_SingleModuleResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SingleModuleResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
    2: .same(proto: "module"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._status) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._module) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._status {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._module {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_SingleModuleResponse, rhs: Clarifai_Api_SingleModuleResponse) -> Bool {
    if lhs._status != rhs._status {return false}
    if lhs._module != rhs._module {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_MultiModuleResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MultiModuleResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
    2: .same(proto: "modules"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._status) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.modules) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._status {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.modules.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.modules, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_MultiModuleResponse, rhs: Clarifai_Api_MultiModuleResponse) -> Bool {
    if lhs._status != rhs._status {return false}
    if lhs.modules != rhs.modules {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_GetModuleVersionRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetModuleVersionRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_app_id"),
    2: .standard(proto: "module_id"),
    3: .standard(proto: "module_version_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._userAppID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.moduleID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.moduleVersionID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._userAppID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.moduleID.isEmpty {
      try visitor.visitSingularStringField(value: self.moduleID, fieldNumber: 2)
    }
    if !self.moduleVersionID.isEmpty {
      try visitor.visitSingularStringField(value: self.moduleVersionID, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_GetModuleVersionRequest, rhs: Clarifai_Api_GetModuleVersionRequest) -> Bool {
    if lhs._userAppID != rhs._userAppID {return false}
    if lhs.moduleID != rhs.moduleID {return false}
    if lhs.moduleVersionID != rhs.moduleVersionID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_ListModuleVersionsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListModuleVersionsRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_app_id"),
    2: .standard(proto: "module_id"),
    3: .same(proto: "page"),
    4: .standard(proto: "per_page"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._userAppID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.moduleID) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.page) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self.perPage) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._userAppID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.moduleID.isEmpty {
      try visitor.visitSingularStringField(value: self.moduleID, fieldNumber: 2)
    }
    if self.page != 0 {
      try visitor.visitSingularUInt32Field(value: self.page, fieldNumber: 3)
    }
    if self.perPage != 0 {
      try visitor.visitSingularUInt32Field(value: self.perPage, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_ListModuleVersionsRequest, rhs: Clarifai_Api_ListModuleVersionsRequest) -> Bool {
    if lhs._userAppID != rhs._userAppID {return false}
    if lhs.moduleID != rhs.moduleID {return false}
    if lhs.page != rhs.page {return false}
    if lhs.perPage != rhs.perPage {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_PostModuleVersionsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PostModuleVersionsRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_app_id"),
    2: .standard(proto: "module_id"),
    3: .standard(proto: "module_versions"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._userAppID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.moduleID) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.moduleVersions) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._userAppID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.moduleID.isEmpty {
      try visitor.visitSingularStringField(value: self.moduleID, fieldNumber: 2)
    }
    if !self.moduleVersions.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.moduleVersions, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_PostModuleVersionsRequest, rhs: Clarifai_Api_PostModuleVersionsRequest) -> Bool {
    if lhs._userAppID != rhs._userAppID {return false}
    if lhs.moduleID != rhs.moduleID {return false}
    if lhs.moduleVersions != rhs.moduleVersions {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_PatchModuleVersionsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PatchModuleVersionsRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_app_id"),
    2: .standard(proto: "module_id"),
    3: .standard(proto: "module_versions"),
    4: .same(proto: "action"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._userAppID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.moduleID) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.moduleVersions) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.action) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._userAppID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.moduleID.isEmpty {
      try visitor.visitSingularStringField(value: self.moduleID, fieldNumber: 2)
    }
    if !self.moduleVersions.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.moduleVersions, fieldNumber: 3)
    }
    if !self.action.isEmpty {
      try visitor.visitSingularStringField(value: self.action, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_PatchModuleVersionsRequest, rhs: Clarifai_Api_PatchModuleVersionsRequest) -> Bool {
    if lhs._userAppID != rhs._userAppID {return false}
    if lhs.moduleID != rhs.moduleID {return false}
    if lhs.moduleVersions != rhs.moduleVersions {return false}
    if lhs.action != rhs.action {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_DeleteModuleVersionsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DeleteModuleVersionsRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_app_id"),
    2: .standard(proto: "module_id"),
    3: .same(proto: "ids"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._userAppID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.moduleID) }()
      case 3: try { try decoder.decodeRepeatedStringField(value: &self.ids) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._userAppID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.moduleID.isEmpty {
      try visitor.visitSingularStringField(value: self.moduleID, fieldNumber: 2)
    }
    if !self.ids.isEmpty {
      try visitor.visitRepeatedStringField(value: self.ids, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_DeleteModuleVersionsRequest, rhs: Clarifai_Api_DeleteModuleVersionsRequest) -> Bool {
    if lhs._userAppID != rhs._userAppID {return false}
    if lhs.moduleID != rhs.moduleID {return false}
    if lhs.ids != rhs.ids {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_GetModuleVersionUsageCountRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetModuleVersionUsageCountRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_app_id"),
    2: .standard(proto: "module_id"),
    3: .standard(proto: "module_version_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._userAppID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.moduleID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.moduleVersionID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._userAppID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.moduleID.isEmpty {
      try visitor.visitSingularStringField(value: self.moduleID, fieldNumber: 2)
    }
    if !self.moduleVersionID.isEmpty {
      try visitor.visitSingularStringField(value: self.moduleVersionID, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_GetModuleVersionUsageCountRequest, rhs: Clarifai_Api_GetModuleVersionUsageCountRequest) -> Bool {
    if lhs._userAppID != rhs._userAppID {return false}
    if lhs.moduleID != rhs.moduleID {return false}
    if lhs.moduleVersionID != rhs.moduleVersionID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_SingleModuleVersionResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SingleModuleVersionResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
    2: .standard(proto: "module_version"),
  ]

  fileprivate class _StorageClass {
    var _status: Clarifai_Api_Status_Status? = nil
    var _moduleVersion: Clarifai_Api_ModuleVersion? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _status = source._status
      _moduleVersion = source._moduleVersion
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._status) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._moduleVersion) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._status {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._moduleVersion {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_SingleModuleVersionResponse, rhs: Clarifai_Api_SingleModuleVersionResponse) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._status != rhs_storage._status {return false}
        if _storage._moduleVersion != rhs_storage._moduleVersion {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_MultiModuleVersionResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MultiModuleVersionResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
    2: .standard(proto: "module_versions"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._status) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.moduleVersions) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._status {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.moduleVersions.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.moduleVersions, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_MultiModuleVersionResponse, rhs: Clarifai_Api_MultiModuleVersionResponse) -> Bool {
    if lhs._status != rhs._status {return false}
    if lhs.moduleVersions != rhs.moduleVersions {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_SingleModuleVersionUsageCountResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SingleModuleVersionUsageCountResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
    2: .standard(proto: "usage_count"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._status) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.usageCount) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._status {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.usageCount != 0 {
      try visitor.visitSingularUInt32Field(value: self.usageCount, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_SingleModuleVersionUsageCountResponse, rhs: Clarifai_Api_SingleModuleVersionUsageCountResponse) -> Bool {
    if lhs._status != rhs._status {return false}
    if lhs.usageCount != rhs.usageCount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_GetInstalledModuleVersionRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetInstalledModuleVersionRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_app_id"),
    2: .standard(proto: "installed_module_version_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._userAppID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.installedModuleVersionID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._userAppID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.installedModuleVersionID.isEmpty {
      try visitor.visitSingularStringField(value: self.installedModuleVersionID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_GetInstalledModuleVersionRequest, rhs: Clarifai_Api_GetInstalledModuleVersionRequest) -> Bool {
    if lhs._userAppID != rhs._userAppID {return false}
    if lhs.installedModuleVersionID != rhs.installedModuleVersionID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_ListInstalledModuleVersionsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListInstalledModuleVersionsRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_app_id"),
    2: .same(proto: "page"),
    3: .standard(proto: "per_page"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._userAppID) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.page) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.perPage) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._userAppID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.page != 0 {
      try visitor.visitSingularUInt32Field(value: self.page, fieldNumber: 2)
    }
    if self.perPage != 0 {
      try visitor.visitSingularUInt32Field(value: self.perPage, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_ListInstalledModuleVersionsRequest, rhs: Clarifai_Api_ListInstalledModuleVersionsRequest) -> Bool {
    if lhs._userAppID != rhs._userAppID {return false}
    if lhs.page != rhs.page {return false}
    if lhs.perPage != rhs.perPage {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_PostInstalledModuleVersionsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PostInstalledModuleVersionsRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_app_id"),
    2: .standard(proto: "installed_module_versions"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._userAppID) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.installedModuleVersions) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._userAppID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.installedModuleVersions.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.installedModuleVersions, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_PostInstalledModuleVersionsRequest, rhs: Clarifai_Api_PostInstalledModuleVersionsRequest) -> Bool {
    if lhs._userAppID != rhs._userAppID {return false}
    if lhs.installedModuleVersions != rhs.installedModuleVersions {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_PostInstalledModuleVersionsKeyRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PostInstalledModuleVersionsKeyRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_app_id"),
    2: .standard(proto: "installed_module_version_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._userAppID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.installedModuleVersionID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._userAppID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.installedModuleVersionID.isEmpty {
      try visitor.visitSingularStringField(value: self.installedModuleVersionID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_PostInstalledModuleVersionsKeyRequest, rhs: Clarifai_Api_PostInstalledModuleVersionsKeyRequest) -> Bool {
    if lhs._userAppID != rhs._userAppID {return false}
    if lhs.installedModuleVersionID != rhs.installedModuleVersionID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_DeleteInstalledModuleVersionsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DeleteInstalledModuleVersionsRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_app_id"),
    2: .same(proto: "ids"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._userAppID) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.ids) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._userAppID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.ids.isEmpty {
      try visitor.visitRepeatedStringField(value: self.ids, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_DeleteInstalledModuleVersionsRequest, rhs: Clarifai_Api_DeleteInstalledModuleVersionsRequest) -> Bool {
    if lhs._userAppID != rhs._userAppID {return false}
    if lhs.ids != rhs.ids {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_SingleInstalledModuleVersionResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SingleInstalledModuleVersionResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
    2: .standard(proto: "installed_module_version"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._status) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._installedModuleVersion) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._status {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._installedModuleVersion {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_SingleInstalledModuleVersionResponse, rhs: Clarifai_Api_SingleInstalledModuleVersionResponse) -> Bool {
    if lhs._status != rhs._status {return false}
    if lhs._installedModuleVersion != rhs._installedModuleVersion {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_MultiInstalledModuleVersionResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MultiInstalledModuleVersionResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
    2: .standard(proto: "installed_module_versions"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._status) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.installedModuleVersions) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._status {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.installedModuleVersions.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.installedModuleVersions, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_MultiInstalledModuleVersionResponse, rhs: Clarifai_Api_MultiInstalledModuleVersionResponse) -> Bool {
    if lhs._status != rhs._status {return false}
    if lhs.installedModuleVersions != rhs.installedModuleVersions {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_ListNextTaskAssignmentsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListNextTaskAssignmentsRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_app_id"),
    2: .standard(proto: "task_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._userAppID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.taskID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._userAppID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.taskID.isEmpty {
      try visitor.visitSingularStringField(value: self.taskID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_ListNextTaskAssignmentsRequest, rhs: Clarifai_Api_ListNextTaskAssignmentsRequest) -> Bool {
    if lhs._userAppID != rhs._userAppID {return false}
    if lhs.taskID != rhs.taskID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_PostBulkOperationsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PostBulkOperationsRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_app_id"),
    2: .standard(proto: "bulk_operations"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._userAppID) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.bulkOperations) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._userAppID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.bulkOperations.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.bulkOperations, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_PostBulkOperationsRequest, rhs: Clarifai_Api_PostBulkOperationsRequest) -> Bool {
    if lhs._userAppID != rhs._userAppID {return false}
    if lhs.bulkOperations != rhs.bulkOperations {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_ListBulkOperationsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListBulkOperationsRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_app_id"),
    2: .same(proto: "page"),
    3: .standard(proto: "per_page"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._userAppID) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.page) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.perPage) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._userAppID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.page != 0 {
      try visitor.visitSingularUInt32Field(value: self.page, fieldNumber: 2)
    }
    if self.perPage != 0 {
      try visitor.visitSingularUInt32Field(value: self.perPage, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_ListBulkOperationsRequest, rhs: Clarifai_Api_ListBulkOperationsRequest) -> Bool {
    if lhs._userAppID != rhs._userAppID {return false}
    if lhs.page != rhs.page {return false}
    if lhs.perPage != rhs.perPage {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_GetBulkOperationRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetBulkOperationRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_app_id"),
    2: .same(proto: "id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._userAppID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.id) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._userAppID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_GetBulkOperationRequest, rhs: Clarifai_Api_GetBulkOperationRequest) -> Bool {
    if lhs._userAppID != rhs._userAppID {return false}
    if lhs.id != rhs.id {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_CancelBulkOperationRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CancelBulkOperationRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_app_id"),
    2: .same(proto: "ids"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._userAppID) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.ids) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._userAppID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.ids.isEmpty {
      try visitor.visitRepeatedStringField(value: self.ids, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_CancelBulkOperationRequest, rhs: Clarifai_Api_CancelBulkOperationRequest) -> Bool {
    if lhs._userAppID != rhs._userAppID {return false}
    if lhs.ids != rhs.ids {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_DeleteBulkOperationRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DeleteBulkOperationRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_app_id"),
    2: .same(proto: "ids"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._userAppID) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.ids) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._userAppID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.ids.isEmpty {
      try visitor.visitRepeatedStringField(value: self.ids, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_DeleteBulkOperationRequest, rhs: Clarifai_Api_DeleteBulkOperationRequest) -> Bool {
    if lhs._userAppID != rhs._userAppID {return false}
    if lhs.ids != rhs.ids {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_SingleBulkOperationsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SingleBulkOperationsResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
    2: .standard(proto: "bulk_operation"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._status) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._bulkOperation) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._status {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._bulkOperation {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_SingleBulkOperationsResponse, rhs: Clarifai_Api_SingleBulkOperationsResponse) -> Bool {
    if lhs._status != rhs._status {return false}
    if lhs._bulkOperation != rhs._bulkOperation {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_MultiBulkOperationsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MultiBulkOperationsResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
    2: .standard(proto: "bulk_operation"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._status) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.bulkOperation) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._status {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.bulkOperation.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.bulkOperation, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_MultiBulkOperationsResponse, rhs: Clarifai_Api_MultiBulkOperationsResponse) -> Bool {
    if lhs._status != rhs._status {return false}
    if lhs.bulkOperation != rhs.bulkOperation {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_PutTaskAssignmentsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PutTaskAssignmentsRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_app_id"),
    2: .standard(proto: "task_id"),
    3: .standard(proto: "input_id"),
    4: .same(proto: "action"),
    6: .standard(proto: "label_submit_config"),
    10: .standard(proto: "review_start_config"),
    7: .standard(proto: "review_approve_config"),
    8: .standard(proto: "review_request_changes_config"),
    9: .standard(proto: "review_reject_config"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._userAppID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.taskID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.inputID) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self.action) }()
      case 6: try {
        var v: Clarifai_Api_LabelSubmitConfig?
        var hadOneofValue = false
        if let current = self.actionConfig {
          hadOneofValue = true
          if case .labelSubmitConfig(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.actionConfig = .labelSubmitConfig(v)
        }
      }()
      case 7: try {
        var v: Clarifai_Api_ReviewApproveConfig?
        var hadOneofValue = false
        if let current = self.actionConfig {
          hadOneofValue = true
          if case .reviewApproveConfig(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.actionConfig = .reviewApproveConfig(v)
        }
      }()
      case 8: try {
        var v: Clarifai_Api_ReviewRequestChangesConfig?
        var hadOneofValue = false
        if let current = self.actionConfig {
          hadOneofValue = true
          if case .reviewRequestChangesConfig(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.actionConfig = .reviewRequestChangesConfig(v)
        }
      }()
      case 9: try {
        var v: Clarifai_Api_ReviewRejectConfig?
        var hadOneofValue = false
        if let current = self.actionConfig {
          hadOneofValue = true
          if case .reviewRejectConfig(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.actionConfig = .reviewRejectConfig(v)
        }
      }()
      case 10: try {
        var v: Clarifai_Api_ReviewStartConfig?
        var hadOneofValue = false
        if let current = self.actionConfig {
          hadOneofValue = true
          if case .reviewStartConfig(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.actionConfig = .reviewStartConfig(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._userAppID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.taskID.isEmpty {
      try visitor.visitSingularStringField(value: self.taskID, fieldNumber: 2)
    }
    if !self.inputID.isEmpty {
      try visitor.visitSingularStringField(value: self.inputID, fieldNumber: 3)
    }
    if self.action != .notSet {
      try visitor.visitSingularEnumField(value: self.action, fieldNumber: 4)
    }
    switch self.actionConfig {
    case .labelSubmitConfig?: try {
      guard case .labelSubmitConfig(let v)? = self.actionConfig else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case .reviewApproveConfig?: try {
      guard case .reviewApproveConfig(let v)? = self.actionConfig else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }()
    case .reviewRequestChangesConfig?: try {
      guard case .reviewRequestChangesConfig(let v)? = self.actionConfig else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    }()
    case .reviewRejectConfig?: try {
      guard case .reviewRejectConfig(let v)? = self.actionConfig else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    }()
    case .reviewStartConfig?: try {
      guard case .reviewStartConfig(let v)? = self.actionConfig else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_PutTaskAssignmentsRequest, rhs: Clarifai_Api_PutTaskAssignmentsRequest) -> Bool {
    if lhs._userAppID != rhs._userAppID {return false}
    if lhs.taskID != rhs.taskID {return false}
    if lhs.inputID != rhs.inputID {return false}
    if lhs.action != rhs.action {return false}
    if lhs.actionConfig != rhs.actionConfig {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_LabelSubmitConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LabelSubmitConfig"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "task_assignments"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.taskAssignments) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.taskAssignments.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.taskAssignments, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_LabelSubmitConfig, rhs: Clarifai_Api_LabelSubmitConfig) -> Bool {
    if lhs.taskAssignments != rhs.taskAssignments {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_ReviewStartConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ReviewStartConfig"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "workers"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.workers) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.workers.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.workers, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_ReviewStartConfig, rhs: Clarifai_Api_ReviewStartConfig) -> Bool {
    if lhs.workers != rhs.workers {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_ReviewApproveConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ReviewApproveConfig"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "task_assignments"),
    2: .same(proto: "workers"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.taskAssignments) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.workers) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.taskAssignments.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.taskAssignments, fieldNumber: 1)
    }
    if !self.workers.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.workers, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_ReviewApproveConfig, rhs: Clarifai_Api_ReviewApproveConfig) -> Bool {
    if lhs.taskAssignments != rhs.taskAssignments {return false}
    if lhs.workers != rhs.workers {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_ReviewRequestChangesConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ReviewRequestChangesConfig"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "task_assignments"),
    2: .same(proto: "workers"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.taskAssignments) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.workers) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.taskAssignments.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.taskAssignments, fieldNumber: 1)
    }
    if !self.workers.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.workers, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_ReviewRequestChangesConfig, rhs: Clarifai_Api_ReviewRequestChangesConfig) -> Bool {
    if lhs.taskAssignments != rhs.taskAssignments {return false}
    if lhs.workers != rhs.workers {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_ReviewRejectConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ReviewRejectConfig"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "task_assignments"),
    2: .same(proto: "workers"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.taskAssignments) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.workers) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.taskAssignments.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.taskAssignments, fieldNumber: 1)
    }
    if !self.workers.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.workers, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_ReviewRejectConfig, rhs: Clarifai_Api_ReviewRejectConfig) -> Bool {
    if lhs.taskAssignments != rhs.taskAssignments {return false}
    if lhs.workers != rhs.workers {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_MultiTaskAssignmentResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MultiTaskAssignmentResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
    2: .standard(proto: "task_assignments"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._status) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.taskAssignments) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._status {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.taskAssignments.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.taskAssignments, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_MultiTaskAssignmentResponse, rhs: Clarifai_Api_MultiTaskAssignmentResponse) -> Bool {
    if lhs._status != rhs._status {return false}
    if lhs.taskAssignments != rhs.taskAssignments {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_ListInputsAddJobsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListInputsAddJobsRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_app_id"),
    2: .same(proto: "page"),
    3: .standard(proto: "per_page"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._userAppID) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.page) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.perPage) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._userAppID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.page != 0 {
      try visitor.visitSingularUInt32Field(value: self.page, fieldNumber: 2)
    }
    if self.perPage != 0 {
      try visitor.visitSingularUInt32Field(value: self.perPage, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_ListInputsAddJobsRequest, rhs: Clarifai_Api_ListInputsAddJobsRequest) -> Bool {
    if lhs._userAppID != rhs._userAppID {return false}
    if lhs.page != rhs.page {return false}
    if lhs.perPage != rhs.perPage {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_GetInputsAddJobRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetInputsAddJobRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_app_id"),
    2: .same(proto: "id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._userAppID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.id) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._userAppID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_GetInputsAddJobRequest, rhs: Clarifai_Api_GetInputsAddJobRequest) -> Bool {
    if lhs._userAppID != rhs._userAppID {return false}
    if lhs.id != rhs.id {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_CancelInputsAddJobRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CancelInputsAddJobRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_app_id"),
    2: .same(proto: "id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._userAppID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.id) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._userAppID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_CancelInputsAddJobRequest, rhs: Clarifai_Api_CancelInputsAddJobRequest) -> Bool {
    if lhs._userAppID != rhs._userAppID {return false}
    if lhs.id != rhs.id {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_MultiInputsAddJobResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MultiInputsAddJobResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
    2: .standard(proto: "inputs_add_jobs"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._status) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.inputsAddJobs) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._status {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.inputsAddJobs.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.inputsAddJobs, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_MultiInputsAddJobResponse, rhs: Clarifai_Api_MultiInputsAddJobResponse) -> Bool {
    if lhs._status != rhs._status {return false}
    if lhs.inputsAddJobs != rhs.inputsAddJobs {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_SingleInputsAddJobResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SingleInputsAddJobResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
    2: .standard(proto: "inputs_add_job"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._status) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._inputsAddJob) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._status {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._inputsAddJob {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_SingleInputsAddJobResponse, rhs: Clarifai_Api_SingleInputsAddJobResponse) -> Bool {
    if lhs._status != rhs._status {return false}
    if lhs._inputsAddJob != rhs._inputsAddJob {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_PostUploadsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PostUploadsRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_app_id"),
    2: .same(proto: "uploads"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._userAppID) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.uploads) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._userAppID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.uploads.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.uploads, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_PostUploadsRequest, rhs: Clarifai_Api_PostUploadsRequest) -> Bool {
    if lhs._userAppID != rhs._userAppID {return false}
    if lhs.uploads != rhs.uploads {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_DeleteUploadsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DeleteUploadsRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_app_id"),
    2: .same(proto: "ids"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._userAppID) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.ids) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._userAppID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.ids.isEmpty {
      try visitor.visitRepeatedStringField(value: self.ids, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_DeleteUploadsRequest, rhs: Clarifai_Api_DeleteUploadsRequest) -> Bool {
    if lhs._userAppID != rhs._userAppID {return false}
    if lhs.ids != rhs.ids {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_ListUploadsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListUploadsRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_app_id"),
    2: .same(proto: "page"),
    3: .standard(proto: "per_page"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._userAppID) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.page) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.perPage) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._userAppID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.page != 0 {
      try visitor.visitSingularUInt32Field(value: self.page, fieldNumber: 2)
    }
    if self.perPage != 0 {
      try visitor.visitSingularUInt32Field(value: self.perPage, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_ListUploadsRequest, rhs: Clarifai_Api_ListUploadsRequest) -> Bool {
    if lhs._userAppID != rhs._userAppID {return false}
    if lhs.page != rhs.page {return false}
    if lhs.perPage != rhs.perPage {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_GetUploadRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetUploadRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_app_id"),
    2: .standard(proto: "upload_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._userAppID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.uploadID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._userAppID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.uploadID.isEmpty {
      try visitor.visitSingularStringField(value: self.uploadID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_GetUploadRequest, rhs: Clarifai_Api_GetUploadRequest) -> Bool {
    if lhs._userAppID != rhs._userAppID {return false}
    if lhs.uploadID != rhs.uploadID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_SingleUploadResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SingleUploadResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
    2: .same(proto: "upload"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._status) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._upload) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._status {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._upload {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_SingleUploadResponse, rhs: Clarifai_Api_SingleUploadResponse) -> Bool {
    if lhs._status != rhs._status {return false}
    if lhs._upload != rhs._upload {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_MultiUploadResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MultiUploadResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
    2: .same(proto: "uploads"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._status) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.uploads) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._status {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.uploads.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.uploads, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_MultiUploadResponse, rhs: Clarifai_Api_MultiUploadResponse) -> Bool {
    if lhs._status != rhs._status {return false}
    if lhs.uploads != rhs.uploads {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_PutUploadContentPartsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PutUploadContentPartsRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_app_id"),
    2: .standard(proto: "upload_id"),
    3: .standard(proto: "content_parts"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._userAppID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.uploadID) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.contentParts) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._userAppID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.uploadID.isEmpty {
      try visitor.visitSingularStringField(value: self.uploadID, fieldNumber: 2)
    }
    if !self.contentParts.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.contentParts, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_PutUploadContentPartsRequest, rhs: Clarifai_Api_PutUploadContentPartsRequest) -> Bool {
    if lhs._userAppID != rhs._userAppID {return false}
    if lhs.uploadID != rhs.uploadID {return false}
    if lhs.contentParts != rhs.contentParts {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_PostInputsDataSourcesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PostInputsDataSourcesRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_app_id"),
    2: .standard(proto: "data_sources"),
    3: .standard(proto: "call_back_url"),
    4: .standard(proto: "app_pat"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._userAppID) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.dataSources) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.callBackURL) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.appPat) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._userAppID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.dataSources.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.dataSources, fieldNumber: 2)
    }
    if !self.callBackURL.isEmpty {
      try visitor.visitSingularStringField(value: self.callBackURL, fieldNumber: 3)
    }
    if !self.appPat.isEmpty {
      try visitor.visitSingularStringField(value: self.appPat, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_PostInputsDataSourcesRequest, rhs: Clarifai_Api_PostInputsDataSourcesRequest) -> Bool {
    if lhs._userAppID != rhs._userAppID {return false}
    if lhs.dataSources != rhs.dataSources {return false}
    if lhs.callBackURL != rhs.callBackURL {return false}
    if lhs.appPat != rhs.appPat {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_GetInputsExtractionJobRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetInputsExtractionJobRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_app_id"),
    2: .standard(proto: "inputs_extraction_job_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._userAppID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.inputsExtractionJobID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._userAppID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.inputsExtractionJobID.isEmpty {
      try visitor.visitSingularStringField(value: self.inputsExtractionJobID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_GetInputsExtractionJobRequest, rhs: Clarifai_Api_GetInputsExtractionJobRequest) -> Bool {
    if lhs._userAppID != rhs._userAppID {return false}
    if lhs.inputsExtractionJobID != rhs.inputsExtractionJobID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_ListInputsExtractionJobsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListInputsExtractionJobsRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_app_id"),
    2: .same(proto: "page"),
    3: .standard(proto: "per_page"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._userAppID) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.page) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.perPage) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._userAppID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.page != 0 {
      try visitor.visitSingularUInt32Field(value: self.page, fieldNumber: 2)
    }
    if self.perPage != 0 {
      try visitor.visitSingularUInt32Field(value: self.perPage, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_ListInputsExtractionJobsRequest, rhs: Clarifai_Api_ListInputsExtractionJobsRequest) -> Bool {
    if lhs._userAppID != rhs._userAppID {return false}
    if lhs.page != rhs.page {return false}
    if lhs.perPage != rhs.perPage {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_SingleInputsExtractionJobResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SingleInputsExtractionJobResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
    2: .standard(proto: "inputs_extraction_job"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._status) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._inputsExtractionJob) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._status {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._inputsExtractionJob {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_SingleInputsExtractionJobResponse, rhs: Clarifai_Api_SingleInputsExtractionJobResponse) -> Bool {
    if lhs._status != rhs._status {return false}
    if lhs._inputsExtractionJob != rhs._inputsExtractionJob {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_MultiInputsExtractionJobResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MultiInputsExtractionJobResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
    2: .standard(proto: "inputs_extraction_jobs"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._status) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.inputsExtractionJobs) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._status {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.inputsExtractionJobs.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.inputsExtractionJobs, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_MultiInputsExtractionJobResponse, rhs: Clarifai_Api_MultiInputsExtractionJobResponse) -> Bool {
    if lhs._status != rhs._status {return false}
    if lhs.inputsExtractionJobs != rhs.inputsExtractionJobs {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_CancelInputsExtractionJobsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CancelInputsExtractionJobsRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_app_id"),
    2: .same(proto: "ids"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._userAppID) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.ids) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._userAppID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.ids.isEmpty {
      try visitor.visitRepeatedStringField(value: self.ids, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_CancelInputsExtractionJobsRequest, rhs: Clarifai_Api_CancelInputsExtractionJobsRequest) -> Bool {
    if lhs._userAppID != rhs._userAppID {return false}
    if lhs.ids != rhs.ids {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_PostInputsUploadsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PostInputsUploadsRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_app_id"),
    2: .standard(proto: "inputs_uploads"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._userAppID) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.inputsUploads) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._userAppID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.inputsUploads.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.inputsUploads, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_PostInputsUploadsRequest, rhs: Clarifai_Api_PostInputsUploadsRequest) -> Bool {
    if lhs._userAppID != rhs._userAppID {return false}
    if lhs.inputsUploads != rhs.inputsUploads {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_GetRunnerRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetRunnerRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_app_id"),
    2: .standard(proto: "nodepool_id"),
    3: .standard(proto: "runner_id"),
    4: .standard(proto: "compute_cluster_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._userAppID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.nodepoolID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.runnerID) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.computeClusterID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._userAppID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.nodepoolID.isEmpty {
      try visitor.visitSingularStringField(value: self.nodepoolID, fieldNumber: 2)
    }
    if !self.runnerID.isEmpty {
      try visitor.visitSingularStringField(value: self.runnerID, fieldNumber: 3)
    }
    if !self.computeClusterID.isEmpty {
      try visitor.visitSingularStringField(value: self.computeClusterID, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_GetRunnerRequest, rhs: Clarifai_Api_GetRunnerRequest) -> Bool {
    if lhs._userAppID != rhs._userAppID {return false}
    if lhs.nodepoolID != rhs.nodepoolID {return false}
    if lhs.runnerID != rhs.runnerID {return false}
    if lhs.computeClusterID != rhs.computeClusterID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_ListRunnersRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListRunnersRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_app_id"),
    2: .standard(proto: "nodepool_id"),
    3: .same(proto: "page"),
    4: .standard(proto: "per_page"),
    5: .standard(proto: "compute_cluster_id"),
    6: .standard(proto: "min_replicas"),
    7: .standard(proto: "model_version_ids"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._userAppID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.nodepoolID) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.page) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self.perPage) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.computeClusterID) }()
      case 6: try { try decoder.decodeSingularUInt32Field(value: &self.minReplicas) }()
      case 7: try { try decoder.decodeRepeatedStringField(value: &self.modelVersionIds) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._userAppID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.nodepoolID.isEmpty {
      try visitor.visitSingularStringField(value: self.nodepoolID, fieldNumber: 2)
    }
    if self.page != 0 {
      try visitor.visitSingularUInt32Field(value: self.page, fieldNumber: 3)
    }
    if self.perPage != 0 {
      try visitor.visitSingularUInt32Field(value: self.perPage, fieldNumber: 4)
    }
    if !self.computeClusterID.isEmpty {
      try visitor.visitSingularStringField(value: self.computeClusterID, fieldNumber: 5)
    }
    if self.minReplicas != 0 {
      try visitor.visitSingularUInt32Field(value: self.minReplicas, fieldNumber: 6)
    }
    if !self.modelVersionIds.isEmpty {
      try visitor.visitRepeatedStringField(value: self.modelVersionIds, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_ListRunnersRequest, rhs: Clarifai_Api_ListRunnersRequest) -> Bool {
    if lhs._userAppID != rhs._userAppID {return false}
    if lhs.nodepoolID != rhs.nodepoolID {return false}
    if lhs.page != rhs.page {return false}
    if lhs.perPage != rhs.perPage {return false}
    if lhs.computeClusterID != rhs.computeClusterID {return false}
    if lhs.minReplicas != rhs.minReplicas {return false}
    if lhs.modelVersionIds != rhs.modelVersionIds {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_PostRunnersRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PostRunnersRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_app_id"),
    2: .standard(proto: "nodepool_id"),
    3: .same(proto: "runners"),
    4: .standard(proto: "compute_cluster_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._userAppID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.nodepoolID) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.runners) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.computeClusterID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._userAppID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.nodepoolID.isEmpty {
      try visitor.visitSingularStringField(value: self.nodepoolID, fieldNumber: 2)
    }
    if !self.runners.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.runners, fieldNumber: 3)
    }
    if !self.computeClusterID.isEmpty {
      try visitor.visitSingularStringField(value: self.computeClusterID, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_PostRunnersRequest, rhs: Clarifai_Api_PostRunnersRequest) -> Bool {
    if lhs._userAppID != rhs._userAppID {return false}
    if lhs.nodepoolID != rhs.nodepoolID {return false}
    if lhs.runners != rhs.runners {return false}
    if lhs.computeClusterID != rhs.computeClusterID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_PatchRunnersRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PatchRunnersRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_app_id"),
    2: .standard(proto: "nodepool_id"),
    3: .same(proto: "runners"),
    4: .standard(proto: "compute_cluster_id"),
    5: .same(proto: "action"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._userAppID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.nodepoolID) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.runners) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.computeClusterID) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.action) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._userAppID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.nodepoolID.isEmpty {
      try visitor.visitSingularStringField(value: self.nodepoolID, fieldNumber: 2)
    }
    if !self.runners.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.runners, fieldNumber: 3)
    }
    if !self.computeClusterID.isEmpty {
      try visitor.visitSingularStringField(value: self.computeClusterID, fieldNumber: 4)
    }
    if !self.action.isEmpty {
      try visitor.visitSingularStringField(value: self.action, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_PatchRunnersRequest, rhs: Clarifai_Api_PatchRunnersRequest) -> Bool {
    if lhs._userAppID != rhs._userAppID {return false}
    if lhs.nodepoolID != rhs.nodepoolID {return false}
    if lhs.runners != rhs.runners {return false}
    if lhs.computeClusterID != rhs.computeClusterID {return false}
    if lhs.action != rhs.action {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_DeleteRunnersRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DeleteRunnersRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_app_id"),
    2: .standard(proto: "nodepool_id"),
    3: .same(proto: "ids"),
    4: .standard(proto: "compute_cluster_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._userAppID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.nodepoolID) }()
      case 3: try { try decoder.decodeRepeatedStringField(value: &self.ids) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.computeClusterID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._userAppID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.nodepoolID.isEmpty {
      try visitor.visitSingularStringField(value: self.nodepoolID, fieldNumber: 2)
    }
    if !self.ids.isEmpty {
      try visitor.visitRepeatedStringField(value: self.ids, fieldNumber: 3)
    }
    if !self.computeClusterID.isEmpty {
      try visitor.visitSingularStringField(value: self.computeClusterID, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_DeleteRunnersRequest, rhs: Clarifai_Api_DeleteRunnersRequest) -> Bool {
    if lhs._userAppID != rhs._userAppID {return false}
    if lhs.nodepoolID != rhs.nodepoolID {return false}
    if lhs.ids != rhs.ids {return false}
    if lhs.computeClusterID != rhs.computeClusterID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_SingleRunnerResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SingleRunnerResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
    2: .same(proto: "runner"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._status) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._runner) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._status {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._runner {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_SingleRunnerResponse, rhs: Clarifai_Api_SingleRunnerResponse) -> Bool {
    if lhs._status != rhs._status {return false}
    if lhs._runner != rhs._runner {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_MultiRunnerResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MultiRunnerResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
    2: .same(proto: "runners"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._status) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.runners) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._status {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.runners.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.runners, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_MultiRunnerResponse, rhs: Clarifai_Api_MultiRunnerResponse) -> Bool {
    if lhs._status != rhs._status {return false}
    if lhs.runners != rhs.runners {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_ListRunnerItemsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListRunnerItemsRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_app_id"),
    2: .standard(proto: "nodepool_id"),
    3: .standard(proto: "runner_id"),
    4: .standard(proto: "compute_cluster_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._userAppID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.nodepoolID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.runnerID) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.computeClusterID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._userAppID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.nodepoolID.isEmpty {
      try visitor.visitSingularStringField(value: self.nodepoolID, fieldNumber: 2)
    }
    if !self.runnerID.isEmpty {
      try visitor.visitSingularStringField(value: self.runnerID, fieldNumber: 3)
    }
    if !self.computeClusterID.isEmpty {
      try visitor.visitSingularStringField(value: self.computeClusterID, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_ListRunnerItemsRequest, rhs: Clarifai_Api_ListRunnerItemsRequest) -> Bool {
    if lhs._userAppID != rhs._userAppID {return false}
    if lhs.nodepoolID != rhs.nodepoolID {return false}
    if lhs.runnerID != rhs.runnerID {return false}
    if lhs.computeClusterID != rhs.computeClusterID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_PostRunnerItemOutputsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PostRunnerItemOutputsRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_app_id"),
    2: .standard(proto: "nodepool_id"),
    3: .standard(proto: "runner_id"),
    4: .standard(proto: "runner_item_id"),
    5: .standard(proto: "runner_item_outputs"),
    6: .same(proto: "status"),
    7: .standard(proto: "runner_replica_id"),
    8: .standard(proto: "compute_cluster_id"),
    9: .standard(proto: "cloud_provider_id"),
    10: .same(proto: "region"),
  ]

  fileprivate class _StorageClass {
    var _userAppID: Clarifai_Api_UserAppIDSet? = nil
    var _nodepoolID: String = String()
    var _runnerID: String = String()
    var _runnerItemID: String = String()
    var _runnerItemOutputs: [Clarifai_Api_RunnerItemOutput] = []
    var _status: Clarifai_Api_Status_Status? = nil
    var _runnerReplicaID: String = String()
    var _computeClusterID: String = String()
    var _cloudProviderID: String = String()
    var _region: String = String()

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _userAppID = source._userAppID
      _nodepoolID = source._nodepoolID
      _runnerID = source._runnerID
      _runnerItemID = source._runnerItemID
      _runnerItemOutputs = source._runnerItemOutputs
      _status = source._status
      _runnerReplicaID = source._runnerReplicaID
      _computeClusterID = source._computeClusterID
      _cloudProviderID = source._cloudProviderID
      _region = source._region
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._userAppID) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._nodepoolID) }()
        case 3: try { try decoder.decodeSingularStringField(value: &_storage._runnerID) }()
        case 4: try { try decoder.decodeSingularStringField(value: &_storage._runnerItemID) }()
        case 5: try { try decoder.decodeRepeatedMessageField(value: &_storage._runnerItemOutputs) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._status) }()
        case 7: try { try decoder.decodeSingularStringField(value: &_storage._runnerReplicaID) }()
        case 8: try { try decoder.decodeSingularStringField(value: &_storage._computeClusterID) }()
        case 9: try { try decoder.decodeSingularStringField(value: &_storage._cloudProviderID) }()
        case 10: try { try decoder.decodeSingularStringField(value: &_storage._region) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._userAppID {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      if !_storage._nodepoolID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._nodepoolID, fieldNumber: 2)
      }
      if !_storage._runnerID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._runnerID, fieldNumber: 3)
      }
      if !_storage._runnerItemID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._runnerItemID, fieldNumber: 4)
      }
      if !_storage._runnerItemOutputs.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._runnerItemOutputs, fieldNumber: 5)
      }
      try { if let v = _storage._status {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
      if !_storage._runnerReplicaID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._runnerReplicaID, fieldNumber: 7)
      }
      if !_storage._computeClusterID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._computeClusterID, fieldNumber: 8)
      }
      if !_storage._cloudProviderID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._cloudProviderID, fieldNumber: 9)
      }
      if !_storage._region.isEmpty {
        try visitor.visitSingularStringField(value: _storage._region, fieldNumber: 10)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_PostRunnerItemOutputsRequest, rhs: Clarifai_Api_PostRunnerItemOutputsRequest) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._userAppID != rhs_storage._userAppID {return false}
        if _storage._nodepoolID != rhs_storage._nodepoolID {return false}
        if _storage._runnerID != rhs_storage._runnerID {return false}
        if _storage._runnerItemID != rhs_storage._runnerItemID {return false}
        if _storage._runnerItemOutputs != rhs_storage._runnerItemOutputs {return false}
        if _storage._status != rhs_storage._status {return false}
        if _storage._runnerReplicaID != rhs_storage._runnerReplicaID {return false}
        if _storage._computeClusterID != rhs_storage._computeClusterID {return false}
        if _storage._cloudProviderID != rhs_storage._cloudProviderID {return false}
        if _storage._region != rhs_storage._region {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_SyncStateRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SyncStateRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "operation_type"),
    2: .standard(proto: "compute_clusters"),
    3: .same(proto: "nodepools"),
    4: .same(proto: "runners"),
    5: .standard(proto: "pipeline_version_runs"),
    6: .same(proto: "secrets"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.operationType) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.computeClusters) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.nodepools) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.runners) }()
      case 5: try { try decoder.decodeRepeatedMessageField(value: &self.pipelineVersionRuns) }()
      case 6: try { try decoder.decodeRepeatedMessageField(value: &self.secrets) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.operationType.isEmpty {
      try visitor.visitSingularStringField(value: self.operationType, fieldNumber: 1)
    }
    if !self.computeClusters.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.computeClusters, fieldNumber: 2)
    }
    if !self.nodepools.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.nodepools, fieldNumber: 3)
    }
    if !self.runners.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.runners, fieldNumber: 4)
    }
    if !self.pipelineVersionRuns.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.pipelineVersionRuns, fieldNumber: 5)
    }
    if !self.secrets.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.secrets, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_SyncStateRequest, rhs: Clarifai_Api_SyncStateRequest) -> Bool {
    if lhs.operationType != rhs.operationType {return false}
    if lhs.computeClusters != rhs.computeClusters {return false}
    if lhs.nodepools != rhs.nodepools {return false}
    if lhs.runners != rhs.runners {return false}
    if lhs.pipelineVersionRuns != rhs.pipelineVersionRuns {return false}
    if lhs.secrets != rhs.secrets {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_MultiRunnerItemResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MultiRunnerItemResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
    2: .standard(proto: "runner_items"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._status) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.runnerItems) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._status {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.runnerItems.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.runnerItems, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_MultiRunnerItemResponse, rhs: Clarifai_Api_MultiRunnerItemResponse) -> Bool {
    if lhs._status != rhs._status {return false}
    if lhs.runnerItems != rhs.runnerItems {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_RunnerItem: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RunnerItem"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "description"),
    3: .standard(proto: "processing_info"),
    4: .standard(proto: "post_model_outputs_request"),
    5: .standard(proto: "sync_state_request"),
  ]

  fileprivate class _StorageClass {
    var _id: String = String()
    var _description_p: String = String()
    var _processingInfo: Clarifai_Api_ProcessingInfo? = nil
    var _request: Clarifai_Api_RunnerItem.OneOf_Request?

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _id = source._id
      _description_p = source._description_p
      _processingInfo = source._processingInfo
      _request = source._request
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._id) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._description_p) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._processingInfo) }()
        case 4: try {
          var v: Clarifai_Api_PostModelOutputsRequest?
          var hadOneofValue = false
          if let current = _storage._request {
            hadOneofValue = true
            if case .postModelOutputsRequest(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._request = .postModelOutputsRequest(v)
          }
        }()
        case 5: try {
          var v: Clarifai_Api_SyncStateRequest?
          var hadOneofValue = false
          if let current = _storage._request {
            hadOneofValue = true
            if case .syncStateRequest(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._request = .syncStateRequest(v)
          }
        }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._id.isEmpty {
        try visitor.visitSingularStringField(value: _storage._id, fieldNumber: 1)
      }
      if !_storage._description_p.isEmpty {
        try visitor.visitSingularStringField(value: _storage._description_p, fieldNumber: 2)
      }
      try { if let v = _storage._processingInfo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      switch _storage._request {
      case .postModelOutputsRequest?: try {
        guard case .postModelOutputsRequest(let v)? = _storage._request else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }()
      case .syncStateRequest?: try {
        guard case .syncStateRequest(let v)? = _storage._request else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      }()
      case nil: break
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_RunnerItem, rhs: Clarifai_Api_RunnerItem) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._id != rhs_storage._id {return false}
        if _storage._description_p != rhs_storage._description_p {return false}
        if _storage._processingInfo != rhs_storage._processingInfo {return false}
        if _storage._request != rhs_storage._request {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_RunnerItemOutput: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RunnerItemOutput"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "multi_output_response"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Clarifai_Api_MultiOutputResponse?
        var hadOneofValue = false
        if let current = self.response {
          hadOneofValue = true
          if case .multiOutputResponse(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.response = .multiOutputResponse(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if case .multiOutputResponse(let v)? = self.response {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_RunnerItemOutput, rhs: Clarifai_Api_RunnerItemOutput) -> Bool {
    if lhs.response != rhs.response {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_MultiRunnerItemOutputResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MultiRunnerItemOutputResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
    2: .standard(proto: "runner_item_outputs"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._status) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.runnerItemOutputs) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._status {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.runnerItemOutputs.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.runnerItemOutputs, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_MultiRunnerItemOutputResponse, rhs: Clarifai_Api_MultiRunnerItemOutputResponse) -> Bool {
    if lhs._status != rhs._status {return false}
    if lhs.runnerItemOutputs != rhs.runnerItemOutputs {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_PostModelVersionsTrainingTimeEstimateRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PostModelVersionsTrainingTimeEstimateRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_app_id"),
    2: .standard(proto: "model_id"),
    3: .standard(proto: "model_versions"),
    4: .standard(proto: "estimated_input_count"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._userAppID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.modelID) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.modelVersions) }()
      case 4: try { try decoder.decodeSingularUInt64Field(value: &self.estimatedInputCount) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._userAppID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.modelID.isEmpty {
      try visitor.visitSingularStringField(value: self.modelID, fieldNumber: 2)
    }
    if !self.modelVersions.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.modelVersions, fieldNumber: 3)
    }
    if self.estimatedInputCount != 0 {
      try visitor.visitSingularUInt64Field(value: self.estimatedInputCount, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_PostModelVersionsTrainingTimeEstimateRequest, rhs: Clarifai_Api_PostModelVersionsTrainingTimeEstimateRequest) -> Bool {
    if lhs._userAppID != rhs._userAppID {return false}
    if lhs.modelID != rhs.modelID {return false}
    if lhs.modelVersions != rhs.modelVersions {return false}
    if lhs.estimatedInputCount != rhs.estimatedInputCount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_MultiTrainingTimeEstimateResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MultiTrainingTimeEstimateResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
    2: .standard(proto: "training_time_estimates"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._status) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.trainingTimeEstimates) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._status {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.trainingTimeEstimates.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.trainingTimeEstimates, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_MultiTrainingTimeEstimateResponse, rhs: Clarifai_Api_MultiTrainingTimeEstimateResponse) -> Bool {
    if lhs._status != rhs._status {return false}
    if lhs.trainingTimeEstimates != rhs.trainingTimeEstimates {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_ListCloudProvidersRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListCloudProvidersRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_ListCloudProvidersRequest, rhs: Clarifai_Api_ListCloudProvidersRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_MultiCloudProviderResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MultiCloudProviderResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
    2: .standard(proto: "cloud_providers"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._status) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.cloudProviders) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._status {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.cloudProviders.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.cloudProviders, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_MultiCloudProviderResponse, rhs: Clarifai_Api_MultiCloudProviderResponse) -> Bool {
    if lhs._status != rhs._status {return false}
    if lhs.cloudProviders != rhs.cloudProviders {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_ListCloudRegionsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListCloudRegionsRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "cloud_provider"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._cloudProvider) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._cloudProvider {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_ListCloudRegionsRequest, rhs: Clarifai_Api_ListCloudRegionsRequest) -> Bool {
    if lhs._cloudProvider != rhs._cloudProvider {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_MultiCloudRegionResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MultiCloudRegionResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
    2: .same(proto: "regions"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._status) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.regions) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._status {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.regions.isEmpty {
      try visitor.visitRepeatedStringField(value: self.regions, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_MultiCloudRegionResponse, rhs: Clarifai_Api_MultiCloudRegionResponse) -> Bool {
    if lhs._status != rhs._status {return false}
    if lhs.regions != rhs.regions {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_ListInstanceTypesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListInstanceTypesRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "cloud_provider"),
    2: .same(proto: "region"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._cloudProvider) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.region) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._cloudProvider {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.region.isEmpty {
      try visitor.visitSingularStringField(value: self.region, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_ListInstanceTypesRequest, rhs: Clarifai_Api_ListInstanceTypesRequest) -> Bool {
    if lhs._cloudProvider != rhs._cloudProvider {return false}
    if lhs.region != rhs.region {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_MultiInstanceTypeResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MultiInstanceTypeResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
    2: .standard(proto: "instance_types"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._status) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.instanceTypes) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._status {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.instanceTypes.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.instanceTypes, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_MultiInstanceTypeResponse, rhs: Clarifai_Api_MultiInstanceTypeResponse) -> Bool {
    if lhs._status != rhs._status {return false}
    if lhs.instanceTypes != rhs.instanceTypes {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_GetComputeClusterRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetComputeClusterRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_app_id"),
    2: .standard(proto: "compute_cluster_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._userAppID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.computeClusterID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._userAppID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.computeClusterID.isEmpty {
      try visitor.visitSingularStringField(value: self.computeClusterID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_GetComputeClusterRequest, rhs: Clarifai_Api_GetComputeClusterRequest) -> Bool {
    if lhs._userAppID != rhs._userAppID {return false}
    if lhs.computeClusterID != rhs.computeClusterID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_ListComputeClustersRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListComputeClustersRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_app_id"),
    2: .same(proto: "page"),
    3: .standard(proto: "per_page"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._userAppID) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.page) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.perPage) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._userAppID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.page != 0 {
      try visitor.visitSingularUInt32Field(value: self.page, fieldNumber: 2)
    }
    if self.perPage != 0 {
      try visitor.visitSingularUInt32Field(value: self.perPage, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_ListComputeClustersRequest, rhs: Clarifai_Api_ListComputeClustersRequest) -> Bool {
    if lhs._userAppID != rhs._userAppID {return false}
    if lhs.page != rhs.page {return false}
    if lhs.perPage != rhs.perPage {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_PostComputeClustersRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PostComputeClustersRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_app_id"),
    2: .standard(proto: "compute_clusters"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._userAppID) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.computeClusters) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._userAppID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.computeClusters.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.computeClusters, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_PostComputeClustersRequest, rhs: Clarifai_Api_PostComputeClustersRequest) -> Bool {
    if lhs._userAppID != rhs._userAppID {return false}
    if lhs.computeClusters != rhs.computeClusters {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_DeleteComputeClustersRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DeleteComputeClustersRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_app_id"),
    2: .same(proto: "ids"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._userAppID) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.ids) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._userAppID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.ids.isEmpty {
      try visitor.visitRepeatedStringField(value: self.ids, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_DeleteComputeClustersRequest, rhs: Clarifai_Api_DeleteComputeClustersRequest) -> Bool {
    if lhs._userAppID != rhs._userAppID {return false}
    if lhs.ids != rhs.ids {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_SingleComputeClusterResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SingleComputeClusterResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
    2: .standard(proto: "compute_cluster"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._status) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._computeCluster) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._status {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._computeCluster {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_SingleComputeClusterResponse, rhs: Clarifai_Api_SingleComputeClusterResponse) -> Bool {
    if lhs._status != rhs._status {return false}
    if lhs._computeCluster != rhs._computeCluster {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_MultiComputeClusterResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MultiComputeClusterResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
    2: .standard(proto: "compute_clusters"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._status) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.computeClusters) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._status {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.computeClusters.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.computeClusters, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_MultiComputeClusterResponse, rhs: Clarifai_Api_MultiComputeClusterResponse) -> Bool {
    if lhs._status != rhs._status {return false}
    if lhs.computeClusters != rhs.computeClusters {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_GetNodepoolRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetNodepoolRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_app_id"),
    2: .standard(proto: "compute_cluster_id"),
    3: .standard(proto: "nodepool_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._userAppID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.computeClusterID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.nodepoolID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._userAppID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.computeClusterID.isEmpty {
      try visitor.visitSingularStringField(value: self.computeClusterID, fieldNumber: 2)
    }
    if !self.nodepoolID.isEmpty {
      try visitor.visitSingularStringField(value: self.nodepoolID, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_GetNodepoolRequest, rhs: Clarifai_Api_GetNodepoolRequest) -> Bool {
    if lhs._userAppID != rhs._userAppID {return false}
    if lhs.computeClusterID != rhs.computeClusterID {return false}
    if lhs.nodepoolID != rhs.nodepoolID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_ListNodepoolsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListNodepoolsRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_app_id"),
    2: .standard(proto: "compute_cluster_id"),
    3: .same(proto: "page"),
    4: .standard(proto: "per_page"),
    5: .standard(proto: "active_usage"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._userAppID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.computeClusterID) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.page) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self.perPage) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.activeUsage) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._userAppID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.computeClusterID.isEmpty {
      try visitor.visitSingularStringField(value: self.computeClusterID, fieldNumber: 2)
    }
    if self.page != 0 {
      try visitor.visitSingularUInt32Field(value: self.page, fieldNumber: 3)
    }
    if self.perPage != 0 {
      try visitor.visitSingularUInt32Field(value: self.perPage, fieldNumber: 4)
    }
    if self.activeUsage != false {
      try visitor.visitSingularBoolField(value: self.activeUsage, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_ListNodepoolsRequest, rhs: Clarifai_Api_ListNodepoolsRequest) -> Bool {
    if lhs._userAppID != rhs._userAppID {return false}
    if lhs.computeClusterID != rhs.computeClusterID {return false}
    if lhs.page != rhs.page {return false}
    if lhs.perPage != rhs.perPage {return false}
    if lhs.activeUsage != rhs.activeUsage {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_PostNodepoolsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PostNodepoolsRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_app_id"),
    2: .standard(proto: "compute_cluster_id"),
    3: .same(proto: "nodepools"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._userAppID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.computeClusterID) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.nodepools) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._userAppID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.computeClusterID.isEmpty {
      try visitor.visitSingularStringField(value: self.computeClusterID, fieldNumber: 2)
    }
    if !self.nodepools.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.nodepools, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_PostNodepoolsRequest, rhs: Clarifai_Api_PostNodepoolsRequest) -> Bool {
    if lhs._userAppID != rhs._userAppID {return false}
    if lhs.computeClusterID != rhs.computeClusterID {return false}
    if lhs.nodepools != rhs.nodepools {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_PatchNodepoolsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PatchNodepoolsRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_app_id"),
    2: .standard(proto: "compute_cluster_id"),
    3: .same(proto: "nodepools"),
    4: .same(proto: "action"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._userAppID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.computeClusterID) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.nodepools) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.action) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._userAppID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.computeClusterID.isEmpty {
      try visitor.visitSingularStringField(value: self.computeClusterID, fieldNumber: 2)
    }
    if !self.nodepools.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.nodepools, fieldNumber: 3)
    }
    if !self.action.isEmpty {
      try visitor.visitSingularStringField(value: self.action, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_PatchNodepoolsRequest, rhs: Clarifai_Api_PatchNodepoolsRequest) -> Bool {
    if lhs._userAppID != rhs._userAppID {return false}
    if lhs.computeClusterID != rhs.computeClusterID {return false}
    if lhs.nodepools != rhs.nodepools {return false}
    if lhs.action != rhs.action {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_DeleteNodepoolsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DeleteNodepoolsRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_app_id"),
    2: .standard(proto: "compute_cluster_id"),
    3: .same(proto: "ids"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._userAppID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.computeClusterID) }()
      case 3: try { try decoder.decodeRepeatedStringField(value: &self.ids) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._userAppID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.computeClusterID.isEmpty {
      try visitor.visitSingularStringField(value: self.computeClusterID, fieldNumber: 2)
    }
    if !self.ids.isEmpty {
      try visitor.visitRepeatedStringField(value: self.ids, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_DeleteNodepoolsRequest, rhs: Clarifai_Api_DeleteNodepoolsRequest) -> Bool {
    if lhs._userAppID != rhs._userAppID {return false}
    if lhs.computeClusterID != rhs.computeClusterID {return false}
    if lhs.ids != rhs.ids {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_SingleNodepoolResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SingleNodepoolResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
    2: .same(proto: "nodepool"),
  ]

  fileprivate class _StorageClass {
    var _status: Clarifai_Api_Status_Status? = nil
    var _nodepool: Clarifai_Api_Nodepool? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _status = source._status
      _nodepool = source._nodepool
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._status) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._nodepool) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._status {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._nodepool {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_SingleNodepoolResponse, rhs: Clarifai_Api_SingleNodepoolResponse) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._status != rhs_storage._status {return false}
        if _storage._nodepool != rhs_storage._nodepool {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_MultiNodepoolResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MultiNodepoolResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
    2: .same(proto: "nodepools"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._status) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.nodepools) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._status {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.nodepools.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.nodepools, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_MultiNodepoolResponse, rhs: Clarifai_Api_MultiNodepoolResponse) -> Bool {
    if lhs._status != rhs._status {return false}
    if lhs.nodepools != rhs.nodepools {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_GetDeploymentRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetDeploymentRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_app_id"),
    2: .standard(proto: "deployment_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._userAppID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.deploymentID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._userAppID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.deploymentID.isEmpty {
      try visitor.visitSingularStringField(value: self.deploymentID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_GetDeploymentRequest, rhs: Clarifai_Api_GetDeploymentRequest) -> Bool {
    if lhs._userAppID != rhs._userAppID {return false}
    if lhs.deploymentID != rhs.deploymentID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_ListDeploymentsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListDeploymentsRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_app_id"),
    2: .standard(proto: "nodepool_id"),
    3: .same(proto: "page"),
    4: .standard(proto: "per_page"),
    5: .standard(proto: "model_version_ids"),
    6: .standard(proto: "workflow_version_ids"),
    7: .standard(proto: "compute_cluster_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._userAppID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.nodepoolID) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.page) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self.perPage) }()
      case 5: try { try decoder.decodeRepeatedStringField(value: &self.modelVersionIds) }()
      case 6: try { try decoder.decodeRepeatedStringField(value: &self.workflowVersionIds) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.computeClusterID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._userAppID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.nodepoolID.isEmpty {
      try visitor.visitSingularStringField(value: self.nodepoolID, fieldNumber: 2)
    }
    if self.page != 0 {
      try visitor.visitSingularUInt32Field(value: self.page, fieldNumber: 3)
    }
    if self.perPage != 0 {
      try visitor.visitSingularUInt32Field(value: self.perPage, fieldNumber: 4)
    }
    if !self.modelVersionIds.isEmpty {
      try visitor.visitRepeatedStringField(value: self.modelVersionIds, fieldNumber: 5)
    }
    if !self.workflowVersionIds.isEmpty {
      try visitor.visitRepeatedStringField(value: self.workflowVersionIds, fieldNumber: 6)
    }
    if !self.computeClusterID.isEmpty {
      try visitor.visitSingularStringField(value: self.computeClusterID, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_ListDeploymentsRequest, rhs: Clarifai_Api_ListDeploymentsRequest) -> Bool {
    if lhs._userAppID != rhs._userAppID {return false}
    if lhs.nodepoolID != rhs.nodepoolID {return false}
    if lhs.page != rhs.page {return false}
    if lhs.perPage != rhs.perPage {return false}
    if lhs.modelVersionIds != rhs.modelVersionIds {return false}
    if lhs.workflowVersionIds != rhs.workflowVersionIds {return false}
    if lhs.computeClusterID != rhs.computeClusterID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_PostDeploymentsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PostDeploymentsRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_app_id"),
    2: .same(proto: "deployments"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._userAppID) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.deployments) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._userAppID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.deployments.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.deployments, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_PostDeploymentsRequest, rhs: Clarifai_Api_PostDeploymentsRequest) -> Bool {
    if lhs._userAppID != rhs._userAppID {return false}
    if lhs.deployments != rhs.deployments {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_DeleteDeploymentsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DeleteDeploymentsRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_app_id"),
    2: .same(proto: "ids"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._userAppID) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.ids) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._userAppID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.ids.isEmpty {
      try visitor.visitRepeatedStringField(value: self.ids, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_DeleteDeploymentsRequest, rhs: Clarifai_Api_DeleteDeploymentsRequest) -> Bool {
    if lhs._userAppID != rhs._userAppID {return false}
    if lhs.ids != rhs.ids {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_PostAuditLogSearchesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PostAuditLogSearchesRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_app_id"),
    2: .same(proto: "query"),
    3: .standard(proto: "sort_ascending"),
    5: .same(proto: "pagination"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._userAppID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._query) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.sortAscending) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._pagination) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._userAppID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._query {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if self.sortAscending != false {
      try visitor.visitSingularBoolField(value: self.sortAscending, fieldNumber: 3)
    }
    try { if let v = self._pagination {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_PostAuditLogSearchesRequest, rhs: Clarifai_Api_PostAuditLogSearchesRequest) -> Bool {
    if lhs._userAppID != rhs._userAppID {return false}
    if lhs._query != rhs._query {return false}
    if lhs.sortAscending != rhs.sortAscending {return false}
    if lhs._pagination != rhs._pagination {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_MultiAuditLogEntryResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MultiAuditLogEntryResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
    2: .same(proto: "entries"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._status) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.entries) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._status {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.entries.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.entries, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_MultiAuditLogEntryResponse, rhs: Clarifai_Api_MultiAuditLogEntryResponse) -> Bool {
    if lhs._status != rhs._status {return false}
    if lhs.entries != rhs.entries {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_PatchDeploymentsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PatchDeploymentsRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_app_id"),
    3: .same(proto: "deployments"),
    4: .same(proto: "action"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._userAppID) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.deployments) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.action) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._userAppID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.deployments.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.deployments, fieldNumber: 3)
    }
    if !self.action.isEmpty {
      try visitor.visitSingularStringField(value: self.action, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_PatchDeploymentsRequest, rhs: Clarifai_Api_PatchDeploymentsRequest) -> Bool {
    if lhs._userAppID != rhs._userAppID {return false}
    if lhs.deployments != rhs.deployments {return false}
    if lhs.action != rhs.action {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_SingleDeploymentResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SingleDeploymentResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
    2: .same(proto: "deployment"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._status) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._deployment) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._status {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._deployment {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_SingleDeploymentResponse, rhs: Clarifai_Api_SingleDeploymentResponse) -> Bool {
    if lhs._status != rhs._status {return false}
    if lhs._deployment != rhs._deployment {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_MultiDeploymentResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MultiDeploymentResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
    2: .same(proto: "deployments"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._status) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.deployments) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._status {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.deployments.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.deployments, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_MultiDeploymentResponse, rhs: Clarifai_Api_MultiDeploymentResponse) -> Bool {
    if lhs._status != rhs._status {return false}
    if lhs.deployments != rhs.deployments {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_ListWorkflowEvaluationTemplatesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListWorkflowEvaluationTemplatesRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_ListWorkflowEvaluationTemplatesRequest, rhs: Clarifai_Api_ListWorkflowEvaluationTemplatesRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_MultiWorkflowEvaluationTemplateResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MultiWorkflowEvaluationTemplateResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
    2: .standard(proto: "workflow_version_evaluation_templates"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._status) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.workflowVersionEvaluationTemplates) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._status {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.workflowVersionEvaluationTemplates.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.workflowVersionEvaluationTemplates, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_MultiWorkflowEvaluationTemplateResponse, rhs: Clarifai_Api_MultiWorkflowEvaluationTemplateResponse) -> Bool {
    if lhs._status != rhs._status {return false}
    if lhs.workflowVersionEvaluationTemplates != rhs.workflowVersionEvaluationTemplates {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_PostWorkflowVersionEvaluationsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PostWorkflowVersionEvaluationsRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_app_id"),
    2: .standard(proto: "workflow_id"),
    3: .standard(proto: "workflow_version_id"),
    4: .standard(proto: "workflow_version_evaluations"),
    5: .standard(proto: "runner_selectors"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._userAppID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.workflowID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.workflowVersionID) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.workflowVersionEvaluations) }()
      case 5: try { try decoder.decodeRepeatedMessageField(value: &self.runnerSelectors) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._userAppID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.workflowID.isEmpty {
      try visitor.visitSingularStringField(value: self.workflowID, fieldNumber: 2)
    }
    if !self.workflowVersionID.isEmpty {
      try visitor.visitSingularStringField(value: self.workflowVersionID, fieldNumber: 3)
    }
    if !self.workflowVersionEvaluations.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.workflowVersionEvaluations, fieldNumber: 4)
    }
    if !self.runnerSelectors.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.runnerSelectors, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_PostWorkflowVersionEvaluationsRequest, rhs: Clarifai_Api_PostWorkflowVersionEvaluationsRequest) -> Bool {
    if lhs._userAppID != rhs._userAppID {return false}
    if lhs.workflowID != rhs.workflowID {return false}
    if lhs.workflowVersionID != rhs.workflowVersionID {return false}
    if lhs.workflowVersionEvaluations != rhs.workflowVersionEvaluations {return false}
    if lhs.runnerSelectors != rhs.runnerSelectors {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_PatchWorkflowVersionEvaluationsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PatchWorkflowVersionEvaluationsRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_app_id"),
    2: .standard(proto: "workflow_id"),
    3: .standard(proto: "workflow_version_id"),
    4: .standard(proto: "workflow_version_evaluations"),
    5: .same(proto: "action"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._userAppID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.workflowID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.workflowVersionID) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.workflowVersionEvaluations) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.action) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._userAppID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.workflowID.isEmpty {
      try visitor.visitSingularStringField(value: self.workflowID, fieldNumber: 2)
    }
    if !self.workflowVersionID.isEmpty {
      try visitor.visitSingularStringField(value: self.workflowVersionID, fieldNumber: 3)
    }
    if !self.workflowVersionEvaluations.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.workflowVersionEvaluations, fieldNumber: 4)
    }
    if !self.action.isEmpty {
      try visitor.visitSingularStringField(value: self.action, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_PatchWorkflowVersionEvaluationsRequest, rhs: Clarifai_Api_PatchWorkflowVersionEvaluationsRequest) -> Bool {
    if lhs._userAppID != rhs._userAppID {return false}
    if lhs.workflowID != rhs.workflowID {return false}
    if lhs.workflowVersionID != rhs.workflowVersionID {return false}
    if lhs.workflowVersionEvaluations != rhs.workflowVersionEvaluations {return false}
    if lhs.action != rhs.action {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_MultiWorkflowVersionEvaluationResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MultiWorkflowVersionEvaluationResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
    2: .standard(proto: "workflow_version_evaluations"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._status) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.workflowVersionEvaluations) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._status {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.workflowVersionEvaluations.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.workflowVersionEvaluations, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_MultiWorkflowVersionEvaluationResponse, rhs: Clarifai_Api_MultiWorkflowVersionEvaluationResponse) -> Bool {
    if lhs._status != rhs._status {return false}
    if lhs.workflowVersionEvaluations != rhs.workflowVersionEvaluations {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_SingleWorkflowVersionEvaluationResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SingleWorkflowVersionEvaluationResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
    2: .standard(proto: "workflow_version_evaluation"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._status) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._workflowVersionEvaluation) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._status {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._workflowVersionEvaluation {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_SingleWorkflowVersionEvaluationResponse, rhs: Clarifai_Api_SingleWorkflowVersionEvaluationResponse) -> Bool {
    if lhs._status != rhs._status {return false}
    if lhs._workflowVersionEvaluation != rhs._workflowVersionEvaluation {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_GetWorkflowVersionEvaluationRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetWorkflowVersionEvaluationRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_app_id"),
    2: .standard(proto: "workflow_id"),
    3: .standard(proto: "workflow_version_id"),
    4: .standard(proto: "workflow_version_evaluation_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._userAppID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.workflowID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.workflowVersionID) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.workflowVersionEvaluationID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._userAppID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.workflowID.isEmpty {
      try visitor.visitSingularStringField(value: self.workflowID, fieldNumber: 2)
    }
    if !self.workflowVersionID.isEmpty {
      try visitor.visitSingularStringField(value: self.workflowVersionID, fieldNumber: 3)
    }
    if !self.workflowVersionEvaluationID.isEmpty {
      try visitor.visitSingularStringField(value: self.workflowVersionEvaluationID, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_GetWorkflowVersionEvaluationRequest, rhs: Clarifai_Api_GetWorkflowVersionEvaluationRequest) -> Bool {
    if lhs._userAppID != rhs._userAppID {return false}
    if lhs.workflowID != rhs.workflowID {return false}
    if lhs.workflowVersionID != rhs.workflowVersionID {return false}
    if lhs.workflowVersionEvaluationID != rhs.workflowVersionEvaluationID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_ListWorkflowVersionEvaluationsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListWorkflowVersionEvaluationsRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_app_id"),
    2: .standard(proto: "workflow_id"),
    3: .standard(proto: "workflow_version_id"),
    4: .same(proto: "page"),
    5: .standard(proto: "per_page"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._userAppID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.workflowID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.workflowVersionID) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self.page) }()
      case 5: try { try decoder.decodeSingularUInt32Field(value: &self.perPage) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._userAppID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.workflowID.isEmpty {
      try visitor.visitSingularStringField(value: self.workflowID, fieldNumber: 2)
    }
    if !self.workflowVersionID.isEmpty {
      try visitor.visitSingularStringField(value: self.workflowVersionID, fieldNumber: 3)
    }
    if self.page != 0 {
      try visitor.visitSingularUInt32Field(value: self.page, fieldNumber: 4)
    }
    if self.perPage != 0 {
      try visitor.visitSingularUInt32Field(value: self.perPage, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_ListWorkflowVersionEvaluationsRequest, rhs: Clarifai_Api_ListWorkflowVersionEvaluationsRequest) -> Bool {
    if lhs._userAppID != rhs._userAppID {return false}
    if lhs.workflowID != rhs.workflowID {return false}
    if lhs.workflowVersionID != rhs.workflowVersionID {return false}
    if lhs.page != rhs.page {return false}
    if lhs.perPage != rhs.perPage {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_PostModelMigrationRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PostModelMigrationRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_app_id"),
    2: .standard(proto: "model_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._userAppID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.modelID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._userAppID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.modelID.isEmpty {
      try visitor.visitSingularStringField(value: self.modelID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_PostModelMigrationRequest, rhs: Clarifai_Api_PostModelMigrationRequest) -> Bool {
    if lhs._userAppID != rhs._userAppID {return false}
    if lhs.modelID != rhs.modelID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_ListWorkflowVersionEvaluationDataRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListWorkflowVersionEvaluationDataRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_app_id"),
    2: .standard(proto: "workflow_id"),
    3: .standard(proto: "workflow_version_id"),
    4: .standard(proto: "workflow_version_evaluation_id"),
    5: .same(proto: "page"),
    6: .standard(proto: "per_page"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._userAppID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.workflowID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.workflowVersionID) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.workflowVersionEvaluationID) }()
      case 5: try { try decoder.decodeSingularUInt32Field(value: &self.page) }()
      case 6: try { try decoder.decodeSingularUInt32Field(value: &self.perPage) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._userAppID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.workflowID.isEmpty {
      try visitor.visitSingularStringField(value: self.workflowID, fieldNumber: 2)
    }
    if !self.workflowVersionID.isEmpty {
      try visitor.visitSingularStringField(value: self.workflowVersionID, fieldNumber: 3)
    }
    if !self.workflowVersionEvaluationID.isEmpty {
      try visitor.visitSingularStringField(value: self.workflowVersionEvaluationID, fieldNumber: 4)
    }
    if self.page != 0 {
      try visitor.visitSingularUInt32Field(value: self.page, fieldNumber: 5)
    }
    if self.perPage != 0 {
      try visitor.visitSingularUInt32Field(value: self.perPage, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_ListWorkflowVersionEvaluationDataRequest, rhs: Clarifai_Api_ListWorkflowVersionEvaluationDataRequest) -> Bool {
    if lhs._userAppID != rhs._userAppID {return false}
    if lhs.workflowID != rhs.workflowID {return false}
    if lhs.workflowVersionID != rhs.workflowVersionID {return false}
    if lhs.workflowVersionEvaluationID != rhs.workflowVersionEvaluationID {return false}
    if lhs.page != rhs.page {return false}
    if lhs.perPage != rhs.perPage {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_PostWorkflowVersionEvaluationDataRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PostWorkflowVersionEvaluationDataRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_app_id"),
    2: .standard(proto: "workflow_id"),
    3: .standard(proto: "workflow_version_id"),
    4: .standard(proto: "workflow_version_evaluation_id"),
    5: .standard(proto: "workflow_version_evaluation_data"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._userAppID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.workflowID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.workflowVersionID) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.workflowVersionEvaluationID) }()
      case 5: try { try decoder.decodeRepeatedMessageField(value: &self.workflowVersionEvaluationData) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._userAppID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.workflowID.isEmpty {
      try visitor.visitSingularStringField(value: self.workflowID, fieldNumber: 2)
    }
    if !self.workflowVersionID.isEmpty {
      try visitor.visitSingularStringField(value: self.workflowVersionID, fieldNumber: 3)
    }
    if !self.workflowVersionEvaluationID.isEmpty {
      try visitor.visitSingularStringField(value: self.workflowVersionEvaluationID, fieldNumber: 4)
    }
    if !self.workflowVersionEvaluationData.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.workflowVersionEvaluationData, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_PostWorkflowVersionEvaluationDataRequest, rhs: Clarifai_Api_PostWorkflowVersionEvaluationDataRequest) -> Bool {
    if lhs._userAppID != rhs._userAppID {return false}
    if lhs.workflowID != rhs.workflowID {return false}
    if lhs.workflowVersionID != rhs.workflowVersionID {return false}
    if lhs.workflowVersionEvaluationID != rhs.workflowVersionEvaluationID {return false}
    if lhs.workflowVersionEvaluationData != rhs.workflowVersionEvaluationData {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_MultiListWorkflowVersionEvaluationDataResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MultiListWorkflowVersionEvaluationDataResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
    2: .standard(proto: "workflow_version_evaluation_data"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._status) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.workflowVersionEvaluationData) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._status {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.workflowVersionEvaluationData.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.workflowVersionEvaluationData, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_MultiListWorkflowVersionEvaluationDataResponse, rhs: Clarifai_Api_MultiListWorkflowVersionEvaluationDataResponse) -> Bool {
    if lhs._status != rhs._status {return false}
    if lhs.workflowVersionEvaluationData != rhs.workflowVersionEvaluationData {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_GetPipelineRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetPipelineRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_app_id"),
    2: .standard(proto: "pipeline_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._userAppID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.pipelineID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._userAppID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.pipelineID.isEmpty {
      try visitor.visitSingularStringField(value: self.pipelineID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_GetPipelineRequest, rhs: Clarifai_Api_GetPipelineRequest) -> Bool {
    if lhs._userAppID != rhs._userAppID {return false}
    if lhs.pipelineID != rhs.pipelineID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_ListPipelinesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListPipelinesRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_app_id"),
    2: .same(proto: "page"),
    3: .standard(proto: "per_page"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._userAppID) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.page) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.perPage) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._userAppID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.page != 0 {
      try visitor.visitSingularUInt32Field(value: self.page, fieldNumber: 2)
    }
    if self.perPage != 0 {
      try visitor.visitSingularUInt32Field(value: self.perPage, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_ListPipelinesRequest, rhs: Clarifai_Api_ListPipelinesRequest) -> Bool {
    if lhs._userAppID != rhs._userAppID {return false}
    if lhs.page != rhs.page {return false}
    if lhs.perPage != rhs.perPage {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_PostPipelinesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PostPipelinesRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_app_id"),
    2: .same(proto: "pipelines"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._userAppID) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.pipelines) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._userAppID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.pipelines.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.pipelines, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_PostPipelinesRequest, rhs: Clarifai_Api_PostPipelinesRequest) -> Bool {
    if lhs._userAppID != rhs._userAppID {return false}
    if lhs.pipelines != rhs.pipelines {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_PatchPipelinesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PatchPipelinesRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_app_id"),
    2: .same(proto: "pipelines"),
    3: .same(proto: "action"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._userAppID) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.pipelines) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.action) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._userAppID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.pipelines.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.pipelines, fieldNumber: 2)
    }
    if !self.action.isEmpty {
      try visitor.visitSingularStringField(value: self.action, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_PatchPipelinesRequest, rhs: Clarifai_Api_PatchPipelinesRequest) -> Bool {
    if lhs._userAppID != rhs._userAppID {return false}
    if lhs.pipelines != rhs.pipelines {return false}
    if lhs.action != rhs.action {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_DeletePipelinesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DeletePipelinesRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_app_id"),
    2: .same(proto: "ids"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._userAppID) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.ids) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._userAppID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.ids.isEmpty {
      try visitor.visitRepeatedStringField(value: self.ids, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_DeletePipelinesRequest, rhs: Clarifai_Api_DeletePipelinesRequest) -> Bool {
    if lhs._userAppID != rhs._userAppID {return false}
    if lhs.ids != rhs.ids {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_SinglePipelineResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SinglePipelineResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
    2: .same(proto: "pipeline"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._status) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._pipeline) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._status {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._pipeline {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_SinglePipelineResponse, rhs: Clarifai_Api_SinglePipelineResponse) -> Bool {
    if lhs._status != rhs._status {return false}
    if lhs._pipeline != rhs._pipeline {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_MultiPipelineResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MultiPipelineResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
    2: .same(proto: "pipelines"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._status) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.pipelines) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._status {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.pipelines.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.pipelines, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_MultiPipelineResponse, rhs: Clarifai_Api_MultiPipelineResponse) -> Bool {
    if lhs._status != rhs._status {return false}
    if lhs.pipelines != rhs.pipelines {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_GetPipelineVersionRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetPipelineVersionRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_app_id"),
    2: .standard(proto: "pipeline_id"),
    3: .standard(proto: "pipeline_version_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._userAppID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.pipelineID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.pipelineVersionID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._userAppID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.pipelineID.isEmpty {
      try visitor.visitSingularStringField(value: self.pipelineID, fieldNumber: 2)
    }
    if !self.pipelineVersionID.isEmpty {
      try visitor.visitSingularStringField(value: self.pipelineVersionID, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_GetPipelineVersionRequest, rhs: Clarifai_Api_GetPipelineVersionRequest) -> Bool {
    if lhs._userAppID != rhs._userAppID {return false}
    if lhs.pipelineID != rhs.pipelineID {return false}
    if lhs.pipelineVersionID != rhs.pipelineVersionID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_ListPipelineVersionsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListPipelineVersionsRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_app_id"),
    2: .standard(proto: "pipeline_id"),
    3: .same(proto: "page"),
    4: .standard(proto: "per_page"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._userAppID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.pipelineID) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.page) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self.perPage) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._userAppID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.pipelineID.isEmpty {
      try visitor.visitSingularStringField(value: self.pipelineID, fieldNumber: 2)
    }
    if self.page != 0 {
      try visitor.visitSingularUInt32Field(value: self.page, fieldNumber: 3)
    }
    if self.perPage != 0 {
      try visitor.visitSingularUInt32Field(value: self.perPage, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_ListPipelineVersionsRequest, rhs: Clarifai_Api_ListPipelineVersionsRequest) -> Bool {
    if lhs._userAppID != rhs._userAppID {return false}
    if lhs.pipelineID != rhs.pipelineID {return false}
    if lhs.page != rhs.page {return false}
    if lhs.perPage != rhs.perPage {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_PatchPipelineVersionsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PatchPipelineVersionsRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_app_id"),
    2: .standard(proto: "pipeline_id"),
    3: .standard(proto: "pipeline_versions"),
    4: .same(proto: "action"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._userAppID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.pipelineID) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.pipelineVersions) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.action) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._userAppID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.pipelineID.isEmpty {
      try visitor.visitSingularStringField(value: self.pipelineID, fieldNumber: 2)
    }
    if !self.pipelineVersions.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.pipelineVersions, fieldNumber: 3)
    }
    if !self.action.isEmpty {
      try visitor.visitSingularStringField(value: self.action, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_PatchPipelineVersionsRequest, rhs: Clarifai_Api_PatchPipelineVersionsRequest) -> Bool {
    if lhs._userAppID != rhs._userAppID {return false}
    if lhs.pipelineID != rhs.pipelineID {return false}
    if lhs.pipelineVersions != rhs.pipelineVersions {return false}
    if lhs.action != rhs.action {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_DeletePipelineVersionsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DeletePipelineVersionsRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_app_id"),
    2: .standard(proto: "pipeline_id"),
    3: .standard(proto: "pipeline_version_ids"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._userAppID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.pipelineID) }()
      case 3: try { try decoder.decodeRepeatedStringField(value: &self.pipelineVersionIds) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._userAppID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.pipelineID.isEmpty {
      try visitor.visitSingularStringField(value: self.pipelineID, fieldNumber: 2)
    }
    if !self.pipelineVersionIds.isEmpty {
      try visitor.visitRepeatedStringField(value: self.pipelineVersionIds, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_DeletePipelineVersionsRequest, rhs: Clarifai_Api_DeletePipelineVersionsRequest) -> Bool {
    if lhs._userAppID != rhs._userAppID {return false}
    if lhs.pipelineID != rhs.pipelineID {return false}
    if lhs.pipelineVersionIds != rhs.pipelineVersionIds {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_SinglePipelineVersionResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SinglePipelineVersionResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
    2: .standard(proto: "pipeline_version"),
  ]

  fileprivate class _StorageClass {
    var _status: Clarifai_Api_Status_Status? = nil
    var _pipelineVersion: Clarifai_Api_PipelineVersion? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _status = source._status
      _pipelineVersion = source._pipelineVersion
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._status) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._pipelineVersion) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._status {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._pipelineVersion {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_SinglePipelineVersionResponse, rhs: Clarifai_Api_SinglePipelineVersionResponse) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._status != rhs_storage._status {return false}
        if _storage._pipelineVersion != rhs_storage._pipelineVersion {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_MultiPipelineVersionResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MultiPipelineVersionResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
    2: .standard(proto: "pipeline_versions"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._status) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.pipelineVersions) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._status {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.pipelineVersions.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.pipelineVersions, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_MultiPipelineVersionResponse, rhs: Clarifai_Api_MultiPipelineVersionResponse) -> Bool {
    if lhs._status != rhs._status {return false}
    if lhs.pipelineVersions != rhs.pipelineVersions {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_GetPipelineVersionRunRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetPipelineVersionRunRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_app_id"),
    2: .standard(proto: "pipeline_id"),
    3: .standard(proto: "pipeline_version_id"),
    4: .standard(proto: "pipeline_version_run_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._userAppID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.pipelineID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.pipelineVersionID) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.pipelineVersionRunID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._userAppID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.pipelineID.isEmpty {
      try visitor.visitSingularStringField(value: self.pipelineID, fieldNumber: 2)
    }
    if !self.pipelineVersionID.isEmpty {
      try visitor.visitSingularStringField(value: self.pipelineVersionID, fieldNumber: 3)
    }
    if !self.pipelineVersionRunID.isEmpty {
      try visitor.visitSingularStringField(value: self.pipelineVersionRunID, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_GetPipelineVersionRunRequest, rhs: Clarifai_Api_GetPipelineVersionRunRequest) -> Bool {
    if lhs._userAppID != rhs._userAppID {return false}
    if lhs.pipelineID != rhs.pipelineID {return false}
    if lhs.pipelineVersionID != rhs.pipelineVersionID {return false}
    if lhs.pipelineVersionRunID != rhs.pipelineVersionRunID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_ListPipelineVersionRunsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListPipelineVersionRunsRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_app_id"),
    2: .standard(proto: "pipeline_id"),
    3: .standard(proto: "pipeline_version_id"),
    4: .same(proto: "page"),
    5: .standard(proto: "per_page"),
    6: .standard(proto: "status_codes"),
    7: .standard(proto: "compute_cluster_id"),
    8: .standard(proto: "nodepool_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._userAppID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.pipelineID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.pipelineVersionID) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self.page) }()
      case 5: try { try decoder.decodeSingularUInt32Field(value: &self.perPage) }()
      case 6: try { try decoder.decodeRepeatedEnumField(value: &self.statusCodes) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.computeClusterID) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self.nodepoolID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._userAppID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.pipelineID.isEmpty {
      try visitor.visitSingularStringField(value: self.pipelineID, fieldNumber: 2)
    }
    if !self.pipelineVersionID.isEmpty {
      try visitor.visitSingularStringField(value: self.pipelineVersionID, fieldNumber: 3)
    }
    if self.page != 0 {
      try visitor.visitSingularUInt32Field(value: self.page, fieldNumber: 4)
    }
    if self.perPage != 0 {
      try visitor.visitSingularUInt32Field(value: self.perPage, fieldNumber: 5)
    }
    if !self.statusCodes.isEmpty {
      try visitor.visitPackedEnumField(value: self.statusCodes, fieldNumber: 6)
    }
    if !self.computeClusterID.isEmpty {
      try visitor.visitSingularStringField(value: self.computeClusterID, fieldNumber: 7)
    }
    if !self.nodepoolID.isEmpty {
      try visitor.visitSingularStringField(value: self.nodepoolID, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_ListPipelineVersionRunsRequest, rhs: Clarifai_Api_ListPipelineVersionRunsRequest) -> Bool {
    if lhs._userAppID != rhs._userAppID {return false}
    if lhs.pipelineID != rhs.pipelineID {return false}
    if lhs.pipelineVersionID != rhs.pipelineVersionID {return false}
    if lhs.page != rhs.page {return false}
    if lhs.perPage != rhs.perPage {return false}
    if lhs.statusCodes != rhs.statusCodes {return false}
    if lhs.computeClusterID != rhs.computeClusterID {return false}
    if lhs.nodepoolID != rhs.nodepoolID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_PostPipelineVersionRunsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PostPipelineVersionRunsRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_app_id"),
    2: .standard(proto: "pipeline_id"),
    3: .standard(proto: "pipeline_version_id"),
    4: .standard(proto: "pipeline_version_runs"),
    5: .standard(proto: "runner_selector"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._userAppID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.pipelineID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.pipelineVersionID) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.pipelineVersionRuns) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._runnerSelector) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._userAppID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.pipelineID.isEmpty {
      try visitor.visitSingularStringField(value: self.pipelineID, fieldNumber: 2)
    }
    if !self.pipelineVersionID.isEmpty {
      try visitor.visitSingularStringField(value: self.pipelineVersionID, fieldNumber: 3)
    }
    if !self.pipelineVersionRuns.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.pipelineVersionRuns, fieldNumber: 4)
    }
    try { if let v = self._runnerSelector {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_PostPipelineVersionRunsRequest, rhs: Clarifai_Api_PostPipelineVersionRunsRequest) -> Bool {
    if lhs._userAppID != rhs._userAppID {return false}
    if lhs.pipelineID != rhs.pipelineID {return false}
    if lhs.pipelineVersionID != rhs.pipelineVersionID {return false}
    if lhs.pipelineVersionRuns != rhs.pipelineVersionRuns {return false}
    if lhs._runnerSelector != rhs._runnerSelector {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_PatchPipelineVersionRunsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PatchPipelineVersionRunsRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_app_id"),
    2: .standard(proto: "pipeline_id"),
    3: .standard(proto: "pipeline_version_id"),
    4: .standard(proto: "pipeline_version_runs"),
    5: .same(proto: "action"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._userAppID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.pipelineID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.pipelineVersionID) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.pipelineVersionRuns) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.action) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._userAppID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.pipelineID.isEmpty {
      try visitor.visitSingularStringField(value: self.pipelineID, fieldNumber: 2)
    }
    if !self.pipelineVersionID.isEmpty {
      try visitor.visitSingularStringField(value: self.pipelineVersionID, fieldNumber: 3)
    }
    if !self.pipelineVersionRuns.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.pipelineVersionRuns, fieldNumber: 4)
    }
    if !self.action.isEmpty {
      try visitor.visitSingularStringField(value: self.action, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_PatchPipelineVersionRunsRequest, rhs: Clarifai_Api_PatchPipelineVersionRunsRequest) -> Bool {
    if lhs._userAppID != rhs._userAppID {return false}
    if lhs.pipelineID != rhs.pipelineID {return false}
    if lhs.pipelineVersionID != rhs.pipelineVersionID {return false}
    if lhs.pipelineVersionRuns != rhs.pipelineVersionRuns {return false}
    if lhs.action != rhs.action {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_SinglePipelineVersionRunResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SinglePipelineVersionRunResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
    2: .standard(proto: "pipeline_version_run"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._status) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._pipelineVersionRun) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._status {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._pipelineVersionRun {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_SinglePipelineVersionRunResponse, rhs: Clarifai_Api_SinglePipelineVersionRunResponse) -> Bool {
    if lhs._status != rhs._status {return false}
    if lhs._pipelineVersionRun != rhs._pipelineVersionRun {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_MultiPipelineVersionRunResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MultiPipelineVersionRunResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
    2: .standard(proto: "pipeline_version_runs"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._status) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.pipelineVersionRuns) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._status {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.pipelineVersionRuns.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.pipelineVersionRuns, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_MultiPipelineVersionRunResponse, rhs: Clarifai_Api_MultiPipelineVersionRunResponse) -> Bool {
    if lhs._status != rhs._status {return false}
    if lhs.pipelineVersionRuns != rhs.pipelineVersionRuns {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_PostPipelineStepsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PostPipelineStepsRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_app_id"),
    3: .standard(proto: "pipeline_steps"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._userAppID) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.pipelineSteps) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._userAppID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.pipelineSteps.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.pipelineSteps, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_PostPipelineStepsRequest, rhs: Clarifai_Api_PostPipelineStepsRequest) -> Bool {
    if lhs._userAppID != rhs._userAppID {return false}
    if lhs.pipelineSteps != rhs.pipelineSteps {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_MultiPipelineStepResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MultiPipelineStepResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
    2: .standard(proto: "pipeline_steps"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._status) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.pipelineSteps) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._status {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.pipelineSteps.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.pipelineSteps, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_MultiPipelineStepResponse, rhs: Clarifai_Api_MultiPipelineStepResponse) -> Bool {
    if lhs._status != rhs._status {return false}
    if lhs.pipelineSteps != rhs.pipelineSteps {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_ListPipelineStepsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListPipelineStepsRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_app_id"),
    2: .same(proto: "page"),
    3: .standard(proto: "per_page"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._userAppID) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.page) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.perPage) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._userAppID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.page != 0 {
      try visitor.visitSingularUInt32Field(value: self.page, fieldNumber: 2)
    }
    if self.perPage != 0 {
      try visitor.visitSingularUInt32Field(value: self.perPage, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_ListPipelineStepsRequest, rhs: Clarifai_Api_ListPipelineStepsRequest) -> Bool {
    if lhs._userAppID != rhs._userAppID {return false}
    if lhs.page != rhs.page {return false}
    if lhs.perPage != rhs.perPage {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_ListPipelineStepVersionsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListPipelineStepVersionsRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_app_id"),
    2: .standard(proto: "pipeline_step_id"),
    3: .same(proto: "page"),
    4: .standard(proto: "per_page"),
    6: .standard(proto: "status_codes"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._userAppID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.pipelineStepID) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.page) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self.perPage) }()
      case 6: try { try decoder.decodeRepeatedEnumField(value: &self.statusCodes) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._userAppID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.pipelineStepID.isEmpty {
      try visitor.visitSingularStringField(value: self.pipelineStepID, fieldNumber: 2)
    }
    if self.page != 0 {
      try visitor.visitSingularUInt32Field(value: self.page, fieldNumber: 3)
    }
    if self.perPage != 0 {
      try visitor.visitSingularUInt32Field(value: self.perPage, fieldNumber: 4)
    }
    if !self.statusCodes.isEmpty {
      try visitor.visitPackedEnumField(value: self.statusCodes, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_ListPipelineStepVersionsRequest, rhs: Clarifai_Api_ListPipelineStepVersionsRequest) -> Bool {
    if lhs._userAppID != rhs._userAppID {return false}
    if lhs.pipelineStepID != rhs.pipelineStepID {return false}
    if lhs.page != rhs.page {return false}
    if lhs.perPage != rhs.perPage {return false}
    if lhs.statusCodes != rhs.statusCodes {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_MultiPipelineStepVersionResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MultiPipelineStepVersionResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
    2: .standard(proto: "pipeline_step_versions"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._status) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.pipelineStepVersions) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._status {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.pipelineStepVersions.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.pipelineStepVersions, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_MultiPipelineStepVersionResponse, rhs: Clarifai_Api_MultiPipelineStepVersionResponse) -> Bool {
    if lhs._status != rhs._status {return false}
    if lhs.pipelineStepVersions != rhs.pipelineStepVersions {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_PostPipelineStepVersionsUploadRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PostPipelineStepVersionsUploadRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .standard(proto: "upload_config"),
    3: .standard(proto: "content_part"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try {
        var v: Clarifai_Api_PostPipelineStepVersionsUploadConfig?
        var hadOneofValue = false
        if let current = self.uploadData {
          hadOneofValue = true
          if case .uploadConfig(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.uploadData = .uploadConfig(v)
        }
      }()
      case 3: try {
        var v: Clarifai_Api_UploadContentPart?
        var hadOneofValue = false
        if let current = self.uploadData {
          hadOneofValue = true
          if case .contentPart(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.uploadData = .contentPart(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.uploadData {
    case .uploadConfig?: try {
      guard case .uploadConfig(let v)? = self.uploadData else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .contentPart?: try {
      guard case .contentPart(let v)? = self.uploadData else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_PostPipelineStepVersionsUploadRequest, rhs: Clarifai_Api_PostPipelineStepVersionsUploadRequest) -> Bool {
    if lhs.uploadData != rhs.uploadData {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_PostPipelineStepVersionsUploadResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PostPipelineStepVersionsUploadResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
    2: .standard(proto: "bytes_remaining"),
    3: .standard(proto: "pipeline_step_version_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._status) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.bytesRemaining) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.pipelineStepVersionID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._status {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.bytesRemaining != 0 {
      try visitor.visitSingularUInt64Field(value: self.bytesRemaining, fieldNumber: 2)
    }
    if !self.pipelineStepVersionID.isEmpty {
      try visitor.visitSingularStringField(value: self.pipelineStepVersionID, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_PostPipelineStepVersionsUploadResponse, rhs: Clarifai_Api_PostPipelineStepVersionsUploadResponse) -> Bool {
    if lhs._status != rhs._status {return false}
    if lhs.bytesRemaining != rhs.bytesRemaining {return false}
    if lhs.pipelineStepVersionID != rhs.pipelineStepVersionID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_PostPipelineStepVersionsUploadConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PostPipelineStepVersionsUploadConfig"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_app_id"),
    2: .standard(proto: "pipeline_step_id"),
    3: .standard(proto: "pipeline_step_version"),
    4: .standard(proto: "total_size"),
    5: .standard(proto: "storage_request_size"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._userAppID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.pipelineStepID) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._pipelineStepVersion) }()
      case 4: try { try decoder.decodeSingularUInt64Field(value: &self.totalSize) }()
      case 5: try { try decoder.decodeSingularUInt64Field(value: &self.storageRequestSize) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._userAppID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.pipelineStepID.isEmpty {
      try visitor.visitSingularStringField(value: self.pipelineStepID, fieldNumber: 2)
    }
    try { if let v = self._pipelineStepVersion {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if self.totalSize != 0 {
      try visitor.visitSingularUInt64Field(value: self.totalSize, fieldNumber: 4)
    }
    if self.storageRequestSize != 0 {
      try visitor.visitSingularUInt64Field(value: self.storageRequestSize, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_PostPipelineStepVersionsUploadConfig, rhs: Clarifai_Api_PostPipelineStepVersionsUploadConfig) -> Bool {
    if lhs._userAppID != rhs._userAppID {return false}
    if lhs.pipelineStepID != rhs.pipelineStepID {return false}
    if lhs._pipelineStepVersion != rhs._pipelineStepVersion {return false}
    if lhs.totalSize != rhs.totalSize {return false}
    if lhs.storageRequestSize != rhs.storageRequestSize {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_GetPipelineStepRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetPipelineStepRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_app_id"),
    2: .standard(proto: "pipeline_step_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._userAppID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.pipelineStepID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._userAppID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.pipelineStepID.isEmpty {
      try visitor.visitSingularStringField(value: self.pipelineStepID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_GetPipelineStepRequest, rhs: Clarifai_Api_GetPipelineStepRequest) -> Bool {
    if lhs._userAppID != rhs._userAppID {return false}
    if lhs.pipelineStepID != rhs.pipelineStepID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_SinglePipelineStepResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SinglePipelineStepResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
    2: .standard(proto: "pipeline_step"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._status) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._pipelineStep) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._status {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._pipelineStep {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_SinglePipelineStepResponse, rhs: Clarifai_Api_SinglePipelineStepResponse) -> Bool {
    if lhs._status != rhs._status {return false}
    if lhs._pipelineStep != rhs._pipelineStep {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_GetPipelineStepVersionRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetPipelineStepVersionRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_app_id"),
    2: .standard(proto: "pipeline_step_id"),
    3: .standard(proto: "pipeline_step_version_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._userAppID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.pipelineStepID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.pipelineStepVersionID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._userAppID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.pipelineStepID.isEmpty {
      try visitor.visitSingularStringField(value: self.pipelineStepID, fieldNumber: 2)
    }
    if !self.pipelineStepVersionID.isEmpty {
      try visitor.visitSingularStringField(value: self.pipelineStepVersionID, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_GetPipelineStepVersionRequest, rhs: Clarifai_Api_GetPipelineStepVersionRequest) -> Bool {
    if lhs._userAppID != rhs._userAppID {return false}
    if lhs.pipelineStepID != rhs.pipelineStepID {return false}
    if lhs.pipelineStepVersionID != rhs.pipelineStepVersionID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_SinglePipelineStepVersionResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SinglePipelineStepVersionResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
    2: .standard(proto: "pipeline_step_version"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._status) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._pipelineStepVersion) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._status {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._pipelineStepVersion {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_SinglePipelineStepVersionResponse, rhs: Clarifai_Api_SinglePipelineStepVersionResponse) -> Bool {
    if lhs._status != rhs._status {return false}
    if lhs._pipelineStepVersion != rhs._pipelineStepVersion {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_GetSecretRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetSecretRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_app_id"),
    2: .same(proto: "id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._userAppID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.id) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._userAppID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_GetSecretRequest, rhs: Clarifai_Api_GetSecretRequest) -> Bool {
    if lhs._userAppID != rhs._userAppID {return false}
    if lhs.id != rhs.id {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_ListSecretsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListSecretsRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_app_id"),
    2: .same(proto: "page"),
    3: .standard(proto: "per_page"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._userAppID) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.page) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.perPage) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._userAppID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.page != 0 {
      try visitor.visitSingularUInt32Field(value: self.page, fieldNumber: 2)
    }
    if self.perPage != 0 {
      try visitor.visitSingularUInt32Field(value: self.perPage, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_ListSecretsRequest, rhs: Clarifai_Api_ListSecretsRequest) -> Bool {
    if lhs._userAppID != rhs._userAppID {return false}
    if lhs.page != rhs.page {return false}
    if lhs.perPage != rhs.perPage {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_PostSecretsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PostSecretsRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_app_id"),
    2: .same(proto: "secrets"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._userAppID) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.secrets) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._userAppID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.secrets.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.secrets, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_PostSecretsRequest, rhs: Clarifai_Api_PostSecretsRequest) -> Bool {
    if lhs._userAppID != rhs._userAppID {return false}
    if lhs.secrets != rhs.secrets {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_PatchSecretsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PatchSecretsRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_app_id"),
    5: .same(proto: "secret"),
    8: .same(proto: "action"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._userAppID) }()
      case 5: try { try decoder.decodeRepeatedMessageField(value: &self.secret) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self.action) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._userAppID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.secret.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.secret, fieldNumber: 5)
    }
    if !self.action.isEmpty {
      try visitor.visitSingularStringField(value: self.action, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_PatchSecretsRequest, rhs: Clarifai_Api_PatchSecretsRequest) -> Bool {
    if lhs._userAppID != rhs._userAppID {return false}
    if lhs.secret != rhs.secret {return false}
    if lhs.action != rhs.action {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_DeleteSecretsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DeleteSecretsRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_app_id"),
    2: .same(proto: "ids"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._userAppID) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.ids) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._userAppID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.ids.isEmpty {
      try visitor.visitRepeatedStringField(value: self.ids, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_DeleteSecretsRequest, rhs: Clarifai_Api_DeleteSecretsRequest) -> Bool {
    if lhs._userAppID != rhs._userAppID {return false}
    if lhs.ids != rhs.ids {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_SingleSecretResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SingleSecretResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
    2: .same(proto: "secret"),
  ]

  fileprivate class _StorageClass {
    var _status: Clarifai_Api_Status_Status? = nil
    var _secret: Clarifai_Api_Secret? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _status = source._status
      _secret = source._secret
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._status) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._secret) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._status {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._secret {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_SingleSecretResponse, rhs: Clarifai_Api_SingleSecretResponse) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._status != rhs_storage._status {return false}
        if _storage._secret != rhs_storage._secret {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Clarifai_Api_MultiSecretResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MultiSecretResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
    2: .same(proto: "secrets"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._status) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.secrets) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._status {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.secrets.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.secrets, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Clarifai_Api_MultiSecretResponse, rhs: Clarifai_Api_MultiSecretResponse) -> Bool {
    if lhs._status != rhs._status {return false}
    if lhs.secrets != rhs.secrets {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
